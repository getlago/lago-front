---
description: Create unit and integration tests for code changes in a GitHub PR. Use this rule when generating tests with 80% coverage on new code, following BDD approach and project conventions.
globs:
  - "src/**/*.tsx"
  - "src/**/*.ts"
---

# Make Tests Guide

This guide helps create comprehensive tests for code changes in a GitHub Pull Request, following the established patterns and conventions in this codebase.

## Overview

When creating tests, follow these principles:
- **Quality over quantity** - Write meaningful tests, not trivial ones
- **~80% coverage on NEW code only** (target, not requirement)
- **Lower coverage is acceptable** if tests would be trivial
- BDD approach with GIVEN/WHEN/THEN (always UPPERCASE)
- No translation keys as selectors
- Use data-test attributes exported from components
- Reuse existing factories/mocks

## Critical Testing Philosophy

**The 80% target is a guideline, not a rule.**

Before writing any test, ask:
1. "What bug would this test catch?"
2. "What behavior am I actually verifying?"
3. "Would a change in this code break something important?"

If you can't answer these questions clearly, **don't write the test**.

### When to Write Tests

Write tests when code has:
- Business logic with conditional paths
- State management or side effects
- User interactions (forms, buttons, navigation)
- Data transformations or calculations
- Error handling that needs verification

### When NOT to Write Tests (Even If Coverage Drops)

Do NOT write tests if code is:
- Simple prop pass-through with no logic
- Pure presentational (only renders what it receives)
- Loading skeletons / spinners
- Configuration or constants
- Type definitions

---

## Prerequisites

Before starting, read these reference files:

1. **Testing Best Practices**: `agents/testing-practices.md`
2. **Existing Test Example**: `src/components/invoices/details/__tests__/InvoiceDetailsTable.integration.test.tsx`
3. **Test Utils**: `src/test-utils.tsx`

---

## Phase 1: PR Analysis

### Step 1.1: Fetch PR Information

```bash
# Get PR diff and changed files
gh pr view <PR_NUMBER> --json files,additions,deletions,body,title
gh pr diff <PR_NUMBER>
```

### Step 1.2: Identify Files Requiring Tests

**Files that NEED tests:**
- Components (`.tsx` files in `src/components/`, `src/pages/`)
- Hooks (`.ts` files in `src/hooks/`)
- Utilities (`.ts` files in `src/core/utils/`, `src/utils/`)
- Business logic modules

**Files that DO NOT need tests:**
- Type definitions (`.d.ts`, pure type files)
- GraphQL query/mutation definitions (generated files)
- Configuration files
- Style files (`.css`, `.scss`)
- Index/barrel exports
- Constants-only files
- Translation files

### Step 1.3: Assess Test Value

**DO NOT test:**
- Simple pass-through components with no logic
- Pure presentational components that only render props
- Trivial getters/setters

---

## Phase 2: Implementation

### Step 2.1: Add data-test Constants to Components

**CRITICAL:** Before writing tests, add `data-test` constants to the component.

**In the component file:**

```typescript
// Export data-test constants at the top (after imports)
export const COMPONENT_NAME_TEST_ID = 'component-name'
export const COMPONENT_NAME_TITLE_TEST_ID = 'component-name-title'
export const COMPONENT_NAME_SUBMIT_BUTTON_TEST_ID = 'component-name-submit-button'

export const ComponentName = ({ ... }) => {
  return (
    <div data-test={COMPONENT_NAME_TEST_ID}>
      <Typography data-test={COMPONENT_NAME_TITLE_TEST_ID}>
        {translate('...')}
      </Typography>
      {/* For form.SubmitButton use dataTest (camelCase) */}
      <form.SubmitButton dataTest={COMPONENT_NAME_SUBMIT_BUTTON_TEST_ID}>
        Submit
      </form.SubmitButton>
    </div>
  )
}
```

**Naming convention:**
- Constants: SCREAMING_SNAKE_CASE
- Values: kebab-case
- Pattern: `{COMPONENT_NAME}_{ELEMENT_DESCRIPTION}_TEST_ID`

### Step 2.2: Create Test File

Create test file at: `src/path/to/__tests__/ComponentName.test.tsx`

```typescript
import { screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

import {
  COMPONENT_NAME_TEST_ID,
  COMPONENT_NAME_TITLE_TEST_ID,
  ComponentName,
} from '../ComponentName'
import { render } from '~/test-utils'

jest.mock('~/hooks/core/useInternationalization', () => ({
  useInternationalization: () => ({
    translate: (key: string) => key,
  }),
}))

describe('ComponentName', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe('GIVEN the component is rendered', () => {
    describe('WHEN in default state', () => {
      it('THEN should display the main container', () => {
        render(<ComponentName />)

        expect(screen.getByTestId(COMPONENT_NAME_TEST_ID)).toBeInTheDocument()
      })
    })
  })
})
```

### Step 2.3: BDD Test Structure Rules

**MANDATORY:** All test descriptions MUST follow this pattern:

```typescript
describe('GIVEN [precondition]', () => {           // UPPERCASE GIVEN
  describe('WHEN [action or state]', () => {        // UPPERCASE WHEN
    it('THEN should [expected outcome]', () => {    // UPPERCASE THEN
      // test implementation
    })
  })
})
```

**Correct:**
```typescript
describe('GIVEN the user is logged in', () => {
  describe('WHEN clicking the logout button', () => {
    it('THEN should redirect to login page', () => { ... })
  })
})
```

**Incorrect:**
```typescript
describe('Given the user is logged in', () => { ... })  // Wrong case
it('should redirect', () => { ... })  // Missing THEN
```

### Step 2.4: Selector Rules

**NEVER use translation keys as selectors:**

```typescript
// WRONG
expect(screen.getByText('text_17440321235444hcxi31f8j6')).toBeInTheDocument()

// CORRECT
expect(screen.getByTestId(COMPONENT_NAME_TITLE_TEST_ID)).toBeInTheDocument()
```

**For form inputs:**
```typescript
const inputContainer = screen.getByTestId(COMPONENT_NAME_INPUT_TEST_ID)
const input = inputContainer.querySelector('input')
await user.type(input!, 'test value')
```

### Step 2.5: Reuse and Refactor Mocks

**Search for existing mocks before creating new ones:**

```bash
grep -r "mockInvoice" src/**/__tests__/*.tsx
grep -r "createMock" src/**/__tests__/*.tsx
```

**If same mock used in multiple files, move to shared location:**

```typescript
// src/__mocks__/invoiceMocks.ts
import { CurrencyEnum, InvoiceStatusTypeEnum } from '~/generated/graphql'

export const createMockInvoice = (overrides = {}) => ({
  id: 'invoice-1',
  status: InvoiceStatusTypeEnum.Finalized,
  currency: CurrencyEnum.Usd,
  totalAmountCents: 10000,
  ...overrides,
})
```

**Usage:**
```typescript
import { createMockInvoice } from '~/mocks/invoiceMocks'

const mockInvoice = createMockInvoice({ status: InvoiceStatusTypeEnum.Draft })
```

---

## Phase 3: Coverage Analysis (Critical Evaluation)

### Run Tests with Coverage on New Files Only

```bash
# Run coverage ONLY on new/changed files from the PR
pnpm test:coverage -- --collectCoverageFrom='src/path/to/new-file.tsx' src/path/to/__tests__/new-file.test.tsx
```

### Analyze Uncovered Code Critically

For each uncovered line, ask:
- Is this code worth testing? (meaningful logic vs trivial)
- Would a test catch real bugs or just test implementation?

### Coverage Guidelines (Not Rules)

| Code Type | Acceptable Coverage | Reason |
|-----------|-------------------|--------|
| Complex business logic | 80-100% | High value |
| Form with validation | 70-90% | Test validation, skip trivial |
| Component with some logic | 60-80% | Test logic only |
| Mostly presentational | 40-60% | Only meaningful interactions |
| Pure presentational | 0% | No tests needed |

### Document Low Coverage Decisions

If coverage < 80%, document WHY:

```typescript
/**
 * Coverage Note: ~65% coverage on NewComponent.
 * Uncovered: Lines 45-50 (prop pass-through), Lines 78-82 (loading skeleton)
 * Intentionally not tested - would not catch meaningful bugs.
 */
```

---

## Common Patterns

### Testing Loading States

```typescript
describe('GIVEN the component is loading', () => {
  describe('WHEN data is being fetched', () => {
    it('THEN should display loading skeleton', () => {
      render(<Component isLoading={true} />)

      expect(screen.getByTestId(COMPONENT_LOADING_TEST_ID)).toBeInTheDocument()
    })
  })
})
```

### Testing Error States

```typescript
describe('GIVEN an error occurred', () => {
  describe('WHEN the error is displayed', () => {
    it('THEN should show error message', () => {
      render(<Component error="Something went wrong" />)

      expect(screen.getByTestId(COMPONENT_ERROR_TEST_ID)).toBeInTheDocument()
    })
  })
})
```

### Testing Form Submissions

```typescript
describe('GIVEN the form is filled', () => {
  describe('WHEN user submits the form', () => {
    it('THEN should call the submit handler', async () => {
      const onSubmit = jest.fn()
      const user = userEvent.setup()
      render(<FormComponent onSubmit={onSubmit} />)

      const nameInput = screen.getByTestId(FORM_NAME_INPUT_TEST_ID).querySelector('input')
      await user.type(nameInput!, 'Test Name')

      const submitButton = screen.getByTestId(FORM_SUBMIT_BUTTON_TEST_ID)
      await user.click(submitButton)

      await waitFor(() => {
        expect(onSubmit).toHaveBeenCalledWith(
          expect.objectContaining({ name: 'Test Name' })
        )
      })
    })
  })
})
```

### Testing Conditional Rendering

```typescript
describe('GIVEN the feature flag is enabled', () => {
  describe('WHEN component renders', () => {
    it('THEN should display the new feature', () => {
      render(<Component featureEnabled={true} />)

      expect(screen.getByTestId(COMPONENT_NEW_FEATURE_TEST_ID)).toBeInTheDocument()
    })
  })
})

describe('GIVEN the feature flag is disabled', () => {
  describe('WHEN component renders', () => {
    it('THEN should not display the new feature', () => {
      render(<Component featureEnabled={false} />)

      expect(screen.queryByTestId(COMPONENT_NEW_FEATURE_TEST_ID)).not.toBeInTheDocument()
    })
  })
})
```

### Testing with Timezone (for date components)

```typescript
import { Settings } from 'luxon'

describe('ComponentWithDates', () => {
  const originalDefaultZone = Settings.defaultZone

  beforeAll(() => {
    Settings.defaultZone = 'UTC'
  })

  afterAll(() => {
    Settings.defaultZone = originalDefaultZone
  })

  // ... tests
})
```

---

## Checklist

- [ ] **Critical analysis performed** - Each test has a clear purpose
- [ ] Tests follow BDD structure (GIVEN/WHEN/THEN in UPPERCASE)
- [ ] All selectors use data-test IDs (no translation keys)
- [ ] data-test constants exported from component
- [ ] Tests import data-test constants from component
- [ ] Existing mocks/factories reused
- [ ] Shared mocks extracted to `src/__mocks__/` if used in multiple files
- [ ] **Coverage is appropriate** (80% target, lower OK if justified)
- [ ] **No trivial tests** written
- [ ] **Snapshot tests considered** (where they add value, not forced)
- [ ] Tests pass: `pnpm test <test-file>`
- [ ] Linting passes: `pnpm lint <test-file>`

---

### Snapshot Tests (When Appropriate)

Use snapshots **where they add value**, don't force them.

**Good for snapshots:**
- Complex UI structures that should remain stable
- Components with multiple visual states
- Tables or lists with specific formatting

**NOT good for snapshots:**
- Simple components (1-2 elements)
- Components that change frequently
- Dynamic content (timestamps, IDs)

```typescript
describe('GIVEN the component renders different states', () => {
  describe('WHEN in error state', () => {
    it('THEN should match snapshot', () => {
      const { container } = render(<Component error="Failed" />)

      expect(container).toMatchSnapshot()
    })
  })
})
```

---

## What NOT to Test (Even If Coverage Drops)

- Translation key values
- Pure UI styling
- Third-party library internals
- Simple prop pass-through
- Components that only re-export
- Loading skeletons / spinners
- Basic JSX structure ("component renders a div")
