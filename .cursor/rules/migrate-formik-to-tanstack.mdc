---
description: Migrate a React form from Formik to TanStack Form following project conventions. Use this rule when migrating a form component from Formik to TanStack Form.
globs:
  - "src/**/*.tsx"
  - "src/**/*.ts"
---

# Formik to TanStack Form Migration Guide

This guide helps migrate React form components from Formik to TanStack Form, following the established patterns in this codebase.

## Prerequisites

Before starting, gather context by reading these reference files:

### Simple Forms
1. **Hook Pattern**: `src/hooks/forms/useAppform.ts` - The custom `useAppForm` hook
2. **Validation Schema Example**: `src/pages/auth/signUpForm/validationSchema.ts`
3. **Form Component Example**: `src/pages/settings/roles/roleCreateEdit/RoleCreateEdit.tsx`

### Complex Forms (with sub-components)
4. **Complex Form Example**: `src/pages/createCustomers/CreateCustomer.tsx` - Main form with sub-components
5. **Complex Validation Schema**: `src/pages/createCustomers/formInitialization/validationSchema.ts` - Nested Zod schemas with refinements
6. **Sub-component with withForm**: `src/pages/createCustomers/customerInformation/CustomerInformation.tsx` - HOC pattern

### Test Examples
7. **TanStack Form Test**: `src/pages/createCustomers/__tests__/CreateCustomer.test.tsx` - Complete test example for TanStack forms

---

## Migration Steps

### Phase 1: Pre-Migration Analysis

#### Step 1.1: Analyze the Current Form Structure

1. Read the target form file completely
2. Identify:
   - Form fields and their types
   - Current Formik configuration (`useFormik` or `<Formik>`)
   - Submit handler logic
   - Field components used (`TextInputField`, `Checkbox`, etc.)
   - Any `formikProps` usage
   - Sub-components that receive `formikProps`

#### Step 1.2: Deep Validation Analysis (CRITICAL)

**This step is critical. Document ALL validations before proceeding.**

1. **Locate validation sources** - Search for:
   ```typescript
   // Yup schema (most common)
   validationSchema: yupSchema

   // Inline validate function
   validate: (values) => { ... }

   // Field-level validation
   <Field validate={(value) => ...} />

   // validateOnBlur, validateOnChange settings
   ```

2. **Create Validation Mapping Table**:

   | Field Name | Current Validation (Formik/Yup) | Zod Equivalent | Notes |
   |------------|--------------------------------|----------------|-------|
   | name | `yup.string().required()` | `z.string().min(1)` | |
   | email | `yup.string().email().required()` | `z.string().email().min(1)` | |
   | age | `yup.number().min(18).max(100)` | `z.number().min(18).max(100)` | |
   | password | `yup.string().min(8).matches(/[A-Z]/)` | `z.string().min(8).regex(/[A-Z]/)` | |

3. **Identify Cross-Field Validations**:
   ```typescript
   // Example: password confirmation
   .test('passwords-match', 'Passwords must match', function(value) {
     return this.parent.password === value
   })

   // Maps to Zod .refine():
   .refine((data) => data.password === data.confirmPassword, {
     message: 'Passwords must match',
     path: ['confirmPassword'],
   })
   ```

4. **Document Conditional Validations**:
   ```typescript
   // Example: required only if another field has value
   .when('hasAddress', {
     is: true,
     then: yup.string().required(),
   })

   // Maps to Zod .refine():
   .refine((data) => !data.hasAddress || data.address, {
     message: 'Address is required',
     path: ['address'],
   })
   ```

5. **Check for Custom Validation Messages** - Note all custom error messages to preserve in Zod schema

6. **Identify Async Validations** (if any) - These require special handling in TanStack Form

#### Step 1.3: Create Validation Migration Plan

Before writing any code, create a plan document:

```markdown
## Validation Migration Plan: [FormName]

### Validation Sources Found
- [ ] Yup validationSchema: `path/to/schema.ts`
- [ ] Inline validate function: line XX
- [ ] Field-level validations: lines XX, YY
- [ ] No explicit validation

### Field Validations
| Field | Yup Validation | Zod Equivalent | Custom Message |
|-------|---------------|----------------|----------------|
| ... | ... | ... | ... |

### Cross-Field Validations
| Fields Involved | Yup Logic | Zod .refine() Logic |
|-----------------|-----------|---------------------|
| ... | ... | ... |

### Conditional Validations
| Condition | Affected Fields | Zod Implementation |
|-----------|-----------------|-------------------|
| ... | ... | ... |

### Submit Button Disabled Logic
Current: `disabled={!formikProps.isValid || !formikProps.dirty || loading}`
TanStack: `form.SubmitButton` handles isValid + dirty automatically
```

---

### Phase 2: Implementation

#### Step 2.1: Create Validation Schema

Create a new file: `src/pages/<path>/<formName>/validationSchema.ts`

**Use your Validation Migration Plan from Phase 1 to implement each validation.**

```typescript
import { z } from 'zod'

// Import any enums from generated GraphQL if needed
import { SomeEnum } from '~/generated/graphql'

// Main form schema - implement ALL validations from the plan
export const <formName>ValidationSchema = z.object({
  // Required string (was: yup.string().required())
  fieldName: z.string().min(1, 'Field is required'),

  // Optional string (was: yup.string())
  optionalField: z.string().optional(),

  // Email validation (was: yup.string().email().required())
  email: z.string().email('Invalid email').min(1, 'Email is required'),

  // Number with range (was: yup.number().min(0).max(100))
  percentage: z.number().min(0).max(100),

  // Enum (was: yup.string().oneOf([...]))
  status: z.nativeEnum(SomeEnum),

  // Array (was: yup.array().of(...))
  items: z.array(fieldSchema),
})
// Add cross-field validations from the plan
.refine(
  (data) => /* validation logic from plan */,
  { message: 'Error message', path: ['fieldName'] }
)

export type <FormName>Values = z.infer<typeof <formName>ValidationSchema>
```

**Yup to Zod Quick Reference:**

| Yup | Zod |
|-----|-----|
| `yup.string().required()` | `z.string().min(1, 'Required')` |
| `yup.string().email()` | `z.string().email()` |
| `yup.string().min(5)` | `z.string().min(5)` |
| `yup.string().max(100)` | `z.string().max(100)` |
| `yup.string().matches(/regex/)` | `z.string().regex(/regex/)` |
| `yup.string().oneOf(['a', 'b'])` | `z.enum(['a', 'b'])` |
| `yup.number().required()` | `z.number()` |
| `yup.number().min(0)` | `z.number().min(0)` |
| `yup.number().max(100)` | `z.number().max(100)` |
| `yup.number().positive()` | `z.number().positive()` |
| `yup.number().integer()` | `z.number().int()` |
| `yup.boolean()` | `z.boolean()` |
| `yup.array().of(schema)` | `z.array(schema)` |
| `yup.array().min(1)` | `z.array(schema).min(1)` |
| `yup.object().shape({})` | `z.object({})` |
| `.nullable()` | `.nullable()` |
| `.optional()` | `.optional()` |
| `.default(value)` | `.default(value)` |
| `.when('field', ...)` | `.refine((data) => ...)` |
| `.test('name', msg, fn)` | `.refine(fn, { message: msg })` |

#### Step 2.2: Update Imports

Replace Formik imports:

```diff
- import { useFormik } from 'formik'
- import * as Yup from 'yup'  // Remove if present
+ import { revalidateLogic, useStore } from '@tanstack/react-form'
+ import { useAppForm } from '~/hooks/forms/useAppform'
```

Add validation schema import:
```typescript
import { <formName>ValidationSchema } from './<formName>/validationSchema'
```

Remove unused Formik-related imports like `TextInputField` with `formikProps`.

#### Step 2.3: Replace useFormik with useAppForm

**Before (Formik):**
```typescript
const formikProps = useFormik<FormValues>({
  initialValues: { name: '', ... },
  validateOnMount: true,
  enableReinitialize: true,
  validationSchema: someSchema,
  onSubmit: async (values) => { ... }
})
```

**After (TanStack Form):**
```typescript
const form = useAppForm({
  defaultValues: {
    name: existingData?.name || '',
    // ... other fields
  },
  validationLogic: revalidateLogic(),
  validators: {
    onDynamic: <formName>ValidationSchema,
  },
  onSubmit: async ({ value }) => {
    const { field1, field2, ...rest } = value
    // ... submit logic
  },
})
```

#### Step 2.4: Subscribe to Form State (if needed)

For accessing form values outside of field components:

```typescript
const someField = useStore(form.store, (state) => state.values.someField)
```

#### Step 2.5: Update Field Components

**Text Input Field:**
```diff
- <TextInputField
-   name="fieldName"
-   label={translate('...')}
-   formikProps={formikProps}
- />
+ <form.AppField name="fieldName">
+   {(field) => (
+     <field.TextInputField
+       label={translate('...')}
+     />
+   )}
+ </form.AppField>
```

**Other field types follow the same pattern:**
- `field.ComboBoxField`
- `field.TextInputField`
- `field.CheckboxField`
- etc.

#### Step 2.6: Update Form Submission

**Wrap content in a form element:**
```typescript
const handleSubmit = (event: React.FormEvent) => {
  event.preventDefault()
  form.handleSubmit()
}

return (
  <form onSubmit={handleSubmit}>
    {/* form content */}
  </form>
)
```

**Replace submit button:**
```diff
- <Button
-   onClick={formikProps.submitForm}
-   disabled={!formikProps.isValid || (isEdition && !formikProps.dirty)}
- >
+ <form.AppForm>
+   <form.SubmitButton disabled={externalLoadingState}>
      {submitButtonText}
+   </form.SubmitButton>
+ </form.AppForm>
```

Note: `form.SubmitButton` handles `canSubmit` (validity + dirty state) automatically.

#### Step 2.7: Update Field Value Changes

**Before:**
```typescript
formikProps.setFieldValue('fieldName', newValue)
```

**After:**
```typescript
form.setFieldValue('fieldName', newValue)
```

#### Step 2.8: Update Value Access

**Before:**
```typescript
formikProps.values.fieldName
```

**After (in field render):**
```typescript
field.state.value
```

**After (outside field, using useStore):**
```typescript
const fieldValue = useStore(form.store, (state) => state.values.fieldName)
```

---

### Phase 3: Verification

#### Step 3.1: Validate Migration Against Plan

Go back to your Validation Migration Plan and verify:

- [ ] All field validations are implemented in Zod schema
- [ ] All cross-field validations use `.refine()`
- [ ] All conditional validations are handled
- [ ] All custom error messages are preserved
- [ ] Validation timing matches original (onChange, onBlur, onMount)

#### Step 3.2: Test Validation Behavior

Manually test each validation case:

1. **Required fields**: Leave empty, verify error appears
2. **Format validations**: Enter invalid email/URL/etc, verify error
3. **Range validations**: Enter out-of-range values, verify error
4. **Cross-field validations**: Test dependent field combinations
5. **Conditional validations**: Toggle conditions, verify validation changes

#### Step 3.3: Proceed to Test Migration

**IMPORTANT:** After verifying the form works correctly, proceed to **Phase 4: Test Migration**. This step is mandatory - never skip updating or creating tests.

---

## Advanced Patterns (Complex Forms)

For complex forms with multiple sections or sub-components, use these additional patterns.

### Pattern 1: withForm HOC for Sub-Components

When splitting a form into multiple sub-components, use the `withForm` HOC:

```typescript
import { withForm } from '~/hooks/forms/useAppform'
import { emptyCreateCustomerDefaultValues } from './formInitialization/validationSchema'

interface CustomerInformationProps {
  isEdition: boolean
  customer?: CustomerDetails
}

const defaultProps: CustomerInformationProps = {
  isEdition: false,
}

const CustomerInformation = withForm({
  defaultValues: emptyCreateCustomerDefaultValues,
  props: defaultProps,
  render: function Render({ form, isEdition, customer }) {
    return (
      <div>
        <form.AppField name="name">
          {(field) => (
            <field.TextInputField label="Name" />
          )}
        </form.AppField>
      </div>
    )
  },
})

export default CustomerInformation
```

**Usage in parent form:**
```typescript
<CustomerInformation form={form} isEdition={isEdition} customer={customer} />
```

### Pattern 2: Complex Zod Schemas with Refinements

```typescript
import { z } from 'zod'

const addressSchema = z.object({
  addressLine1: z.string().optional(),
  city: z.string().optional(),
  zipcode: z.string().optional(),
  country: z.string().optional(),
})

export const customerValidationSchema = z
  .object({
    name: z.string().min(1, 'Name is required'),
    externalId: z.string().min(1, 'External ID is required'),
    billingConfiguration: z.object({
      documentLocale: z.string().optional(),
    }),
    shippingAddress: addressSchema,
  })
  .refine(
    (data) => {
      if (data.someCondition) {
        return data.relatedField !== undefined
      }
      return true
    },
    {
      message: 'Related field is required when condition is true',
      path: ['relatedField'],
    }
  )

export const emptyDefaultValues: z.infer<typeof customerValidationSchema> = {
  name: '',
  externalId: '',
  // ... all fields with default values
}
```

### Pattern 3: Mappers for API â†” Form Data

```typescript
export const mapFromApiToForm = (customer: CustomerFragment): CustomerFormValues => ({
  name: customer.name || '',
  externalId: customer.externalId || '',
  currency: customer.currency || undefined,
})

export const mapFromFormToApi = (values: CustomerFormValues): CreateCustomerInput => ({
  name: values.name,
  externalId: values.externalId,
  currency: values.currency || null,
})
```

### Pattern 4: Error Handling with setErrorMap

```typescript
const form = useAppForm({
  onSubmit: async ({ value, formApi }) => {
    try {
      await createCustomer({ variables: { input: value } })
    } catch (error) {
      if (error instanceof ApolloError) {
        formApi.setErrorMap({
          onSubmit: {
            fields: {
              externalId: 'This ID already exists',
            },
          },
        })
      }
    }
  },
})
```

### Pattern 5: Scroll to First Error on Invalid Submit

```typescript
const form = useAppForm({
  onSubmitInvalid: ({ formApi }) => {
    const firstErrorField = Object.keys(formApi.state.fieldMeta).find(
      (key) => formApi.state.fieldMeta[key]?.errors?.length > 0
    )

    if (firstErrorField) {
      const element = document.querySelector(`[name="${firstErrorField}"]`)
      element?.scrollIntoView({ behavior: 'smooth', block: 'center' })
    }
  },
})
```

---

---

### Phase 4: Test Migration

**CRITICAL: This phase is mandatory. Never skip test migration/creation.**

After completing Phases 1-3 and verifying the form migration works correctly, invoke the `/make-tests` skill to handle test creation or migration.

Pass the local branch name (not yet pushed to origin) so the skill can automatically detect all modified files:

```
/make-tests <local-branch-name>
```

**Example:**
```
/make-tests feature/migrate-customer-form-to-tanstack
```

The `/make-tests` skill will:
- Use git diff to find all component files modified in the branch
- Add `data-test` attributes to the components
- Check for existing tests and migrate them from Formik patterns
- Create new tests if none exist
- Follow all project testing conventions

---

## Common Issues

### Basic Issues
1. **Form not submitting**: Ensure `<form onSubmit={handleSubmit}>` wraps content
2. **Submit button always disabled**: Check `form.SubmitButton` is inside `form.AppForm`
3. **Values not updating**: Use `useStore` to subscribe to values outside field components
4. **TypeScript errors**: Ensure validation schema matches form field types
5. **jsdom CSS selector errors in tests**: Use `fireEvent.click` instead of `userEvent.click` for checkbox tests

### Complex Form Issues
6. **Sub-component not receiving form**: Pass `form={form}` prop explicitly to sub-components using `withForm`
7. **Nested validation not working**: Ensure nested Zod schemas are properly composed (not just referenced)
8. **Server errors not displaying**: Use `formApi.setErrorMap` with the correct field paths
9. **Refine validation failing silently**: Check that the `path` option in `.refine()` matches the actual field name
10. **Default values type mismatch**: Export and use `emptyDefaultValues` from validation schema for consistent typing
11. **Form dirty state incorrect with mappers**: Ensure mapper output structure exactly matches `defaultValues` structure

### Test Migration Issues
12. **Tests still using Formik mocks**: Remove `createMockFormikProps` and similar patterns; TanStack forms don't need mocking
13. **Tests failing on async operations**: Add `waitFor` wrappers for form state changes
14. **Checkbox tests failing in jsdom**: Use `fireEvent.click` instead of `userEvent.click` for checkbox interactions
15. **Missing GraphQL mocks**: Ensure all queries used by the form component have mock responses in tests

### Testing with data-test Attributes Issues
16. **Tests using translation keys**: Never use `getByText(translate('key'))` - export data-test constants from component and use `getByTestId()`
17. **Missing data-test exports**: Export constants like `MY_FORM_TEST_ID` from the component file for tests to import
18. **form.SubmitButton data-test not working**: Use `dataTest` prop (camelCase) instead of `data-test` attribute
19. **Component doesn't support data-test**: Wrap the component in a `<div data-test={...}>` container
20. **Test can't find element by testId**: Verify the data-test attribute is on the correct element and the constant is properly exported/imported
