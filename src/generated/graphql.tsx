import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: { input: any; output: any; }
  ChargeFilterValues: { input: any; output: any; }
  /** Api Logs HTTP status */
  HttpStatus: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: any; output: any; }
  /** Represents untyped JSON */
  JSON: { input: any; output: any; }
  ObfuscatedString: { input: any; output: any; }
};

/** Autogenerated input type of AcceptInvite */
export type AcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  /** Uniq token of the Invite */
  token: Scalars['String']['input'];
};

/** Base activity log */
export type ActivityLog = {
  __typename?: 'ActivityLog';
  activityId: Scalars['ID']['output'];
  activityObject?: Maybe<Scalars['JSON']['output']>;
  activityObjectChanges?: Maybe<Scalars['JSON']['output']>;
  activitySource: ActivitySourceEnum;
  activityType: ActivityTypeEnum;
  apiKey?: Maybe<SanitizedApiKey>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  externalSubscriptionId?: Maybe<Scalars['String']['output']>;
  loggedAt: Scalars['ISO8601DateTime']['output'];
  organization?: Maybe<Organization>;
  resource?: Maybe<ActivityLogResourceObject>;
  userEmail?: Maybe<Scalars['String']['output']>;
};

/** ActivityLogCollection type */
export type ActivityLogCollection = {
  __typename?: 'ActivityLogCollection';
  /** A collection of paginated ActivityLogCollection */
  collection: Array<ActivityLog>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Activity log resource */
export type ActivityLogResourceObject = BillableMetric | BillingEntity | Coupon | CreditNote | Customer | FeatureObject | Invoice | PaymentRequest | Plan | Subscription | Wallet;

/** Activity Logs source enums */
export enum ActivitySourceEnum {
  Api = 'api',
  Front = 'front',
  System = 'system'
}

/** Activity Logs type enums */
export enum ActivityTypeEnum {
  /** applied_coupon.created */
  AppliedCouponCreated = 'applied_coupon_created',
  /** applied_coupon.deleted */
  AppliedCouponDeleted = 'applied_coupon_deleted',
  /** billable_metric.created */
  BillableMetricCreated = 'billable_metric_created',
  /** billable_metric.deleted */
  BillableMetricDeleted = 'billable_metric_deleted',
  /** billable_metric.updated */
  BillableMetricUpdated = 'billable_metric_updated',
  /** billing_entities.created */
  BillingEntitiesCreated = 'billing_entities_created',
  /** billing_entities.deleted */
  BillingEntitiesDeleted = 'billing_entities_deleted',
  /** billing_entities.updated */
  BillingEntitiesUpdated = 'billing_entities_updated',
  /** coupon.created */
  CouponCreated = 'coupon_created',
  /** coupon.deleted */
  CouponDeleted = 'coupon_deleted',
  /** coupon.updated */
  CouponUpdated = 'coupon_updated',
  /** credit_note.created */
  CreditNoteCreated = 'credit_note_created',
  /** credit_note.generated */
  CreditNoteGenerated = 'credit_note_generated',
  /** credit_note.refund_failure */
  CreditNoteRefundFailure = 'credit_note_refund_failure',
  /** customer.created */
  CustomerCreated = 'customer_created',
  /** customer.deleted */
  CustomerDeleted = 'customer_deleted',
  /** customer.updated */
  CustomerUpdated = 'customer_updated',
  /** feature.created */
  FeatureCreated = 'feature_created',
  /** feature.deleted */
  FeatureDeleted = 'feature_deleted',
  /** feature.updated */
  FeatureUpdated = 'feature_updated',
  /** invoice.created */
  InvoiceCreated = 'invoice_created',
  /** invoice.drafted */
  InvoiceDrafted = 'invoice_drafted',
  /** invoice.failed */
  InvoiceFailed = 'invoice_failed',
  /** invoice.generated */
  InvoiceGenerated = 'invoice_generated',
  /** invoice.one_off_created */
  InvoiceOneOffCreated = 'invoice_one_off_created',
  /** invoice.paid_credit_added */
  InvoicePaidCreditAdded = 'invoice_paid_credit_added',
  /** invoice.payment_failure */
  InvoicePaymentFailure = 'invoice_payment_failure',
  /** invoice.payment_overdue */
  InvoicePaymentOverdue = 'invoice_payment_overdue',
  /** invoice.payment_status_updated */
  InvoicePaymentStatusUpdated = 'invoice_payment_status_updated',
  /** invoice.regenerated */
  InvoiceRegenerated = 'invoice_regenerated',
  /** invoice.voided */
  InvoiceVoided = 'invoice_voided',
  /** payment_receipt.created */
  PaymentReceiptCreated = 'payment_receipt_created',
  /** payment_receipt.generated */
  PaymentReceiptGenerated = 'payment_receipt_generated',
  /** payment.recorded */
  PaymentRecorded = 'payment_recorded',
  /** payment_request.created */
  PaymentRequestCreated = 'payment_request_created',
  /** plan.created */
  PlanCreated = 'plan_created',
  /** plan.deleted */
  PlanDeleted = 'plan_deleted',
  /** plan.updated */
  PlanUpdated = 'plan_updated',
  /** subscription.started */
  SubscriptionStarted = 'subscription_started',
  /** subscription.terminated */
  SubscriptionTerminated = 'subscription_terminated',
  /** subscription.updated */
  SubscriptionUpdated = 'subscription_updated',
  /** wallet.created */
  WalletCreated = 'wallet_created',
  /** wallet_transaction.created */
  WalletTransactionCreated = 'wallet_transaction_created',
  /** wallet_transaction.payment_failure */
  WalletTransactionPaymentFailure = 'wallet_transaction_payment_failure',
  /** wallet_transaction.updated */
  WalletTransactionUpdated = 'wallet_transaction_updated',
  /** wallet.updated */
  WalletUpdated = 'wallet_updated'
}

/** Adyen input arguments */
export type AddAdyenPaymentProviderInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  hmacKey?: InputMaybe<Scalars['String']['input']>;
  livePrefix?: InputMaybe<Scalars['String']['input']>;
  merchantAccount: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Cashfree input arguments */
export type AddCashfreePaymentProviderInput = {
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Flutterwave input arguments */
export type AddFlutterwavePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  secretKey: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Gocardless input arguments */
export type AddGocardlessPaymentProviderInput = {
  accessCode?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Moneyhash input arguments */
export type AddMoneyhashPaymentProviderInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  flowId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export type AddOn = {
  __typename?: 'AddOn';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  appliedAddOnsCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this add-on */
  customersCount: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};


export type AddOnIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};

/** AddOnCollection type */
export type AddOnCollection = {
  __typename?: 'AddOnCollection';
  /** A collection of paginated AddOnCollection */
  collection: Array<AddOn>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Stripe input arguments */
export type AddStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  secretKey?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum AdjustedFeeTypeEnum {
  AdjustedAmount = 'adjusted_amount',
  AdjustedUnits = 'adjusted_units'
}

export type AdyenProvider = {
  __typename?: 'AdyenProvider';
  apiKey?: Maybe<Scalars['ObfuscatedString']['output']>;
  code: Scalars['String']['output'];
  hmacKey?: Maybe<Scalars['ObfuscatedString']['output']>;
  id: Scalars['ID']['output'];
  livePrefix?: Maybe<Scalars['String']['output']>;
  merchantAccount?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export enum AggregationTypeEnum {
  CountAgg = 'count_agg',
  CustomAgg = 'custom_agg',
  LatestAgg = 'latest_agg',
  MaxAgg = 'max_agg',
  SumAgg = 'sum_agg',
  UniqueCountAgg = 'unique_count_agg',
  WeightedSumAgg = 'weighted_sum_agg'
}

export type AiConversation = {
  __typename?: 'AiConversation';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  mistralConversationId?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  organization: Organization;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** AiConversationCollection type */
export type AiConversationCollection = {
  __typename?: 'AiConversationCollection';
  /** A collection of paginated AiConversationCollection */
  collection: Array<AiConversation>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type AiConversationMessage = {
  __typename?: 'AiConversationMessage';
  content: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  type: Scalars['String']['output'];
};

export type AiConversationStream = {
  __typename?: 'AiConversationStream';
  chunk?: Maybe<Scalars['String']['output']>;
  done: Scalars['Boolean']['output'];
};

export type AiConversationWithMessages = {
  __typename?: 'AiConversationWithMessages';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Messages belonging to this conversation */
  messages: Array<AiConversationMessage>;
  mistralConversationId?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  organization: Organization;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Alert = {
  __typename?: 'Alert';
  alertType: AlertTypeEnum;
  billableMetric?: Maybe<BillableMetric>;
  billableMetricId?: Maybe<Scalars['ID']['output']>;
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  subscriptionExternalId: Scalars['String']['output'];
  thresholds?: Maybe<Array<AlertThreshold>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** AlertCollection type */
export type AlertCollection = {
  __typename?: 'AlertCollection';
  /** A collection of paginated AlertCollection */
  collection: Array<Alert>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type AlertThreshold = {
  __typename?: 'AlertThreshold';
  code?: Maybe<Scalars['String']['output']>;
  recurring: Scalars['Boolean']['output'];
  value: Scalars['String']['output'];
};

export enum AlertTypeEnum {
  BillableMetricCurrentUsageAmount = 'billable_metric_current_usage_amount',
  BillableMetricCurrentUsageUnits = 'billable_metric_current_usage_units',
  CurrentUsageAmount = 'current_usage_amount',
  LifetimeUsageAmount = 'lifetime_usage_amount'
}

export type AnrokCustomer = {
  __typename?: 'AnrokCustomer';
  externalAccountId?: Maybe<Scalars['String']['output']>;
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type AnrokIntegration = {
  __typename?: 'AnrokIntegration';
  apiKey: Scalars['ObfuscatedString']['output'];
  code: Scalars['String']['output'];
  externalAccountId?: Maybe<Scalars['String']['output']>;
  failedInvoicesCount?: Maybe<Scalars['Int']['output']>;
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type ApiKey = {
  __typename?: 'ApiKey';
  createdAt: Scalars['ISO8601DateTime']['output'];
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastUsedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  permissions: Scalars['JSON']['output'];
  value: Scalars['String']['output'];
};

export enum ApiKeysPermissionsEnum {
  ActivityLog = 'activity_log',
  AddOn = 'add_on',
  Alert = 'alert',
  Analytic = 'analytic',
  AppliedCoupon = 'applied_coupon',
  BillableMetric = 'billable_metric',
  BillingEntity = 'billing_entity',
  Coupon = 'coupon',
  CreditNote = 'credit_note',
  Customer = 'customer',
  CustomerUsage = 'customer_usage',
  Event = 'event',
  Feature = 'feature',
  Fee = 'fee',
  Invoice = 'invoice',
  InvoiceCustomSection = 'invoice_custom_section',
  LifetimeUsage = 'lifetime_usage',
  Organization = 'organization',
  Payment = 'payment',
  PaymentReceipt = 'payment_receipt',
  PaymentRequest = 'payment_request',
  Plan = 'plan',
  Subscription = 'subscription',
  Tax = 'tax',
  Wallet = 'wallet',
  WalletTransaction = 'wallet_transaction',
  WebhookEndpoint = 'webhook_endpoint',
  WebhookJwtPublicKey = 'webhook_jwt_public_key'
}

/** Base api log */
export type ApiLog = {
  __typename?: 'ApiLog';
  apiKey?: Maybe<SanitizedApiKey>;
  apiVersion?: Maybe<Scalars['String']['output']>;
  client?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  httpMethod: HttpMethodEnum;
  httpStatus: Scalars['Int']['output'];
  loggedAt: Scalars['ISO8601DateTime']['output'];
  requestBody?: Maybe<Scalars['JSON']['output']>;
  requestId: Scalars['ID']['output'];
  requestOrigin?: Maybe<Scalars['String']['output']>;
  requestPath?: Maybe<Scalars['String']['output']>;
  requestResponse: Scalars['JSON']['output'];
};

/** ApiLogCollection type */
export type ApiLogCollection = {
  __typename?: 'ApiLogCollection';
  /** A collection of paginated ApiLogCollection */
  collection: Array<ApiLog>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type AppliedAddOn = {
  __typename?: 'AppliedAddOn';
  addOn: AddOn;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
};

export type AppliedCoupon = {
  __typename?: 'AppliedCoupon';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCentsRemaining?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  coupon: Coupon;
  createdAt: Scalars['ISO8601DateTime']['output'];
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  frequencyDurationRemaining?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  percentageRate?: Maybe<Scalars['Float']['output']>;
  terminatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AppliedPricingUnit = {
  __typename?: 'AppliedPricingUnit';
  conversionRate: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  pricingUnit: PricingUnit;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AppliedPricingUnitInput = {
  code: Scalars['String']['input'];
  conversionRate: Scalars['Float']['input'];
};

export type AppliedPricingUnitOverrideInput = {
  conversionRate: Scalars['Float']['input'];
};

export type AppliedTax = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AppliesToInput = {
  billableMetricIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  feeTypes?: InputMaybe<Array<FeeTypesEnum>>;
};

/** Autogenerated input type of ApplyTaxes */
export type ApplyTaxesInput = {
  billingEntityId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  taxCodes: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of ApplyTaxes. */
export type ApplyTaxesPayload = {
  __typename?: 'ApplyTaxesPayload';
  appliedTaxes: Array<Tax>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type AuthUrl = {
  __typename?: 'AuthUrl';
  url: Scalars['String']['output'];
};

/** Organization Authentication Methods Values */
export enum AuthenticationMethodsEnum {
  EmailPassword = 'email_password',
  GoogleOauth = 'google_oauth',
  Okta = 'okta'
}

export type Authorize = {
  __typename?: 'Authorize';
  url: Scalars['String']['output'];
};

export type AvalaraCustomer = {
  __typename?: 'AvalaraCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type AvalaraIntegration = {
  __typename?: 'AvalaraIntegration';
  accountId?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  companyCode: Scalars['String']['output'];
  companyId?: Maybe<Scalars['String']['output']>;
  failedInvoicesCount?: Maybe<Scalars['Int']['output']>;
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  licenseKey: Scalars['ObfuscatedString']['output'];
  name: Scalars['String']['output'];
};

/** Base billable metric */
export type BillableMetric = {
  __typename?: 'BillableMetric';
  activityLogs?: Maybe<Array<ActivityLog>>;
  aggregationType: AggregationTypeEnum;
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['String']['output']>;
  fieldName?: Maybe<Scalars['String']['output']>;
  filters?: Maybe<Array<BillableMetricFilter>>;
  hasActiveSubscriptions: Scalars['Boolean']['output'];
  hasDraftInvoices: Scalars['Boolean']['output'];
  hasPlans: Scalars['Boolean']['output'];
  hasSubscriptions: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  recurring: Scalars['Boolean']['output'];
  roundingFunction?: Maybe<RoundingFunctionEnum>;
  roundingPrecision?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  weightedInterval?: Maybe<WeightedIntervalEnum>;
};


/** Base billable metric */
export type BillableMetricIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};

/** BillableMetricCollection type */
export type BillableMetricCollection = {
  __typename?: 'BillableMetricCollection';
  /** A collection of paginated BillableMetricCollection */
  collection: Array<BillableMetric>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Billable metric filters */
export type BillableMetricFilter = {
  __typename?: 'BillableMetricFilter';
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

/** Billable metric filters input arguments */
export type BillableMetricFiltersInput = {
  key: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

/** Base billing entity */
export type BillingEntity = {
  __typename?: 'BillingEntity';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  appliedDunningCampaign?: Maybe<DunningCampaign>;
  billingConfiguration?: Maybe<BillingEntityBillingConfiguration>;
  city?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  defaultCurrency: CurrencyEnum;
  documentNumberPrefix: Scalars['String']['output'];
  documentNumbering: BillingEntityDocumentNumberingEnum;
  einvoicing: Scalars['Boolean']['output'];
  email?: Maybe<Scalars['String']['output']>;
  emailSettings?: Maybe<Array<BillingEntityEmailSettingsEnum>>;
  euTaxManagement: Scalars['Boolean']['output'];
  finalizeZeroAmountInvoice: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  netPaymentTerm: Scalars['Int']['output'];
  organization: Organization;
  selectedInvoiceCustomSections?: Maybe<Array<InvoiceCustomSection>>;
  state?: Maybe<Scalars['String']['output']>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  zipcode?: Maybe<Scalars['String']['output']>;
};

export type BillingEntityBillingConfiguration = {
  __typename?: 'BillingEntityBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceFooter?: Maybe<Scalars['String']['output']>;
  invoiceGracePeriod: Scalars['Int']['output'];
};

export type BillingEntityBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  invoiceFooter?: InputMaybe<Scalars['String']['input']>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

/** BillingEntityCollection type */
export type BillingEntityCollection = {
  __typename?: 'BillingEntityCollection';
  /** A collection of paginated BillingEntityCollection */
  collection: Array<BillingEntity>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Document numbering type */
export enum BillingEntityDocumentNumberingEnum {
  PerBillingEntity = 'per_billing_entity',
  PerCustomer = 'per_customer'
}

/** BillingEntity Email Settings Values */
export enum BillingEntityEmailSettingsEnum {
  /** credit_note.created */
  CreditNoteCreated = 'credit_note_created',
  /** invoice.finalized */
  InvoiceFinalized = 'invoice_finalized',
  /** payment_receipt.created */
  PaymentReceiptCreated = 'payment_receipt_created'
}

/** Autogenerated input type of BillingEntityUpdateAppliedDunningCampaign */
export type BillingEntityUpdateAppliedDunningCampaignInput = {
  appliedDunningCampaignId?: InputMaybe<Scalars['String']['input']>;
  billingEntityId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

export enum BillingTimeEnum {
  Anniversary = 'anniversary',
  Calendar = 'calendar'
}

export type CashfreeProvider = {
  __typename?: 'CashfreeProvider';
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export type Charge = {
  __typename?: 'Charge';
  appliedPricingUnit?: Maybe<AppliedPricingUnit>;
  billableMetric: BillableMetric;
  chargeModel: ChargeModelEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  filters?: Maybe<Array<ChargeFilter>>;
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceable: Scalars['Boolean']['output'];
  minAmountCents: Scalars['BigInt']['output'];
  payInAdvance: Scalars['Boolean']['output'];
  properties?: Maybe<Properties>;
  prorated: Scalars['Boolean']['output'];
  regroupPaidFees?: Maybe<RegroupPaidFeesEnum>;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Charge filters object */
export type ChargeFilter = {
  __typename?: 'ChargeFilter';
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  properties: Properties;
  values: Scalars['ChargeFilterValues']['output'];
};

/** Charge filters input arguments */
export type ChargeFilterInput = {
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  properties: PropertiesInput;
  values: Scalars['ChargeFilterValues']['input'];
};

export type ChargeFilterUsage = {
  __typename?: 'ChargeFilterUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  id?: Maybe<Scalars['ID']['output']>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  units: Scalars['Float']['output'];
  values: Scalars['ChargeFilterValues']['output'];
};

export type ChargeInput = {
  appliedPricingUnit?: InputMaybe<AppliedPricingUnitInput>;
  billableMetricId: Scalars['ID']['input'];
  chargeModel: ChargeModelEnum;
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  invoiceable?: InputMaybe<Scalars['Boolean']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  payInAdvance?: InputMaybe<Scalars['Boolean']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  prorated?: InputMaybe<Scalars['Boolean']['input']>;
  regroupPaidFees?: InputMaybe<RegroupPaidFeesEnum>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum ChargeModelEnum {
  Custom = 'custom',
  Dynamic = 'dynamic',
  Graduated = 'graduated',
  GraduatedPercentage = 'graduated_percentage',
  Package = 'package',
  Percentage = 'percentage',
  Standard = 'standard',
  Volume = 'volume'
}

export type ChargeOverridesInput = {
  appliedPricingUnit?: InputMaybe<AppliedPricingUnitOverrideInput>;
  billableMetricId: Scalars['ID']['input'];
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ChargeUsage = {
  __typename?: 'ChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  billableMetric: BillableMetric;
  charge: Charge;
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedUsage: Array<GroupedChargeUsage>;
  id: Scalars['ID']['output'];
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  units: Scalars['Float']['output'];
};

export type CollectionMapping = {
  __typename?: 'CollectionMapping';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappingType: MappingTypeEnum;
  taxCode?: Maybe<Scalars['String']['output']>;
  taxNexus?: Maybe<Scalars['String']['output']>;
  taxType?: Maybe<Scalars['String']['output']>;
};

/** CollectionMappingCollection type */
export type CollectionMappingCollection = {
  __typename?: 'CollectionMappingCollection';
  /** A collection of paginated CollectionMappingCollection */
  collection: Array<CollectionMapping>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Type for CollectionMetadataType */
export type CollectionMetadata = {
  __typename?: 'CollectionMetadata';
  /** Current Page of loaded data */
  currentPage: Scalars['Int']['output'];
  /** The number of items per page */
  limitValue: Scalars['Int']['output'];
  /** The total number of items to be paginated */
  totalCount: Scalars['Int']['output'];
  /** The total number of pages in the pagination */
  totalPages: Scalars['Int']['output'];
};

export type Commitment = {
  __typename?: 'Commitment';
  amountCents: Scalars['BigInt']['output'];
  commitmentType: CommitmentTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  plan: Plan;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CommitmentInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  commitmentType?: InputMaybe<CommitmentTypeEnum>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum CommitmentTypeEnum {
  MinimumCommitment = 'minimum_commitment'
}

export enum CountryCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates (the) */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland Islands */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia (Plurinational State of) */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas (the) */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands (the) */
  Cc = 'CC',
  /** Congo (the Democratic Republic of the) */
  Cd = 'CD',
  /** Central African Republic (the) */
  Cf = 'CF',
  /** Congo (the) */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands (the) */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cuba */
  Cu = 'CU',
  /** Cabo Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czechia */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic (the) */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands (the) [Malvinas] */
  Fk = 'FK',
  /** Micronesia (Federated States of) */
  Fm = 'FM',
  /** Faroe Islands (the) */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom of Great Britain and Northern Ireland (the) */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia (the) */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and the South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard Island and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory (the) */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran (Islamic Republic of) */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros (the) */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea (the Democratic People's Republic of) */
  Kp = 'KP',
  /** Korea (the Republic of) */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands (the) */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Lao People's Democratic Republic (the) */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova (the Republic of) */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands (the) */
  Mh = 'MH',
  /** North Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macao */
  Mo = 'MO',
  /** Northern Mariana Islands (the) */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger (the) */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands (the) */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines (the) */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine, State of */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Réunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation (the) */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan (the) */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena, Ascension and Tristan da Cunha */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Syrian Arab Republic */
  Sy = 'SY',
  /** Eswatini */
  Sz = 'SZ',
  /** Turks and Caicos Islands (the) */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Territories (the) */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Türkiye */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan (Province of China) */
  Tw = 'TW',
  /** Tanzania, United Republic of */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands (the) */
  Um = 'UM',
  /** United States of America (the) */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Holy See (the) */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela (Bolivarian Republic of) */
  Ve = 'VE',
  /** Virgin Islands (British) */
  Vg = 'VG',
  /** Virgin Islands (U.S.) */
  Vi = 'VI',
  /** Viet Nam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Kosovo */
  Xk = 'XK',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW'
}

export type Coupon = {
  __typename?: 'Coupon';
  activityLogs?: Maybe<Array<ActivityLog>>;
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  appliedCouponsCount: Scalars['Int']['output'];
  billableMetrics?: Maybe<Array<BillableMetric>>;
  code?: Maybe<Scalars['String']['output']>;
  couponType: CouponTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this coupon */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  expiration: CouponExpiration;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  limitedBillableMetrics: Scalars['Boolean']['output'];
  limitedPlans: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  percentageRate?: Maybe<Scalars['Float']['output']>;
  plans?: Maybe<Array<Plan>>;
  reusable: Scalars['Boolean']['output'];
  status: CouponStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** CouponCollection type */
export type CouponCollection = {
  __typename?: 'CouponCollection';
  /** A collection of paginated CouponCollection */
  collection: Array<Coupon>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum CouponExpiration {
  NoExpiration = 'no_expiration',
  TimeLimit = 'time_limit'
}

export enum CouponFrequency {
  Forever = 'forever',
  Once = 'once',
  Recurring = 'recurring'
}

export enum CouponStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export enum CouponTypeEnum {
  FixedAmount = 'fixed_amount',
  Percentage = 'percentage'
}

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Create Adjusted Fee Input */
export type CreateAdjustedFeeInput = {
  chargeFilterId?: InputMaybe<Scalars['ID']['input']>;
  chargeId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  feeId?: InputMaybe<Scalars['ID']['input']>;
  fixedChargeId?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
  invoiceSubscriptionId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
  unitPreciseAmount?: InputMaybe<Scalars['String']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of CreateAiConversation */
export type CreateAiConversationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  conversationId?: InputMaybe<Scalars['ID']['input']>;
  message: Scalars['String']['input'];
};

/** Autogenerated input type of CreateAnrokIntegration */
export type CreateAnrokIntegrationInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated input type of CreateApiKey */
export type CreateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<Scalars['JSON']['input']>;
};

/** Autogenerated input type of CreateAppliedCoupon */
export type CreateAppliedCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  couponId: Scalars['ID']['input'];
  customerId: Scalars['ID']['input'];
  frequency?: InputMaybe<CouponFrequency>;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of CreateAvalaraIntegration */
export type CreateAvalaraIntegrationInput = {
  accountId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  companyCode: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  licenseKey: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** Create Billable metric input arguments */
export type CreateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  expression?: InputMaybe<Scalars['String']['input']>;
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  roundingFunction?: InputMaybe<RoundingFunctionEnum>;
  roundingPrecision?: InputMaybe<Scalars['Int']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Create Billing Entity input arguments */
export type CreateBillingEntityInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<BillingEntityBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  country?: InputMaybe<CountryCode>;
  defaultCurrency?: InputMaybe<CurrencyEnum>;
  documentNumberPrefix?: InputMaybe<Scalars['String']['input']>;
  documentNumbering?: InputMaybe<BillingEntityDocumentNumberingEnum>;
  einvoicing?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<Array<BillingEntityEmailSettingsEnum>>;
  euTaxManagement?: InputMaybe<Scalars['Boolean']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<Scalars['Boolean']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateCoupon */
export type CreateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateCreditNote */
export type CreateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
  reason: CreditNoteReasonEnum;
  refundAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Create Customer input arguments */
export type CreateCustomerInput = {
  accountType?: InputMaybe<CustomerAccountTypeEnum>;
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  integrationCustomers?: InputMaybe<Array<IntegrationCustomerInput>>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateCustomerPortalWalletTransaction */
export type CreateCustomerPortalWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  walletId: Scalars['ID']['input'];
};

/** Create Wallet Input */
export type CreateCustomerWalletInput = {
  appliesTo?: InputMaybe<AppliesToInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency: CurrencyEnum;
  customerId: Scalars['ID']['input'];
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  grantedCredits: Scalars['String']['input'];
  ignorePaidTopUpLimitsOnCreation?: InputMaybe<Scalars['Boolean']['input']>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paidCredits: Scalars['String']['input'];
  paidTopUpMaxAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  paidTopUpMinAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  priority: Scalars['Int']['input'];
  rateAmount: Scalars['String']['input'];
  recurringTransactionRules?: InputMaybe<Array<CreateRecurringTransactionRuleInput>>;
  transactionName?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateCustomerWalletTransaction */
export type CreateCustomerWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  ignorePaidTopUpLimits?: InputMaybe<Scalars['Boolean']['input']>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Array<WalletTransactionMetadataInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  voidedCredits?: InputMaybe<Scalars['String']['input']>;
  walletId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateCreditNotesDataExport */
export type CreateDataExportsCreditNotesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  filters: DataExportCreditNoteFiltersInput;
  format: DataExportFormatTypeEnum;
  resourceType: CreditNoteExportTypeEnum;
};

/** Autogenerated input type of CreateInvoicesDataExport */
export type CreateDataExportsInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  filters: DataExportInvoiceFiltersInput;
  format: DataExportFormatTypeEnum;
  resourceType: InvoiceExportTypeEnum;
};

/** Autogenerated input type of CreateDunningCampaign */
export type CreateDunningCampaignInput = {
  appliedToOrganization: Scalars['Boolean']['input'];
  bccEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  daysBetweenAttempts: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  maxAttempts: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  thresholds: Array<DunningCampaignThresholdInput>;
};

/** Input for creating a feature */
export type CreateFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The code of the feature */
  code: Scalars['String']['input'];
  /** The description of the feature */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the feature */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The privileges configuration */
  privileges: Array<UpdatePrivilegeInput>;
};

/** Autogenerated input type of CreateHubspotIntegration */
export type CreateHubspotIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  defaultTargetedObject: HubspotTargetedObjectsEnum;
  name: Scalars['String']['input'];
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncSubscriptions?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateIntegrationCollectionMapping */
export type CreateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappingType: MappingTypeEnum;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxNexus?: InputMaybe<Scalars['String']['input']>;
  taxType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateIntegrationMapping */
export type CreateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappableId: Scalars['ID']['input'];
  mappableType: MappableTypeEnum;
};

/** Autogenerated input type of CreateInvite */
export type CreateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  role: MembershipRole;
};

/** Autogenerated input type of CreateInvoiceCustomSection */
export type CreateInvoiceCustomSectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** Create Invoice input arguments */
export type CreateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerId: Scalars['ID']['input'];
  fees: Array<FeeInput>;
  voidedInvoiceId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of CreateNetsuiteIntegration */
export type CreateNetsuiteIntegrationInput = {
  accountId: Scalars['String']['input'];
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  scriptEndpointUrl: Scalars['String']['input'];
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  tokenId: Scalars['String']['input'];
  tokenSecret: Scalars['String']['input'];
};

/** Autogenerated input type of CreateOktaIntegration */
export type CreateOktaIntegrationInput = {
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  domain: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

/** Autogenerated input type of CreateOrUpdateSubscriptionEntitlement */
export type CreateOrUpdateSubscriptionEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  entitlement: EntitlementInput;
  subscriptionId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreatePasswordReset */
export type CreatePasswordResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePasswordReset. */
export type CreatePasswordResetPayload = {
  __typename?: 'CreatePasswordResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
};

/** Autogenerated input type of CreatePayment */
export type CreatePaymentInput = {
  amountCents: Scalars['BigInt']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  createdAt: Scalars['ISO8601DateTime']['input'];
  invoiceId: Scalars['ID']['input'];
  reference: Scalars['String']['input'];
};

/** Autogenerated input type of CreatePlan */
export type CreatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  billFixedChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  entitlements?: InputMaybe<Array<EntitlementInput>>;
  fixedCharges?: InputMaybe<Array<FixedChargeInput>>;
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdInput>>;
};

/** Autogenerated input type of CreatePricingUnit */
export type CreatePricingUnitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  shortName: Scalars['String']['input'];
};

export type CreateRecurringTransactionRuleInput = {
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  ignorePaidTopUpLimits?: InputMaybe<Scalars['Boolean']['input']>;
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  method?: InputMaybe<RecurringTransactionMethodEnum>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  targetOngoingBalance?: InputMaybe<Scalars['String']['input']>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  transactionMetadata?: InputMaybe<Array<CreateTransactionMetadataInput>>;
  transactionName?: InputMaybe<Scalars['String']['input']>;
  trigger: RecurringTransactionTriggerEnum;
};

/** Autogenerated input type of CreateSalesforceIntegration */
export type CreateSalesforceIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  instanceId: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated input type of CreateSubscriptionAlert */
export type CreateSubscriptionAlertInput = {
  alertType: AlertTypeEnum;
  billableMetricId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  subscriptionId: Scalars['ID']['input'];
  thresholds: Array<ThresholdInput>;
};

/** Create Subscription input arguments */
export type CreateSubscriptionInput = {
  billingTime: BillingTimeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['ID']['input'];
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  planId: Scalars['ID']['input'];
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
};

export type CreateTransactionMetadataInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Autogenerated input type of CreateXeroIntegration */
export type CreateXeroIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

/** CreditNote */
export type CreditNote = {
  __typename?: 'CreditNote';
  activityLogs?: Maybe<Array<ActivityLog>>;
  appliedTaxes?: Maybe<Array<CreditNoteAppliedTax>>;
  balanceAmountCents: Scalars['BigInt']['output'];
  billingEntity: BillingEntity;
  /** Check if credit note can be voided */
  canBeVoided: Scalars['Boolean']['output'];
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmountCents: Scalars['BigInt']['output'];
  creditStatus?: Maybe<CreditNoteCreditStatusEnum>;
  currency: CurrencyEnum;
  customer: Customer;
  description?: Maybe<Scalars['String']['output']>;
  errorDetails?: Maybe<Array<ErrorDetail>>;
  externalIntegrationId?: Maybe<Scalars['String']['output']>;
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationSyncable: Scalars['Boolean']['output'];
  invoice?: Maybe<Invoice>;
  issuingDate: Scalars['ISO8601Date']['output'];
  items: Array<CreditNoteItem>;
  number: Scalars['String']['output'];
  reason: CreditNoteReasonEnum;
  refundAmountCents: Scalars['BigInt']['output'];
  refundStatus?: Maybe<CreditNoteRefundStatusEnum>;
  refundedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  sequentialId: Scalars['ID']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxProviderId?: Maybe<Scalars['String']['output']>;
  taxProviderSyncable: Scalars['Boolean']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  voidedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

export type CreditNoteAppliedTax = AppliedTax & {
  __typename?: 'CreditNoteAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  baseAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNote: CreditNote;
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** CreditNoteCollection type */
export type CreditNoteCollection = {
  __typename?: 'CreditNoteCollection';
  /** A collection of paginated CreditNoteCollection */
  collection: Array<CreditNote>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum CreditNoteCreditStatusEnum {
  Available = 'available',
  Consumed = 'consumed',
  Voided = 'voided'
}

/** Estimate amounts for credit note creation */
export type CreditNoteEstimate = {
  __typename?: 'CreditNoteEstimate';
  appliedTaxes: Array<CreditNoteAppliedTax>;
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  items: Array<CreditNoteItemEstimate>;
  maxCreditableAmountCents: Scalars['BigInt']['output'];
  maxRefundableAmountCents: Scalars['BigInt']['output'];
  preciseCouponsAdjustmentAmountCents: Scalars['Float']['output'];
  preciseTaxesAmountCents: Scalars['Float']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
};

export enum CreditNoteExportTypeEnum {
  CreditNoteItems = 'credit_note_items',
  CreditNotes = 'credit_notes'
}

export type CreditNoteItem = {
  __typename?: 'CreditNoteItem';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
};

export type CreditNoteItemEstimate = {
  __typename?: 'CreditNoteItemEstimate';
  amountCents: Scalars['BigInt']['output'];
  fee: Fee;
};

export type CreditNoteItemInput = {
  amountCents: Scalars['BigInt']['input'];
  feeId: Scalars['ID']['input'];
};

export enum CreditNoteReasonEnum {
  DuplicatedCharge = 'duplicated_charge',
  FraudulentCharge = 'fraudulent_charge',
  OrderCancellation = 'order_cancellation',
  OrderChange = 'order_change',
  Other = 'other',
  ProductUnsatisfactory = 'product_unsatisfactory'
}

export enum CreditNoteRefundStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum CurrencyEnum {
  /** United Arab Emirates Dirham */
  Aed = 'AED',
  /** Afghan Afghani */
  Afn = 'AFN',
  /** Albanian Lek */
  All = 'ALL',
  /** Armenian Dram */
  Amd = 'AMD',
  /** Netherlands Antillean Gulden */
  Ang = 'ANG',
  /** Angolan Kwanza */
  Aoa = 'AOA',
  /** Argentine Peso */
  Ars = 'ARS',
  /** Australian Dollar */
  Aud = 'AUD',
  /** Aruban Florin */
  Awg = 'AWG',
  /** Azerbaijani Manat */
  Azn = 'AZN',
  /** Bosnia and Herzegovina Convertible Mark */
  Bam = 'BAM',
  /** Barbadian Dollar */
  Bbd = 'BBD',
  /** Bangladeshi Taka */
  Bdt = 'BDT',
  /** Bulgarian Lev */
  Bgn = 'BGN',
  /** Bahraini Dinar */
  Bhd = 'BHD',
  /** Burundian Franc */
  Bif = 'BIF',
  /** Bermudian Dollar */
  Bmd = 'BMD',
  /** Brunei Dollar */
  Bnd = 'BND',
  /** Bolivian Boliviano */
  Bob = 'BOB',
  /** Brazilian Real */
  Brl = 'BRL',
  /** Bahamian Dollar */
  Bsd = 'BSD',
  /** Botswana Pula */
  Bwp = 'BWP',
  /** Belarusian Ruble */
  Byn = 'BYN',
  /** Belize Dollar */
  Bzd = 'BZD',
  /** Canadian Dollar */
  Cad = 'CAD',
  /** Congolese Franc */
  Cdf = 'CDF',
  /** Swiss Franc */
  Chf = 'CHF',
  /** Unidad de Fomento */
  Clf = 'CLF',
  /** Chilean Peso */
  Clp = 'CLP',
  /** Chinese Renminbi Yuan */
  Cny = 'CNY',
  /** Colombian Peso */
  Cop = 'COP',
  /** Costa Rican Colón */
  Crc = 'CRC',
  /** Cape Verdean Escudo */
  Cve = 'CVE',
  /** Czech Koruna */
  Czk = 'CZK',
  /** Djiboutian Franc */
  Djf = 'DJF',
  /** Danish Krone */
  Dkk = 'DKK',
  /** Dominican Peso */
  Dop = 'DOP',
  /** Algerian Dinar */
  Dzd = 'DZD',
  /** Egyptian Pound */
  Egp = 'EGP',
  /** Ethiopian Birr */
  Etb = 'ETB',
  /** Euro */
  Eur = 'EUR',
  /** Fijian Dollar */
  Fjd = 'FJD',
  /** Falkland Pound */
  Fkp = 'FKP',
  /** British Pound */
  Gbp = 'GBP',
  /** Georgian Lari */
  Gel = 'GEL',
  /** Ghanaian Cedi */
  Ghs = 'GHS',
  /** Gibraltar Pound */
  Gip = 'GIP',
  /** Gambian Dalasi */
  Gmd = 'GMD',
  /** Guinean Franc */
  Gnf = 'GNF',
  /** Guatemalan Quetzal */
  Gtq = 'GTQ',
  /** Guyanese Dollar */
  Gyd = 'GYD',
  /** Hong Kong Dollar */
  Hkd = 'HKD',
  /** Honduran Lempira */
  Hnl = 'HNL',
  /** Croatian Kuna */
  Hrk = 'HRK',
  /** Haitian Gourde */
  Htg = 'HTG',
  /** Hungarian Forint */
  Huf = 'HUF',
  /** Indonesian Rupiah */
  Idr = 'IDR',
  /** Israeli New Sheqel */
  Ils = 'ILS',
  /** Indian Rupee */
  Inr = 'INR',
  /** Iranian Rial */
  Irr = 'IRR',
  /** Icelandic Króna */
  Isk = 'ISK',
  /** Jamaican Dollar */
  Jmd = 'JMD',
  /** Jordanian Dinar */
  Jod = 'JOD',
  /** Japanese Yen */
  Jpy = 'JPY',
  /** Kenyan Shilling */
  Kes = 'KES',
  /** Kyrgyzstani Som */
  Kgs = 'KGS',
  /** Cambodian Riel */
  Khr = 'KHR',
  /** Comorian Franc */
  Kmf = 'KMF',
  /** South Korean Won */
  Krw = 'KRW',
  /** Kuwaiti Dinar */
  Kwd = 'KWD',
  /** Cayman Islands Dollar */
  Kyd = 'KYD',
  /** Kazakhstani Tenge */
  Kzt = 'KZT',
  /** Lao Kip */
  Lak = 'LAK',
  /** Lebanese Pound */
  Lbp = 'LBP',
  /** Sri Lankan Rupee */
  Lkr = 'LKR',
  /** Liberian Dollar */
  Lrd = 'LRD',
  /** Lesotho Loti */
  Lsl = 'LSL',
  /** Moroccan Dirham */
  Mad = 'MAD',
  /** Moldovan Leu */
  Mdl = 'MDL',
  /** Malagasy Ariary */
  Mga = 'MGA',
  /** Macedonian Denar */
  Mkd = 'MKD',
  /** Myanmar Kyat */
  Mmk = 'MMK',
  /** Mongolian Tögrög */
  Mnt = 'MNT',
  /** Macanese Pataca */
  Mop = 'MOP',
  /** Mauritanian Ouguiya */
  Mro = 'MRO',
  /** Mauritian Rupee */
  Mur = 'MUR',
  /** Maldivian Rufiyaa */
  Mvr = 'MVR',
  /** Malawian Kwacha */
  Mwk = 'MWK',
  /** Mexican Peso */
  Mxn = 'MXN',
  /** Malaysian Ringgit */
  Myr = 'MYR',
  /** Mozambican Metical */
  Mzn = 'MZN',
  /** Namibian Dollar */
  Nad = 'NAD',
  /** Nigerian Naira */
  Ngn = 'NGN',
  /** Nicaraguan Córdoba */
  Nio = 'NIO',
  /** Norwegian Krone */
  Nok = 'NOK',
  /** Nepalese Rupee */
  Npr = 'NPR',
  /** New Zealand Dollar */
  Nzd = 'NZD',
  /** Panamanian Balboa */
  Pab = 'PAB',
  /** Peruvian Sol */
  Pen = 'PEN',
  /** Papua New Guinean Kina */
  Pgk = 'PGK',
  /** Philippine Peso */
  Php = 'PHP',
  /** Pakistani Rupee */
  Pkr = 'PKR',
  /** Polish Złoty */
  Pln = 'PLN',
  /** Paraguayan Guaraní */
  Pyg = 'PYG',
  /** Qatari Riyal */
  Qar = 'QAR',
  /** Romanian Leu */
  Ron = 'RON',
  /** Serbian Dinar */
  Rsd = 'RSD',
  /** Russian Ruble */
  Rub = 'RUB',
  /** Rwandan Franc */
  Rwf = 'RWF',
  /** Saudi Riyal */
  Sar = 'SAR',
  /** Solomon Islands Dollar */
  Sbd = 'SBD',
  /** Seychellois Rupee */
  Scr = 'SCR',
  /** Swedish Krona */
  Sek = 'SEK',
  /** Singapore Dollar */
  Sgd = 'SGD',
  /** Saint Helenian Pound */
  Shp = 'SHP',
  /** Sierra Leonean Leone */
  Sll = 'SLL',
  /** Somali Shilling */
  Sos = 'SOS',
  /** Surinamese Dollar */
  Srd = 'SRD',
  /** São Tomé and Príncipe Dobra */
  Std = 'STD',
  /** Swazi Lilangeni */
  Szl = 'SZL',
  /** Thai Baht */
  Thb = 'THB',
  /** Tajikistani Somoni */
  Tjs = 'TJS',
  /** Tongan Paʻanga */
  Top = 'TOP',
  /** Turkish Lira */
  Try = 'TRY',
  /** Trinidad and Tobago Dollar */
  Ttd = 'TTD',
  /** New Taiwan Dollar */
  Twd = 'TWD',
  /** Tanzanian Shilling */
  Tzs = 'TZS',
  /** Ukrainian Hryvnia */
  Uah = 'UAH',
  /** Ugandan Shilling */
  Ugx = 'UGX',
  /** United States Dollar */
  Usd = 'USD',
  /** Uruguayan Peso */
  Uyu = 'UYU',
  /** Uzbekistan Som */
  Uzs = 'UZS',
  /** Vietnamese Đồng */
  Vnd = 'VND',
  /** Vanuatu Vatu */
  Vuv = 'VUV',
  /** Samoan Tala */
  Wst = 'WST',
  /** Central African Cfa Franc */
  Xaf = 'XAF',
  /** East Caribbean Dollar */
  Xcd = 'XCD',
  /** West African Cfa Franc */
  Xof = 'XOF',
  /** Cfp Franc */
  Xpf = 'XPF',
  /** Yemeni Rial */
  Yer = 'YER',
  /** South African Rand */
  Zar = 'ZAR',
  /** Zambian Kwacha */
  Zmw = 'ZMW'
}

/** Current Organization Type */
export type CurrentOrganization = {
  __typename?: 'CurrentOrganization';
  accessibleByCurrentSession: Scalars['Boolean']['output'];
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  adyenPaymentProviders?: Maybe<Array<AdyenProvider>>;
  apiKey?: Maybe<Scalars['String']['output']>;
  appliedDunningCampaign?: Maybe<DunningCampaign>;
  authenticatedMethod: AuthenticationMethodsEnum;
  authenticationMethods: Array<AuthenticationMethodsEnum>;
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  canCreateBillingEntity: Scalars['Boolean']['output'];
  cashfreePaymentProviders?: Maybe<Array<CashfreeProvider>>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  defaultCurrency: CurrencyEnum;
  documentNumberPrefix: Scalars['String']['output'];
  documentNumbering: DocumentNumberingEnum;
  email?: Maybe<Scalars['String']['output']>;
  emailSettings?: Maybe<Array<EmailSettingsEnum>>;
  euTaxManagement: Scalars['Boolean']['output'];
  finalizeZeroAmountInvoice: Scalars['Boolean']['output'];
  gocardlessPaymentProviders?: Maybe<Array<GocardlessProvider>>;
  hmacKey?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  netPaymentTerm: Scalars['Int']['output'];
  premiumIntegrations: Array<PremiumIntegrationTypeEnum>;
  state?: Maybe<Scalars['String']['output']>;
  stripePaymentProviders?: Maybe<Array<StripeProvider>>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  /** Query taxes of an organization */
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


/** Current Organization Type */
export type CurrentOrganizationTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};

export type CurrentVersion = {
  __typename?: 'CurrentVersion';
  githubUrl: Scalars['String']['output'];
  number: Scalars['String']['output'];
};

export type Customer = {
  __typename?: 'Customer';
  accountType: CustomerAccountTypeEnum;
  /** Number of active subscriptions per customer */
  activeSubscriptionsCount: Scalars['Int']['output'];
  activityLogs?: Maybe<Array<ActivityLog>>;
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  anrokCustomer?: Maybe<AnrokCustomer>;
  applicableTimezone: TimezoneEnum;
  appliedAddOns?: Maybe<Array<AppliedAddOn>>;
  appliedCoupons?: Maybe<Array<AppliedCoupon>>;
  appliedDunningCampaign?: Maybe<DunningCampaign>;
  avalaraCustomer?: Maybe<AvalaraCustomer>;
  billingConfiguration?: Maybe<CustomerBillingConfiguration>;
  billingEntity: BillingEntity;
  /** Check if customer attributes are editable */
  canEditAttributes: Scalars['Boolean']['output'];
  city?: Maybe<Scalars['String']['output']>;
  /** Invoice custom sections manually configured for the customer */
  configurableInvoiceCustomSections?: Maybe<Array<InvoiceCustomSection>>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  /** Credit notes credits balance available per customer */
  creditNotesBalanceAmountCents: Scalars['BigInt']['output'];
  /** Number of available credits from credit notes per customer */
  creditNotesCreditsAvailableCount: Scalars['Int']['output'];
  currency?: Maybe<CurrencyEnum>;
  customerType?: Maybe<CustomerTypeEnum>;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  excludeFromDunningCampaign: Scalars['Boolean']['output'];
  externalId: Scalars['String']['output'];
  externalSalesforceId?: Maybe<Scalars['String']['output']>;
  /** Options for handling invoices with a zero total amount. */
  finalizeZeroAmountInvoice?: Maybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: Maybe<Scalars['String']['output']>;
  /** Define if a customer has an active wallet */
  hasActiveWallet: Scalars['Boolean']['output'];
  /** Define if a customer has any credit note */
  hasCreditNotes: Scalars['Boolean']['output'];
  /** Define if a customer has overdue invoices */
  hasOverdueInvoices: Scalars['Boolean']['output'];
  /** Define if the customer has custom invoice custom sections selection */
  hasOverwrittenInvoiceCustomSectionsSelection?: Maybe<Scalars['Boolean']['output']>;
  hubspotCustomer?: Maybe<HubspotCustomer>;
  id: Scalars['ID']['output'];
  invoiceGracePeriod?: Maybe<Scalars['Int']['output']>;
  invoices?: Maybe<Array<Invoice>>;
  lastDunningCampaignAttempt: Scalars['Int']['output'];
  lastDunningCampaignAttemptAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastname?: Maybe<Scalars['String']['output']>;
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Array<CustomerMetadata>>;
  name?: Maybe<Scalars['String']['output']>;
  netPaymentTerm?: Maybe<Scalars['Int']['output']>;
  netsuiteCustomer?: Maybe<NetsuiteCustomer>;
  paymentProvider?: Maybe<ProviderTypeEnum>;
  paymentProviderCode?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  providerCustomer?: Maybe<ProviderCustomer>;
  salesforceCustomer?: Maybe<SalesforceCustomer>;
  sequentialId: Scalars['String']['output'];
  shippingAddress?: Maybe<CustomerAddress>;
  /** Skip invoice custom sections for the customer */
  skipInvoiceCustomSections?: Maybe<Scalars['Boolean']['output']>;
  slug: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  /** Query subscriptions of a customer */
  subscriptions: Array<Subscription>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  url?: Maybe<Scalars['String']['output']>;
  xeroCustomer?: Maybe<XeroCustomer>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


export type CustomerSubscriptionsArgs = {
  status?: InputMaybe<Array<StatusTypeEnum>>;
};

export enum CustomerAccountTypeEnum {
  Customer = 'customer',
  Partner = 'partner'
}

export type CustomerAddress = {
  __typename?: 'CustomerAddress';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  state?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};

export type CustomerAddressInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  state?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerBillingConfiguration = {
  __typename?: 'CustomerBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
};

export type CustomerBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
};

/** CustomerCollection type */
export type CustomerCollection = {
  __typename?: 'CustomerCollection';
  /** A collection of paginated CustomerCollection */
  collection: Array<Customer>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type CustomerMetadata = {
  __typename?: 'CustomerMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayInInvoice: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

export type CustomerMetadataFilter = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type CustomerMetadataInput = {
  displayInInvoice: Scalars['Boolean']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type CustomerPortalCustomer = {
  __typename?: 'CustomerPortalCustomer';
  accountType: CustomerAccountTypeEnum;
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  applicableTimezone: TimezoneEnum;
  billingConfiguration?: Maybe<CustomerBillingConfiguration>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  currency?: Maybe<CurrencyEnum>;
  customerType?: Maybe<CustomerTypeEnum>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  firstname?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastname?: Maybe<Scalars['String']['output']>;
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  premium: Scalars['Boolean']['output'];
  shippingAddress?: Maybe<CustomerAddress>;
  state?: Maybe<Scalars['String']['output']>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};

/** CustomerPortalOrganization */
export type CustomerPortalOrganization = {
  __typename?: 'CustomerPortalOrganization';
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  defaultCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  premiumIntegrations: Array<PremiumIntegrationTypeEnum>;
  timezone?: Maybe<TimezoneEnum>;
};

/** CustomerPortalWallet */
export type CustomerPortalWallet = {
  __typename?: 'CustomerPortalWallet';
  balanceCents: Scalars['BigInt']['output'];
  consumedAmountCents: Scalars['BigInt']['output'];
  consumedCredits: Scalars['Float']['output'];
  creditsBalance: Scalars['Float']['output'];
  creditsOngoingBalance: Scalars['Float']['output'];
  currency: CurrencyEnum;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ongoingBalanceCents: Scalars['BigInt']['output'];
  ongoingUsageBalanceCents: Scalars['BigInt']['output'];
  paidTopUpMaxAmountCents?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMaxCredits?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMinAmountCents?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMinCredits?: Maybe<Scalars['BigInt']['output']>;
  priority: Scalars['Int']['output'];
  rateAmount: Scalars['Float']['output'];
  status: WalletStatusEnum;
};

/** CustomerPortalWalletCollection type */
export type CustomerPortalWalletCollection = {
  __typename?: 'CustomerPortalWalletCollection';
  /** A collection of paginated CustomerPortalWalletCollection */
  collection: Array<CustomerPortalWallet>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type CustomerPortalWalletTransaction = {
  __typename?: 'CustomerPortalWalletTransaction';
  amount: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmount: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status: WalletTransactionStatusEnum;
  transactionStatus: WalletTransactionTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  wallet?: Maybe<CustomerPortalWallet>;
};

/** CustomerPortalWalletTransactionCollection type */
export type CustomerPortalWalletTransactionCollection = {
  __typename?: 'CustomerPortalWalletTransactionCollection';
  /** A collection of paginated CustomerPortalWalletTransactionCollection */
  collection: Array<CustomerPortalWalletTransaction>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type CustomerProjectedUsage = {
  __typename?: 'CustomerProjectedUsage';
  amountCents: Scalars['BigInt']['output'];
  chargesUsage: Array<ProjectedChargeUsage>;
  currency: CurrencyEnum;
  fromDatetime: Scalars['ISO8601DateTime']['output'];
  issuingDate: Scalars['ISO8601Date']['output'];
  projectedAmountCents: Scalars['BigInt']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  toDatetime: Scalars['ISO8601DateTime']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
};

export enum CustomerTypeEnum {
  Company = 'company',
  Individual = 'individual'
}

export type CustomerUsage = {
  __typename?: 'CustomerUsage';
  amountCents: Scalars['BigInt']['output'];
  chargesUsage: Array<ChargeUsage>;
  currency: CurrencyEnum;
  fromDatetime: Scalars['ISO8601DateTime']['output'];
  issuingDate: Scalars['ISO8601Date']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  toDatetime: Scalars['ISO8601DateTime']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
};

export type DataApiMetadata = {
  __typename?: 'DataApiMetadata';
  currentPage: Scalars['Int']['output'];
  nextPage: Scalars['Int']['output'];
  prevPage: Scalars['Int']['output'];
  totalCount: Scalars['Int']['output'];
  totalPages: Scalars['Int']['output'];
};

export type DataApiMrr = {
  __typename?: 'DataApiMrr';
  amountCurrency: CurrencyEnum;
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  endingMrr: Scalars['BigInt']['output'];
  mrrChange: Scalars['BigInt']['output'];
  mrrChurn: Scalars['BigInt']['output'];
  mrrContraction: Scalars['BigInt']['output'];
  mrrExpansion: Scalars['BigInt']['output'];
  mrrNew: Scalars['BigInt']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
  startingMrr: Scalars['BigInt']['output'];
};

/** DataApiMrrCollection type */
export type DataApiMrrCollection = {
  __typename?: 'DataApiMrrCollection';
  /** A collection of paginated DataApiMrrCollection */
  collection: Array<DataApiMrr>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataApiMrrPlan = {
  __typename?: 'DataApiMrrPlan';
  activeCustomersCount: Scalars['BigInt']['output'];
  activeCustomersShare: Scalars['Float']['output'];
  amountCurrency: CurrencyEnum;
  dt: Scalars['ISO8601Date']['output'];
  mrr: Scalars['Float']['output'];
  mrrShare?: Maybe<Scalars['Float']['output']>;
  planCode: Scalars['String']['output'];
  planDeletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  planId: Scalars['ID']['output'];
  planInterval: PlanInterval;
  planName: Scalars['String']['output'];
};

export type DataApiMrrsPlans = {
  __typename?: 'DataApiMrrsPlans';
  collection: Array<DataApiMrrPlan>;
  metadata: DataApiMetadata;
};

export type DataApiPrepaidCredit = {
  __typename?: 'DataApiPrepaidCredit';
  amountCurrency: CurrencyEnum;
  consumedAmount: Scalars['Float']['output'];
  consumedCreditsQuantity: Scalars['Float']['output'];
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  offeredAmount: Scalars['Float']['output'];
  offeredCreditsQuantity: Scalars['Float']['output'];
  purchasedAmount: Scalars['Float']['output'];
  purchasedCreditsQuantity: Scalars['Float']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
  voidedAmount: Scalars['Float']['output'];
  voidedCreditsQuantity: Scalars['Float']['output'];
};

/** DataApiPrepaidCreditCollection type */
export type DataApiPrepaidCreditCollection = {
  __typename?: 'DataApiPrepaidCreditCollection';
  /** A collection of paginated DataApiPrepaidCreditCollection */
  collection: Array<DataApiPrepaidCredit>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataApiRevenueStream = {
  __typename?: 'DataApiRevenueStream';
  amountCurrency: CurrencyEnum;
  commitmentFeeAmountCents: Scalars['BigInt']['output'];
  contraRevenueAmountCents?: Maybe<Scalars['BigInt']['output']>;
  couponsAmountCents: Scalars['BigInt']['output'];
  creditNotesCreditsAmountCents?: Maybe<Scalars['BigInt']['output']>;
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  freeCreditsAmountCents?: Maybe<Scalars['BigInt']['output']>;
  grossRevenueAmountCents: Scalars['BigInt']['output'];
  netRevenueAmountCents: Scalars['BigInt']['output'];
  oneOffFeeAmountCents: Scalars['BigInt']['output'];
  prepaidCreditsAmountCents?: Maybe<Scalars['BigInt']['output']>;
  progressiveBillingCreditAmountCents?: Maybe<Scalars['BigInt']['output']>;
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
  subscriptionFeeAmountCents: Scalars['BigInt']['output'];
  usageBasedFeeAmountCents: Scalars['BigInt']['output'];
};

/** DataApiRevenueStreamCollection type */
export type DataApiRevenueStreamCollection = {
  __typename?: 'DataApiRevenueStreamCollection';
  /** A collection of paginated DataApiRevenueStreamCollection */
  collection: Array<DataApiRevenueStream>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataApiRevenueStreamCustomer = {
  __typename?: 'DataApiRevenueStreamCustomer';
  amountCurrency: CurrencyEnum;
  customerDeletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  customerId: Scalars['ID']['output'];
  customerName?: Maybe<Scalars['String']['output']>;
  externalCustomerId: Scalars['String']['output'];
  grossRevenueAmountCents: Scalars['BigInt']['output'];
  grossRevenueShare?: Maybe<Scalars['Float']['output']>;
  netRevenueAmountCents: Scalars['BigInt']['output'];
  netRevenueShare?: Maybe<Scalars['Float']['output']>;
};

export type DataApiRevenueStreamPlan = {
  __typename?: 'DataApiRevenueStreamPlan';
  amountCurrency: CurrencyEnum;
  customersCount: Scalars['Int']['output'];
  customersShare: Scalars['Float']['output'];
  grossRevenueAmountCents: Scalars['BigInt']['output'];
  grossRevenueShare?: Maybe<Scalars['Float']['output']>;
  netRevenueAmountCents: Scalars['BigInt']['output'];
  netRevenueShare?: Maybe<Scalars['Float']['output']>;
  planCode: Scalars['String']['output'];
  planDeletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  planId: Scalars['ID']['output'];
  planInterval: PlanInterval;
  planName: Scalars['String']['output'];
};

export type DataApiRevenueStreamsCustomers = {
  __typename?: 'DataApiRevenueStreamsCustomers';
  collection: Array<DataApiRevenueStreamCustomer>;
  metadata: DataApiMetadata;
};

export type DataApiRevenueStreamsPlans = {
  __typename?: 'DataApiRevenueStreamsPlans';
  collection: Array<DataApiRevenueStreamPlan>;
  metadata: DataApiMetadata;
};

export type DataApiUsage = {
  __typename?: 'DataApiUsage';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  billableMetricCode: Scalars['String']['output'];
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  isBillableMetricDeleted: Scalars['Boolean']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
  units: Scalars['Float']['output'];
};

export type DataApiUsageAggregatedAmount = {
  __typename?: 'DataApiUsageAggregatedAmount';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
};

/** DataApiUsageAggregatedAmountCollection type */
export type DataApiUsageAggregatedAmountCollection = {
  __typename?: 'DataApiUsageAggregatedAmountCollection';
  /** A collection of paginated DataApiUsageAggregatedAmountCollection */
  collection: Array<DataApiUsageAggregatedAmount>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** DataApiUsageCollection type */
export type DataApiUsageCollection = {
  __typename?: 'DataApiUsageCollection';
  /** A collection of paginated DataApiUsageCollection */
  collection: Array<DataApiUsage>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataApiUsageForecasted = {
  __typename?: 'DataApiUsageForecasted';
  amountCents: Scalars['BigInt']['output'];
  amountCentsForecastConservative: Scalars['BigInt']['output'];
  amountCentsForecastOptimistic: Scalars['BigInt']['output'];
  amountCentsForecastRealistic: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
  units: Scalars['Float']['output'];
  unitsForecastConservative: Scalars['Float']['output'];
  unitsForecastOptimistic: Scalars['Float']['output'];
  unitsForecastRealistic: Scalars['Float']['output'];
};

/** DataApiUsageForecastedCollection type */
export type DataApiUsageForecastedCollection = {
  __typename?: 'DataApiUsageForecastedCollection';
  /** A collection of paginated DataApiUsageForecastedCollection */
  collection: Array<DataApiUsageForecasted>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataApiUsageInvoiced = {
  __typename?: 'DataApiUsageInvoiced';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  billableMetricCode: Scalars['String']['output'];
  endOfPeriodDt: Scalars['ISO8601Date']['output'];
  startOfPeriodDt: Scalars['ISO8601Date']['output'];
};

/** DataApiUsageInvoicedCollection type */
export type DataApiUsageInvoicedCollection = {
  __typename?: 'DataApiUsageInvoicedCollection';
  /** A collection of paginated DataApiUsageInvoicedCollection */
  collection: Array<DataApiUsageInvoiced>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DataExport = {
  __typename?: 'DataExport';
  id: Scalars['ID']['output'];
  status: DataExportStatusEnum;
};

/** Export credit notes search query and filters input argument */
export type DataExportCreditNoteFiltersInput = {
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  creditStatus?: InputMaybe<Array<CreditNoteCreditStatusEnum>>;
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  /** Uniq ID of the customer */
  customerId?: InputMaybe<Scalars['ID']['input']>;
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  reason?: InputMaybe<Array<CreditNoteReasonEnum>>;
  refundStatus?: InputMaybe<Array<CreditNoteRefundStatusEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum DataExportFormatTypeEnum {
  Csv = 'csv'
}

/** Export Invoices search query and filters input argument */
export type DataExportInvoiceFiltersInput = {
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum>>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};

export enum DataExportStatusEnum {
  Completed = 'completed',
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing'
}

/** Autogenerated input type of DestroyAddOn */
export type DestroyAddOnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAddOn. */
export type DestroyAddOnPayload = {
  __typename?: 'DestroyAddOnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyAdjustedFee */
export type DestroyAdjustedFeeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAdjustedFee. */
export type DestroyAdjustedFeePayload = {
  __typename?: 'DestroyAdjustedFeePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyApiKey */
export type DestroyApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyBillableMetric */
export type DestroyBillableMetricInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** Autogenerated return type of DestroyBillableMetric. */
export type DestroyBillableMetricPayload = {
  __typename?: 'DestroyBillableMetricPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyBillingEntity */
export type DestroyBillingEntityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** Autogenerated return type of DestroyBillingEntity. */
export type DestroyBillingEntityPayload = {
  __typename?: 'DestroyBillingEntityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DestroyCoupon */
export type DestroyCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCoupon. */
export type DestroyCouponPayload = {
  __typename?: 'DestroyCouponPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyCustomer */
export type DestroyCustomerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCustomer. */
export type DestroyCustomerPayload = {
  __typename?: 'DestroyCustomerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyDunningCampaign */
export type DestroyDunningCampaignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyDunningCampaign. */
export type DestroyDunningCampaignPayload = {
  __typename?: 'DestroyDunningCampaignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyFeature */
export type DestroyFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the feature to destroy */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyIntegrationCollectionMapping */
export type DestroyIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationCollectionMapping. */
export type DestroyIntegrationCollectionMappingPayload = {
  __typename?: 'DestroyIntegrationCollectionMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyIntegration */
export type DestroyIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyIntegrationMapping */
export type DestroyIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationMapping. */
export type DestroyIntegrationMappingPayload = {
  __typename?: 'DestroyIntegrationMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DestroyIntegration. */
export type DestroyIntegrationPayload = {
  __typename?: 'DestroyIntegrationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyInvoiceCustomSection */
export type DestroyInvoiceCustomSectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyInvoiceCustomSection. */
export type DestroyInvoiceCustomSectionPayload = {
  __typename?: 'DestroyInvoiceCustomSectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPaymentMethod */
export type DestroyPaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPaymentMethod. */
export type DestroyPaymentMethodPayload = {
  __typename?: 'DestroyPaymentMethodPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPaymentProvider */
export type DestroyPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPaymentProvider. */
export type DestroyPaymentProviderPayload = {
  __typename?: 'DestroyPaymentProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPlan */
export type DestroyPlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPlan. */
export type DestroyPlanPayload = {
  __typename?: 'DestroyPlanPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroySubscriptionAlert */
export type DestroySubscriptionAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyTax */
export type DestroyTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyTax. */
export type DestroyTaxPayload = {
  __typename?: 'DestroyTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyWebhookEndpoint */
export type DestroyWebhookEndpointInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyWebhookEndpoint. */
export type DestroyWebhookEndpointPayload = {
  __typename?: 'DestroyWebhookEndpointPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Document numbering type */
export enum DocumentNumberingEnum {
  PerCustomer = 'per_customer',
  PerOrganization = 'per_organization'
}

/** Autogenerated input type of DownloadCreditNote */
export type DownloadCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadCustomerPortalInvoice */
export type DownloadCustomerPortalInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadInvoice */
export type DownloadInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadPaymentReceipt */
export type DownloadPaymentReceiptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type DunningCampaign = {
  __typename?: 'DunningCampaign';
  appliedToOrganization: Scalars['Boolean']['output'];
  bccEmails?: Maybe<Array<Scalars['String']['output']>>;
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  customersCount: Scalars['Int']['output'];
  daysBetweenAttempts: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  maxAttempts: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  thresholds: Array<DunningCampaignThreshold>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** DunningCampaignCollection type */
export type DunningCampaignCollection = {
  __typename?: 'DunningCampaignCollection';
  /** A collection of paginated DunningCampaignCollection */
  collection: Array<DunningCampaign>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DunningCampaignThreshold = {
  __typename?: 'DunningCampaignThreshold';
  amountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  id: Scalars['ID']['output'];
};

export type DunningCampaignThresholdInput = {
  amountCents: Scalars['BigInt']['input'];
  currency: CurrencyEnum;
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Organization Email Settings Values */
export enum EmailSettingsEnum {
  /** credit_note.created */
  CreditNoteCreated = 'credit_note_created',
  /** invoice.finalized */
  InvoiceFinalized = 'invoice_finalized',
  /** payment_receipt.created */
  PaymentReceiptCreated = 'payment_receipt_created'
}

/** Input for updating a plan entitlement */
export type EntitlementInput = {
  featureCode: Scalars['String']['input'];
  /** The privileges configuration */
  privileges?: InputMaybe<Array<EntitlementPrivilegeInput>>;
};

/** Input for updating a plan entitlement privilege value */
export type EntitlementPrivilegeInput = {
  privilegeCode: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum ErrorCodesEnum {
  InvoiceGenerationError = 'invoice_generation_error',
  NotProvided = 'not_provided',
  TaxError = 'tax_error',
  TaxVoidingError = 'tax_voiding_error'
}

export type ErrorDetail = {
  __typename?: 'ErrorDetail';
  errorCode: ErrorCodesEnum;
  errorDetails?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
};

export type Event = {
  __typename?: 'Event';
  apiClient?: Maybe<Scalars['String']['output']>;
  billableMetricName?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  customerTimezone: TimezoneEnum;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalSubscriptionId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  matchBillableMetric?: Maybe<Scalars['Boolean']['output']>;
  matchCustomField?: Maybe<Scalars['Boolean']['output']>;
  matchCustomer?: Maybe<Scalars['Boolean']['output']>;
  matchSubscription?: Maybe<Scalars['Boolean']['output']>;
  payload: Scalars['JSON']['output'];
  receivedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  timestamp?: Maybe<Scalars['ISO8601DateTime']['output']>;
  transactionId?: Maybe<Scalars['String']['output']>;
};

/** EventCollection type */
export type EventCollection = {
  __typename?: 'EventCollection';
  /** A collection of paginated EventCollection */
  collection: Array<Event>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type FeatureObject = {
  __typename?: 'FeatureObject';
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  privileges: Array<PrivilegeObject>;
  subscriptionsCount: Scalars['Int']['output'];
};

/** FeatureObjectCollection type */
export type FeatureObjectCollection = {
  __typename?: 'FeatureObjectCollection';
  /** A collection of paginated FeatureObjectCollection */
  collection: Array<FeatureObject>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type Fee = InvoiceItem & {
  __typename?: 'Fee';
  addOn?: Maybe<AddOn>;
  adjustedFee: Scalars['Boolean']['output'];
  adjustedFeeType?: Maybe<AdjustedFeeTypeEnum>;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  amountDetails?: Maybe<FeeAmountDetails>;
  appliedTaxes?: Maybe<Array<FeeAppliedTax>>;
  charge?: Maybe<Charge>;
  chargeFilter?: Maybe<ChargeFilter>;
  creditableAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  description?: Maybe<Scalars['String']['output']>;
  eventsCount?: Maybe<Scalars['BigInt']['output']>;
  feeType: FeeTypesEnum;
  fixedCharge?: Maybe<FixedCharge>;
  groupedBy: Scalars['JSON']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceName?: Maybe<Scalars['String']['output']>;
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
  preciseUnitAmount: Scalars['Float']['output'];
  pricingUnitUsage?: Maybe<PricingUnitUsage>;
  properties?: Maybe<FeeProperties>;
  subscription?: Maybe<Subscription>;
  succeededAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate?: Maybe<Scalars['Float']['output']>;
  trueUpFee?: Maybe<Fee>;
  trueUpParentFee?: Maybe<Fee>;
  units: Scalars['Float']['output'];
  walletTransaction?: Maybe<WalletTransaction>;
};

export type FeeAmountDetails = {
  __typename?: 'FeeAmountDetails';
  fixedFeeTotalAmount?: Maybe<Scalars['String']['output']>;
  fixedFeeUnitAmount?: Maybe<Scalars['String']['output']>;
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  freeEvents?: Maybe<Scalars['Int']['output']>;
  freeUnits?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<FeeAmountDetailsGraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<FeeAmountDetailsGraduatedRange>>;
  minMaxAdjustmentTotalAmount?: Maybe<Scalars['String']['output']>;
  paidEvents?: Maybe<Scalars['Int']['output']>;
  paidUnits?: Maybe<Scalars['String']['output']>;
  perPackageSize?: Maybe<Scalars['Int']['output']>;
  perPackageUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedPercentageRange = {
  __typename?: 'FeeAmountDetailsGraduatedPercentageRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedRange = {
  __typename?: 'FeeAmountDetailsGraduatedRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAppliedTax = AppliedTax & {
  __typename?: 'FeeAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Fee input for creating invoice */
export type FeeInput = {
  addOnId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fromDatetime: Scalars['ISO8601DateTime']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  toDatetime: Scalars['ISO8601DateTime']['input'];
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

export type FeeProperties = {
  __typename?: 'FeeProperties';
  fromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  toDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

export enum FeeTypesEnum {
  AddOn = 'add_on',
  Charge = 'charge',
  Commitment = 'commitment',
  Credit = 'credit',
  FixedCharge = 'fixed_charge',
  Subscription = 'subscription'
}

/** Create Invoice input arguments */
export type FetchDraftInvoiceTaxesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerId: Scalars['ID']['input'];
  fees: Array<FeeInput>;
  voidedInvoiceId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of FetchIntegrationAccounts */
export type FetchIntegrationAccountsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FetchIntegrationItems */
export type FetchIntegrationItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FinalizeAllInvoices */
export type FinalizeAllInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of FinalizeInvoice */
export type FinalizeInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum FinalizeZeroAmountInvoiceEnum {
  Finalize = 'finalize',
  Inherit = 'inherit',
  Skip = 'skip'
}

export type FinalizedInvoiceCollection = {
  __typename?: 'FinalizedInvoiceCollection';
  amountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  invoicesCount: Scalars['BigInt']['output'];
  month: Scalars['ISO8601DateTime']['output'];
  paymentStatus?: Maybe<InvoicePaymentStatusTypeEnum>;
};

/** FinalizedInvoiceCollectionCollection type */
export type FinalizedInvoiceCollectionCollection = {
  __typename?: 'FinalizedInvoiceCollectionCollection';
  /** A collection of paginated FinalizedInvoiceCollectionCollection */
  collection: Array<FinalizedInvoiceCollection>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type FixedCharge = {
  __typename?: 'FixedCharge';
  addOn: AddOn;
  chargeModel: FixedChargeChargeModelEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  payInAdvance: Scalars['Boolean']['output'];
  properties?: Maybe<FixedChargeProperties>;
  prorated: Scalars['Boolean']['output'];
  taxes?: Maybe<Array<Tax>>;
  units: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export enum FixedChargeChargeModelEnum {
  Graduated = 'graduated',
  Standard = 'standard',
  Volume = 'volume'
}

export type FixedChargeInput = {
  addOnId: Scalars['ID']['input'];
  applyUnitsImmediately?: InputMaybe<Scalars['Boolean']['input']>;
  chargeModel: FixedChargeChargeModelEnum;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  payInAdvance?: InputMaybe<Scalars['Boolean']['input']>;
  properties?: InputMaybe<FixedChargePropertiesInput>;
  prorated?: InputMaybe<Scalars['Boolean']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  units?: InputMaybe<Scalars['String']['input']>;
};

export type FixedChargeOverridesInput = {
  addOnId?: InputMaybe<Scalars['ID']['input']>;
  applyUnitsImmediately?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  properties?: InputMaybe<FixedChargePropertiesInput>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  units?: InputMaybe<Scalars['String']['input']>;
};

export type FixedChargeProperties = {
  __typename?: 'FixedChargeProperties';
  amount?: Maybe<Scalars['String']['output']>;
  graduatedRanges?: Maybe<Array<GraduatedRange>>;
  volumeRanges?: Maybe<Array<VolumeRange>>;
};

export type FixedChargePropertiesInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  graduatedRanges?: InputMaybe<Array<GraduatedRangeInput>>;
  volumeRanges?: InputMaybe<Array<VolumeRangeInput>>;
};

export type FlutterwaveProvider = {
  __typename?: 'FlutterwaveProvider';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  secretKey?: Maybe<Scalars['ObfuscatedString']['output']>;
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
  webhookSecret?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of GenerateCheckoutUrl */
export type GenerateCheckoutUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['ID']['input'];
};

/** Autogenerated return type of GenerateCheckoutUrl. */
export type GenerateCheckoutUrlPayload = {
  __typename?: 'GenerateCheckoutUrlPayload';
  checkoutUrl: Scalars['String']['output'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of GenerateCustomerPortalUrl */
export type GenerateCustomerPortalUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of GenerateCustomerPortalUrl. */
export type GenerateCustomerPortalUrlPayload = {
  __typename?: 'GenerateCustomerPortalUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

/** Autogenerated input type of GeneratePaymentUrl */
export type GeneratePaymentUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of GeneratePaymentUrl. */
export type GeneratePaymentUrlPayload = {
  __typename?: 'GeneratePaymentUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentUrl?: Maybe<Scalars['String']['output']>;
};

export type GocardlessProvider = {
  __typename?: 'GocardlessProvider';
  code: Scalars['String']['output'];
  hasAccessToken?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
  webhookSecret?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of GoogleAcceptInvite */
export type GoogleAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleLoginUser */
export type GoogleLoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleRegisterUser */
export type GoogleRegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

export type GraduatedPercentageRange = {
  __typename?: 'GraduatedPercentageRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  rate: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedPercentageRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  rate: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GraduatedRange = {
  __typename?: 'GraduatedRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GraphqlSubscription = {
  __typename?: 'GraphqlSubscription';
  aiConversationStreamed: AiConversationStream;
};


export type GraphqlSubscriptionAiConversationStreamedArgs = {
  id: Scalars['ID']['input'];
};

export type GrossRevenue = {
  __typename?: 'GrossRevenue';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  invoicesCount: Scalars['BigInt']['output'];
  month: Scalars['ISO8601DateTime']['output'];
};

/** GrossRevenueCollection type */
export type GrossRevenueCollection = {
  __typename?: 'GrossRevenueCollection';
  /** A collection of paginated GrossRevenueCollection */
  collection: Array<GrossRevenue>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type GroupedChargeUsage = {
  __typename?: 'GroupedChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedBy?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['ID']['output'];
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  units: Scalars['Float']['output'];
};

/** Api Logs http method enums */
export enum HttpMethodEnum {
  Delete = 'delete',
  Post = 'post',
  Put = 'put'
}

export type HubspotCustomer = {
  __typename?: 'HubspotCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
  targetedObject?: Maybe<HubspotTargetedObjectsEnum>;
};

export type HubspotIntegration = {
  __typename?: 'HubspotIntegration';
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  defaultTargetedObject: HubspotTargetedObjectsEnum;
  id: Scalars['ID']['output'];
  invoicesObjectTypeId?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  portalId?: Maybe<Scalars['String']['output']>;
  subscriptionsObjectTypeId?: Maybe<Scalars['String']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncSubscriptions?: Maybe<Scalars['Boolean']['output']>;
};

export enum HubspotTargetedObjectsEnum {
  Companies = 'companies',
  Contacts = 'contacts'
}

export type Integration = AnrokIntegration | AvalaraIntegration | HubspotIntegration | NetsuiteIntegration | OktaIntegration | SalesforceIntegration | XeroIntegration;

/** IntegrationCollection type */
export type IntegrationCollection = {
  __typename?: 'IntegrationCollection';
  /** A collection of paginated IntegrationCollection */
  collection: Array<Integration>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type IntegrationCustomerInput = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  integrationCode?: InputMaybe<Scalars['String']['input']>;
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  integrationType?: InputMaybe<IntegrationTypeEnum>;
  subsidiaryId?: InputMaybe<Scalars['String']['input']>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
  targetedObject?: InputMaybe<HubspotTargetedObjectsEnum>;
};

export type IntegrationItem = {
  __typename?: 'IntegrationItem';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  itemType: IntegrationItemTypeEnum;
};

/** IntegrationItemCollection type */
export type IntegrationItemCollection = {
  __typename?: 'IntegrationItemCollection';
  /** A collection of paginated IntegrationItemCollection */
  collection: Array<IntegrationItem>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum IntegrationItemTypeEnum {
  Account = 'account',
  Standard = 'standard',
  Tax = 'tax'
}

export enum IntegrationTypeEnum {
  AnalyticsDashboards = 'analytics_dashboards',
  Anrok = 'anrok',
  ApiPermissions = 'api_permissions',
  AutoDunning = 'auto_dunning',
  Avalara = 'avalara',
  BetaPaymentAuthorization = 'beta_payment_authorization',
  ClickhouseLiveAggregation = 'clickhouse_live_aggregation',
  ForecastedUsage = 'forecasted_usage',
  FromEmail = 'from_email',
  Hubspot = 'hubspot',
  IssueReceipts = 'issue_receipts',
  LifetimeUsage = 'lifetime_usage',
  ManualPayments = 'manual_payments',
  MultiEntitiesEnterprise = 'multi_entities_enterprise',
  MultiEntitiesPro = 'multi_entities_pro',
  Netsuite = 'netsuite',
  Okta = 'okta',
  Preview = 'preview',
  ProgressiveBilling = 'progressive_billing',
  ProjectedUsage = 'projected_usage',
  RemoveBrandingWatermark = 'remove_branding_watermark',
  RevenueAnalytics = 'revenue_analytics',
  RevenueShare = 'revenue_share',
  Salesforce = 'salesforce',
  Xero = 'xero',
  ZeroAmountFees = 'zero_amount_fees'
}

export type Invite = {
  __typename?: 'Invite';
  acceptedAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  recipient: Membership;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role: MembershipRole;
  status: InviteStatusTypeEnum;
  token: Scalars['String']['output'];
};

/** InviteCollection type */
export type InviteCollection = {
  __typename?: 'InviteCollection';
  /** A collection of paginated InviteCollection */
  collection: Array<Invite>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum InviteStatusTypeEnum {
  Accepted = 'accepted',
  Pending = 'pending',
  Revoked = 'revoked'
}

/** Invoice */
export type Invoice = {
  __typename?: 'Invoice';
  activityLogs?: Maybe<Array<ActivityLog>>;
  allChargesHaveFees: Scalars['Boolean']['output'];
  appliedTaxes?: Maybe<Array<InvoiceAppliedTax>>;
  associatedActiveWalletPresent: Scalars['Boolean']['output'];
  availableToCreditAmountCents: Scalars['BigInt']['output'];
  billingEntity: BillingEntity;
  chargeAmountCents: Scalars['BigInt']['output'];
  couponsAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  creditNotesAmountCents: Scalars['BigInt']['output'];
  creditableAmountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  customer: Customer;
  errorDetails?: Maybe<Array<ErrorDetail>>;
  externalHubspotIntegrationId?: Maybe<Scalars['String']['output']>;
  externalIntegrationId?: Maybe<Scalars['String']['output']>;
  externalSalesforceIntegrationId?: Maybe<Scalars['String']['output']>;
  fees?: Maybe<Array<Fee>>;
  feesAmountCents: Scalars['BigInt']['output'];
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationHubspotSyncable: Scalars['Boolean']['output'];
  integrationSalesforceSyncable: Scalars['Boolean']['output'];
  integrationSyncable: Scalars['Boolean']['output'];
  invoiceSubscriptions?: Maybe<Array<InvoiceSubscription>>;
  invoiceType: InvoiceTypeEnum;
  issuingDate: Scalars['ISO8601Date']['output'];
  metadata?: Maybe<Array<InvoiceMetadata>>;
  number: Scalars['String']['output'];
  payableType: Scalars['String']['output'];
  paymentDisputeLosable: Scalars['Boolean']['output'];
  paymentDisputeLostAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  paymentDueDate: Scalars['ISO8601Date']['output'];
  paymentOverdue: Scalars['Boolean']['output'];
  paymentStatus: InvoicePaymentStatusTypeEnum;
  payments?: Maybe<Array<Payment>>;
  prepaidCreditAmountCents: Scalars['BigInt']['output'];
  progressiveBillingCreditAmountCents: Scalars['BigInt']['output'];
  refundableAmountCents: Scalars['BigInt']['output'];
  regeneratedInvoiceId?: Maybe<Scalars['String']['output']>;
  selfBilled: Scalars['Boolean']['output'];
  sequentialId: Scalars['ID']['output'];
  status: InvoiceStatusTypeEnum;
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  subTotalIncludingTaxesAmountCents: Scalars['BigInt']['output'];
  subscriptions?: Maybe<Array<Subscription>>;
  taxProviderId?: Maybe<Scalars['String']['output']>;
  taxProviderVoidable: Scalars['Boolean']['output'];
  taxStatus?: Maybe<InvoiceTaxStatusTypeEnum>;
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  totalDueAmountCents: Scalars['BigInt']['output'];
  totalPaidAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  versionNumber: Scalars['Int']['output'];
  voidable: Scalars['Boolean']['output'];
  voidedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  voidedInvoiceId?: Maybe<Scalars['String']['output']>;
};

export type InvoiceAppliedTax = AppliedTax & {
  __typename?: 'InvoiceAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  appliedOnWholeInvoice: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  enumedTaxCode?: Maybe<InvoiceAppliedTaxOnWholeInvoiceCodeEnum>;
  feesAmountCents: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  invoice: Invoice;
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  taxableAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export enum InvoiceAppliedTaxOnWholeInvoiceCodeEnum {
  CustomerExempt = 'customer_exempt',
  JurisHasNoTax = 'juris_has_no_tax',
  JurisNotTaxed = 'juris_not_taxed',
  NotCollecting = 'not_collecting',
  ReverseCharge = 'reverse_charge',
  TransactionExempt = 'transaction_exempt',
  UnknownTaxation = 'unknown_taxation'
}

/** InvoiceCollection type */
export type InvoiceCollection = {
  __typename?: 'InvoiceCollection';
  /** A collection of paginated InvoiceCollection */
  collection: Array<Invoice>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type InvoiceCustomSection = {
  __typename?: 'InvoiceCustomSection';
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  details?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
};

/** InvoiceCustomSectionCollection type */
export type InvoiceCustomSectionCollection = {
  __typename?: 'InvoiceCustomSectionCollection';
  /** A collection of paginated InvoiceCustomSectionCollection */
  collection: Array<InvoiceCustomSection>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum InvoiceExportTypeEnum {
  InvoiceFees = 'invoice_fees',
  Invoices = 'invoices'
}

/** Invoice Item */
export type InvoiceItem = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
};

/** Attributes for invoice metadata object */
export type InvoiceMetadata = {
  __typename?: 'InvoiceMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

/** Attributes for creating or updating invoice metadata object */
export type InvoiceMetadataInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum InvoicePaymentStatusTypeEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum InvoiceStatusTypeEnum {
  Closed = 'closed',
  Draft = 'draft',
  Failed = 'failed',
  Finalized = 'finalized',
  Generating = 'generating',
  Open = 'open',
  Pending = 'pending',
  Voided = 'voided'
}

export type InvoiceSubscription = {
  __typename?: 'InvoiceSubscription';
  acceptNewChargeFees: Scalars['Boolean']['output'];
  chargeAmountCents: Scalars['BigInt']['output'];
  chargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  chargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  fees?: Maybe<Array<Fee>>;
  fromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  invoice: Invoice;
  subscription: Subscription;
  subscriptionAmountCents: Scalars['BigInt']['output'];
  toDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  totalAmountCents: Scalars['BigInt']['output'];
};

export enum InvoiceTaxStatusTypeEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum InvoiceTypeEnum {
  AddOn = 'add_on',
  AdvanceCharges = 'advance_charges',
  Credit = 'credit',
  OneOff = 'one_off',
  ProgressiveBilling = 'progressive_billing',
  Subscription = 'subscription'
}

export type InvoicedUsage = {
  __typename?: 'InvoicedUsage';
  amountCents: Scalars['BigInt']['output'];
  code?: Maybe<Scalars['String']['output']>;
  currency: CurrencyEnum;
  month: Scalars['ISO8601DateTime']['output'];
};

/** InvoicedUsageCollection type */
export type InvoicedUsageCollection = {
  __typename?: 'InvoicedUsageCollection';
  /** A collection of paginated InvoicedUsageCollection */
  collection: Array<InvoicedUsage>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum LagoApiError {
  AddressLocationNotFound = 'AddressLocationNotFound',
  EntityNotFoundError = 'EntityNotFoundError',
  InvalidAddress = 'InvalidAddress',
  InvalidEnumValue = 'InvalidEnumValue',
  InvalidPostalCode = 'InvalidPostalCode',
  MissingAddress = 'MissingAddress',
  NotEnoughAddressesInfo = 'NotEnoughAddressesInfo',
  TaxCodeAssociatedWithItemCodeNotFound = 'TaxCodeAssociatedWithItemCodeNotFound',
  CouponIsNotReusable = 'coupon_is_not_reusable',
  CurrenciesDoesNotMatch = 'currencies_does_not_match',
  CurrencyCodeNotSupported = 'currencyCodeNotSupported',
  CustomerAddressCouldNotResolve = 'customerAddressCouldNotResolve',
  CustomerAddressCountryNotSupported = 'customerAddressCountryNotSupported',
  DoesNotMatchItemAmounts = 'does_not_match_item_amounts',
  DomainNotConfigured = 'domain_not_configured',
  EmailAlreadyUsed = 'email_already_used',
  ExpiredJwtToken = 'expired_jwt_token',
  Forbidden = 'forbidden',
  GoogleAuthMissingSetup = 'google_auth_missing_setup',
  GoogleLoginMethodNotAuthorized = 'google_login_method_not_authorized',
  IncorrectLoginOrPassword = 'incorrect_login_or_password',
  InternalError = 'internal_error',
  InvalidGoogleCode = 'invalid_google_code',
  InvalidGoogleToken = 'invalid_google_token',
  InviteAlreadyExists = 'invite_already_exists',
  InviteEmailMistmatch = 'invite_email_mistmatch',
  InviteNotFound = 'invite_not_found',
  InvoicesNotOverdue = 'invoices_not_overdue',
  LoginMethodNotAuthorized = 'login_method_not_authorized',
  MissingPaymentProviderCustomer = 'missing_payment_provider_customer',
  NotFound = 'not_found',
  NotOrganizationMember = 'not_organization_member',
  OktaLoginMethodNotAuthorized = 'okta_login_method_not_authorized',
  OktaUserinfoError = 'okta_userinfo_error',
  PaymentProcessorIsCurrentlyHandlingPayment = 'payment_processor_is_currently_handling_payment',
  PlanNotFound = 'plan_not_found',
  PlanOverlapping = 'plan_overlapping',
  ProductExternalIdUnknown = 'productExternalIdUnknown',
  TokenEncodingError = 'token_encoding_error',
  Unauthorized = 'unauthorized',
  UnprocessableEntity = 'unprocessable_entity',
  UrlIsInvalid = 'url_is_invalid',
  UserAlreadyExists = 'user_already_exists',
  UserDoesNotExist = 'user_does_not_exist',
  ValueAlreadyExist = 'value_already_exist',
  ValueIsDuplicated = 'value_is_duplicated',
  ValueIsInvalid = 'value_is_invalid',
  ValueIsOutOfRange = 'value_is_out_of_range'
}

export type LimitationInput = {
  billableMetricIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  planIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type LoginUser = {
  __typename?: 'LoginUser';
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of LoginUser */
export type LoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated input type of LoseInvoiceDispute */
export type LoseInvoiceDisputeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum MappableTypeEnum {
  AddOn = 'AddOn',
  BillableMetric = 'BillableMetric'
}

export type Mapping = {
  __typename?: 'Mapping';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappableId: Scalars['ID']['output'];
  mappableType: MappableTypeEnum;
};

export enum MappingTypeEnum {
  Account = 'account',
  Coupon = 'coupon',
  CreditNote = 'credit_note',
  FallbackItem = 'fallback_item',
  MinimumCommitment = 'minimum_commitment',
  PrepaidCredit = 'prepaid_credit',
  SubscriptionFee = 'subscription_fee',
  Tax = 'tax'
}

export type Membership = {
  __typename?: 'Membership';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  permissions: Permissions;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role: MembershipRole;
  status: MembershipStatus;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

/** MembershipCollection type */
export type MembershipCollection = {
  __typename?: 'MembershipCollection';
  /** A collection of paginated MembershipCollection */
  collection: Array<Membership>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: Metadata;
};

export enum MembershipRole {
  Admin = 'admin',
  Finance = 'finance',
  Manager = 'manager'
}

export enum MembershipStatus {
  Active = 'active',
  Revoked = 'revoked'
}

/** Type for CollectionMetadataType */
export type Metadata = {
  __typename?: 'Metadata';
  adminCount: Scalars['Int']['output'];
  /** Current Page of loaded data */
  currentPage: Scalars['Int']['output'];
  /** The number of items per page */
  limitValue: Scalars['Int']['output'];
  /** The total number of items to be paginated */
  totalCount: Scalars['Int']['output'];
  /** The total number of pages in the pagination */
  totalPages: Scalars['Int']['output'];
};

export type MoneyhashProvider = {
  __typename?: 'MoneyhashProvider';
  apiKey?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  flowId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export type Mrr = {
  __typename?: 'Mrr';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  month: Scalars['ISO8601DateTime']['output'];
};

/** MrrCollection type */
export type MrrCollection = {
  __typename?: 'MrrCollection';
  /** A collection of paginated MrrCollection */
  collection: Array<Mrr>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a new Invite */
  acceptInvite?: Maybe<RegisterUser>;
  /** Add Adyen payment provider */
  addAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Add or update Cashfree payment provider */
  addCashfreePaymentProvider?: Maybe<CashfreeProvider>;
  /** Add Flutterwave payment provider */
  addFlutterwavePaymentProvider?: Maybe<FlutterwaveProvider>;
  /** Add or update Gocardless payment provider */
  addGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Add Moneyhash payment provider */
  addMoneyhashPaymentProvider?: Maybe<MoneyhashProvider>;
  /** Add Stripe API keys to the organization */
  addStripePaymentProvider?: Maybe<StripeProvider>;
  billingEntityApplyTaxes?: Maybe<ApplyTaxesPayload>;
  billingEntityRemoveTaxes?: Maybe<RemoveTaxesPayload>;
  /** Updates the applied dunning campaign for a billing entity */
  billingEntityUpdateAppliedDunningCampaign?: Maybe<BillingEntity>;
  /** Creates a new add-on */
  createAddOn?: Maybe<AddOn>;
  /** Creates Adjusted Fee */
  createAdjustedFee?: Maybe<Fee>;
  /** Creates an AI conversation and appends a message to it */
  createAiConversation?: Maybe<AiConversation>;
  /** Create Anrok integration */
  createAnrokIntegration?: Maybe<AnrokIntegration>;
  /** Creates a new API key */
  createApiKey?: Maybe<ApiKey>;
  /** Assigns a Coupon to a Customer */
  createAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Create Avalara integration */
  createAvalaraIntegration?: Maybe<AvalaraIntegration>;
  /** Creates a new Billable metric */
  createBillableMetric?: Maybe<BillableMetric>;
  /** Creates a new Billing Entity */
  createBillingEntity?: Maybe<BillingEntity>;
  /** Creates a new Coupon */
  createCoupon?: Maybe<Coupon>;
  /** Creates a new Credit Note */
  createCreditNote?: Maybe<CreditNote>;
  /** Request data export of credit notes */
  createCreditNotesDataExport?: Maybe<DataExport>;
  /** Creates a new customer */
  createCustomer?: Maybe<Customer>;
  /** Creates a new Customer Wallet Transaction from Customer Portal */
  createCustomerPortalWalletTransaction?: Maybe<CustomerPortalWalletTransactionCollection>;
  /** Creates a new Customer Wallet */
  createCustomerWallet?: Maybe<Wallet>;
  /** Creates a new Customer Wallet Transaction */
  createCustomerWalletTransaction?: Maybe<WalletTransactionCollection>;
  /** Creates a new dunning campaign */
  createDunningCampaign?: Maybe<DunningCampaign>;
  /** Creates a new feature */
  createFeature?: Maybe<FeatureObject>;
  /** Create Hubspot integration */
  createHubspotIntegration?: Maybe<HubspotIntegration>;
  /** Create integration collection mapping */
  createIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Create integration mapping */
  createIntegrationMapping?: Maybe<Mapping>;
  /** Creates a new Invite */
  createInvite?: Maybe<Invite>;
  /** Creates a new Invoice */
  createInvoice?: Maybe<Invoice>;
  /** Creates a new InvoiceCustomSection */
  createInvoiceCustomSection?: Maybe<InvoiceCustomSection>;
  /** Request data export of invoices */
  createInvoicesDataExport?: Maybe<DataExport>;
  /** Create Netsuite integration */
  createNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Create Okta integration */
  createOktaIntegration?: Maybe<OktaIntegration>;
  /** Updates a subscription entitlement */
  createOrUpdateSubscriptionEntitlement?: Maybe<SubscriptionEntitlement>;
  /** Creates a new password reset */
  createPasswordReset?: Maybe<CreatePasswordResetPayload>;
  /** Creates a manual payment */
  createPayment?: Maybe<Payment>;
  /** Creates a payment request */
  createPaymentRequest?: Maybe<PaymentRequest>;
  /** Creates a new Plan */
  createPlan?: Maybe<Plan>;
  /** Creates a new pricing unit */
  createPricingUnit?: Maybe<PricingUnit>;
  /** Create Salesforce integration */
  createSalesforceIntegration?: Maybe<SalesforceIntegration>;
  /** Create a new Subscription */
  createSubscription?: Maybe<Subscription>;
  /** Creates a new Alert for subscription */
  createSubscriptionAlert?: Maybe<Alert>;
  /** Creates a tax */
  createTax?: Maybe<Tax>;
  /** Create a new webhook endpoint */
  createWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Create Xero integration */
  createXeroIntegration?: Maybe<XeroIntegration>;
  /** Deletes an add-on */
  destroyAddOn?: Maybe<DestroyAddOnPayload>;
  /** Deletes an adjusted fee */
  destroyAdjustedFee?: Maybe<DestroyAdjustedFeePayload>;
  /** Deletes an API key */
  destroyApiKey?: Maybe<ApiKey>;
  /** Deletes a Billable metric */
  destroyBillableMetric?: Maybe<DestroyBillableMetricPayload>;
  /** Destroys a new Billing Entity */
  destroyBillingEntity?: Maybe<DestroyBillingEntityPayload>;
  /** Deletes a coupon */
  destroyCoupon?: Maybe<DestroyCouponPayload>;
  /** Delete a Customer */
  destroyCustomer?: Maybe<DestroyCustomerPayload>;
  /** Deletes a dunning campaign */
  destroyDunningCampaign?: Maybe<DestroyDunningCampaignPayload>;
  /** Destroys an existing feature */
  destroyFeature?: Maybe<FeatureObject>;
  /** Destroy an integration */
  destroyIntegration?: Maybe<DestroyIntegrationPayload>;
  /** Destroy an integration collection mapping */
  destroyIntegrationCollectionMapping?: Maybe<DestroyIntegrationCollectionMappingPayload>;
  /** Destroy an integration mapping */
  destroyIntegrationMapping?: Maybe<DestroyIntegrationMappingPayload>;
  /** Deletes an invoice_custom_section */
  destroyInvoiceCustomSection?: Maybe<DestroyInvoiceCustomSectionPayload>;
  /** Deletes a payment method */
  destroyPaymentMethod?: Maybe<DestroyPaymentMethodPayload>;
  /** Destroy a payment provider */
  destroyPaymentProvider?: Maybe<DestroyPaymentProviderPayload>;
  /** Deletes a Plan */
  destroyPlan?: Maybe<DestroyPlanPayload>;
  /** Deletes an alert */
  destroySubscriptionAlert?: Maybe<Alert>;
  /** Deletes a tax */
  destroyTax?: Maybe<DestroyTaxPayload>;
  /** Deletes a webhook endpoint */
  destroyWebhookEndpoint?: Maybe<DestroyWebhookEndpointPayload>;
  /** Download a Credit Note PDF */
  downloadCreditNote?: Maybe<CreditNote>;
  /** Download customer portal invoice PDF */
  downloadCustomerPortalInvoice?: Maybe<Invoice>;
  /** Download an Invoice PDF */
  downloadInvoice?: Maybe<Invoice>;
  /** Download an PaymentReceipt PDF */
  downloadPaymentReceipt?: Maybe<PaymentReceipt>;
  /** Fetches taxes for one-off invoice */
  fetchDraftInvoiceTaxes?: Maybe<TaxFeeObjectCollection>;
  /** Fetch integration accounts */
  fetchIntegrationAccounts: IntegrationItemCollection;
  /** Fetch integration items */
  fetchIntegrationItems: IntegrationItemCollection;
  /** Finalize all draft invoices */
  finalizeAllInvoices?: Maybe<InvoiceCollection>;
  /** Finalize a draft invoice */
  finalizeInvoice?: Maybe<Invoice>;
  /** Generates checkout url for payment method */
  generateCheckoutUrl?: Maybe<GenerateCheckoutUrlPayload>;
  /** Generate customer portal URL */
  generateCustomerPortalUrl?: Maybe<GenerateCustomerPortalUrlPayload>;
  /** Generates a payment URL for an invoice */
  generatePaymentUrl?: Maybe<GeneratePaymentUrlPayload>;
  /** Accepts a membership invite with Google Oauth */
  googleAcceptInvite?: Maybe<RegisterUser>;
  /** Opens a session for an existing user with Google Oauth */
  googleLoginUser?: Maybe<LoginUser>;
  /** Register a new user with Google Oauth */
  googleRegisterUser?: Maybe<RegisterUser>;
  /** Opens a session for an existing user */
  loginUser?: Maybe<LoginUser>;
  /** Mark payment dispute as lost */
  loseInvoiceDispute?: Maybe<Invoice>;
  /** Accepts a membership invite with Okta Oauth */
  oktaAcceptInvite?: Maybe<LoginUser>;
  oktaAuthorize?: Maybe<Authorize>;
  oktaLogin?: Maybe<LoginUser>;
  /** Preview Adjusted Fee */
  previewAdjustedFee?: Maybe<Fee>;
  /** Refresh a draft invoice */
  refreshInvoice?: Maybe<Invoice>;
  /** Regenerate an invoice from a voided invoice */
  regenerateFromVoided?: Maybe<Invoice>;
  /** Registers a new user and creates related organization */
  registerUser?: Maybe<RegisterUser>;
  /** Removes a feature entitlement from a subscription */
  removeSubscriptionEntitlement?: Maybe<RemoveSubscriptionEntitlementPayload>;
  /** Reset password for user and log in */
  resetPassword?: Maybe<LoginUser>;
  /** Retry all invoice payments */
  retryAllInvoicePayments?: Maybe<InvoiceCollection>;
  /** Retry all failed invoices */
  retryAllInvoices?: Maybe<InvoiceCollection>;
  /** Retry failed invoice */
  retryInvoice?: Maybe<Invoice>;
  /** Retry invoice payment */
  retryInvoicePayment?: Maybe<Invoice>;
  /** Retry voided invoice sync */
  retryTaxProviderVoiding?: Maybe<Invoice>;
  /** Retry tax reporting */
  retryTaxReporting?: Maybe<CreditNote>;
  /** Retry a Webhook */
  retryWebhook?: Maybe<Webhook>;
  /** Revokes an invite */
  revokeInvite?: Maybe<Invite>;
  /** Revoke a membership */
  revokeMembership?: Maybe<Membership>;
  /** Create new ApiKey while expiring provided */
  rotateApiKey?: Maybe<ApiKey>;
  /** Set payment method as default */
  setPaymentMethodAsDefault?: Maybe<PaymentMethod>;
  /** Sync hubspot integration invoice */
  syncHubspotIntegrationInvoice?: Maybe<SyncHubspotInvoicePayload>;
  /** Sync integration credit note */
  syncIntegrationCreditNote?: Maybe<SyncIntegrationCreditNotePayload>;
  /** Sync integration invoice */
  syncIntegrationInvoice?: Maybe<SyncIntegrationInvoicePayload>;
  /** Sync Salesforce integration invoice */
  syncSalesforceInvoice?: Maybe<SyncSalesforceInvoicePayload>;
  /** Unassign a coupon from a customer */
  terminateAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Deletes a coupon */
  terminateCoupon?: Maybe<Coupon>;
  /** Terminates a new Customer Wallet */
  terminateCustomerWallet?: Maybe<Wallet>;
  /** Terminate a Subscription */
  terminateSubscription?: Maybe<Subscription>;
  /** Update an existing add-on */
  updateAddOn?: Maybe<AddOn>;
  /** Update Adyen payment provider */
  updateAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Update Anrok integration */
  updateAnrokIntegration?: Maybe<AnrokIntegration>;
  updateApiKey?: Maybe<ApiKey>;
  /** Update Avalara integration */
  updateAvalaraIntegration?: Maybe<AvalaraIntegration>;
  /** Updates an existing Billable metric */
  updateBillableMetric?: Maybe<BillableMetric>;
  /** Updates a Billing Entity */
  updateBillingEntity?: Maybe<BillingEntity>;
  /** Update Cashfree payment provider */
  updateCashfreePaymentProvider?: Maybe<CashfreeProvider>;
  /** Update an existing coupon */
  updateCoupon?: Maybe<Coupon>;
  /** Updates an existing Credit Note */
  updateCreditNote?: Maybe<CreditNote>;
  /** Updates an existing Customer */
  updateCustomer?: Maybe<Customer>;
  /** Assign the invoice grace period to Customers */
  updateCustomerInvoiceGracePeriod?: Maybe<Customer>;
  /** Update customer data from Customer Portal */
  updateCustomerPortalCustomer?: Maybe<CustomerPortalCustomer>;
  /** Updates a new Customer Wallet */
  updateCustomerWallet?: Maybe<Wallet>;
  /** Updates a dunning campaign and its thresholds */
  updateDunningCampaign?: Maybe<DunningCampaign>;
  /** Updates an existing feature */
  updateFeature?: Maybe<FeatureObject>;
  /** Update Flutterwave payment provider */
  updateFlutterwavePaymentProvider?: Maybe<FlutterwaveProvider>;
  /** Update Gocardless payment provider */
  updateGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Update Hubspot integration */
  updateHubspotIntegration?: Maybe<HubspotIntegration>;
  /** Update integration mapping */
  updateIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Update integration mapping */
  updateIntegrationMapping?: Maybe<Mapping>;
  /** Update an invite */
  updateInvite?: Maybe<Invite>;
  /** Update an existing invoice */
  updateInvoice?: Maybe<Invoice>;
  /** Updates an InvoiceCustomSection */
  updateInvoiceCustomSection?: Maybe<InvoiceCustomSection>;
  /** Update a membership */
  updateMembership?: Maybe<Membership>;
  /** Update Moneyhash payment provider */
  updateMoneyhashPaymentProvider?: Maybe<MoneyhashProvider>;
  /** Update Netsuite integration */
  updateNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Update Okta integration */
  updateOktaIntegration?: Maybe<OktaIntegration>;
  /** Updates an Organization */
  updateOrganization?: Maybe<CurrentOrganization>;
  /** Updates an existing Plan */
  updatePlan?: Maybe<Plan>;
  updatePricingUnit?: Maybe<PricingUnit>;
  /** Update Salesforce integration */
  updateSalesforceIntegration?: Maybe<SalesforceIntegration>;
  /** Update Stripe payment provider */
  updateStripePaymentProvider?: Maybe<StripeProvider>;
  /** Update a Subscription */
  updateSubscription?: Maybe<Subscription>;
  /** Updates an alert */
  updateSubscriptionAlert?: Maybe<Alert>;
  /** Update an existing tax */
  updateTax?: Maybe<Tax>;
  /** Update a new webhook endpoint */
  updateWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Update Xero integration */
  updateXeroIntegration?: Maybe<XeroIntegration>;
  /** Voids a Credit Note */
  voidCreditNote?: Maybe<CreditNote>;
  /** Void an invoice */
  voidInvoice?: Maybe<Invoice>;
};


export type MutationAcceptInviteArgs = {
  input: AcceptInviteInput;
};


export type MutationAddAdyenPaymentProviderArgs = {
  input: AddAdyenPaymentProviderInput;
};


export type MutationAddCashfreePaymentProviderArgs = {
  input: AddCashfreePaymentProviderInput;
};


export type MutationAddFlutterwavePaymentProviderArgs = {
  input: AddFlutterwavePaymentProviderInput;
};


export type MutationAddGocardlessPaymentProviderArgs = {
  input: AddGocardlessPaymentProviderInput;
};


export type MutationAddMoneyhashPaymentProviderArgs = {
  input: AddMoneyhashPaymentProviderInput;
};


export type MutationAddStripePaymentProviderArgs = {
  input: AddStripePaymentProviderInput;
};


export type MutationBillingEntityApplyTaxesArgs = {
  input: ApplyTaxesInput;
};


export type MutationBillingEntityRemoveTaxesArgs = {
  input: RemoveTaxesInput;
};


export type MutationBillingEntityUpdateAppliedDunningCampaignArgs = {
  input: BillingEntityUpdateAppliedDunningCampaignInput;
};


export type MutationCreateAddOnArgs = {
  input: CreateAddOnInput;
};


export type MutationCreateAdjustedFeeArgs = {
  input: CreateAdjustedFeeInput;
};


export type MutationCreateAiConversationArgs = {
  input: CreateAiConversationInput;
};


export type MutationCreateAnrokIntegrationArgs = {
  input: CreateAnrokIntegrationInput;
};


export type MutationCreateApiKeyArgs = {
  input: CreateApiKeyInput;
};


export type MutationCreateAppliedCouponArgs = {
  input: CreateAppliedCouponInput;
};


export type MutationCreateAvalaraIntegrationArgs = {
  input: CreateAvalaraIntegrationInput;
};


export type MutationCreateBillableMetricArgs = {
  input: CreateBillableMetricInput;
};


export type MutationCreateBillingEntityArgs = {
  input: CreateBillingEntityInput;
};


export type MutationCreateCouponArgs = {
  input: CreateCouponInput;
};


export type MutationCreateCreditNoteArgs = {
  input: CreateCreditNoteInput;
};


export type MutationCreateCreditNotesDataExportArgs = {
  input: CreateDataExportsCreditNotesInput;
};


export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


export type MutationCreateCustomerPortalWalletTransactionArgs = {
  input: CreateCustomerPortalWalletTransactionInput;
};


export type MutationCreateCustomerWalletArgs = {
  input: CreateCustomerWalletInput;
};


export type MutationCreateCustomerWalletTransactionArgs = {
  input: CreateCustomerWalletTransactionInput;
};


export type MutationCreateDunningCampaignArgs = {
  input: CreateDunningCampaignInput;
};


export type MutationCreateFeatureArgs = {
  input: CreateFeatureInput;
};


export type MutationCreateHubspotIntegrationArgs = {
  input: CreateHubspotIntegrationInput;
};


export type MutationCreateIntegrationCollectionMappingArgs = {
  input: CreateIntegrationCollectionMappingInput;
};


export type MutationCreateIntegrationMappingArgs = {
  input: CreateIntegrationMappingInput;
};


export type MutationCreateInviteArgs = {
  input: CreateInviteInput;
};


export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


export type MutationCreateInvoiceCustomSectionArgs = {
  input: CreateInvoiceCustomSectionInput;
};


export type MutationCreateInvoicesDataExportArgs = {
  input: CreateDataExportsInvoicesInput;
};


export type MutationCreateNetsuiteIntegrationArgs = {
  input: CreateNetsuiteIntegrationInput;
};


export type MutationCreateOktaIntegrationArgs = {
  input: CreateOktaIntegrationInput;
};


export type MutationCreateOrUpdateSubscriptionEntitlementArgs = {
  input: CreateOrUpdateSubscriptionEntitlementInput;
};


export type MutationCreatePasswordResetArgs = {
  input: CreatePasswordResetInput;
};


export type MutationCreatePaymentArgs = {
  input: CreatePaymentInput;
};


export type MutationCreatePaymentRequestArgs = {
  input: PaymentRequestCreateInput;
};


export type MutationCreatePlanArgs = {
  input: CreatePlanInput;
};


export type MutationCreatePricingUnitArgs = {
  input: CreatePricingUnitInput;
};


export type MutationCreateSalesforceIntegrationArgs = {
  input: CreateSalesforceIntegrationInput;
};


export type MutationCreateSubscriptionArgs = {
  input: CreateSubscriptionInput;
};


export type MutationCreateSubscriptionAlertArgs = {
  input: CreateSubscriptionAlertInput;
};


export type MutationCreateTaxArgs = {
  input: TaxCreateInput;
};


export type MutationCreateWebhookEndpointArgs = {
  input: WebhookEndpointCreateInput;
};


export type MutationCreateXeroIntegrationArgs = {
  input: CreateXeroIntegrationInput;
};


export type MutationDestroyAddOnArgs = {
  input: DestroyAddOnInput;
};


export type MutationDestroyAdjustedFeeArgs = {
  input: DestroyAdjustedFeeInput;
};


export type MutationDestroyApiKeyArgs = {
  input: DestroyApiKeyInput;
};


export type MutationDestroyBillableMetricArgs = {
  input: DestroyBillableMetricInput;
};


export type MutationDestroyBillingEntityArgs = {
  input: DestroyBillingEntityInput;
};


export type MutationDestroyCouponArgs = {
  input: DestroyCouponInput;
};


export type MutationDestroyCustomerArgs = {
  input: DestroyCustomerInput;
};


export type MutationDestroyDunningCampaignArgs = {
  input: DestroyDunningCampaignInput;
};


export type MutationDestroyFeatureArgs = {
  input: DestroyFeatureInput;
};


export type MutationDestroyIntegrationArgs = {
  input: DestroyIntegrationInput;
};


export type MutationDestroyIntegrationCollectionMappingArgs = {
  input: DestroyIntegrationCollectionMappingInput;
};


export type MutationDestroyIntegrationMappingArgs = {
  input: DestroyIntegrationMappingInput;
};


export type MutationDestroyInvoiceCustomSectionArgs = {
  input: DestroyInvoiceCustomSectionInput;
};


export type MutationDestroyPaymentMethodArgs = {
  input: DestroyPaymentMethodInput;
};


export type MutationDestroyPaymentProviderArgs = {
  input: DestroyPaymentProviderInput;
};


export type MutationDestroyPlanArgs = {
  input: DestroyPlanInput;
};


export type MutationDestroySubscriptionAlertArgs = {
  input: DestroySubscriptionAlertInput;
};


export type MutationDestroyTaxArgs = {
  input: DestroyTaxInput;
};


export type MutationDestroyWebhookEndpointArgs = {
  input: DestroyWebhookEndpointInput;
};


export type MutationDownloadCreditNoteArgs = {
  input: DownloadCreditNoteInput;
};


export type MutationDownloadCustomerPortalInvoiceArgs = {
  input: DownloadCustomerPortalInvoiceInput;
};


export type MutationDownloadInvoiceArgs = {
  input: DownloadInvoiceInput;
};


export type MutationDownloadPaymentReceiptArgs = {
  input: DownloadPaymentReceiptInput;
};


export type MutationFetchDraftInvoiceTaxesArgs = {
  input: FetchDraftInvoiceTaxesInput;
};


export type MutationFetchIntegrationAccountsArgs = {
  input: FetchIntegrationAccountsInput;
};


export type MutationFetchIntegrationItemsArgs = {
  input: FetchIntegrationItemsInput;
};


export type MutationFinalizeAllInvoicesArgs = {
  input: FinalizeAllInvoicesInput;
};


export type MutationFinalizeInvoiceArgs = {
  input: FinalizeInvoiceInput;
};


export type MutationGenerateCheckoutUrlArgs = {
  input: GenerateCheckoutUrlInput;
};


export type MutationGenerateCustomerPortalUrlArgs = {
  input: GenerateCustomerPortalUrlInput;
};


export type MutationGeneratePaymentUrlArgs = {
  input: GeneratePaymentUrlInput;
};


export type MutationGoogleAcceptInviteArgs = {
  input: GoogleAcceptInviteInput;
};


export type MutationGoogleLoginUserArgs = {
  input: GoogleLoginUserInput;
};


export type MutationGoogleRegisterUserArgs = {
  input: GoogleRegisterUserInput;
};


export type MutationLoginUserArgs = {
  input: LoginUserInput;
};


export type MutationLoseInvoiceDisputeArgs = {
  input: LoseInvoiceDisputeInput;
};


export type MutationOktaAcceptInviteArgs = {
  input: OktaAcceptInviteInput;
};


export type MutationOktaAuthorizeArgs = {
  input: OktaAuthorizeInput;
};


export type MutationOktaLoginArgs = {
  input: OktaLoginInput;
};


export type MutationPreviewAdjustedFeeArgs = {
  input: PreviewAdjustedFeeInput;
};


export type MutationRefreshInvoiceArgs = {
  input: RefreshInvoiceInput;
};


export type MutationRegenerateFromVoidedArgs = {
  input: RegenerateInvoiceInput;
};


export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};


export type MutationRemoveSubscriptionEntitlementArgs = {
  input: RemoveSubscriptionEntitlementInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


export type MutationRetryAllInvoicePaymentsArgs = {
  input: RetryAllInvoicePaymentsInput;
};


export type MutationRetryAllInvoicesArgs = {
  input: RetryAllInvoicesInput;
};


export type MutationRetryInvoiceArgs = {
  input: RetryInvoiceInput;
};


export type MutationRetryInvoicePaymentArgs = {
  input: RetryInvoicePaymentInput;
};


export type MutationRetryTaxProviderVoidingArgs = {
  input: RetryTaxProviderVoidingInput;
};


export type MutationRetryTaxReportingArgs = {
  input: RetryTaxReportingInput;
};


export type MutationRetryWebhookArgs = {
  input: RetryWebhookInput;
};


export type MutationRevokeInviteArgs = {
  input: RevokeInviteInput;
};


export type MutationRevokeMembershipArgs = {
  input: RevokeMembershipInput;
};


export type MutationRotateApiKeyArgs = {
  input: RotateApiKeyInput;
};


export type MutationSetPaymentMethodAsDefaultArgs = {
  input: SetAsDefaultInput;
};


export type MutationSyncHubspotIntegrationInvoiceArgs = {
  input: SyncHubspotIntegrationInvoiceInput;
};


export type MutationSyncIntegrationCreditNoteArgs = {
  input: SyncIntegrationCreditNoteInput;
};


export type MutationSyncIntegrationInvoiceArgs = {
  input: SyncIntegrationInvoiceInput;
};


export type MutationSyncSalesforceInvoiceArgs = {
  input: SyncSalesforceInvoiceInput;
};


export type MutationTerminateAppliedCouponArgs = {
  input: TerminateAppliedCouponInput;
};


export type MutationTerminateCouponArgs = {
  input: TerminateCouponInput;
};


export type MutationTerminateCustomerWalletArgs = {
  input: TerminateCustomerWalletInput;
};


export type MutationTerminateSubscriptionArgs = {
  input: TerminateSubscriptionInput;
};


export type MutationUpdateAddOnArgs = {
  input: UpdateAddOnInput;
};


export type MutationUpdateAdyenPaymentProviderArgs = {
  input: UpdateAdyenPaymentProviderInput;
};


export type MutationUpdateAnrokIntegrationArgs = {
  input: UpdateAnrokIntegrationInput;
};


export type MutationUpdateApiKeyArgs = {
  input: UpdateApiKeyInput;
};


export type MutationUpdateAvalaraIntegrationArgs = {
  input: UpdateAvalaraIntegrationInput;
};


export type MutationUpdateBillableMetricArgs = {
  input: UpdateBillableMetricInput;
};


export type MutationUpdateBillingEntityArgs = {
  input: UpdateBillingEntityInput;
};


export type MutationUpdateCashfreePaymentProviderArgs = {
  input: UpdateCashfreePaymentProviderInput;
};


export type MutationUpdateCouponArgs = {
  input: UpdateCouponInput;
};


export type MutationUpdateCreditNoteArgs = {
  input: UpdateCreditNoteInput;
};


export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


export type MutationUpdateCustomerInvoiceGracePeriodArgs = {
  input: UpdateCustomerInvoiceGracePeriodInput;
};


export type MutationUpdateCustomerPortalCustomerArgs = {
  input: UpdateCustomerPortalCustomerInput;
};


export type MutationUpdateCustomerWalletArgs = {
  input: UpdateCustomerWalletInput;
};


export type MutationUpdateDunningCampaignArgs = {
  input: UpdateDunningCampaignInput;
};


export type MutationUpdateFeatureArgs = {
  input: UpdateFeatureInput;
};


export type MutationUpdateFlutterwavePaymentProviderArgs = {
  input: UpdateFlutterwavePaymentProviderInput;
};


export type MutationUpdateGocardlessPaymentProviderArgs = {
  input: UpdateGocardlessPaymentProviderInput;
};


export type MutationUpdateHubspotIntegrationArgs = {
  input: UpdateHubspotIntegrationInput;
};


export type MutationUpdateIntegrationCollectionMappingArgs = {
  input: UpdateIntegrationCollectionMappingInput;
};


export type MutationUpdateIntegrationMappingArgs = {
  input: UpdateIntegrationMappingInput;
};


export type MutationUpdateInviteArgs = {
  input: UpdateInviteInput;
};


export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


export type MutationUpdateInvoiceCustomSectionArgs = {
  input: UpdateInvoiceCustomSectionInput;
};


export type MutationUpdateMembershipArgs = {
  input: UpdateMembershipInput;
};


export type MutationUpdateMoneyhashPaymentProviderArgs = {
  input: UpdateMoneyhashPaymentProviderInput;
};


export type MutationUpdateNetsuiteIntegrationArgs = {
  input: UpdateNetsuiteIntegrationInput;
};


export type MutationUpdateOktaIntegrationArgs = {
  input: UpdateOktaIntegrationInput;
};


export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


export type MutationUpdatePlanArgs = {
  input: UpdatePlanInput;
};


export type MutationUpdatePricingUnitArgs = {
  input: UpdatePricingUnitInput;
};


export type MutationUpdateSalesforceIntegrationArgs = {
  input: UpdateSalesforceIntegrationInput;
};


export type MutationUpdateStripePaymentProviderArgs = {
  input: UpdateStripePaymentProviderInput;
};


export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


export type MutationUpdateSubscriptionAlertArgs = {
  input: UpdateSubscriptionAlertInput;
};


export type MutationUpdateTaxArgs = {
  input: TaxUpdateInput;
};


export type MutationUpdateWebhookEndpointArgs = {
  input: WebhookEndpointUpdateInput;
};


export type MutationUpdateXeroIntegrationArgs = {
  input: UpdateXeroIntegrationInput;
};


export type MutationVoidCreditNoteArgs = {
  input: VoidCreditNoteInput;
};


export type MutationVoidInvoiceArgs = {
  input: VoidInvoiceInput;
};

export type NetsuiteCustomer = {
  __typename?: 'NetsuiteCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  subsidiaryId?: Maybe<Scalars['String']['output']>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type NetsuiteIntegration = {
  __typename?: 'NetsuiteIntegration';
  accountId?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['ObfuscatedString']['output']>;
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  scriptEndpointUrl: Scalars['String']['output'];
  syncCreditNotes?: Maybe<Scalars['Boolean']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncPayments?: Maybe<Scalars['Boolean']['output']>;
  tokenId?: Maybe<Scalars['String']['output']>;
  tokenSecret?: Maybe<Scalars['ObfuscatedString']['output']>;
};

export enum NextSubscriptionTypeEnum {
  Downgrade = 'downgrade',
  Upgrade = 'upgrade'
}

/** Accept Invite with Okta Oauth input arguments */
export type OktaAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

/** Autogenerated input type of OktaAuthorize */
export type OktaAuthorizeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  inviteToken?: InputMaybe<Scalars['String']['input']>;
};

export type OktaIntegration = {
  __typename?: 'OktaIntegration';
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['ObfuscatedString']['output']>;
  code: Scalars['String']['output'];
  domain: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organizationName: Scalars['String']['output'];
};

/** Autogenerated input type of OktaLogin */
export type OktaLoginInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

export enum OnTerminationCreditNoteEnum {
  Credit = 'credit',
  Refund = 'refund',
  Skip = 'skip'
}

export enum OnTerminationInvoiceEnum {
  Generate = 'generate',
  Skip = 'skip'
}

export enum OrderByEnum {
  GrossRevenueAmountCents = 'gross_revenue_amount_cents',
  NetRevenueAmountCents = 'net_revenue_amount_cents'
}

/** Safe Organization Type */
export type Organization = {
  __typename?: 'Organization';
  accessibleByCurrentSession: Scalars['Boolean']['output'];
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  canCreateBillingEntity: Scalars['Boolean']['output'];
  defaultCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  timezone?: Maybe<TimezoneEnum>;
};

export type OrganizationBillingConfiguration = {
  __typename?: 'OrganizationBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceFooter?: Maybe<Scalars['String']['output']>;
  invoiceGracePeriod: Scalars['Int']['output'];
};

export type OrganizationBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  invoiceFooter?: InputMaybe<Scalars['String']['input']>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

export type OverdueBalance = {
  __typename?: 'OverdueBalance';
  amountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  lagoInvoiceIds: Array<Scalars['String']['output']>;
  month: Scalars['ISO8601DateTime']['output'];
};

/** OverdueBalanceCollection type */
export type OverdueBalanceCollection = {
  __typename?: 'OverdueBalanceCollection';
  /** A collection of paginated OverdueBalanceCollection */
  collection: Array<OverdueBalance>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type Payable = Invoice | PaymentRequest;

export enum PayablePaymentStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing',
  Succeeded = 'succeeded'
}

export type Payment = {
  __typename?: 'Payment';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  customer: Customer;
  id: Scalars['ID']['output'];
  payable: Payable;
  payablePaymentStatus?: Maybe<PayablePaymentStatusEnum>;
  paymentProviderType?: Maybe<ProviderTypeEnum>;
  paymentReceipt?: Maybe<PaymentReceipt>;
  paymentType: PaymentTypeEnum;
  providerPaymentId?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

/** PaymentCollection type */
export type PaymentCollection = {
  __typename?: 'PaymentCollection';
  /** A collection of paginated PaymentCollection */
  collection: Array<Payment>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PaymentMethod = {
  __typename?: 'PaymentMethod';
  createdAt: Scalars['ISO8601DateTime']['output'];
  customer: Customer;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  paymentProviderCode?: Maybe<Scalars['String']['output']>;
  paymentProviderCustomerId?: Maybe<Scalars['ID']['output']>;
  paymentProviderType?: Maybe<ProviderTypeEnum>;
  updatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

/** PaymentMethodCollection type */
export type PaymentMethodCollection = {
  __typename?: 'PaymentMethodCollection';
  /** A collection of paginated PaymentMethodCollection */
  collection: Array<PaymentMethod>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PaymentProvider = AdyenProvider | CashfreeProvider | FlutterwaveProvider | GocardlessProvider | MoneyhashProvider | StripeProvider;

/** PaymentProviderCollection type */
export type PaymentProviderCollection = {
  __typename?: 'PaymentProviderCollection';
  /** A collection of paginated PaymentProviderCollection */
  collection: Array<PaymentProvider>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** PaymentReceipt */
export type PaymentReceipt = {
  __typename?: 'PaymentReceipt';
  createdAt: Scalars['ISO8601DateTime']['output'];
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  number: Scalars['String']['output'];
  organization: Organization;
  payment: Payment;
};

export type PaymentRequest = {
  __typename?: 'PaymentRequest';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  customer: Customer;
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  invoices: Array<Invoice>;
  payableType: Scalars['String']['output'];
  paymentStatus: InvoicePaymentStatusTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** PaymentRequestCollection type */
export type PaymentRequestCollection = {
  __typename?: 'PaymentRequestCollection';
  /** A collection of paginated PaymentRequestCollection */
  collection: Array<PaymentRequest>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreatePaymentRequest */
export type PaymentRequestCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalCustomerId: Scalars['String']['input'];
  lagoInvoiceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum PaymentTypeEnum {
  Manual = 'manual',
  Provider = 'provider'
}

/** Permissions Type */
export type Permissions = {
  __typename?: 'Permissions';
  addonsCreate: Scalars['Boolean']['output'];
  addonsDelete: Scalars['Boolean']['output'];
  addonsUpdate: Scalars['Boolean']['output'];
  addonsView: Scalars['Boolean']['output'];
  aiConversationsCreate: Scalars['Boolean']['output'];
  aiConversationsView: Scalars['Boolean']['output'];
  analyticsOverdueBalancesView: Scalars['Boolean']['output'];
  analyticsView: Scalars['Boolean']['output'];
  auditLogsView: Scalars['Boolean']['output'];
  authenticationMethodsUpdate: Scalars['Boolean']['output'];
  authenticationMethodsView: Scalars['Boolean']['output'];
  billableMetricsCreate: Scalars['Boolean']['output'];
  billableMetricsDelete: Scalars['Boolean']['output'];
  billableMetricsUpdate: Scalars['Boolean']['output'];
  billableMetricsView: Scalars['Boolean']['output'];
  billingEntitiesCreate: Scalars['Boolean']['output'];
  billingEntitiesDelete: Scalars['Boolean']['output'];
  billingEntitiesDunningCampaignsUpdate: Scalars['Boolean']['output'];
  billingEntitiesEmailsUpdate: Scalars['Boolean']['output'];
  billingEntitiesEmailsView: Scalars['Boolean']['output'];
  billingEntitiesInvoicesUpdate: Scalars['Boolean']['output'];
  billingEntitiesInvoicesView: Scalars['Boolean']['output'];
  billingEntitiesTaxesUpdate: Scalars['Boolean']['output'];
  billingEntitiesTaxesView: Scalars['Boolean']['output'];
  billingEntitiesUpdate: Scalars['Boolean']['output'];
  billingEntitiesView: Scalars['Boolean']['output'];
  couponsAttach: Scalars['Boolean']['output'];
  couponsCreate: Scalars['Boolean']['output'];
  couponsDelete: Scalars['Boolean']['output'];
  couponsDetach: Scalars['Boolean']['output'];
  couponsUpdate: Scalars['Boolean']['output'];
  couponsView: Scalars['Boolean']['output'];
  creditNotesCreate: Scalars['Boolean']['output'];
  creditNotesExport: Scalars['Boolean']['output'];
  creditNotesUpdate: Scalars['Boolean']['output'];
  creditNotesView: Scalars['Boolean']['output'];
  creditNotesVoid: Scalars['Boolean']['output'];
  customerSettingsUpdateGracePeriod: Scalars['Boolean']['output'];
  customerSettingsUpdateLang: Scalars['Boolean']['output'];
  customerSettingsUpdatePaymentTerms: Scalars['Boolean']['output'];
  customerSettingsUpdateTaxRates: Scalars['Boolean']['output'];
  customerSettingsView: Scalars['Boolean']['output'];
  customersCreate: Scalars['Boolean']['output'];
  customersDelete: Scalars['Boolean']['output'];
  customersUpdate: Scalars['Boolean']['output'];
  customersView: Scalars['Boolean']['output'];
  dataApiView: Scalars['Boolean']['output'];
  developersKeysManage: Scalars['Boolean']['output'];
  developersManage: Scalars['Boolean']['output'];
  draftInvoicesUpdate: Scalars['Boolean']['output'];
  dunningCampaignsCreate: Scalars['Boolean']['output'];
  dunningCampaignsDelete: Scalars['Boolean']['output'];
  dunningCampaignsUpdate: Scalars['Boolean']['output'];
  dunningCampaignsView: Scalars['Boolean']['output'];
  featuresCreate: Scalars['Boolean']['output'];
  featuresDelete: Scalars['Boolean']['output'];
  featuresUpdate: Scalars['Boolean']['output'];
  featuresView: Scalars['Boolean']['output'];
  invoiceCustomSectionsCreate: Scalars['Boolean']['output'];
  invoiceCustomSectionsDelete: Scalars['Boolean']['output'];
  invoiceCustomSectionsUpdate: Scalars['Boolean']['output'];
  invoiceCustomSectionsView: Scalars['Boolean']['output'];
  invoicesCreate: Scalars['Boolean']['output'];
  invoicesExport: Scalars['Boolean']['output'];
  invoicesSend: Scalars['Boolean']['output'];
  invoicesUpdate: Scalars['Boolean']['output'];
  invoicesView: Scalars['Boolean']['output'];
  invoicesVoid: Scalars['Boolean']['output'];
  organizationEmailsUpdate: Scalars['Boolean']['output'];
  organizationEmailsView: Scalars['Boolean']['output'];
  organizationIntegrationsCreate: Scalars['Boolean']['output'];
  organizationIntegrationsDelete: Scalars['Boolean']['output'];
  organizationIntegrationsUpdate: Scalars['Boolean']['output'];
  organizationIntegrationsView: Scalars['Boolean']['output'];
  organizationInvoicesUpdate: Scalars['Boolean']['output'];
  organizationInvoicesView: Scalars['Boolean']['output'];
  organizationMembersCreate: Scalars['Boolean']['output'];
  organizationMembersDelete: Scalars['Boolean']['output'];
  organizationMembersUpdate: Scalars['Boolean']['output'];
  organizationMembersView: Scalars['Boolean']['output'];
  organizationTaxesUpdate: Scalars['Boolean']['output'];
  organizationTaxesView: Scalars['Boolean']['output'];
  organizationUpdate: Scalars['Boolean']['output'];
  organizationView: Scalars['Boolean']['output'];
  paymentMethodsCreate: Scalars['Boolean']['output'];
  paymentMethodsDelete: Scalars['Boolean']['output'];
  paymentMethodsUpdate: Scalars['Boolean']['output'];
  paymentMethodsView: Scalars['Boolean']['output'];
  paymentRequestsCreate: Scalars['Boolean']['output'];
  paymentRequestsView: Scalars['Boolean']['output'];
  paymentsCreate: Scalars['Boolean']['output'];
  paymentsView: Scalars['Boolean']['output'];
  plansCreate: Scalars['Boolean']['output'];
  plansDelete: Scalars['Boolean']['output'];
  plansUpdate: Scalars['Boolean']['output'];
  plansView: Scalars['Boolean']['output'];
  pricingUnitsCreate: Scalars['Boolean']['output'];
  pricingUnitsUpdate: Scalars['Boolean']['output'];
  pricingUnitsView: Scalars['Boolean']['output'];
  subscriptionsCreate: Scalars['Boolean']['output'];
  subscriptionsUpdate: Scalars['Boolean']['output'];
  subscriptionsView: Scalars['Boolean']['output'];
  walletsCreate: Scalars['Boolean']['output'];
  walletsTerminate: Scalars['Boolean']['output'];
  walletsTopUp: Scalars['Boolean']['output'];
  walletsUpdate: Scalars['Boolean']['output'];
};

export type Plan = {
  __typename?: 'Plan';
  activeSubscriptionsCount: Scalars['Int']['output'];
  activityLogs?: Maybe<Array<ActivityLog>>;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: Maybe<Scalars['Boolean']['output']>;
  billFixedChargesMonthly?: Maybe<Scalars['Boolean']['output']>;
  charges?: Maybe<Array<Charge>>;
  /** Number of charges attached to a plan */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers attached to a plan */
  customersCount: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  draftInvoicesCount: Scalars['Int']['output'];
  entitlements?: Maybe<Array<PlanEntitlement>>;
  fixedCharges?: Maybe<Array<FixedCharge>>;
  /** Number of fixed charges attached to a plan */
  fixedChargesCount: Scalars['Int']['output'];
  hasActiveSubscriptions: Scalars['Boolean']['output'];
  hasCharges: Scalars['Boolean']['output'];
  hasCustomers: Scalars['Boolean']['output'];
  hasDraftInvoices: Scalars['Boolean']['output'];
  hasFixedCharges: Scalars['Boolean']['output'];
  hasOverriddenPlans?: Maybe<Scalars['Boolean']['output']>;
  hasSubscriptions: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  interval: PlanInterval;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  isOverridden: Scalars['Boolean']['output'];
  minimumCommitment?: Maybe<Commitment>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  parent?: Maybe<Plan>;
  payInAdvance: Scalars['Boolean']['output'];
  subscriptionsCount: Scalars['Int']['output'];
  taxes?: Maybe<Array<Tax>>;
  trialPeriod?: Maybe<Scalars['Float']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  usageThresholds?: Maybe<Array<UsageThreshold>>;
};

/** PlanCollection type */
export type PlanCollection = {
  __typename?: 'PlanCollection';
  /** A collection of paginated PlanCollection */
  collection: Array<Plan>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PlanEntitlement = {
  __typename?: 'PlanEntitlement';
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  privileges: Array<PlanEntitlementPrivilegeObject>;
};

export type PlanEntitlementPrivilegeObject = {
  __typename?: 'PlanEntitlementPrivilegeObject';
  code: Scalars['String']['output'];
  config: PrivilegeConfigObject;
  name?: Maybe<Scalars['String']['output']>;
  value: Scalars['String']['output'];
  valueType: PrivilegeValueTypeEnum;
};

export enum PlanInterval {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Semiannual = 'semiannual',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export type PlanOverridesInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  charges?: InputMaybe<Array<ChargeOverridesInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  fixedCharges?: InputMaybe<Array<FixedChargeOverridesInput>>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdOverridesInput>>;
};

export enum PremiumIntegrationTypeEnum {
  AnalyticsDashboards = 'analytics_dashboards',
  ApiPermissions = 'api_permissions',
  AutoDunning = 'auto_dunning',
  Avalara = 'avalara',
  BetaPaymentAuthorization = 'beta_payment_authorization',
  ClickhouseLiveAggregation = 'clickhouse_live_aggregation',
  ForecastedUsage = 'forecasted_usage',
  FromEmail = 'from_email',
  Hubspot = 'hubspot',
  IssueReceipts = 'issue_receipts',
  LifetimeUsage = 'lifetime_usage',
  ManualPayments = 'manual_payments',
  MultiEntitiesEnterprise = 'multi_entities_enterprise',
  MultiEntitiesPro = 'multi_entities_pro',
  Netsuite = 'netsuite',
  Okta = 'okta',
  Preview = 'preview',
  ProgressiveBilling = 'progressive_billing',
  ProjectedUsage = 'projected_usage',
  RemoveBrandingWatermark = 'remove_branding_watermark',
  RevenueAnalytics = 'revenue_analytics',
  RevenueShare = 'revenue_share',
  Salesforce = 'salesforce',
  Xero = 'xero',
  ZeroAmountFees = 'zero_amount_fees'
}

/** Create Adjusted Fee Input */
export type PreviewAdjustedFeeInput = {
  chargeFilterId?: InputMaybe<Scalars['ID']['input']>;
  chargeId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  feeId?: InputMaybe<Scalars['ID']['input']>;
  fixedChargeId?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
  invoiceSubscriptionId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
  unitPreciseAmount?: InputMaybe<Scalars['String']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

export type PricingUnit = {
  __typename?: 'PricingUnit';
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  shortName: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** PricingUnitCollection type */
export type PricingUnitCollection = {
  __typename?: 'PricingUnitCollection';
  /** A collection of paginated PricingUnitCollection */
  collection: Array<PricingUnit>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PricingUnitUsage = {
  __typename?: 'PricingUnitUsage';
  amountCents: Scalars['BigInt']['output'];
  conversionRate: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  preciseAmountCents: Scalars['Float']['output'];
  preciseUnitAmount: Scalars['Float']['output'];
  pricingUnit: PricingUnit;
  shortName: Scalars['String']['output'];
  unitAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Input for privilege configuration */
export type PrivilegeConfigInput = {
  /** Available options for select type privileges */
  selectOptions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Configuration object for privileges */
export type PrivilegeConfigObject = {
  __typename?: 'PrivilegeConfigObject';
  /** Available options for select type privileges */
  selectOptions?: Maybe<Array<Scalars['String']['output']>>;
};

export type PrivilegeObject = {
  __typename?: 'PrivilegeObject';
  code: Scalars['String']['output'];
  config: PrivilegeConfigObject;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  valueType: PrivilegeValueTypeEnum;
};

export enum PrivilegeValueTypeEnum {
  Boolean = 'boolean',
  Integer = 'integer',
  Select = 'select',
  String = 'string'
}

export type ProjectedChargeFilterUsage = {
  __typename?: 'ProjectedChargeFilterUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  id?: Maybe<Scalars['ID']['output']>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  pricingUnitProjectedAmountCents?: Maybe<Scalars['BigInt']['output']>;
  projectedAmountCents: Scalars['BigInt']['output'];
  projectedUnits: Scalars['Float']['output'];
  units: Scalars['Float']['output'];
  values: Scalars['ChargeFilterValues']['output'];
};

export type ProjectedChargeUsage = {
  __typename?: 'ProjectedChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  billableMetric: BillableMetric;
  charge: Charge;
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ProjectedChargeFilterUsage>>;
  groupedUsage: Array<ProjectedGroupedChargeUsage>;
  id: Scalars['ID']['output'];
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  pricingUnitProjectedAmountCents?: Maybe<Scalars['BigInt']['output']>;
  projectedAmountCents: Scalars['BigInt']['output'];
  projectedUnits: Scalars['Float']['output'];
  units: Scalars['Float']['output'];
};

export type ProjectedGroupedChargeUsage = {
  __typename?: 'ProjectedGroupedChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ProjectedChargeFilterUsage>>;
  groupedBy?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['ID']['output'];
  pricingUnitAmountCents?: Maybe<Scalars['BigInt']['output']>;
  pricingUnitProjectedAmountCents?: Maybe<Scalars['BigInt']['output']>;
  projectedAmountCents: Scalars['BigInt']['output'];
  projectedUnits: Scalars['Float']['output'];
  units: Scalars['Float']['output'];
};

export type Properties = {
  __typename?: 'Properties';
  amount?: Maybe<Scalars['String']['output']>;
  customProperties?: Maybe<Scalars['JSON']['output']>;
  fixedAmount?: Maybe<Scalars['String']['output']>;
  freeUnits?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerEvents?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerTotalAggregation?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<GraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<GraduatedRange>>;
  packageSize?: Maybe<Scalars['BigInt']['output']>;
  perTransactionMaxAmount?: Maybe<Scalars['String']['output']>;
  perTransactionMinAmount?: Maybe<Scalars['String']['output']>;
  pricingGroupKeys?: Maybe<Array<Scalars['String']['output']>>;
  rate?: Maybe<Scalars['String']['output']>;
  volumeRanges?: Maybe<Array<VolumeRange>>;
};

export type PropertiesInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  customProperties?: InputMaybe<Scalars['JSON']['input']>;
  fixedAmount?: InputMaybe<Scalars['String']['input']>;
  freeUnits?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerEvents?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerTotalAggregation?: InputMaybe<Scalars['String']['input']>;
  graduatedPercentageRanges?: InputMaybe<Array<GraduatedPercentageRangeInput>>;
  graduatedRanges?: InputMaybe<Array<GraduatedRangeInput>>;
  packageSize?: InputMaybe<Scalars['BigInt']['input']>;
  perTransactionMaxAmount?: InputMaybe<Scalars['String']['input']>;
  perTransactionMinAmount?: InputMaybe<Scalars['String']['input']>;
  pricingGroupKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  rate?: InputMaybe<Scalars['String']['input']>;
  volumeRanges?: InputMaybe<Array<VolumeRangeInput>>;
};

export type ProviderCustomer = {
  __typename?: 'ProviderCustomer';
  id: Scalars['ID']['output'];
  providerCustomerId?: Maybe<Scalars['ID']['output']>;
  providerPaymentMethods?: Maybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type ProviderCustomerInput = {
  providerCustomerId?: InputMaybe<Scalars['ID']['input']>;
  providerPaymentMethods?: InputMaybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ProviderPaymentMethodsEnum {
  BacsDebit = 'bacs_debit',
  Boleto = 'boleto',
  Card = 'card',
  Crypto = 'crypto',
  CustomerBalance = 'customer_balance',
  Link = 'link',
  SepaDebit = 'sepa_debit',
  UsBankAccount = 'us_bank_account'
}

export enum ProviderTypeEnum {
  Adyen = 'adyen',
  Cashfree = 'cashfree',
  Flutterwave = 'flutterwave',
  Gocardless = 'gocardless',
  Moneyhash = 'moneyhash',
  Stripe = 'stripe'
}

export type Query = {
  __typename?: 'Query';
  /** Query a single activity log of an organization */
  activityLog?: Maybe<ActivityLog>;
  /** Query activity logs of an organization */
  activityLogs?: Maybe<ActivityLogCollection>;
  /** Query a single add-on of an organization */
  addOn?: Maybe<AddOn>;
  /** Query add-ons of an organization */
  addOns: AddOnCollection;
  /** Query a single ai conversation of an organization */
  aiConversation?: Maybe<AiConversationWithMessages>;
  /** Query the latest AI conversations of current organization */
  aiConversations?: Maybe<AiConversationCollection>;
  /** Query a single alert */
  alert?: Maybe<Alert>;
  /** Query alerts of a subscription */
  alerts: AlertCollection;
  /** Query the API key */
  apiKey: ApiKey;
  /** Query the API keys of current organization */
  apiKeys: SanitizedApiKeyCollection;
  /** Query a single api log of an organization */
  apiLog?: Maybe<ApiLog>;
  /** Query api logs of an organization */
  apiLogs?: Maybe<ApiLogCollection>;
  /** Query a single billable metric of an organization */
  billableMetric?: Maybe<BillableMetric>;
  /** Query billable metrics of an organization */
  billableMetrics: BillableMetricCollection;
  /** Query active billing_entities of an organization */
  billingEntities: BillingEntityCollection;
  /** Query a single billing_entity of an organization */
  billingEntity?: Maybe<BillingEntity>;
  /** Query taxes of a billing entity */
  billingEntityTaxes: TaxCollection;
  /** Query a single coupon of an organization */
  coupon?: Maybe<Coupon>;
  /** Query coupons of an organization */
  coupons: CouponCollection;
  /** Query a single credit note */
  creditNote?: Maybe<CreditNote>;
  /** Fetch amounts for credit note creation */
  creditNoteEstimate: CreditNoteEstimate;
  /** Query credit notes */
  creditNotes: CreditNoteCollection;
  /** Retrieves currently connected user */
  currentUser: User;
  /** Retrieve the version of the application */
  currentVersion: CurrentVersion;
  /** Query a single customer of an organization */
  customer?: Maybe<Customer>;
  /** Query invoices of a customer */
  customerInvoices: InvoiceCollection;
  /** Query the projected usage of the customer on the current billing period */
  customerPortalCustomerProjectedUsage: CustomerProjectedUsage;
  /** Query the usage of the customer on the current billing period */
  customerPortalCustomerUsage: CustomerUsage;
  /** Query invoice collections of a customer portal user */
  customerPortalInvoiceCollections: FinalizedInvoiceCollectionCollection;
  /** Query invoices of a customer */
  customerPortalInvoices: InvoiceCollection;
  /** Query customer portal organization */
  customerPortalOrganization?: Maybe<CustomerPortalOrganization>;
  /** Query overdue balances of a customer portal user */
  customerPortalOverdueBalances: OverdueBalanceCollection;
  /** Query a single subscription from the customer portal */
  customerPortalSubscription?: Maybe<Subscription>;
  /** Query customer portal subscriptions */
  customerPortalSubscriptions: SubscriptionCollection;
  /** Query a customer portal user */
  customerPortalUser?: Maybe<CustomerPortalCustomer>;
  /** Query a single wallet from the customer portal */
  customerPortalWallet?: Maybe<CustomerPortalWallet>;
  /** Query wallets */
  customerPortalWallets: CustomerPortalWalletCollection;
  /** Query the projected usage of the customer on the current billing period */
  customerProjectedUsage: CustomerProjectedUsage;
  /** Query the usage of the customer on the current billing period */
  customerUsage: CustomerUsage;
  /** Query customers of an organization */
  customers: CustomerCollection;
  /** Query monthly recurring revenues of an organization */
  dataApiMrrs: DataApiMrrCollection;
  /** Query monthly recurring revenues plans of an organization */
  dataApiMrrsPlans: DataApiMrrsPlans;
  /** Query prepaid credits of an organization */
  dataApiPrepaidCredits: DataApiPrepaidCreditCollection;
  /** Query revenue streams of an organization */
  dataApiRevenueStreams: DataApiRevenueStreamCollection;
  /** Query revenue streams customers of an organization */
  dataApiRevenueStreamsCustomers: DataApiRevenueStreamsCustomers;
  /** Query revenue streams plans of an organization */
  dataApiRevenueStreamsPlans: DataApiRevenueStreamsPlans;
  /** Query usages of an organization */
  dataApiUsages: DataApiUsageCollection;
  /** Query usages of an organization */
  dataApiUsagesAggregatedAmounts: DataApiUsageAggregatedAmountCollection;
  /** Query forecasted usages of an organization */
  dataApiUsagesForecasted: DataApiUsageForecastedCollection;
  /** Query invoiced usages of an organization */
  dataApiUsagesInvoiced: DataApiUsageInvoicedCollection;
  /** Query a single dunning campaign of an organization */
  dunningCampaign: DunningCampaign;
  /** Query dunning campaigns of an organization */
  dunningCampaigns: DunningCampaignCollection;
  /** Query a single event of an organization */
  event?: Maybe<Event>;
  /** Query events of an organization */
  events?: Maybe<EventCollection>;
  /** Query a single feature */
  feature: FeatureObject;
  /** Query features of an organization */
  features: FeatureObjectCollection;
  /** Get Google auth url. */
  googleAuthUrl: AuthUrl;
  /** Query gross revenue of an organization */
  grossRevenues: GrossRevenueCollection;
  /** Query a single integration */
  integration?: Maybe<Integration>;
  /** Query integration collection mappings */
  integrationCollectionMappings?: Maybe<CollectionMappingCollection>;
  /** Query integration items of an integration */
  integrationItems: IntegrationItemCollection;
  /** Query integration subsidiaries */
  integrationSubsidiaries?: Maybe<SubsidiaryCollection>;
  /** Query organization's integrations */
  integrations?: Maybe<IntegrationCollection>;
  /** Query a single Invite */
  invite?: Maybe<Invite>;
  /** Query pending invites of an organization */
  invites: InviteCollection;
  /** Query a single Invoice of an organization */
  invoice?: Maybe<Invoice>;
  /** Query invoice collections of an organization */
  invoiceCollections: FinalizedInvoiceCollectionCollection;
  /** Query invoice's credit note */
  invoiceCreditNotes?: Maybe<CreditNoteCollection>;
  /** Query a single invoice_custom_section of an organization */
  invoiceCustomSection: InvoiceCustomSection;
  /** Query invoice_custom_sections */
  invoiceCustomSections?: Maybe<InvoiceCustomSectionCollection>;
  /** Query invoiced usage of an organization */
  invoicedUsages: InvoicedUsageCollection;
  /** Query invoices */
  invoices: InvoiceCollection;
  /** Query memberships of an organization */
  memberships: MembershipCollection;
  /** Query MRR of an organization */
  mrrs: MrrCollection;
  /** Query the current organization */
  organization?: Maybe<CurrentOrganization>;
  /** Query overdue balances of an organization */
  overdueBalances: OverdueBalanceCollection;
  /** Query a password reset by token */
  passwordReset: ResetPassword;
  /** Query a single Payment */
  payment?: Maybe<Payment>;
  /** Query payment methods of a customer */
  paymentMethods: PaymentMethodCollection;
  /** Query a single payment provider */
  paymentProvider?: Maybe<PaymentProvider>;
  /** Query organization's payment providers */
  paymentProviders?: Maybe<PaymentProviderCollection>;
  /** Query payment requests of an organization */
  paymentRequests: PaymentRequestCollection;
  /** Query payments of an organization */
  payments: PaymentCollection;
  /** Query a single plan of an organization */
  plan?: Maybe<Plan>;
  /** Query plans of an organization */
  plans: PlanCollection;
  /** Query the pricing unit */
  pricingUnit: PricingUnit;
  /** Query the pricing units of current organization */
  pricingUnits: PricingUnitCollection;
  /** Query a single subscription of an organization */
  subscription?: Maybe<Subscription>;
  /** Retrieve an entitlement of a subscriptions */
  subscriptionEntitlement: SubscriptionEntitlement;
  /** Query entitlements of a subscriptions */
  subscriptionEntitlements: SubscriptionEntitlementCollection;
  /** Query subscriptions of an organization */
  subscriptions: SubscriptionCollection;
  /** Query a single tax of an organization */
  tax?: Maybe<Tax>;
  /** Query taxes of an organization */
  taxes: TaxCollection;
  /** Query a single wallet of an organization */
  wallet?: Maybe<Wallet>;
  /** Query a single wallet transaction */
  walletTransaction?: Maybe<WalletTransaction>;
  /** Query wallet transactions */
  walletTransactions: WalletTransactionCollection;
  /** Query wallets */
  wallets: WalletCollection;
  /** Query a webhook */
  webhook?: Maybe<Webhook>;
  /** Query a single webhook endpoint */
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Query webhook endpoints of an organization */
  webhookEndpoints: WebhookEndpointCollection;
  /** Query Webhooks */
  webhooks: WebhookCollection;
};


export type QueryActivityLogArgs = {
  activityId: Scalars['ID']['input'];
};


export type QueryActivityLogsArgs = {
  activityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  activitySources?: InputMaybe<Array<ActivitySourceEnum>>;
  activityTypes?: InputMaybe<Array<ActivityTypeEnum>>;
  apiKeyIds?: InputMaybe<Array<Scalars['String']['input']>>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  fromDatetime?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum>>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDatetime?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  userEmails?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAddOnArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAddOnsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAiConversationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAiConversationsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAlertArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAlertsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  subscriptionExternalId: Scalars['String']['input'];
};


export type QueryApiKeyArgs = {
  id: Scalars['ID']['input'];
};


export type QueryApiKeysArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryApiLogArgs = {
  requestId: Scalars['ID']['input'];
};


export type QueryApiLogsArgs = {
  apiKeyIds?: InputMaybe<Array<Scalars['String']['input']>>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  fromDatetime?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  httpMethods?: InputMaybe<Array<HttpMethodEnum>>;
  httpStatuses?: InputMaybe<Array<Scalars['HttpStatus']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  requestIds?: InputMaybe<Array<Scalars['String']['input']>>;
  requestPaths?: InputMaybe<Array<Scalars['String']['input']>>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDatetime?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
};


export type QueryBillableMetricArgs = {
  id: Scalars['ID']['input'];
};


export type QueryBillableMetricsArgs = {
  aggregationTypes?: InputMaybe<Array<AggregationTypeEnum>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planId?: InputMaybe<Scalars['ID']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryBillingEntityArgs = {
  code: Scalars['String']['input'];
};


export type QueryBillingEntityTaxesArgs = {
  billingEntityId: Scalars['ID']['input'];
};


export type QueryCouponArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCouponsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
};


export type QueryCreditNoteArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCreditNoteEstimateArgs = {
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
};


export type QueryCreditNotesArgs = {
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  creditStatus?: InputMaybe<Array<CreditNoteCreditStatusEnum>>;
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  customerId?: InputMaybe<Scalars['ID']['input']>;
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  reason?: InputMaybe<Array<CreditNoteReasonEnum>>;
  refundStatus?: InputMaybe<Array<CreditNoteRefundStatusEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryCustomerArgs = {
  externalId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryCustomerInvoicesArgs = {
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerPortalCustomerProjectedUsageArgs = {
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomerPortalCustomerUsageArgs = {
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomerPortalInvoiceCollectionsArgs = {
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerPortalInvoicesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerPortalOverdueBalancesArgs = {
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerPortalSubscriptionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCustomerPortalSubscriptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum>>;
};


export type QueryCustomerPortalWalletArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCustomerPortalWalletsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletStatusEnum>;
};


export type QueryCustomerProjectedUsageArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomerUsageArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomersArgs = {
  accountType?: InputMaybe<Array<CustomerAccountTypeEnum>>;
  activeSubscriptionsCountFrom?: InputMaybe<Scalars['Int']['input']>;
  activeSubscriptionsCountTo?: InputMaybe<Scalars['Int']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  countries?: InputMaybe<Array<CountryCode>>;
  currencies?: InputMaybe<Array<CurrencyEnum>>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  hasCustomerType?: InputMaybe<Scalars['Boolean']['input']>;
  hasTaxIdentificationNumber?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataFilter>>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<Array<Scalars['String']['input']>>;
  withDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  zipcodes?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryDataApiMrrsArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiMrrsPlansArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDataApiPrepaidCreditsArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiRevenueStreamsArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiRevenueStreamsCustomersArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrderByEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDataApiRevenueStreamsPlansArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrderByEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDataApiUsagesArgs = {
  billableMetricCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isBillableMetricRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiUsagesAggregatedAmountsArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isBillableMetricRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiUsagesForecastedArgs = {
  billableMetricCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  chargeFilterId?: InputMaybe<Scalars['String']['input']>;
  chargeId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDataApiUsagesInvoicedArgs = {
  billableMetricCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  filterValues?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  groupedBy?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QueryDunningCampaignArgs = {
  id: Scalars['ID']['input'];
};


export type QueryDunningCampaignsArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  currency?: InputMaybe<Array<CurrencyEnum>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryEventArgs = {
  transactionId: Scalars['ID']['input'];
};


export type QueryEventsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryFeatureArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFeaturesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGrossRevenuesArgs = {
  billingEntityId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationCollectionMappingsArgs = {
  integrationId: Scalars['ID']['input'];
};


export type QueryIntegrationItemsArgs = {
  integrationId: Scalars['ID']['input'];
  itemType?: InputMaybe<IntegrationItemTypeEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryIntegrationSubsidiariesArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum>>;
};


export type QueryInviteArgs = {
  token: Scalars['String']['input'];
};


export type QueryInvitesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoiceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryInvoiceCollectionsArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryInvoiceCreditNotesArgs = {
  invoiceId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoiceCustomSectionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryInvoiceCustomSectionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoicedUsagesArgs = {
  billingEntityId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryInvoicesArgs = {
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  customerId?: InputMaybe<Scalars['ID']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum>>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  partiallyPaid?: InputMaybe<Scalars['Boolean']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum>>;
  positiveDueAmount?: InputMaybe<Scalars['Boolean']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMembershipsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMrrsArgs = {
  billingEntityId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryOverdueBalancesArgs = {
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPasswordResetArgs = {
  token: Scalars['String']['input'];
};


export type QueryPaymentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentMethodsArgs = {
  externalCustomerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPaymentProviderArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentProvidersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
};


export type QueryPaymentRequestsArgs = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  paymentStatus?: InputMaybe<InvoicePaymentStatusTypeEnum>;
};


export type QueryPaymentsArgs = {
  externalCustomerId?: InputMaybe<Scalars['ID']['input']>;
  invoiceId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPlansArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  withDeleted?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryPricingUnitArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPricingUnitsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySubscriptionArgs = {
  externalId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySubscriptionEntitlementArgs = {
  featureCode: Scalars['String']['input'];
  subscriptionId: Scalars['ID']['input'];
};


export type QuerySubscriptionEntitlementsArgs = {
  subscriptionId: Scalars['ID']['input'];
};


export type QuerySubscriptionsArgs = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  overriden?: InputMaybe<Scalars['Boolean']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum>>;
};


export type QueryTaxArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWalletArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWalletTransactionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWalletTransactionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletTransactionStatusEnum>;
  transactionType?: InputMaybe<WalletTransactionTransactionTypeEnum>;
  walletId: Scalars['ID']['input'];
};


export type QueryWalletsArgs = {
  customerId: Scalars['ID']['input'];
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletStatusEnum>;
};


export type QueryWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookEndpointArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookEndpointsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWebhooksArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<WebhookStatusEnum>;
  webhookEndpointId: Scalars['String']['input'];
};

export enum RecurringTransactionIntervalEnum {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Semiannual = 'semiannual',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export enum RecurringTransactionMethodEnum {
  Fixed = 'fixed',
  Target = 'target'
}

export type RecurringTransactionRule = {
  __typename?: 'RecurringTransactionRule';
  createdAt: Scalars['ISO8601DateTime']['output'];
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  grantedCredits: Scalars['String']['output'];
  ignorePaidTopUpLimits: Scalars['Boolean']['output'];
  interval?: Maybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  lagoId: Scalars['ID']['output'];
  method: RecurringTransactionMethodEnum;
  paidCredits: Scalars['String']['output'];
  startedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  targetOngoingBalance?: Maybe<Scalars['String']['output']>;
  thresholdCredits?: Maybe<Scalars['String']['output']>;
  transactionMetadata?: Maybe<Array<TransactionMetadata>>;
  transactionName?: Maybe<Scalars['String']['output']>;
  trigger: RecurringTransactionTriggerEnum;
};

export enum RecurringTransactionTriggerEnum {
  Interval = 'interval',
  Threshold = 'threshold'
}

/** Autogenerated input type of RefreshInvoice */
export type RefreshInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RegenerateInvoice */
export type RegenerateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fees: Array<VoidedInvoiceFeeInput>;
  voidedInvoiceId: Scalars['ID']['input'];
};

export type RegisterUser = {
  __typename?: 'RegisterUser';
  membership: Membership;
  organization: Organization;
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of RegisterUser */
export type RegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export enum RegroupPaidFeesEnum {
  Invoice = 'invoice'
}

/** Autogenerated input type of RemoveSubscriptionEntitlement */
export type RemoveSubscriptionEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  featureCode: Scalars['String']['input'];
  subscriptionId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveSubscriptionEntitlement. */
export type RemoveSubscriptionEntitlementPayload = {
  __typename?: 'RemoveSubscriptionEntitlementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  featureCode?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveTaxes */
export type RemoveTaxesInput = {
  billingEntityId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  taxCodes: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of RemoveTaxes. */
export type RemoveTaxesPayload = {
  __typename?: 'RemoveTaxesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  removedTaxes: Array<Tax>;
};

/** ResetPassword type */
export type ResetPassword = {
  __typename?: 'ResetPassword';
  expireAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of ResetPassword */
export type ResetPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

/** Activity Logs resource type enums */
export enum ResourceTypeEnum {
  /** BillableMetric */
  BillableMetric = 'billable_metric',
  /** BillingEntity */
  BillingEntity = 'billing_entity',
  /** Coupon */
  Coupon = 'coupon',
  /** CreditNote */
  CreditNote = 'credit_note',
  /** Customer */
  Customer = 'customer',
  /** Entitlement::Feature */
  Feature = 'feature',
  /** Invoice */
  Invoice = 'invoice',
  /** PaymentRequest */
  PaymentRequest = 'payment_request',
  /** Plan */
  Plan = 'plan',
  /** Subscription */
  Subscription = 'subscription',
  /** Wallet */
  Wallet = 'wallet'
}

/** Autogenerated input type of RetryAllInvoicePayments */
export type RetryAllInvoicePaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RetryAllInvoices */
export type RetryAllInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RetryInvoice */
export type RetryInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryInvoicePayment */
export type RetryInvoicePaymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryTaxProviderVoiding */
export type RetryTaxProviderVoidingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryTaxReporting */
export type RetryTaxReportingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryWebhook */
export type RetryWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeInvite */
export type RevokeInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeMembership */
export type RevokeMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RotateApiKey */
export type RotateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum RoundingFunctionEnum {
  Ceil = 'ceil',
  Floor = 'floor',
  Round = 'round'
}

export type SalesforceCustomer = {
  __typename?: 'SalesforceCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type SalesforceIntegration = {
  __typename?: 'SalesforceIntegration';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  instanceId: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type SanitizedApiKey = {
  __typename?: 'SanitizedApiKey';
  createdAt: Scalars['ISO8601DateTime']['output'];
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastUsedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  permissions: Scalars['JSON']['output'];
  value: Scalars['String']['output'];
};

/** SanitizedApiKeyCollection type */
export type SanitizedApiKeyCollection = {
  __typename?: 'SanitizedApiKeyCollection';
  /** A collection of paginated SanitizedApiKeyCollection */
  collection: Array<SanitizedApiKey>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of SetAsDefault */
export type SetAsDefaultInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum StatusTypeEnum {
  Active = 'active',
  Canceled = 'canceled',
  Pending = 'pending',
  Terminated = 'terminated'
}

export type StripeProvider = {
  __typename?: 'StripeProvider';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  secretKey?: Maybe<Scalars['ObfuscatedString']['output']>;
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  activityLogs?: Maybe<Array<ActivityLog>>;
  billingTime?: Maybe<BillingTimeEnum>;
  canceledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  currentBillingPeriodEndingAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  currentBillingPeriodStartedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  customer: Customer;
  endingAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalId: Scalars['String']['output'];
  fees?: Maybe<Array<Fee>>;
  id: Scalars['ID']['output'];
  lifetimeUsage?: Maybe<SubscriptionLifetimeUsage>;
  name?: Maybe<Scalars['String']['output']>;
  nextName?: Maybe<Scalars['String']['output']>;
  nextPlan?: Maybe<Plan>;
  nextSubscription?: Maybe<Subscription>;
  nextSubscriptionAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  nextSubscriptionType?: Maybe<NextSubscriptionTypeEnum>;
  onTerminationCreditNote?: Maybe<OnTerminationCreditNoteEnum>;
  onTerminationInvoice: OnTerminationInvoiceEnum;
  periodEndDate?: Maybe<Scalars['ISO8601Date']['output']>;
  plan: Plan;
  startedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status?: Maybe<StatusTypeEnum>;
  subscriptionAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** SubscriptionCollection type */
export type SubscriptionCollection = {
  __typename?: 'SubscriptionCollection';
  /** A collection of paginated SubscriptionCollection */
  collection: Array<Subscription>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type SubscriptionEntitlement = {
  __typename?: 'SubscriptionEntitlement';
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  privileges: Array<SubscriptionEntitlementPrivilegeObject>;
};

/** SubscriptionEntitlementCollection type */
export type SubscriptionEntitlementCollection = {
  __typename?: 'SubscriptionEntitlementCollection';
  /** A collection of paginated SubscriptionEntitlementCollection */
  collection: Array<SubscriptionEntitlement>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type SubscriptionEntitlementPrivilegeObject = {
  __typename?: 'SubscriptionEntitlementPrivilegeObject';
  code: Scalars['String']['output'];
  config: PrivilegeConfigObject;
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
  valueType: PrivilegeValueTypeEnum;
};

export type SubscriptionLifetimeUsage = {
  __typename?: 'SubscriptionLifetimeUsage';
  lastThresholdAmountCents?: Maybe<Scalars['BigInt']['output']>;
  nextThresholdAmountCents?: Maybe<Scalars['BigInt']['output']>;
  nextThresholdRatio?: Maybe<Scalars['Float']['output']>;
  totalUsageAmountCents: Scalars['BigInt']['output'];
  totalUsageFromDatetime: Scalars['ISO8601DateTime']['output'];
  totalUsageToDatetime: Scalars['ISO8601DateTime']['output'];
};

export type Subsidiary = {
  __typename?: 'Subsidiary';
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
};

/** SubsidiaryCollection type */
export type SubsidiaryCollection = {
  __typename?: 'SubsidiaryCollection';
  /** A collection of paginated SubsidiaryCollection */
  collection: Array<Subsidiary>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of SyncHubspotInvoice */
export type SyncHubspotIntegrationInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncHubspotInvoice. */
export type SyncHubspotInvoicePayload = {
  __typename?: 'SyncHubspotInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoiceId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of SyncIntegrationCreditNote */
export type SyncIntegrationCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditNoteId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncIntegrationCreditNote. */
export type SyncIntegrationCreditNotePayload = {
  __typename?: 'SyncIntegrationCreditNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  creditNoteId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of SyncIntegrationInvoice */
export type SyncIntegrationInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncIntegrationInvoice. */
export type SyncIntegrationInvoicePayload = {
  __typename?: 'SyncIntegrationInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoiceId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of SyncSalesforceInvoice */
export type SyncSalesforceInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncSalesforceInvoice. */
export type SyncSalesforceInvoicePayload = {
  __typename?: 'SyncSalesforceInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoiceId?: Maybe<Scalars['ID']['output']>;
};

export type Tax = {
  __typename?: 'Tax';
  /** Number of add ons using this tax */
  addOnsCount: Scalars['Int']['output'];
  appliedToOrganization: Scalars['Boolean']['output'];
  autoGenerated: Scalars['Boolean']['output'];
  /** Number of charges using this tax */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this tax */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  /** Number of plans using this tax */
  plansCount: Scalars['Int']['output'];
  rate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type TaxBreakdownObject = {
  __typename?: 'TaxBreakdownObject';
  enumedTaxCode?: Maybe<InvoiceAppliedTaxOnWholeInvoiceCodeEnum>;
  name?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['BigInt']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** TaxCollection type */
export type TaxCollection = {
  __typename?: 'TaxCollection';
  /** A collection of paginated TaxCollection */
  collection: Array<Tax>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateTax */
export type TaxCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  rate: Scalars['Float']['input'];
};

export type TaxFeeObject = {
  __typename?: 'TaxFeeObject';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  itemCode?: Maybe<Scalars['String']['output']>;
  itemId?: Maybe<Scalars['String']['output']>;
  taxAmountCents?: Maybe<Scalars['BigInt']['output']>;
  taxBreakdown?: Maybe<Array<TaxBreakdownObject>>;
};

/** TaxFeeObjectCollection type */
export type TaxFeeObjectCollection = {
  __typename?: 'TaxFeeObjectCollection';
  /** A collection of paginated TaxFeeObjectCollection */
  collection: Array<TaxFeeObject>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of UpdateTax */
export type TaxUpdateInput = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  rate?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of TerminateAppliedCoupon */
export type TerminateAppliedCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCoupon */
export type TerminateCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCustomerWallet */
export type TerminateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Input for terminating a subscription */
export type TerminateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  onTerminationCreditNote?: InputMaybe<OnTerminationCreditNoteEnum>;
  onTerminationInvoice?: InputMaybe<OnTerminationInvoiceEnum>;
};

export type ThresholdInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

export enum TimeGranularityEnum {
  Daily = 'daily',
  Monthly = 'monthly',
  Weekly = 'weekly'
}

export enum TimezoneEnum {
  /** Africa/Algiers */
  TzAfricaAlgiers = 'TZ_AFRICA_ALGIERS',
  /** Africa/Cairo */
  TzAfricaCairo = 'TZ_AFRICA_CAIRO',
  /** Africa/Casablanca */
  TzAfricaCasablanca = 'TZ_AFRICA_CASABLANCA',
  /** Africa/Harare */
  TzAfricaHarare = 'TZ_AFRICA_HARARE',
  /** Africa/Johannesburg */
  TzAfricaJohannesburg = 'TZ_AFRICA_JOHANNESBURG',
  /** Africa/Monrovia */
  TzAfricaMonrovia = 'TZ_AFRICA_MONROVIA',
  /** Africa/Nairobi */
  TzAfricaNairobi = 'TZ_AFRICA_NAIROBI',
  /** America/Argentina/Buenos_Aires */
  TzAmericaArgentinaBuenosAires = 'TZ_AMERICA_ARGENTINA_BUENOS_AIRES',
  /** America/Bogota */
  TzAmericaBogota = 'TZ_AMERICA_BOGOTA',
  /** America/Caracas */
  TzAmericaCaracas = 'TZ_AMERICA_CARACAS',
  /** America/Chicago */
  TzAmericaChicago = 'TZ_AMERICA_CHICAGO',
  /** America/Chihuahua */
  TzAmericaChihuahua = 'TZ_AMERICA_CHIHUAHUA',
  /** America/Denver */
  TzAmericaDenver = 'TZ_AMERICA_DENVER',
  /** America/Guatemala */
  TzAmericaGuatemala = 'TZ_AMERICA_GUATEMALA',
  /** America/Guyana */
  TzAmericaGuyana = 'TZ_AMERICA_GUYANA',
  /** America/Halifax */
  TzAmericaHalifax = 'TZ_AMERICA_HALIFAX',
  /** America/Indiana/Indianapolis */
  TzAmericaIndianaIndianapolis = 'TZ_AMERICA_INDIANA_INDIANAPOLIS',
  /** America/Juneau */
  TzAmericaJuneau = 'TZ_AMERICA_JUNEAU',
  /** America/La_Paz */
  TzAmericaLaPaz = 'TZ_AMERICA_LA_PAZ',
  /** America/Lima */
  TzAmericaLima = 'TZ_AMERICA_LIMA',
  /** America/Los_Angeles */
  TzAmericaLosAngeles = 'TZ_AMERICA_LOS_ANGELES',
  /** America/Mazatlan */
  TzAmericaMazatlan = 'TZ_AMERICA_MAZATLAN',
  /** America/Mexico_City */
  TzAmericaMexicoCity = 'TZ_AMERICA_MEXICO_CITY',
  /** America/Monterrey */
  TzAmericaMonterrey = 'TZ_AMERICA_MONTERREY',
  /** America/Montevideo */
  TzAmericaMontevideo = 'TZ_AMERICA_MONTEVIDEO',
  /** America/New_York */
  TzAmericaNewYork = 'TZ_AMERICA_NEW_YORK',
  /** America/Nuuk */
  TzAmericaNuuk = 'TZ_AMERICA_NUUK',
  /** America/Phoenix */
  TzAmericaPhoenix = 'TZ_AMERICA_PHOENIX',
  /** America/Puerto_Rico */
  TzAmericaPuertoRico = 'TZ_AMERICA_PUERTO_RICO',
  /** America/Regina */
  TzAmericaRegina = 'TZ_AMERICA_REGINA',
  /** America/Santiago */
  TzAmericaSantiago = 'TZ_AMERICA_SANTIAGO',
  /** America/Sao_Paulo */
  TzAmericaSaoPaulo = 'TZ_AMERICA_SAO_PAULO',
  /** America/St_Johns */
  TzAmericaStJohns = 'TZ_AMERICA_ST_JOHNS',
  /** America/Tijuana */
  TzAmericaTijuana = 'TZ_AMERICA_TIJUANA',
  /** Asia/Almaty */
  TzAsiaAlmaty = 'TZ_ASIA_ALMATY',
  /** Asia/Baghdad */
  TzAsiaBaghdad = 'TZ_ASIA_BAGHDAD',
  /** Asia/Baku */
  TzAsiaBaku = 'TZ_ASIA_BAKU',
  /** Asia/Bangkok */
  TzAsiaBangkok = 'TZ_ASIA_BANGKOK',
  /** Asia/Chongqing */
  TzAsiaChongqing = 'TZ_ASIA_CHONGQING',
  /** Asia/Colombo */
  TzAsiaColombo = 'TZ_ASIA_COLOMBO',
  /** Asia/Dhaka */
  TzAsiaDhaka = 'TZ_ASIA_DHAKA',
  /** Asia/Hong_Kong */
  TzAsiaHongKong = 'TZ_ASIA_HONG_KONG',
  /** Asia/Irkutsk */
  TzAsiaIrkutsk = 'TZ_ASIA_IRKUTSK',
  /** Asia/Jakarta */
  TzAsiaJakarta = 'TZ_ASIA_JAKARTA',
  /** Asia/Jerusalem */
  TzAsiaJerusalem = 'TZ_ASIA_JERUSALEM',
  /** Asia/Kabul */
  TzAsiaKabul = 'TZ_ASIA_KABUL',
  /** Asia/Kamchatka */
  TzAsiaKamchatka = 'TZ_ASIA_KAMCHATKA',
  /** Asia/Karachi */
  TzAsiaKarachi = 'TZ_ASIA_KARACHI',
  /** Asia/Kathmandu */
  TzAsiaKathmandu = 'TZ_ASIA_KATHMANDU',
  /** Asia/Kolkata */
  TzAsiaKolkata = 'TZ_ASIA_KOLKATA',
  /** Asia/Krasnoyarsk */
  TzAsiaKrasnoyarsk = 'TZ_ASIA_KRASNOYARSK',
  /** Asia/Kuala_Lumpur */
  TzAsiaKualaLumpur = 'TZ_ASIA_KUALA_LUMPUR',
  /** Asia/Kuwait */
  TzAsiaKuwait = 'TZ_ASIA_KUWAIT',
  /** Asia/Magadan */
  TzAsiaMagadan = 'TZ_ASIA_MAGADAN',
  /** Asia/Muscat */
  TzAsiaMuscat = 'TZ_ASIA_MUSCAT',
  /** Asia/Novosibirsk */
  TzAsiaNovosibirsk = 'TZ_ASIA_NOVOSIBIRSK',
  /** Asia/Riyadh */
  TzAsiaRiyadh = 'TZ_ASIA_RIYADH',
  /** Asia/Seoul */
  TzAsiaSeoul = 'TZ_ASIA_SEOUL',
  /** Asia/Shanghai */
  TzAsiaShanghai = 'TZ_ASIA_SHANGHAI',
  /** Asia/Singapore */
  TzAsiaSingapore = 'TZ_ASIA_SINGAPORE',
  /** Asia/Srednekolymsk */
  TzAsiaSrednekolymsk = 'TZ_ASIA_SREDNEKOLYMSK',
  /** Asia/Taipei */
  TzAsiaTaipei = 'TZ_ASIA_TAIPEI',
  /** Asia/Tashkent */
  TzAsiaTashkent = 'TZ_ASIA_TASHKENT',
  /** Asia/Tbilisi */
  TzAsiaTbilisi = 'TZ_ASIA_TBILISI',
  /** Asia/Tehran */
  TzAsiaTehran = 'TZ_ASIA_TEHRAN',
  /** Asia/Tokyo */
  TzAsiaTokyo = 'TZ_ASIA_TOKYO',
  /** Asia/Ulaanbaatar */
  TzAsiaUlaanbaatar = 'TZ_ASIA_ULAANBAATAR',
  /** Asia/Urumqi */
  TzAsiaUrumqi = 'TZ_ASIA_URUMQI',
  /** Asia/Vladivostok */
  TzAsiaVladivostok = 'TZ_ASIA_VLADIVOSTOK',
  /** Asia/Yakutsk */
  TzAsiaYakutsk = 'TZ_ASIA_YAKUTSK',
  /** Asia/Yangon */
  TzAsiaYangon = 'TZ_ASIA_YANGON',
  /** Asia/Yekaterinburg */
  TzAsiaYekaterinburg = 'TZ_ASIA_YEKATERINBURG',
  /** Asia/Yerevan */
  TzAsiaYerevan = 'TZ_ASIA_YEREVAN',
  /** Atlantic/Azores */
  TzAtlanticAzores = 'TZ_ATLANTIC_AZORES',
  /** Atlantic/Cape_Verde */
  TzAtlanticCapeVerde = 'TZ_ATLANTIC_CAPE_VERDE',
  /** Atlantic/South_Georgia */
  TzAtlanticSouthGeorgia = 'TZ_ATLANTIC_SOUTH_GEORGIA',
  /** Australia/Adelaide */
  TzAustraliaAdelaide = 'TZ_AUSTRALIA_ADELAIDE',
  /** Australia/Brisbane */
  TzAustraliaBrisbane = 'TZ_AUSTRALIA_BRISBANE',
  /** Australia/Canberra */
  TzAustraliaCanberra = 'TZ_AUSTRALIA_CANBERRA',
  /** Australia/Darwin */
  TzAustraliaDarwin = 'TZ_AUSTRALIA_DARWIN',
  /** Australia/Hobart */
  TzAustraliaHobart = 'TZ_AUSTRALIA_HOBART',
  /** Australia/Melbourne */
  TzAustraliaMelbourne = 'TZ_AUSTRALIA_MELBOURNE',
  /** Australia/Perth */
  TzAustraliaPerth = 'TZ_AUSTRALIA_PERTH',
  /** Australia/Sydney */
  TzAustraliaSydney = 'TZ_AUSTRALIA_SYDNEY',
  /** Etc/GMT+12 */
  TzEtcGmt_12 = 'TZ_ETC_GMT_12',
  /** Europe/Amsterdam */
  TzEuropeAmsterdam = 'TZ_EUROPE_AMSTERDAM',
  /** Europe/Athens */
  TzEuropeAthens = 'TZ_EUROPE_ATHENS',
  /** Europe/Belgrade */
  TzEuropeBelgrade = 'TZ_EUROPE_BELGRADE',
  /** Europe/Berlin */
  TzEuropeBerlin = 'TZ_EUROPE_BERLIN',
  /** Europe/Bratislava */
  TzEuropeBratislava = 'TZ_EUROPE_BRATISLAVA',
  /** Europe/Brussels */
  TzEuropeBrussels = 'TZ_EUROPE_BRUSSELS',
  /** Europe/Bucharest */
  TzEuropeBucharest = 'TZ_EUROPE_BUCHAREST',
  /** Europe/Budapest */
  TzEuropeBudapest = 'TZ_EUROPE_BUDAPEST',
  /** Europe/Copenhagen */
  TzEuropeCopenhagen = 'TZ_EUROPE_COPENHAGEN',
  /** Europe/Dublin */
  TzEuropeDublin = 'TZ_EUROPE_DUBLIN',
  /** Europe/Helsinki */
  TzEuropeHelsinki = 'TZ_EUROPE_HELSINKI',
  /** Europe/Istanbul */
  TzEuropeIstanbul = 'TZ_EUROPE_ISTANBUL',
  /** Europe/Kaliningrad */
  TzEuropeKaliningrad = 'TZ_EUROPE_KALININGRAD',
  /** Europe/Kyiv */
  TzEuropeKyiv = 'TZ_EUROPE_KYIV',
  /** Europe/Lisbon */
  TzEuropeLisbon = 'TZ_EUROPE_LISBON',
  /** Europe/Ljubljana */
  TzEuropeLjubljana = 'TZ_EUROPE_LJUBLJANA',
  /** Europe/London */
  TzEuropeLondon = 'TZ_EUROPE_LONDON',
  /** Europe/Madrid */
  TzEuropeMadrid = 'TZ_EUROPE_MADRID',
  /** Europe/Minsk */
  TzEuropeMinsk = 'TZ_EUROPE_MINSK',
  /** Europe/Moscow */
  TzEuropeMoscow = 'TZ_EUROPE_MOSCOW',
  /** Europe/Paris */
  TzEuropeParis = 'TZ_EUROPE_PARIS',
  /** Europe/Prague */
  TzEuropePrague = 'TZ_EUROPE_PRAGUE',
  /** Europe/Riga */
  TzEuropeRiga = 'TZ_EUROPE_RIGA',
  /** Europe/Rome */
  TzEuropeRome = 'TZ_EUROPE_ROME',
  /** Europe/Samara */
  TzEuropeSamara = 'TZ_EUROPE_SAMARA',
  /** Europe/Sarajevo */
  TzEuropeSarajevo = 'TZ_EUROPE_SARAJEVO',
  /** Europe/Skopje */
  TzEuropeSkopje = 'TZ_EUROPE_SKOPJE',
  /** Europe/Sofia */
  TzEuropeSofia = 'TZ_EUROPE_SOFIA',
  /** Europe/Stockholm */
  TzEuropeStockholm = 'TZ_EUROPE_STOCKHOLM',
  /** Europe/Tallinn */
  TzEuropeTallinn = 'TZ_EUROPE_TALLINN',
  /** Europe/Vienna */
  TzEuropeVienna = 'TZ_EUROPE_VIENNA',
  /** Europe/Vilnius */
  TzEuropeVilnius = 'TZ_EUROPE_VILNIUS',
  /** Europe/Volgograd */
  TzEuropeVolgograd = 'TZ_EUROPE_VOLGOGRAD',
  /** Europe/Warsaw */
  TzEuropeWarsaw = 'TZ_EUROPE_WARSAW',
  /** Europe/Zagreb */
  TzEuropeZagreb = 'TZ_EUROPE_ZAGREB',
  /** Europe/Zurich */
  TzEuropeZurich = 'TZ_EUROPE_ZURICH',
  /** Pacific/Apia */
  TzPacificApia = 'TZ_PACIFIC_APIA',
  /** Pacific/Auckland */
  TzPacificAuckland = 'TZ_PACIFIC_AUCKLAND',
  /** Pacific/Chatham */
  TzPacificChatham = 'TZ_PACIFIC_CHATHAM',
  /** Pacific/Fakaofo */
  TzPacificFakaofo = 'TZ_PACIFIC_FAKAOFO',
  /** Pacific/Fiji */
  TzPacificFiji = 'TZ_PACIFIC_FIJI',
  /** Pacific/Guadalcanal */
  TzPacificGuadalcanal = 'TZ_PACIFIC_GUADALCANAL',
  /** Pacific/Guam */
  TzPacificGuam = 'TZ_PACIFIC_GUAM',
  /** Pacific/Honolulu */
  TzPacificHonolulu = 'TZ_PACIFIC_HONOLULU',
  /** Pacific/Majuro */
  TzPacificMajuro = 'TZ_PACIFIC_MAJURO',
  /** Pacific/Midway */
  TzPacificMidway = 'TZ_PACIFIC_MIDWAY',
  /** Pacific/Noumea */
  TzPacificNoumea = 'TZ_PACIFIC_NOUMEA',
  /** Pacific/Pago_Pago */
  TzPacificPagoPago = 'TZ_PACIFIC_PAGO_PAGO',
  /** Pacific/Port_Moresby */
  TzPacificPortMoresby = 'TZ_PACIFIC_PORT_MORESBY',
  /** Pacific/Tongatapu */
  TzPacificTongatapu = 'TZ_PACIFIC_TONGATAPU',
  /** UTC */
  TzUtc = 'TZ_UTC'
}

export type TransactionMetadata = {
  __typename?: 'TransactionMetadata';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Update input arguments */
export type UpdateAdyenPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateAnrokIntegration */
export type UpdateAnrokIntegrationInput = {
  apiKey?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateApiKey */
export type UpdateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<Scalars['JSON']['input']>;
};

/** Autogenerated input type of UpdateAvalaraIntegration */
export type UpdateAvalaraIntegrationInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  companyCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  licenseKey?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Update Billable metric input arguments */
export type UpdateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  expression?: InputMaybe<Scalars['String']['input']>;
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  roundingFunction?: InputMaybe<RoundingFunctionEnum>;
  roundingPrecision?: InputMaybe<Scalars['Int']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Update Billing Entity input arguments */
export type UpdateBillingEntityInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<BillingEntityBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  defaultCurrency?: InputMaybe<CurrencyEnum>;
  documentNumberPrefix?: InputMaybe<Scalars['String']['input']>;
  documentNumbering?: InputMaybe<BillingEntityDocumentNumberingEnum>;
  einvoicing?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<Array<BillingEntityEmailSettingsEnum>>;
  euTaxManagement?: InputMaybe<Scalars['Boolean']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  invoiceCustomSectionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Update input arguments */
export type UpdateCashfreePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateCoupon */
export type UpdateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateCreditNote */
export type UpdateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  refundStatus: CreditNoteRefundStatusEnum;
};

/** Update Customer input arguments */
export type UpdateCustomerInput = {
  accountType?: InputMaybe<CustomerAccountTypeEnum>;
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  appliedDunningCampaignId?: InputMaybe<Scalars['ID']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  configurableInvoiceCustomSectionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  excludeFromDunningCampaign?: InputMaybe<Scalars['Boolean']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationCustomers?: InputMaybe<Array<IntegrationCustomerInput>>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  skipInvoiceCustomSections?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateCustomerInvoiceGracePeriod */
export type UpdateCustomerInvoiceGracePeriodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

/** Customer Portal Customer Update input arguments */
export type UpdateCustomerPortalCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Update Wallet Input */
export type UpdateCustomerWalletInput = {
  appliesTo?: InputMaybe<AppliesToInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paidTopUpMaxAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  paidTopUpMinAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  priority: Scalars['Int']['input'];
  recurringTransactionRules?: InputMaybe<Array<UpdateRecurringTransactionRuleInput>>;
};

/** Autogenerated input type of UpdateDunningCampaign */
export type UpdateDunningCampaignInput = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  bccEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  daysBetweenAttempts?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  maxAttempts?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  thresholds?: InputMaybe<Array<DunningCampaignThresholdInput>>;
};

/** Input for updating a feature */
export type UpdateFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The description of the feature */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the feature to update */
  id: Scalars['ID']['input'];
  /** The name of the feature */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The privileges configuration */
  privileges: Array<UpdatePrivilegeInput>;
};

/** Update input arguments */
export type UpdateFlutterwavePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Update input arguments */
export type UpdateGocardlessPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateHubspotIntegration */
export type UpdateHubspotIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  defaultTargetedObject?: InputMaybe<HubspotTargetedObjectsEnum>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncSubscriptions?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateIntegrationCollectionMapping */
export type UpdateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappingType?: InputMaybe<MappingTypeEnum>;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxNexus?: InputMaybe<Scalars['String']['input']>;
  taxType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateIntegrationMapping */
export type UpdateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappableId?: InputMaybe<Scalars['ID']['input']>;
  mappableType?: InputMaybe<MappableTypeEnum>;
};

/** Autogenerated input type of UpdateInvite */
export type UpdateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: MembershipRole;
};

/** Autogenerated input type of UpdateInvoiceCustomSection */
export type UpdateInvoiceCustomSectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Update Invoice input arguments */
export type UpdateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<Array<InvoiceMetadataInput>>;
  paymentStatus?: InputMaybe<InvoicePaymentStatusTypeEnum>;
};

/** Autogenerated input type of UpdateMembership */
export type UpdateMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: MembershipRole;
};

/** Update input arguments */
export type UpdateMoneyhashPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateNetsuiteIntegration */
export type UpdateNetsuiteIntegrationInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  scriptEndpointUrl?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  tokenId?: InputMaybe<Scalars['String']['input']>;
  tokenSecret?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateOktaIntegration */
export type UpdateOktaIntegrationInput = {
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  domain?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  organizationName?: InputMaybe<Scalars['String']['input']>;
};

/** Update Organization input arguments */
export type UpdateOrganizationInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  authenticationMethods?: InputMaybe<Array<AuthenticationMethodsEnum>>;
  billingConfiguration?: InputMaybe<OrganizationBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  defaultCurrency?: InputMaybe<CurrencyEnum>;
  documentNumberPrefix?: InputMaybe<Scalars['String']['input']>;
  documentNumbering?: InputMaybe<DocumentNumberingEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<Array<EmailSettingsEnum>>;
  euTaxManagement?: InputMaybe<Scalars['Boolean']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<Scalars['Boolean']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  webhookUrl?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdatePlan */
export type UpdatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  billFixedChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  cascadeUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  entitlements?: InputMaybe<Array<EntitlementInput>>;
  fixedCharges?: InputMaybe<Array<FixedChargeInput>>;
  id: Scalars['ID']['input'];
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdInput>>;
};

/** Autogenerated input type of UpdatePricingUnit */
export type UpdatePricingUnitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  shortName?: InputMaybe<Scalars['String']['input']>;
};

/** Input for updating a privilege */
export type UpdatePrivilegeInput = {
  code: Scalars['String']['input'];
  config?: InputMaybe<PrivilegeConfigInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  valueType?: InputMaybe<PrivilegeValueTypeEnum>;
};

export type UpdateRecurringTransactionRuleInput = {
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  ignorePaidTopUpLimits?: InputMaybe<Scalars['Boolean']['input']>;
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  lagoId?: InputMaybe<Scalars['ID']['input']>;
  method?: InputMaybe<RecurringTransactionMethodEnum>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  targetOngoingBalance?: InputMaybe<Scalars['String']['input']>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  transactionMetadata?: InputMaybe<Array<CreateTransactionMetadataInput>>;
  transactionName?: InputMaybe<Scalars['String']['input']>;
  trigger?: InputMaybe<RecurringTransactionTriggerEnum>;
};

/** Autogenerated input type of UpdateSalesforceIntegration */
export type UpdateSalesforceIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  instanceId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Update input arguments */
export type UpdateStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateSubscriptionAlert */
export type UpdateSubscriptionAlertInput = {
  billableMetricId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  thresholds?: InputMaybe<Array<ThresholdInput>>;
};

/** Update Subscription input arguments */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
};

/** Autogenerated input type of UpdateXeroIntegration */
export type UpdateXeroIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UsageThreshold = {
  __typename?: 'UsageThreshold';
  amountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  recurring: Scalars['Boolean']['output'];
  thresholdDisplayName?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type UsageThresholdInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdDisplayName?: InputMaybe<Scalars['String']['input']>;
};

export type UsageThresholdOverridesInput = {
  amountCents: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdDisplayName?: InputMaybe<Scalars['String']['input']>;
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  memberships: Array<Membership>;
  organizations: Array<Organization>;
  premium: Scalars['Boolean']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of VoidCreditNote */
export type VoidCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Void Invoice input arguments */
export type VoidInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditAmount?: InputMaybe<Scalars['BigInt']['input']>;
  generateCreditNote?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  refundAmount?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Fee input for creating or updating invoice from voided invoice */
export type VoidedInvoiceFeeInput = {
  addOnId?: InputMaybe<Scalars['ID']['input']>;
  chargeFilterId?: InputMaybe<Scalars['ID']['input']>;
  chargeId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

export type VolumeRange = {
  __typename?: 'VolumeRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type VolumeRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Wallet */
export type Wallet = {
  __typename?: 'Wallet';
  activityLogs?: Maybe<Array<ActivityLog>>;
  appliesTo?: Maybe<WalletAppliesTo>;
  balanceCents: Scalars['BigInt']['output'];
  consumedAmountCents: Scalars['BigInt']['output'];
  consumedCredits: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditsBalance: Scalars['Float']['output'];
  creditsOngoingBalance: Scalars['Float']['output'];
  creditsOngoingUsageBalance: Scalars['Float']['output'];
  currency: CurrencyEnum;
  customer?: Maybe<Customer>;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastConsumedCreditAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastOngoingBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ongoingBalanceCents: Scalars['BigInt']['output'];
  ongoingUsageBalanceCents: Scalars['BigInt']['output'];
  paidTopUpMaxAmountCents?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMaxCredits?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMinAmountCents?: Maybe<Scalars['BigInt']['output']>;
  paidTopUpMinCredits?: Maybe<Scalars['BigInt']['output']>;
  priority: Scalars['Int']['output'];
  rateAmount: Scalars['Float']['output'];
  recurringTransactionRules?: Maybe<Array<RecurringTransactionRule>>;
  status: WalletStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type WalletAppliesTo = {
  __typename?: 'WalletAppliesTo';
  billableMetrics?: Maybe<Array<BillableMetric>>;
  feeTypes?: Maybe<Array<FeeTypesEnum>>;
};

/** WalletCollection type */
export type WalletCollection = {
  __typename?: 'WalletCollection';
  /** A collection of paginated WalletCollection */
  collection: Array<Wallet>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: WalletCollectionMetadata;
};

/** Type for CollectionMetadataType */
export type WalletCollectionMetadata = {
  __typename?: 'WalletCollectionMetadata';
  /** Current Page of loaded data */
  currentPage: Scalars['Int']['output'];
  customerActiveWalletsCount: Scalars['Int']['output'];
  /** The number of items per page */
  limitValue: Scalars['Int']['output'];
  /** The total number of items to be paginated */
  totalCount: Scalars['Int']['output'];
  /** The total number of pages in the pagination */
  totalPages: Scalars['Int']['output'];
};

export enum WalletStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  amount: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmount: Scalars['String']['output'];
  failedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoice?: Maybe<Invoice>;
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  metadata?: Maybe<Array<WalletTransactionMetadataObject>>;
  name?: Maybe<Scalars['String']['output']>;
  priority: Scalars['Int']['output'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  source: WalletTransactionSourceEnum;
  status: WalletTransactionStatusEnum;
  transactionStatus: WalletTransactionTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  wallet?: Maybe<Wallet>;
  walletName?: Maybe<Scalars['String']['output']>;
};

/** WalletTransactionCollection type */
export type WalletTransactionCollection = {
  __typename?: 'WalletTransactionCollection';
  /** A collection of paginated WalletTransactionCollection */
  collection: Array<WalletTransaction>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type WalletTransactionMetadataInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type WalletTransactionMetadataObject = {
  __typename?: 'WalletTransactionMetadataObject';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export enum WalletTransactionSourceEnum {
  Interval = 'interval',
  Manual = 'manual',
  Threshold = 'threshold'
}

export enum WalletTransactionStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Settled = 'settled'
}

export enum WalletTransactionTransactionStatusEnum {
  Granted = 'granted',
  Invoiced = 'invoiced',
  Purchased = 'purchased',
  Voided = 'voided'
}

export enum WalletTransactionTransactionTypeEnum {
  Inbound = 'inbound',
  Outbound = 'outbound'
}

export type Webhook = {
  __typename?: 'Webhook';
  createdAt: Scalars['ISO8601DateTime']['output'];
  endpoint: Scalars['String']['output'];
  httpStatus?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  lastRetriedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  objectType: Scalars['String']['output'];
  payload?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  retries: Scalars['Int']['output'];
  status: WebhookStatusEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  webhookType: Scalars['String']['output'];
};

/** WebhookCollection type */
export type WebhookCollection = {
  __typename?: 'WebhookCollection';
  /** A collection of paginated WebhookCollection */
  collection: Array<Webhook>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type WebhookEndpoint = {
  __typename?: 'WebhookEndpoint';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization?: Maybe<Organization>;
  signatureAlgo?: Maybe<WebhookEndpointSignatureAlgoEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl: Scalars['String']['output'];
};

/** WebhookEndpointCollection type */
export type WebhookEndpointCollection = {
  __typename?: 'WebhookEndpointCollection';
  /** A collection of paginated WebhookEndpointCollection */
  collection: Array<WebhookEndpoint>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateWebhookEndpoint */
export type WebhookEndpointCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookEndpointSignatureAlgoEnum {
  Hmac = 'hmac',
  Jwt = 'jwt'
}

/** Autogenerated input type of UpdateWebhookEndpoint */
export type WebhookEndpointUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum WeightedIntervalEnum {
  Seconds = 'seconds'
}

export type XeroCustomer = {
  __typename?: 'XeroCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type XeroIntegration = {
  __typename?: 'XeroIntegration';
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  syncCreditNotes?: Maybe<Scalars['Boolean']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncPayments?: Maybe<Scalars['Boolean']['output']>;
};

export type UserIdentifierQueryVariables = Exact<{ [key: string]: never; }>;


export type UserIdentifierQuery = { __typename?: 'Query', me: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null, accessibleByCurrentSession: boolean }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> }, organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum>, canCreateBillingEntity: boolean, authenticationMethods: Array<AuthenticationMethodsEnum>, authenticatedMethod: AuthenticationMethodsEnum } | null };

export type ActivityLogsTableDataFragment = { __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null };

export type DeleteAddOnFragment = { __typename?: 'AddOn', id: string, name: string };

export type DeleteAddOnMutationVariables = Exact<{
  input: DestroyAddOnInput;
}>;


export type DeleteAddOnMutation = { __typename?: 'Mutation', destroyAddOn?: { __typename?: 'DestroyAddOnPayload', id?: string | null } | null };

export type GetMrrPlanBreakdownQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetMrrPlanBreakdownQuery = { __typename?: 'Query', dataApiMrrsPlans: { __typename?: 'DataApiMrrsPlans', collection: Array<{ __typename?: 'DataApiMrrPlan', activeCustomersCount: any, activeCustomersShare: number, amountCurrency: CurrencyEnum, mrr: number, mrrShare?: number | null, planCode: string, planDeletedAt?: any | null, planId: string, planInterval: PlanInterval, planName: string }>, metadata: { __typename?: 'DataApiMetadata', currentPage: number, totalPages: number } } };

export type MrrDataForOverviewSectionFragment = { __typename?: 'DataApiMrr', endOfPeriodDt: any, endingMrr: any, mrrChange: any, mrrChurn: any, mrrContraction: any, mrrExpansion: any, mrrNew: any, startOfPeriodDt: any, startingMrr: any };

export type GetMrrsQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetMrrsQuery = { __typename?: 'Query', dataApiMrrs: { __typename?: 'DataApiMrrCollection', collection: Array<{ __typename?: 'DataApiMrr', endOfPeriodDt: any, endingMrr: any, mrrChange: any, mrrChurn: any, mrrContraction: any, mrrExpansion: any, mrrNew: any, startOfPeriodDt: any, startingMrr: any }> } };

export type PrepaidCreditsDataForOverviewSectionFragment = { __typename?: 'DataApiPrepaidCredit', amountCurrency: CurrencyEnum, consumedAmount: number, consumedCreditsQuantity: number, endOfPeriodDt: any, offeredAmount: number, offeredCreditsQuantity: number, purchasedAmount: number, purchasedCreditsQuantity: number, startOfPeriodDt: any, voidedAmount: number, voidedCreditsQuantity: number };

export type GetPrepaidCreditsQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetPrepaidCreditsQuery = { __typename?: 'Query', dataApiPrepaidCredits: { __typename?: 'DataApiPrepaidCreditCollection', collection: Array<{ __typename?: 'DataApiPrepaidCredit', amountCurrency: CurrencyEnum, consumedAmount: number, consumedCreditsQuantity: number, endOfPeriodDt: any, offeredAmount: number, offeredCreditsQuantity: number, purchasedAmount: number, purchasedCreditsQuantity: number, startOfPeriodDt: any, voidedAmount: number, voidedCreditsQuantity: number }> } };

export type GetRevenueStreamsCustomerBreakdownQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetRevenueStreamsCustomerBreakdownQuery = { __typename?: 'Query', dataApiRevenueStreamsCustomers: { __typename?: 'DataApiRevenueStreamsCustomers', collection: Array<{ __typename?: 'DataApiRevenueStreamCustomer', amountCurrency: CurrencyEnum, customerDeletedAt?: any | null, customerName?: string | null, externalCustomerId: string, grossRevenueAmountCents: any, grossRevenueShare?: number | null }>, metadata: { __typename?: 'DataApiMetadata', currentPage: number, totalPages: number } } };

export type RevenueStreamDataForOverviewSectionFragment = { __typename?: 'DataApiRevenueStream', commitmentFeeAmountCents: any, couponsAmountCents: any, endOfPeriodDt: any, grossRevenueAmountCents: any, netRevenueAmountCents: any, oneOffFeeAmountCents: any, startOfPeriodDt: any, subscriptionFeeAmountCents: any, usageBasedFeeAmountCents: any, contraRevenueAmountCents?: any | null, creditNotesCreditsAmountCents?: any | null, freeCreditsAmountCents?: any | null, prepaidCreditsAmountCents?: any | null, progressiveBillingCreditAmountCents?: any | null };

export type GetRevenueStreamsPlanBreakdownQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetRevenueStreamsPlanBreakdownQuery = { __typename?: 'Query', dataApiRevenueStreamsPlans: { __typename?: 'DataApiRevenueStreamsPlans', collection: Array<{ __typename?: 'DataApiRevenueStreamPlan', amountCurrency: CurrencyEnum, customersCount: number, customersShare: number, netRevenueAmountCents: any, netRevenueShare?: number | null, planCode: string, planDeletedAt?: any | null, planId: string, planInterval: PlanInterval, planName: string }>, metadata: { __typename?: 'DataApiMetadata', currentPage: number, totalPages: number } } };

export type GetRevenueStreamsQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetRevenueStreamsQuery = { __typename?: 'Query', dataApiRevenueStreams: { __typename?: 'DataApiRevenueStreamCollection', collection: Array<{ __typename?: 'DataApiRevenueStream', commitmentFeeAmountCents: any, couponsAmountCents: any, endOfPeriodDt: any, grossRevenueAmountCents: any, netRevenueAmountCents: any, oneOffFeeAmountCents: any, startOfPeriodDt: any, subscriptionFeeAmountCents: any, usageBasedFeeAmountCents: any, contraRevenueAmountCents?: any | null, creditNotesCreditsAmountCents?: any | null, freeCreditsAmountCents?: any | null, prepaidCreditsAmountCents?: any | null, progressiveBillingCreditAmountCents?: any | null }> } };

export type GetUsageBillableMetricQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  billableMetricCode?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUsageBillableMetricQuery = { __typename?: 'Query', dataApiUsages: { __typename?: 'DataApiUsageCollection', collection: Array<{ __typename?: 'DataApiUsage', amountCents: any, amountCurrency: CurrencyEnum, endOfPeriodDt: any, startOfPeriodDt: any, units: number }> } };

export type GetUsageBreakdownQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  isBillableMetricRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUsageBreakdownQuery = { __typename?: 'Query', dataApiUsages: { __typename?: 'DataApiUsageCollection', collection: Array<{ __typename?: 'DataApiUsage', startOfPeriodDt: any, endOfPeriodDt: any, amountCurrency: CurrencyEnum, amountCents: any, billableMetricCode: string, units: number, isBillableMetricDeleted: boolean }> } };

export type GetUsageOverviewQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUsageOverviewQuery = { __typename?: 'Query', dataApiUsagesAggregatedAmounts: { __typename?: 'DataApiUsageAggregatedAmountCollection', collection: Array<{ __typename?: 'DataApiUsageAggregatedAmount', amountCents: any, amountCurrency: CurrencyEnum, endOfPeriodDt: any, startOfPeriodDt: any }> } };

export type GetGoogleAuthUrlQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGoogleAuthUrlQuery = { __typename?: 'Query', googleAuthUrl: { __typename?: 'AuthUrl', url: string } };

export type BillableMetricActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type BillableMetricActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type BillableMetricDetailsFragment = { __typename?: 'BillableMetric', name: string, code: string, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, recurring: boolean, expression?: string | null, weightedInterval?: WeightedIntervalEnum | null, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type GetBillableMetricForDetailsOverviewQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBillableMetricForDetailsOverviewQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, recurring: boolean, expression?: string | null, weightedInterval?: WeightedIntervalEnum | null, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null } | null };

export type DeleteBillableMetricDialogFragment = { __typename?: 'BillableMetric', id: string, name: string, hasDraftInvoices: boolean, hasActiveSubscriptions: boolean };

export type GetBillableMetricToDeleteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBillableMetricToDeleteQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, hasDraftInvoices: boolean, hasActiveSubscriptions: boolean } | null };

export type DeleteBillableMetricMutationVariables = Exact<{
  input: DestroyBillableMetricInput;
}>;


export type DeleteBillableMetricMutation = { __typename?: 'Mutation', destroyBillableMetric?: { __typename?: 'DestroyBillableMetricPayload', id?: string | null } | null };

export type BillableMetricsForCouponsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string };

export type GetBillableMetricsForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetBillableMetricsForCouponsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> } };

export type PlansForCouponsFragment = { __typename?: 'Plan', id: string, name: string, code: string };

export type GetPlansForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansForCouponsQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> } };

export type CouponCaptionFragment = { __typename?: 'Coupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type AppliedCouponCaptionFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null };

export type CouponDetailsActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type CouponDetailsActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type CouponDetailsForOverviewFragment = { __typename?: 'Coupon', name: string, code?: string | null, couponType: CouponTypeEnum, amountCurrency?: CurrencyEnum | null, status: CouponStatusEnum, frequency: CouponFrequency, reusable: boolean, expirationAt?: any | null, amountCents?: any | null, percentageRate?: number | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null };

export type GetCouponForDetailsOverviewQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCouponForDetailsOverviewQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, name: string, code?: string | null, couponType: CouponTypeEnum, amountCurrency?: CurrencyEnum | null, status: CouponStatusEnum, frequency: CouponFrequency, reusable: boolean, expirationAt?: any | null, amountCents?: any | null, percentageRate?: number | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null } | null };

export type DeleteCouponFragment = { __typename?: 'Coupon', id: string, name: string, appliedCouponsCount: number };

export type GetCouponToDeleteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCouponToDeleteQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, name: string, appliedCouponsCount: number } | null };

export type DeleteCouponMutationVariables = Exact<{
  input: DestroyCouponInput;
}>;


export type DeleteCouponMutation = { __typename?: 'Mutation', destroyCoupon?: { __typename?: 'DestroyCouponPayload', id?: string | null } | null };

export type TerminateCouponFragment = { __typename?: 'Coupon', id: string, name: string };

export type TerminateCouponMutationVariables = Exact<{
  input: TerminateCouponInput;
}>;


export type TerminateCouponMutation = { __typename?: 'Mutation', terminateCoupon?: { __typename?: 'Coupon', id: string } | null };

export type CreditNoteDetailsActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type CreditNoteDetailsActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type CustomerForCreditNoteDetailsExternalSyncFragment = { __typename?: 'Customer', anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalAccountId?: string | null } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null } | null };

export type GetCreditNoteForDetailsExternalSyncQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCreditNoteForDetailsExternalSyncQuery = { __typename?: 'Query', creditNote?: { __typename?: 'CreditNote', id: string, taxProviderId?: string | null, taxProviderSyncable: boolean, externalIntegrationId?: string | null, customer: { __typename?: 'Customer', anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalAccountId?: string | null } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null } | null } } | null };

export type GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetIntegrationsListForCreditNoteDetailsExternalSyncQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename: 'AnrokIntegration', id: string }
      | { __typename: 'AvalaraIntegration', id: string, accountId?: string | null, companyId?: string | null }
      | { __typename?: 'HubspotIntegration' }
      | { __typename: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename: 'XeroIntegration', id: string }
    > } | null };

export type GetCreditNoteForDetailsOverviewQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCreditNoteForDetailsOverviewQuery = { __typename?: 'Query', creditNote?: { __typename?: 'CreditNote', id: string, createdAt: any, balanceAmountCents: any, currency: CurrencyEnum, creditStatus?: CreditNoteCreditStatusEnum | null, refundStatus?: CreditNoteRefundStatusEnum | null, refundedAt?: any | null, refundAmountCents: any, couponsAdjustmentAmountCents: any, subTotalExcludingTaxesAmountCents: any, creditAmountCents: any, totalAmountCents: any, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, deletedAt?: any | null, applicableTimezone: TimezoneEnum }, invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string } | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, itemName: string, groupedBy: any, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }>, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type CreditNoteDetailsForOverviewTableFragment = { __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, currency: CurrencyEnum, subTotalExcludingTaxesAmountCents: any, creditAmountCents: any, refundAmountCents: any, totalAmountCents: any, invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string } | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, itemName: string, groupedBy: any, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }>, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null };

export type InvoiceForCreditNoteFormCalculationFragment = { __typename?: 'Invoice', id: string, couponsAmountCents: any, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, feesAmountCents: any, currency?: CurrencyEnum | null, versionNumber: number, paymentDisputeLostAt?: any | null, totalPaidAmountCents: any, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null }> | null };

export type CreditNoteEstimateQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput> | CreditNoteItemInput;
}>;


export type CreditNoteEstimateQuery = { __typename?: 'Query', creditNoteEstimate: { __typename?: 'CreditNoteEstimate', couponsAdjustmentAmountCents: any, currency: CurrencyEnum, maxCreditableAmountCents: any, maxRefundableAmountCents: any, subTotalExcludingTaxesAmountCents: any, taxesAmountCents: any, taxesRate: number, appliedTaxes: Array<{ __typename?: 'CreditNoteAppliedTax', taxCode: string, taxName: string, taxRate: number, amountCents: any }>, items: Array<{ __typename?: 'CreditNoteItemEstimate', amountCents: any, fee: { __typename?: 'Fee', id: string } }> } };

export type CreditNoteTableItemFragment = { __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } };

export type CreditNotesForTableFragment = { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }> };

export type DownloadCreditNoteMutationVariables = Exact<{
  input: DownloadCreditNoteInput;
}>;


export type DownloadCreditNoteMutation = { __typename?: 'Mutation', downloadCreditNote?: { __typename?: 'CreditNote', id: string, fileUrl?: string | null } | null };

export type GetPortalCustomerInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalCustomerInfosQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null } | null };

export type PortalInvoiceListItemFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, paymentDisputeLostAt?: any | null, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum };

export type CustomerPortalInvoicesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type CustomerPortalInvoicesQuery = { __typename?: 'Query', customerPortalInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, paymentDisputeLostAt?: any | null, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum }> } };

export type DownloadCustomerPortalInvoiceMutationVariables = Exact<{
  input: DownloadCustomerPortalInvoiceInput;
}>;


export type DownloadCustomerPortalInvoiceMutation = { __typename?: 'Mutation', downloadCustomerPortalInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type GetCustomerPortalInvoicesCollectionQueryVariables = Exact<{
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerPortalInvoicesCollectionQuery = { __typename?: 'Query', customerPortalInvoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', amountCents: any, invoicesCount: any, currency?: CurrencyEnum | null }> } };

export type GetCustomerPortalOverdueBalancesQueryVariables = Exact<{
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerPortalOverdueBalancesQuery = { __typename?: 'Query', customerPortalOverdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, lagoInvoiceIds: Array<string> }> } };

export type GetCustomerPortalUserCurrencyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCustomerPortalUserCurrencyQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', currency?: CurrencyEnum | null } | null };

export type GetPortalLocaleQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalLocaleQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'CustomerPortalOrganization', id: string, premiumIntegrations: Array<PremiumIntegrationTypeEnum>, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, documentLocale?: string | null } | null } | null, customerPortalUser?: { __typename?: 'CustomerPortalCustomer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type UpdatePortalCustomerMutationVariables = Exact<{
  input: UpdateCustomerPortalCustomerInput;
}>;


export type UpdatePortalCustomerMutation = { __typename?: 'Mutation', updateCustomerPortalCustomer?: { __typename?: 'CustomerPortalCustomer', id: string } | null };

export type SubscriptionForPortalUsageFragment = { __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null };

export type GetSubscriptionForPortalQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForPortalQuery = { __typename?: 'Query', customerPortalSubscription?: { __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null } | null };

export type GetCustomerUsageForPortalQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetCustomerUsageForPortalQuery = { __typename?: 'Query', customerPortalCustomerUsage: { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, id: string, pricingUnitAmountCents?: any | null, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null }> }> } };

export type GetCustomerProjectedUsageForPortalQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetCustomerProjectedUsageForPortalQuery = { __typename?: 'Query', customerPortalCustomerProjectedUsage: { __typename?: 'CustomerProjectedUsage', amountCents: any, projectedAmountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ProjectedChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, projectedUnits: number, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null, groupedUsage: Array<{ __typename?: 'ProjectedGroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, projectedUnits: number, projectedAmountCents: any, id: string, pricingUnitAmountCents?: any | null, pricingUnitProjectedAmountCents?: any | null, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null }> }> } };

export type GetPortalUsageQueryVariables = Exact<{
  status?: InputMaybe<Array<StatusTypeEnum> | StatusTypeEnum>;
}>;


export type GetPortalUsageQuery = { __typename?: 'Query', customerPortalSubscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null }> } };

export type CustomerPortalWalletQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type CustomerPortalWalletQuery = { __typename?: 'Query', customerPortalWallet?: { __typename?: 'CustomerPortalWallet', id: string, currency: CurrencyEnum, name?: string | null, rateAmount: number, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null } | null };

export type TopUpPortalWalletMutationVariables = Exact<{
  input: CreateCustomerPortalWalletTransactionInput;
}>;


export type TopUpPortalWalletMutation = { __typename?: 'Mutation', createCustomerPortalWalletTransaction?: { __typename?: 'CustomerPortalWalletTransactionCollection', collection: Array<{ __typename?: 'CustomerPortalWalletTransaction', id: string }> } | null };

export type CustomerPortalWalletInfoFragment = { __typename?: 'CustomerPortalWallet', id: string, name?: string | null, currency: CurrencyEnum, balanceCents: any, creditsBalance: number, expirationAt?: any | null, consumedCredits: number, consumedAmountCents: any, status: WalletStatusEnum, creditsOngoingBalance: number, ongoingBalanceCents: any, rateAmount: number, lastBalanceSyncAt?: any | null, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null };

export type GetPortalCustomerDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalCustomerDataQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', applicableTimezone: TimezoneEnum, premium: boolean } | null };

export type GetPortalWalletsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletStatusEnum>;
}>;


export type GetPortalWalletsQuery = { __typename?: 'Query', customerPortalWallets: { __typename?: 'CustomerPortalWalletCollection', collection: Array<{ __typename?: 'CustomerPortalWallet', id: string, name?: string | null, currency: CurrencyEnum, balanceCents: any, creditsBalance: number, expirationAt?: any | null, consumedCredits: number, consumedAmountCents: any, status: WalletStatusEnum, creditsOngoingBalance: number, ongoingBalanceCents: any, rateAmount: number, lastBalanceSyncAt?: any | null, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type CouponPlansForCustomerFragment = { __typename?: 'Plan', id: string, name: string };

export type CouponBillableMetricsForCustomerFragment = { __typename?: 'BillableMetric', id: string, name: string };

export type GetCouponForCustomerQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCouponForCustomerQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null }> } };

export type AddCouponMutationVariables = Exact<{
  input: CreateAppliedCouponInput;
}>;


export type AddCouponMutation = { __typename?: 'Mutation', createAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string, code?: string | null } } | null };

export type CustomerActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
}>;


export type CustomerActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetCustomerCreditNotesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerCreditNotesQuery = { __typename?: 'Query', creditNotes: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }> } };

export type InvoiceListItemFragment = { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } };

export type InvoiceForInvoiceListFragment = { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } };

export type DownloadInvoiceItemMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceItemMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RetryInvoicePaymentMutationVariables = Exact<{
  input: RetryInvoicePaymentInput;
}>;


export type RetryInvoicePaymentMutation = { __typename?: 'Mutation', retryInvoicePayment?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } } | null };

export type GeneratePaymentUrlMutationVariables = Exact<{
  input: GeneratePaymentUrlInput;
}>;


export type GeneratePaymentUrlMutation = { __typename?: 'Mutation', generatePaymentUrl?: { __typename?: 'GeneratePaymentUrlPayload', paymentUrl?: string | null } | null };

export type GetCustomerInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type CustomerMainInfosFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, email?: string | null, currency?: CurrencyEnum | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, url?: string | null, zipcode?: string | null, paymentProvider?: ProviderTypeEnum | null, timezone?: TimezoneEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename?: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } };

export type PaymentProvidersListForCustomerMainInfosQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PaymentProvidersListForCustomerMainInfosQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider', id: string, name: string, code: string }
      | { __typename?: 'CashfreeProvider', id: string, name: string, code: string }
      | { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string }
      | { __typename?: 'GocardlessProvider', id: string, name: string, code: string }
      | { __typename?: 'MoneyhashProvider', id: string, name: string, code: string }
      | { __typename?: 'StripeProvider', id: string, name: string, code: string }
    > } | null };

export type IntegrationsListForCustomerMainInfosQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerMainInfosQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename: 'AnrokIntegration', id: string, name: string, apiKey: any, externalAccountId?: string | null }
      | { __typename: 'AvalaraIntegration', id: string, name: string, accountId?: string | null }
      | { __typename: 'HubspotIntegration', id: string, name: string, portalId?: string | null }
      | { __typename: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null }
      | { __typename?: 'OktaIntegration' }
      | { __typename: 'SalesforceIntegration', id: string, name: string, instanceId: string }
      | { __typename: 'XeroIntegration', id: string, name: string }
    > } | null };

export type CustomerAppliedTaxRatesForSettingsFragment = { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null };

export type CustomerAppliedDunningCampaignForSettingsFragment = { __typename?: 'Customer', currency?: CurrencyEnum | null, excludeFromDunningCampaign: boolean, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, appliedToOrganization: boolean, code: string, name: string, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', currency: CurrencyEnum }> } | null };

export type CustomerAppliedInvoiceCustomSectionsFragment = { __typename?: 'Customer', skipInvoiceCustomSections?: boolean | null, configurableInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null };

export type GetCustomerSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSettingsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null, netPaymentTerm?: number | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null, currency?: CurrencyEnum | null, excludeFromDunningCampaign: boolean, skipInvoiceCustomSections?: boolean | null, externalId: string, hasOverwrittenInvoiceCustomSectionsSelection?: boolean | null, name?: string | null, displayName: string, billingEntity: { __typename?: 'BillingEntity', id: string, netPaymentTerm: number, finalizeZeroAmountInvoice: boolean, billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, invoiceGracePeriod: number, documentLocale?: string | null } | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string, appliedToOrganization: boolean, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', currency: CurrencyEnum }> } | null }, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, appliedToOrganization: boolean, code: string, name: string, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', currency: CurrencyEnum }> } | null, configurableInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null } | null };

export type DeleteCustomerDialogFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string };

export type DeleteCustomerMutationVariables = Exact<{
  input: DestroyCustomerInput;
}>;


export type DeleteCustomerMutation = { __typename?: 'Mutation', destroyCustomer?: { __typename?: 'DestroyCustomerPayload', id?: string | null } | null };

export type DeleteCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string };

export type DeleteCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type DeleteCustomerFinalizeZeroAmountInvoiceFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null };

export type DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null } | null };

export type DeleteCustomerGracePeriodFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string };

export type DeleteCustomerGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type DeleteCustomerGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type DeleteCustomerNetPaymentTermFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, netPaymentTerm?: number | null };

export type DeleteCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, netPaymentTerm?: number | null } | null };

export type CustomerForDeleteVatRateDialogFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type TaxRateForDeleteCustomerVatRateDialogFragment = { __typename?: 'Tax', id: string, name: string };

export type RemoveAppliedTaxRateOnCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type RemoveAppliedTaxRateOnCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string } | null };

export type EditCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null };

export type UpdateCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type EditCustomerDunningCampaignFragment = { __typename?: 'Customer', id: string, externalId: string, currency?: CurrencyEnum | null, excludeFromDunningCampaign: boolean, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string } | null };

export type GetApplicableDunningCampaignsQueryVariables = Exact<{
  currency?: InputMaybe<Array<CurrencyEnum> | CurrencyEnum>;
}>;


export type GetApplicableDunningCampaignsQuery = { __typename?: 'Query', dunningCampaigns: { __typename?: 'DunningCampaignCollection', collection: Array<{ __typename?: 'DunningCampaign', id: string, name: string, code: string }> } };

export type EditCustomerDunningCampaignMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type EditCustomerDunningCampaignMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, excludeFromDunningCampaign: boolean, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string } | null } | null };

export type EditCustomerInvoiceCustomSectionFragment = { __typename?: 'Customer', id: string, externalId: string, hasOverwrittenInvoiceCustomSectionsSelection?: boolean | null, skipInvoiceCustomSections?: boolean | null, configurableInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string }> | null };

export type GetInvoiceCustomSectionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetInvoiceCustomSectionsQuery = { __typename?: 'Query', invoiceCustomSections?: { __typename?: 'InvoiceCustomSectionCollection', collection: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string, code: string }> } | null };

export type EditCustomerInvoiceCustomSectionMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type EditCustomerInvoiceCustomSectionMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, skipInvoiceCustomSections?: boolean | null, configurableInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null } | null };

export type EditCustomerInvoiceGracePeriodFragment = { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null };

export type UpdateCustomerInvoiceGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type UpdateCustomerInvoiceGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type EditCustomerVatRateFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type GetTaxRatesForEditCustomerQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxRatesForEditCustomerQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type CreateCustomerAppliedTaxMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type CreateCustomerAppliedTaxMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null } | null };

export type GetAccountingIntegrationsForExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetAccountingIntegrationsForExternalAppsAccordionQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename: 'NetsuiteIntegration', id: string, code: string, name: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename: 'XeroIntegration', id: string, code: string, name: string }
    > } | null };

export type SubsidiariesListForExternalAppsAccordionQueryVariables = Exact<{
  integrationId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SubsidiariesListForExternalAppsAccordionQuery = { __typename?: 'Query', integrationSubsidiaries?: { __typename?: 'SubsidiaryCollection', collection: Array<{ __typename?: 'Subsidiary', externalId: string, externalName?: string | null }> } | null };

export type GetCrmIntegrationsForExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetCrmIntegrationsForExternalAppsAccordionQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename: 'HubspotIntegration', id: string, code: string, name: string, defaultTargetedObject: HubspotTargetedObjectsEnum }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename: 'SalesforceIntegration', id: string, code: string, name: string }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename: 'AdyenProvider', id: string, name: string, code: string }
      | { __typename: 'CashfreeProvider', id: string, name: string, code: string }
      | { __typename: 'FlutterwaveProvider', id: string, name: string, code: string }
      | { __typename: 'GocardlessProvider', id: string, name: string, code: string }
      | { __typename: 'MoneyhashProvider', id: string, name: string, code: string }
      | { __typename: 'StripeProvider', id: string, name: string, code: string }
    > } | null };

export type GetTaxIntegrationsForExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxIntegrationsForExternalAppsAccordionQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename: 'AnrokIntegration', id: string, code: string, name: string }
      | { __typename: 'AvalaraIntegration', id: string, code: string, name: string }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type CreditNoteForVoidCreditNoteDialogFragment = { __typename?: 'CreditNote', id: string, totalAmountCents: any, currency: CurrencyEnum };

export type VoidCreditNoteMutationVariables = Exact<{
  input: VoidCreditNoteInput;
}>;


export type VoidCreditNoteMutation = { __typename?: 'Mutation', voidCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type CustomerCouponFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string, code?: string | null } };

export type CustomerAppliedCouponsFragment = { __typename?: 'Customer', id: string, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string, code?: string | null } }> | null };

export type GetCustomerCouponsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerCouponsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string, code?: string | null } }> | null } | null };

export type RemoveCouponMutationVariables = Exact<{
  input: TerminateAppliedCouponInput;
}>;


export type RemoveCouponMutation = { __typename?: 'Mutation', terminateAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string } | null };

export type GetCustomerOverdueBalancesQueryVariables = Exact<{
  externalCustomerId: Scalars['String']['input'];
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerOverdueBalancesQuery = { __typename?: 'Query', paymentRequests: { __typename?: 'PaymentRequestCollection', collection: Array<{ __typename?: 'PaymentRequest', createdAt: any }> }, overdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, lagoInvoiceIds: Array<string> }> } };

export type GetCustomerGrossRevenuesQueryVariables = Exact<{
  externalCustomerId: Scalars['String']['input'];
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerGrossRevenuesQuery = { __typename?: 'Query', grossRevenues: { __typename?: 'GrossRevenueCollection', collection: Array<{ __typename?: 'GrossRevenue', amountCents?: any | null, currency?: CurrencyEnum | null, invoicesCount: any, month: any }> } };

export type GetCustomerSubscriptionForListQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, subscriptions: Array<{ __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextSubscriptionAt?: any | null, nextSubscriptionType?: NextSubscriptionTypeEnum | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, terminatedAt?: any | null, plan: { __typename?: 'Plan', id: string, isOverridden: boolean, amountCurrency: CurrencyEnum, name: string, interval: PlanInterval, payInAdvance: boolean, parent?: { __typename?: 'Plan', id: string } | null }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval } | null, nextSubscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, status?: StatusTypeEnum | null } | null }> } | null };

export type TerminateCustomerSubscriptionMutationVariables = Exact<{
  input: TerminateSubscriptionInput;
}>;


export type TerminateCustomerSubscriptionMutation = { __typename?: 'Mutation', terminateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number } } | null };

export type GetInvoicesForTerminationQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum> | InvoiceTypeEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvoicesForTerminationQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, number: string, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum, refundableAmountCents: any }> } };

export type GetCustomerSubscriptionForUsageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForUsageQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, externalId: string, currency?: CurrencyEnum | null } | null };

export type CustomerUsageForUsageDetailsFragment = { __typename?: 'CustomerUsage', fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, pricingUnitAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', id: string, amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, pricingUnitAmountCents?: any | null, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null }> }> };

export type CustomerProjectedUsageForUsageDetailsFragment = { __typename?: 'CustomerProjectedUsage', fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ProjectedChargeUsage', id: string, pricingUnitAmountCents?: any | null, pricingUnitProjectedAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', name: string }, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null, groupedUsage: Array<{ __typename?: 'ProjectedGroupedChargeUsage', id: string, amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null }> }> };

export type GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetApiKeyIdsForFilterItemApiKeyIdsQuery = { __typename?: 'Query', apiKeys: { __typename?: 'SanitizedApiKeyCollection', collection: Array<{ __typename?: 'SanitizedApiKey', id: string, value: string }> } };

export type GetCustomersForFilterItemCustomerQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomersForFilterItemCustomerQuery = { __typename?: 'Query', customers: { __typename?: 'CustomerCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Customer', id: string, displayName: string, externalId: string, deletedAt?: any | null }> } };

export type GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetInvoiceNumbersForFilterItemInvoiceNumbersQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Invoice', id: string, number: string }> } };

export type GetPlansForFiltersItemPlanCodeQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansForFiltersItemPlanCodeQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Plan', id: string, code: string, deletedAt?: any | null }> } };

export type ActivityLogDetailsFragment = { __typename?: 'ActivityLog', activityType: ActivityTypeEnum, activitySource: ActivitySourceEnum, activityObject?: any | null, activityObjectChanges?: any | null, loggedAt: any, userEmail?: string | null, externalSubscriptionId?: string | null, externalCustomerId?: string | null, apiKey?: { __typename?: 'SanitizedApiKey', value: string, name?: string | null } | null, resource?:
    | { __typename?: 'BillableMetric', id: string }
    | { __typename?: 'BillingEntity', id: string, code: string }
    | { __typename?: 'Coupon', id: string }
    | { __typename?: 'CreditNote', id: string, customer: { __typename?: 'Customer', id: string }, invoice?: { __typename?: 'Invoice', id: string } | null }
    | { __typename?: 'Customer', id: string }
    | { __typename?: 'FeatureObject', id: string }
    | { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string } }
    | { __typename?: 'PaymentRequest', id: string }
    | { __typename?: 'Plan', id: string }
    | { __typename?: 'Subscription', id: string }
    | { __typename?: 'Wallet', id: string, walletCustomer?: { __typename?: 'Customer', id: string } | null }
   | null };

export type GetSingleActivityLogQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleActivityLogQuery = { __typename?: 'Query', activityLog?: { __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activitySource: ActivitySourceEnum, activityObject?: any | null, activityObjectChanges?: any | null, loggedAt: any, userEmail?: string | null, externalSubscriptionId?: string | null, externalCustomerId?: string | null, apiKey?: { __typename?: 'SanitizedApiKey', value: string, name?: string | null } | null, resource?:
      | { __typename?: 'BillableMetric', id: string }
      | { __typename?: 'BillingEntity', id: string, code: string }
      | { __typename?: 'Coupon', id: string }
      | { __typename?: 'CreditNote', id: string, customer: { __typename?: 'Customer', id: string }, invoice?: { __typename?: 'Invoice', id: string } | null }
      | { __typename?: 'Customer', id: string }
      | { __typename?: 'FeatureObject', id: string }
      | { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string } }
      | { __typename?: 'PaymentRequest', id: string }
      | { __typename?: 'Plan', id: string }
      | { __typename?: 'Subscription', id: string }
      | { __typename?: 'Wallet', id: string, walletCustomer?: { __typename?: 'Customer', id: string } | null }
     | null } | null };

export type GetCustomerIdForActivityLogDetailsQueryVariables = Exact<{
  externalId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetCustomerIdForActivityLogDetailsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string } | null };

export type GetSubscriptionIdForActivityLogDetailsQueryVariables = Exact<{
  externalId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetSubscriptionIdForActivityLogDetailsQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string } | null };

export type ActivityItemFragment = { __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, externalCustomerId?: string | null, externalSubscriptionId?: string | null, loggedAt: any };

export type ActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  activityIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  activitySources?: InputMaybe<Array<ActivitySourceEnum> | ActivitySourceEnum>;
  activityTypes?: InputMaybe<Array<ActivityTypeEnum> | ActivityTypeEnum>;
  apiKeyIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  toDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  userEmails?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type ActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, externalCustomerId?: string | null, externalSubscriptionId?: string | null, loggedAt: any }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type ApiKeyRevealedForApiKeysListFragment = { __typename?: 'ApiKey', id: string, value: string };

export type GetOrganizationInfosForApiKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfosForApiKeyQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, name: string, createdAt: any } | null };

export type GetApiKeysQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetApiKeysQuery = { __typename?: 'Query', apiKeys: { __typename?: 'SanitizedApiKeyCollection', collection: Array<{ __typename?: 'SanitizedApiKey', id: string, createdAt: any, expiresAt?: any | null, lastUsedAt?: any | null, name?: string | null, value: string }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number } } };

export type GetApiKeyValueQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetApiKeyValueQuery = { __typename?: 'Query', apiKey: { __typename?: 'ApiKey', id: string, value: string } };

export type ApiKeyForDeleteApiKeyDialogFragment = { __typename?: 'SanitizedApiKey', id: string, lastUsedAt?: any | null };

export type DestroyApiKeyMutationVariables = Exact<{
  input: DestroyApiKeyInput;
}>;


export type DestroyApiKeyMutation = { __typename?: 'Mutation', destroyApiKey?: { __typename?: 'ApiKey', id: string } | null };

export type ApiKeyForRotateApiKeyDialogFragment = { __typename?: 'SanitizedApiKey', id: string, lastUsedAt?: any | null, name?: string | null };

export type RotateApiKeyMutationVariables = Exact<{
  input: RotateApiKeyInput;
}>;


export type RotateApiKeyMutation = { __typename?: 'Mutation', rotateApiKey?: { __typename?: 'ApiKey', id: string, value: string } | null };

export type ApiLogDetailsFragment = { __typename?: 'ApiLog', apiVersion?: string | null, client?: string | null, httpMethod: HttpMethodEnum, httpStatus: number, loggedAt: any, requestBody?: any | null, requestId: string, requestOrigin?: string | null, requestPath?: string | null, requestResponse: any, apiKey?: { __typename?: 'SanitizedApiKey', name?: string | null, value: string } | null };

export type GetApiLogDetailsQueryVariables = Exact<{
  requestId: Scalars['ID']['input'];
}>;


export type GetApiLogDetailsQuery = { __typename?: 'Query', apiLog?: { __typename?: 'ApiLog', apiVersion?: string | null, client?: string | null, httpMethod: HttpMethodEnum, httpStatus: number, loggedAt: any, requestBody?: any | null, requestId: string, requestOrigin?: string | null, requestPath?: string | null, requestResponse: any, apiKey?: { __typename?: 'SanitizedApiKey', name?: string | null, value: string } | null } | null };

export type ApiLogItemFragment = { __typename?: 'ApiLog', requestId: string, httpMethod: HttpMethodEnum, httpStatus: number, requestPath?: string | null, loggedAt: any };

export type GetApiLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  requestIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  toDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  apiKeyIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  httpMethods?: InputMaybe<Array<HttpMethodEnum> | HttpMethodEnum>;
  httpStatuses?: InputMaybe<Array<Scalars['HttpStatus']['input']> | Scalars['HttpStatus']['input']>;
  requestPaths?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type GetApiLogsQuery = { __typename?: 'Query', apiLogs?: { __typename?: 'ApiLogCollection', collection: Array<{ __typename?: 'ApiLog', requestId: string, httpMethod: HttpMethodEnum, httpStatus: number, requestPath?: string | null, loggedAt: any }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type EventDetailsFragment = { __typename?: 'Event', id: string, code: string, transactionId?: string | null, timestamp?: any | null, receivedAt?: any | null, payload: any, billableMetricName?: string | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum };

export type GetSingleEventQueryVariables = Exact<{
  transactionId: Scalars['ID']['input'];
}>;


export type GetSingleEventQuery = { __typename?: 'Query', event?: { __typename?: 'Event', id: string, code: string, transactionId?: string | null, timestamp?: any | null, receivedAt?: any | null, payload: any, billableMetricName?: string | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum } | null };

export type EventItemFragment = { __typename?: 'Event', id: string, transactionId?: string | null, code: string, receivedAt?: any | null };

export type EventsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type EventsQuery = { __typename?: 'Query', events?: { __typename?: 'EventCollection', collection: Array<{ __typename?: 'Event', id: string, transactionId?: string | null, code: string, receivedAt?: any | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type WebhookForCreateAndEditFragment = { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null };

export type CreateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointCreateInput;
}>;


export type CreateWebhookEndpointMutation = { __typename?: 'Mutation', createWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type UpdateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointUpdateInput;
}>;


export type UpdateWebhookEndpointMutation = { __typename?: 'Mutation', updateWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type DeleteWebhookMutationVariables = Exact<{
  input: DestroyWebhookEndpointInput;
}>;


export type DeleteWebhookMutation = { __typename?: 'Mutation', destroyWebhookEndpoint?: { __typename?: 'DestroyWebhookEndpointPayload', id?: string | null } | null };

export type WebhookLogDetailsFragment = { __typename?: 'Webhook', id: string, webhookType: string, status: WebhookStatusEnum, payload?: string | null, response?: string | null, httpStatus?: number | null, endpoint: string, retries: number, updatedAt: any };

export type RetryWebhookMutationVariables = Exact<{
  input: RetryWebhookInput;
}>;


export type RetryWebhookMutation = { __typename?: 'Mutation', retryWebhook?: { __typename?: 'Webhook', id: string } | null };

export type GetSingleWebhookLogQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleWebhookLogQuery = { __typename?: 'Query', webhook?: { __typename?: 'Webhook', id: string, webhookType: string, status: WebhookStatusEnum, payload?: string | null, response?: string | null, httpStatus?: number | null, endpoint: string, retries: number, updatedAt: any } | null };

export type GetWebhookInformationsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWebhookInformationsQuery = { __typename?: 'Query', webhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string } | null };

export type WebhookLogFragment = { __typename?: 'Webhook', id: string, status: WebhookStatusEnum, webhookType: string, createdAt: any, updatedAt: any, endpoint: string };

export type GetWebhookLogQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  webhookEndpointId: Scalars['String']['input'];
  status?: InputMaybe<WebhookStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetWebhookLogQuery = { __typename?: 'Query', webhooks: { __typename?: 'WebhookCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Webhook', id: string, status: WebhookStatusEnum, webhookType: string, createdAt: any, updatedAt: any, endpoint: string }> } };

export type GetOrganizationHmacDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationHmacDataQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, hmacKey?: string | null } | null };

export type GetWebhookListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWebhookListQuery = { __typename?: 'Query', webhookEndpoints: { __typename?: 'WebhookEndpointCollection', collection: Array<{ __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null }> } };

export type CustomerForDunningEmailFragment = { __typename?: 'Customer', displayName: string, paymentProvider?: ProviderTypeEnum | null, netPaymentTerm?: number | null, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', documentLocale?: string | null } | null };

export type OrganizationForDunningEmailFragment = { __typename?: 'CurrentOrganization', name: string, logoUrl?: string | null, email?: string | null, netPaymentTerm: number, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', documentLocale?: string | null } | null };

export type InvoicesForDunningEmailFragment = { __typename?: 'Invoice', id: string, number: string, totalDueAmountCents: any, currency?: CurrencyEnum | null };

export type FeatureForDeleteFeatureDialogFragment = { __typename?: 'FeatureObject', id: string };

export type DestroyFeatureMutationVariables = Exact<{
  input: DestroyFeatureInput;
}>;


export type DestroyFeatureMutation = { __typename?: 'Mutation', destroyFeature?: { __typename?: 'FeatureObject', id: string } | null };

export type FeatureDetailsActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type FeatureDetailsActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type FeatureDetailsFragment = { __typename?: 'FeatureObject', id: string, name?: string | null, code: string, description?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, name?: string | null, code: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> };

export type GetFeatureForDetailsOverviewQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetFeatureForDetailsOverviewQuery = { __typename?: 'Query', feature: { __typename?: 'FeatureObject', id: string, name?: string | null, code: string, description?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, name?: string | null, code: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> } };

export type FeaturePrivilegeAccordionFragment = { __typename?: 'PrivilegeObject', id: string, code: string, name?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } };

export type OrganizationForDatePickerFragment = { __typename?: 'CurrentOrganization', id: string, timezone?: TimezoneEnum | null };

export type GetGrossRevenuesQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetGrossRevenuesQuery = { __typename?: 'Query', grossRevenues: { __typename?: 'GrossRevenueCollection', collection: Array<{ __typename?: 'GrossRevenue', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetInvoiceCollectionsQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoiceCollectionsQuery = { __typename?: 'Query', invoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', paymentStatus?: InvoicePaymentStatusTypeEnum | null, invoicesCount: any, amountCents: any, currency?: CurrencyEnum | null, month: any }> } };

export type GetMrrQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetMrrQuery = { __typename?: 'Query', mrrs: { __typename?: 'MrrCollection', collection: Array<{ __typename?: 'Mrr', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetOverdueQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months: Scalars['Int']['input'];
}>;


export type GetOverdueQuery = { __typename?: 'Query', overdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, month: any, lagoInvoiceIds: Array<string> }> } };

export type GetInvoicedUsagesQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoicedUsagesQuery = { __typename?: 'Query', invoicedUsages: { __typename?: 'InvoicedUsageCollection', collection: Array<{ __typename?: 'InvoicedUsage', amountCents: any, month: any, currency: CurrencyEnum, code?: string | null }> } };

export type InvoiceMetadatasForMetadataDrawerFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type UpdateInvoiceMetadataMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoiceMetadataMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null } | null };

export type GetInvoiceMetadataForEditionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceMetadataForEditionQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null } | null };

export type DisputeInvoiceMutationVariables = Exact<{
  input: LoseInvoiceDisputeInput;
}>;


export type DisputeInvoiceMutation = { __typename?: 'Mutation', loseInvoiceDispute?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, associatedActiveWalletPresent: boolean, voidedAt?: any | null, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, issuingDate: any, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, totalPaidAmountCents: any, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type TaxForInvoiceEditTaxDialogFragment = { __typename?: 'Tax', id: string, name: string, rate: number, code: string };

export type AddOnForInvoiceEditTaxDialogFragment = { __typename?: 'AddOn', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> | null };

export type GetTaxesForInvoiceEditTaxDialogQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForInvoiceEditTaxDialogQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type InvoiceForUpdateInvoicePaymentStatusFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum };

export type UpdateInvoicePaymentStatusMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoicePaymentStatusMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, integrationSyncable: boolean, externalIntegrationId?: string | null, integrationHubspotSyncable: boolean, voidedAt?: any | null, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type InvoiceForFinalizeInvoiceFragment = { __typename?: 'Invoice', id: string, issuingDate: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } };

export type FinalizeInvoiceMutationVariables = Exact<{
  input: FinalizeInvoiceInput;
}>;


export type FinalizeInvoiceMutation = { __typename?: 'Mutation', finalizeInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, associatedActiveWalletPresent: boolean, voidedAt?: any | null, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, issuingDate: any, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, totalPaidAmountCents: any, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type InvoiceActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type InvoiceActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetInvoiceCreditNotesQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvoiceCreditNotesQuery = { __typename?: 'Query', invoiceCreditNotes?: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }> } | null, invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, associatedActiveWalletPresent: boolean, paymentStatus: InvoicePaymentStatusTypeEnum, refundableAmountCents: any, creditableAmountCents: any, totalPaidAmountCents: any, totalDueAmountCents: any, status: InvoiceStatusTypeEnum, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, displayName: string } } | null };

export type InvoiceForCreditNotesTableFragment = { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null };

export type InvoiceForInvoiceInfosFragment = { __typename?: 'Invoice', number: string, issuingDate: any, paymentDueDate: any, paymentOverdue: boolean, status: InvoiceStatusTypeEnum, totalPaidAmountCents: any, totalAmountCents: any, paymentStatus: InvoicePaymentStatusTypeEnum, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum } };

export type CustomerMetadatasForInvoiceOverviewFragment = { __typename?: 'Customer', id: string, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null };

export type InvoiceMetadatasForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type GetInvoiceMetadatasQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceMetadatasQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null } | null };

export type PaymentForPaymentsListFragment = { __typename?: 'Payment', amountCents: any, amountCurrency: CurrencyEnum, createdAt: any, id: string, payablePaymentStatus?: PayablePaymentStatusEnum | null, paymentProviderType?: ProviderTypeEnum | null, paymentType: PaymentTypeEnum, providerPaymentId?: string | null, reference?: string | null, payable:
    | { __typename?: 'Invoice', id: string, number: string, payableType: string }
    | { __typename?: 'PaymentRequest', payableType: string, invoices: Array<{ __typename?: 'Invoice', id: string }> }
  , customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, paymentReceipt?: { __typename?: 'PaymentReceipt', id: string } | null };

export type InvoiceForVoidInvoiceDialogFragment = { __typename?: 'Invoice', id: string, number: string };

export type VoidInvoiceMutationVariables = Exact<{
  input: VoidInvoiceInput;
}>;


export type VoidInvoiceMutation = { __typename?: 'Mutation', voidInvoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, integrationSyncable: boolean, externalIntegrationId?: string | null, integrationHubspotSyncable: boolean, voidedAt?: any | null, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type FeeForDeleteAdjustmentFeeDialogFragment = { __typename?: 'Fee', id: string };

export type DestroyAdjustedFeeMutationVariables = Exact<{
  input: DestroyAdjustedFeeInput;
}>;


export type DestroyAdjustedFeeMutation = { __typename?: 'Mutation', destroyAdjustedFee?: { __typename?: 'DestroyAdjustedFeePayload', id?: string | null } | null };

export type InvoiceSubscriptionForCreateFeeDrawerFragment = { __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, charges?: Array<{ __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, properties?: { __typename?: 'Properties', amount?: string | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, code: string } }> | null } }, fees?: Array<{ __typename?: 'Fee', id: string, charge?: { __typename?: 'Charge', id: string, filters?: Array<{ __typename?: 'ChargeFilter', id: string, values: any }> | null, properties?: { __typename?: 'Properties', graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null } | null } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null }> | null };

export type FeeForEditfeeDrawerFragment = { __typename?: 'Fee', id: string, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, prorated: boolean } | null };

export type GetInvoiceDetailsForCreateFeeDrawerQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
}>;


export type GetInvoiceDetailsForCreateFeeDrawerQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, charges?: Array<{ __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, properties?: { __typename?: 'Properties', amount?: string | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, code: string } }> | null } }, fees?: Array<{ __typename?: 'Fee', id: string, charge?: { __typename?: 'Charge', id: string, filters?: Array<{ __typename?: 'ChargeFilter', id: string, values: any }> | null, properties?: { __typename?: 'Properties', graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null } | null } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null }> | null }> | null } | null };

export type CreateAdjustedFeeMutationVariables = Exact<{
  input: CreateAdjustedFeeInput;
}>;


export type CreateAdjustedFeeMutation = { __typename?: 'Mutation', createAdjustedFee?: { __typename?: 'Fee', id: string } | null };

export type FeeForInvoiceDetailsTableFragment = { __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, walletTransaction?: { __typename?: 'WalletTransaction', id: string, name?: string | null, wallet?: { __typename?: 'Wallet', id: string, name?: string | null } | null } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string, taxRate: number }> | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type InvoiceSubscriptionForInvoiceDetailsTableFragment = { __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, acceptNewChargeFees: boolean, subscriptionAmountCents: any, invoice: { __typename?: 'Invoice', chargeAmountCents: any, progressiveBillingCreditAmountCents: any, id: string, status: InvoiceStatusTypeEnum }, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null, billChargesMonthly?: boolean | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, walletTransaction?: { __typename?: 'WalletTransaction', id: string, name?: string | null, wallet?: { __typename?: 'Wallet', id: string, name?: string | null } | null } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string, taxRate: number }> | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null };

export type InvoiceForDetailsTableFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any, allChargesHaveFees: boolean, versionNumber: number, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type FeeForInvoiceDetailsTableBodyLineFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null };

export type FeeForInvoiceDetailsTableBodyLinePackageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, shortName: string } | null };

export type FeeForInvoiceDetailsTableBodyLinePercentageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', fixedFeeTotalAmount?: string | null, fixedFeeUnitAmount?: string | null, freeEvents?: number | null, freeUnits?: string | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, paidUnits?: string | null, perUnitTotalAmount?: string | null, rate?: string | null, units?: string | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null };

export type FeeForInvoiceDetailsTableBodyLineVolumeFragment = { __typename?: 'Fee', id: string, units: number, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', shortName: string } | null };

export type InvoiceForDetailsTableFooterFragment = { __typename?: 'Invoice', couponsAmountCents: any, creditNotesAmountCents: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, versionNumber: number, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type FeeForInvoiceFeeAdvanceDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceFeeArrearsDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type PercentageChargeFragment = { __typename?: 'Properties', fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null };

export type GetTaxesForCommitmentsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForCommitmentsQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type CustomChargeFragment = { __typename?: 'Properties', customProperties?: any | null };

export type DeletePlanDialogFragment = { __typename?: 'Plan', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type DeletePlanMutationVariables = Exact<{
  input: DestroyPlanInput;
}>;


export type DeletePlanMutation = { __typename?: 'Mutation', destroyPlan?: { __typename?: 'DestroyPlanPayload', id?: string | null } | null };

export type FeatureEntitlementForPlanFragment = { __typename?: 'Plan', entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null };

export type GetFeaturesListForPlanSectionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetFeaturesListForPlanSectionQuery = { __typename?: 'Query', features: { __typename?: 'FeatureObjectCollection', collection: Array<{ __typename?: 'FeatureObject', id: string, name?: string | null, code: string, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, name?: string | null, code: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> } };

export type FeatureEntitlementPrivilegeForPlanFragment = { __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } };

export type FeatureObjectEntitlementPrivilegeForPlanFragment = { __typename?: 'FeatureObject', id: string, code: string, name?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, name?: string | null, code: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> };

export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery = { __typename?: 'Query', feature: { __typename?: 'FeatureObject', id: string, code: string, name?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, name?: string | null, code: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> } };

export type GraduatedChargeFragment = { __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null };

export type GraduatedPercentageChargeFragment = { __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null };

export type PackageChargeFragment = { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null };

export type TaxForPlanSettingsSectionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type PlanForSettingsSectionFragment = { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum, code: string, description?: string | null, interval: PlanInterval, name: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetTaxesForPlanQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxesForPlanQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type PricingGroupKeysFragment = { __typename?: 'Properties', pricingGroupKeys?: Array<string> | null };

export type StandardChargeFragment = { __typename?: 'Properties', amount?: string | null, pricingGroupKeys?: Array<string> | null };

export type PlanForSubscriptionFeeSectionFragment = { __typename?: 'Plan', id: string, amountCents: any, payInAdvance: boolean, trialPeriod?: number | null, invoiceDisplayName?: string | null };

export type UsageChargeAccordionFragment = { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null }, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type PlanForUsageChargeAccordionFragment = { __typename?: 'Plan', billChargesMonthly?: boolean | null };

export type BillableMetricForUsageChargeSectionFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type GetMeteredBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetMeteredBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type GetRecurringBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetRecurringBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type VolumeRangesFragment = { __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null };

export type ChargeForUsageChargeOptionsAccordionFragment = { __typename?: 'Charge', id: string, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean, regroupPaidFees?: RegroupPaidFeesEnum | null };

export type PlanDetailsActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  resourceTypes?: InputMaybe<Array<ResourceTypeEnum> | ResourceTypeEnum>;
  resourceIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type PlanDetailsActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetPlanForDetailsOverviewSectionQueryVariables = Exact<{
  plan: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsOverviewSectionQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, hasOverriddenPlans?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', conversionRate: number, pricingUnit: { __typename?: 'PricingUnit', id: string, code: string, name: string, shortName: string } } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null } | null };

export type GetSubscribtionsForPlanDetailsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum> | StatusTypeEnum>;
}>;


export type GetSubscribtionsForPlanDetailsQuery = { __typename?: 'Query', subscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, endingAt?: any | null, subscriptionAt?: any | null, plan: { __typename?: 'Plan', id: string, parent?: { __typename?: 'Plan', id: string } | null }, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type AddOnForFixedChargesSectionFragment = { __typename?: 'AddOn', id: string, name: string, code: string };

export type DeleteOktaIntegrationDialogFragment = { __typename?: 'OktaIntegration', id: string, name: string };

export type DestroyIntegrationMutationVariables = Exact<{
  input: DestroyIntegrationInput;
}>;


export type DestroyIntegrationMutation = { __typename?: 'Mutation', destroyIntegration?: { __typename?: 'DestroyIntegrationPayload', id?: string | null } | null };

export type AddOktaIntegrationDialogFragment = { __typename?: 'OktaIntegration', id: string, domain: string, clientId?: string | null, clientSecret?: any | null, organizationName: string, name: string };

export type CreateOktaIntegrationMutationVariables = Exact<{
  input: CreateOktaIntegrationInput;
}>;


export type CreateOktaIntegrationMutation = { __typename?: 'Mutation', createOktaIntegration?: { __typename?: 'OktaIntegration', id: string } | null };

export type UpdateOktaIntegrationMutationVariables = Exact<{
  input: UpdateOktaIntegrationInput;
}>;


export type UpdateOktaIntegrationMutation = { __typename?: 'Mutation', updateOktaIntegration?: { __typename?: 'OktaIntegration', id: string } | null };

export type DeleteCampaignFragment = { __typename?: 'DunningCampaign', id: string, appliedToOrganization: boolean };

export type DeleteDunningCampaignMutationVariables = Exact<{
  input: DestroyDunningCampaignInput;
}>;


export type DeleteDunningCampaignMutation = { __typename?: 'Mutation', destroyDunningCampaign?: { __typename?: 'DestroyDunningCampaignPayload', id?: string | null } | null };

export type OrganizationInfoForPreviewDunningCampaignFragment = { __typename?: 'CurrentOrganization', name: string, email?: string | null, logoUrl?: string | null };

export type GetOrganizationInfoForPreviewDunningCampaignQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfoForPreviewDunningCampaignQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', name: string, email?: string | null, logoUrl?: string | null } | null };

export type UpdateBillingEntityLogoMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityLogoMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, logoUrl?: string | null } | null };

export type AddAdyenProviderDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: any | null, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null };

export type GetProviderByCodeForAdyenQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForAdyenQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type AddAdyenApiKeyMutationVariables = Exact<{
  input: AddAdyenPaymentProviderInput;
}>;


export type AddAdyenApiKeyMutation = { __typename?: 'Mutation', addAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: any | null, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateAdyenApiKeyMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenApiKeyMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: any | null, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null } | null };

export type AddAnrokIntegrationDialogFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any };

export type CreateAnrokIntegrationMutationVariables = Exact<{
  input: CreateAnrokIntegrationInput;
}>;


export type CreateAnrokIntegrationMutation = { __typename?: 'Mutation', createAnrokIntegration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any } | null };

export type UpdateAnrokIntegrationMutationVariables = Exact<{
  input: UpdateAnrokIntegrationInput;
}>;


export type UpdateAnrokIntegrationMutation = { __typename?: 'Mutation', updateAnrokIntegration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any } | null };

export type AddAvalaraIntegrationDialogFragment = { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, code: string, companyCode: string, licenseKey: any, name: string };

export type CreateAvalaraIntegrationMutationVariables = Exact<{
  input: CreateAvalaraIntegrationInput;
}>;


export type CreateAvalaraIntegrationMutation = { __typename?: 'Mutation', createAvalaraIntegration?: { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, code: string, companyCode: string, licenseKey: any, name: string } | null };

export type UpdateAvalaraIntegrationMutationVariables = Exact<{
  input: UpdateAvalaraIntegrationInput;
}>;


export type UpdateAvalaraIntegrationMutation = { __typename?: 'Mutation', updateAvalaraIntegration?: { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, code: string, companyCode: string, licenseKey: any, name: string } | null };

export type AddCashfreeProviderDialogFragment = { __typename?: 'CashfreeProvider', id: string, name: string, code: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null };

export type GetProviderByCodeForCashfreeQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForCashfreeQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type AddCashfreeApiKeyMutationVariables = Exact<{
  input: AddCashfreePaymentProviderInput;
}>;


export type AddCashfreeApiKeyMutation = { __typename?: 'Mutation', addCashfreePaymentProvider?: { __typename?: 'CashfreeProvider', id: string, name: string, code: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateCashfreeApiKeyMutationVariables = Exact<{
  input: UpdateCashfreePaymentProviderInput;
}>;


export type UpdateCashfreeApiKeyMutation = { __typename?: 'Mutation', updateCashfreePaymentProvider?: { __typename?: 'CashfreeProvider', id: string, name: string, code: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null } | null };

export type AdyenForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null };

export type CashfreeForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'CashfreeProvider', id: string, successRedirectUrl?: string | null };

export type FlutterwaveForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'FlutterwaveProvider', id: string, successRedirectUrl?: string | null };

export type GocardlessForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null };

export type StripeForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null };

export type MoneyhashForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'MoneyhashProvider', id: string, flowId?: string | null, successRedirectUrl?: string | null };

export type UpdateAdyenPaymentProviderMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenPaymentProviderMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateCashfreePaymentProviderMutationVariables = Exact<{
  input: UpdateCashfreePaymentProviderInput;
}>;


export type UpdateCashfreePaymentProviderMutation = { __typename?: 'Mutation', updateCashfreePaymentProvider?: { __typename?: 'CashfreeProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationVariables = Exact<{
  input: UpdateFlutterwavePaymentProviderInput;
}>;


export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation = { __typename?: 'Mutation', updateFlutterwavePaymentProvider?: { __typename?: 'FlutterwaveProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateGocardlessPaymentProviderMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessPaymentProviderMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateStripePaymentProviderMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripePaymentProviderMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateMoneyhashPaymentProviderMutationVariables = Exact<{
  input: UpdateMoneyhashPaymentProviderInput;
}>;


export type UpdateMoneyhashPaymentProviderMutation = { __typename?: 'Mutation', updateMoneyhashPaymentProvider?: { __typename?: 'MoneyhashProvider', id: string, flowId?: string | null } | null };

export type AddFlutterwaveProviderDialogFragment = { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string, secretKey?: any | null, webhookSecret?: string | null, successRedirectUrl?: string | null };

export type GetProviderByCodeForFlutterwaveQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForFlutterwaveQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type AddFlutterwavePaymentProviderMutationVariables = Exact<{
  input: AddFlutterwavePaymentProviderInput;
}>;


export type AddFlutterwavePaymentProviderMutation = { __typename?: 'Mutation', addFlutterwavePaymentProvider?: { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string, secretKey?: any | null, webhookSecret?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateFlutterwavePaymentProviderMutationVariables = Exact<{
  input: UpdateFlutterwavePaymentProviderInput;
}>;


export type UpdateFlutterwavePaymentProviderMutation = { __typename?: 'Mutation', updateFlutterwavePaymentProvider?: { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string, secretKey?: any | null, webhookSecret?: string | null, successRedirectUrl?: string | null } | null };

export type AddGocardlessProviderDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetProviderByCodeForGocardlessQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForGocardlessQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type UpdateGocardlessApiKeyMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessApiKeyMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string, successRedirectUrl?: string | null, webhookSecret?: string | null } | null };

export type HubspotForCreateDialogFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type CreateHubspotIntegrationMutationVariables = Exact<{
  input: CreateHubspotIntegrationInput;
}>;


export type CreateHubspotIntegrationMutation = { __typename?: 'Mutation', createHubspotIntegration?: { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | null };

export type UpdateHubspotIntegrationMutationVariables = Exact<{
  input: UpdateHubspotIntegrationInput;
}>;


export type UpdateHubspotIntegrationMutation = { __typename?: 'Mutation', updateHubspotIntegration?: { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | null };

export type AddMoneyhashProviderDialogFragment = { __typename?: 'MoneyhashProvider', id: string, name: string, code: string, apiKey?: string | null, flowId?: string | null };

export type GetProviderByCodeForMoneyhashQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForMoneyhashQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type AddMoneyhashApiKeyMutationVariables = Exact<{
  input: AddMoneyhashPaymentProviderInput;
}>;


export type AddMoneyhashApiKeyMutation = { __typename?: 'Mutation', addMoneyhashPaymentProvider?: { __typename?: 'MoneyhashProvider', id: string, name: string, code: string, apiKey?: string | null, flowId?: string | null } | null };

export type UpdateMoneyhashApiKeyMutationVariables = Exact<{
  input: UpdateMoneyhashPaymentProviderInput;
}>;


export type UpdateMoneyhashApiKeyMutation = { __typename?: 'Mutation', updateMoneyhashPaymentProvider?: { __typename?: 'MoneyhashProvider', id: string, name: string, code: string, apiKey?: string | null, flowId?: string | null } | null };

export type NetsuiteForCreateDialogDialogFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null };

export type CreateNetsuiteIntegrationMutationVariables = Exact<{
  input: CreateNetsuiteIntegrationInput;
}>;


export type CreateNetsuiteIntegrationMutation = { __typename?: 'Mutation', createNetsuiteIntegration?: { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null } | null };

export type UpdateNetsuiteIntegrationMutationVariables = Exact<{
  input: UpdateNetsuiteIntegrationInput;
}>;


export type UpdateNetsuiteIntegrationMutation = { __typename?: 'Mutation', updateNetsuiteIntegration?: { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null } | null };

export type SalesforceForCreateDialogFragment = { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string };

export type CreateSalesforceIntegrationMutationVariables = Exact<{
  input: CreateSalesforceIntegrationInput;
}>;


export type CreateSalesforceIntegrationMutation = { __typename?: 'Mutation', createSalesforceIntegration?: { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string } | null };

export type UpdateSalesforceIntegrationMutationVariables = Exact<{
  input: UpdateSalesforceIntegrationInput;
}>;


export type UpdateSalesforceIntegrationMutation = { __typename?: 'Mutation', updateSalesforceIntegration?: { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string } | null };

export type AddStripeProviderDialogFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: any | null };

export type GetProviderByCodeForStripeQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForStripeQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string }
    | { __typename?: 'CashfreeProvider', id: string }
    | { __typename?: 'FlutterwaveProvider', id: string }
    | { __typename?: 'GocardlessProvider', id: string }
    | { __typename?: 'MoneyhashProvider', id: string }
    | { __typename?: 'StripeProvider', id: string }
   | null };

export type AddStripeApiKeyMutationVariables = Exact<{
  input: AddStripePaymentProviderInput;
}>;


export type AddStripeApiKeyMutation = { __typename?: 'Mutation', addStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: any | null, successRedirectUrl?: string | null } | null };

export type UpdateStripeApiKeyMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripeApiKeyMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: any | null, successRedirectUrl?: string | null } | null };

export type XeroForCreateDialogDialogFragment = { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type CreateXeroIntegrationMutationVariables = Exact<{
  input: CreateXeroIntegrationInput;
}>;


export type CreateXeroIntegrationMutation = { __typename?: 'Mutation', createXeroIntegration?: { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null };

export type UpdateXeroIntegrationMutationVariables = Exact<{
  input: UpdateXeroIntegrationInput;
}>;


export type UpdateXeroIntegrationMutation = { __typename?: 'Mutation', updateXeroIntegration?: { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null };

export type AnrokIntegrationItemsFragment = { __typename?: 'AnrokIntegration', id: string };

export type GetAnrokIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetAnrokIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null }> } | null };

export type GetAddOnsForAnrokItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForAnrokItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForAnrokItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForAnrokItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type AnrokIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AnrokIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AnrokIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null };

export type AnrokIntegrationMapItemDialogFragment = { __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum };

export type AnrokIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type AnrokIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type CreateAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateAnrokIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateAnrokIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateAnrokIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateAnrokIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteAnrokIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteAnrokIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type AnrokIntegrationSettingsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any, hasMappingsConfigured?: boolean | null, failedInvoicesCount?: number | null };

export type GetAnrokIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetAnrokIntegrationsSettingsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any, hasMappingsConfigured?: boolean | null, failedInvoicesCount?: number | null }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration', id: string }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type RetryAllInvoicesMutationVariables = Exact<{
  input: RetryAllInvoicesInput;
}>;


export type RetryAllInvoicesMutation = { __typename?: 'Mutation', retryAllInvoices?: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } | null };

export type AvalaraIntegrationItemsFragment = { __typename?: 'AvalaraIntegration', id: string };

export type GetAvalaraIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetAvalaraIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null }> } | null };

export type GetAddOnsForAvalaraItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForAvalaraItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForAvalaraItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForAvalaraItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type AvalaraIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AvalaraIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AvalaraIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null };

export type AvalaraIntegrationMapItemDialogFragment = { __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum };

export type AvalaraIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type AvalaraIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type CreateAvalaraIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateAvalaraIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateAvalaraIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateAvalaraIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateAvalaraIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateAvalaraIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateAvalaraIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateAvalaraIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteAvalaraIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteAvalaraIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteAvalaraIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteAvalaraIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type AvalaraIntegrationSettingsFragment = { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, code: string, companyCode: string, failedInvoicesCount?: number | null, hasMappingsConfigured?: boolean | null, licenseKey: any, name: string };

export type GetAvalaraIntegrationSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetAvalaraIntegrationSettingsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, code: string, companyCode: string, failedInvoicesCount?: number | null, hasMappingsConfigured?: boolean | null, licenseKey: any, name: string }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration', id: string }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type RetryAllAvalaraInvoicesMutationVariables = Exact<{
  input: RetryAllInvoicesInput;
}>;


export type RetryAllAvalaraInvoicesMutation = { __typename?: 'Mutation', retryAllInvoices?: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } | null };

export type DeleteAdyenIntegrationDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string };

export type DeleteAdyenIntegrationMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteAdyenIntegrationMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteAnrokIntegrationDialogFragment = { __typename?: 'AnrokIntegration', id: string, name: string };

export type DestroyNangoIntegrationMutationVariables = Exact<{
  input: DestroyIntegrationInput;
}>;


export type DestroyNangoIntegrationMutation = { __typename?: 'Mutation', destroyIntegration?: { __typename?: 'DestroyIntegrationPayload', id?: string | null } | null };

export type DeleteAvalaraIntegrationDialogFragment = { __typename?: 'AvalaraIntegration', id: string, name: string };

export type DestroyAvalaraIntegrationMutationVariables = Exact<{
  input: DestroyIntegrationInput;
}>;


export type DestroyAvalaraIntegrationMutation = { __typename?: 'Mutation', destroyIntegration?: { __typename?: 'DestroyIntegrationPayload', id?: string | null } | null };

export type DeleteCashfreeIntegrationDialogFragment = { __typename?: 'CashfreeProvider', id: string, name: string };

export type DeleteCashfreeMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteCashfreeMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteFlutterwaveIntegrationDialogFragment = { __typename?: 'FlutterwaveProvider', id: string, name: string };

export type DeleteFlutterwaveIntegrationMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteFlutterwaveIntegrationMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteGocardlessIntegrationDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string };

export type DeleteGocardlessMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteGocardlessMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteHubspotIntegrationDialogFragment = { __typename?: 'HubspotIntegration', id: string, name: string };

export type DeleteMoneyhashIntegrationDialogFragment = { __typename?: 'MoneyhashProvider', id: string, name: string };

export type DeleteMoneyhashIntegrationMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteMoneyhashIntegrationMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteNetsuiteIntegrationDialogFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string };

export type DeleteSalesforceIntegrationDialogFragment = { __typename?: 'SalesforceIntegration', id: string, name: string };

export type DeleteStripeIntegrationDialogFragment = { __typename?: 'StripeProvider', id: string, name: string };

export type DeleteStripeMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteStripeMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteXeroIntegrationDialogFragment = { __typename?: 'XeroIntegration', id: string, name: string };

export type NetsuiteIntegrationItemsFragment = { __typename?: 'NetsuiteIntegration', id: string };

export type GetNetsuiteIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetNetsuiteIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null, taxCode?: string | null, taxNexus?: string | null, taxType?: string | null }> } | null };

export type GetAddOnsForNetsuiteItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForNetsuiteItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForNetsuiteItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForNetsuiteItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type NetsuiteIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type NetsuiteIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type NetsuiteIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null, taxCode?: string | null, taxNexus?: string | null, taxType?: string | null };

export type NetsuiteIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type NetsuiteIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type CreateNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type NetsuiteIntegrationSettingsFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, hasMappingsConfigured?: boolean | null, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetNetsuiteIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetNetsuiteIntegrationsSettingsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, hasMappingsConfigured?: boolean | null, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration', id: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type XeroIntegrationItemsFragment = { __typename?: 'XeroIntegration', id: string };

export type GetXeroIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetXeroIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null }> } | null };

export type GetAddOnsForXeroItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForXeroItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForXeroItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForXeroItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type XeroIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type XeroIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type XeroIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null };

export type XeroIntegrationMapItemDialogFragment = { __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum };

export type XeroIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type XeroIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type GetXeroIntegrationItemsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
  itemType?: InputMaybe<IntegrationItemTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetXeroIntegrationItemsQuery = { __typename?: 'Query', integrationItems: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number } } };

export type TriggerXeroIntegrationAccountsRefetchMutationVariables = Exact<{
  input: FetchIntegrationAccountsInput;
}>;


export type TriggerXeroIntegrationAccountsRefetchMutation = { __typename?: 'Mutation', fetchIntegrationAccounts: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }> } };

export type TriggerXeroIntegrationItemsRefetchMutationVariables = Exact<{
  input: FetchIntegrationItemsInput;
}>;


export type TriggerXeroIntegrationItemsRefetchMutation = { __typename?: 'Mutation', fetchIntegrationItems: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }> } };

export type CreateXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateXeroIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateXeroIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateXeroIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateXeroIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteXeroIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteXeroIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type XeroIntegrationSettingsFragment = { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetXeroIntegrationsSettingsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration', id: string }
    > } | null };

export type DeleteCustomSectionFragment = { __typename?: 'InvoiceCustomSection', id: string };

export type DeleteCustomSectionMutationVariables = Exact<{
  input: DestroyInvoiceCustomSectionInput;
}>;


export type DeleteCustomSectionMutation = { __typename?: 'Mutation', destroyInvoiceCustomSection?: { __typename?: 'DestroyInvoiceCustomSectionPayload', id?: string | null } | null };

export type UpdateDocumentLocaleBillingEntityMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateDocumentLocaleBillingEntityMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type UpdateBillingEntityGracePeriodMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityGracePeriodMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, invoiceGracePeriod: number } | null } | null };

export type EditBillingEntityInvoiceNumberingDialogFragment = { __typename?: 'BillingEntity', id: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string };

export type UpdateBillingEntityInvoiceNumberingMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityInvoiceNumberingMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string } | null };

export type EditBillingEntityInvoiceTemplateDialogFragment = { __typename?: 'BillingEntity', billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, invoiceFooter?: string | null } | null };

export type UpdateBillingEntityInvoiceTemplateMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityInvoiceTemplateMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, invoiceFooter?: string | null } | null } | null };

export type EditBillingEntityDefaultCurrencyForDialogFragment = { __typename?: 'BillingEntity', id: string, defaultCurrency: CurrencyEnum };

export type UpdateBillingEntityDefaultCurrencyMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityDefaultCurrencyMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, defaultCurrency: CurrencyEnum } | null };

export type EditCustomerFinalizeZeroAmountInvoiceForDialogFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null };

export type EditBillingEntityFinalizeZeroAmountInvoiceForDialogFragment = { __typename?: 'BillingEntity', id: string, finalizeZeroAmountInvoice: boolean };

export type UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null } | null };

export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, finalizeZeroAmountInvoice: boolean } | null };

export type EditCustomerNetPaymentTermForDialogFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null };

export type EditBillingEntityNetPaymentTermForDialogFragment = { __typename?: 'BillingEntity', id: string, netPaymentTerm: number };

export type UpdateCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null } | null };

export type UpdateBillingEntityNetPaymentTermMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityNetPaymentTermMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, netPaymentTerm: number } | null };

export type GetOrganizationCustomFooterForInvoiceQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationCustomFooterForInvoiceQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', invoiceFooter?: string | null } | null } | null };

export type CreateInviteMutationVariables = Exact<{
  input: CreateInviteInput;
}>;


export type CreateInviteMutation = { __typename?: 'Mutation', createInvite?: { __typename?: 'Invite', id: string, token: string, email: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type InviteForEditRoleForDialogFragment = { __typename?: 'Invite', id: string, role: MembershipRole, email: string };

export type UpdateInviteRoleMutationVariables = Exact<{
  input: UpdateInviteInput;
}>;


export type UpdateInviteRoleMutation = { __typename?: 'Mutation', updateInvite?: { __typename?: 'Invite', id: string, role: MembershipRole, email: string } | null };

export type MemberForEditRoleForDialogFragment = { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type UpdateMembershipRoleMutationVariables = Exact<{
  input: UpdateMembershipInput;
}>;


export type UpdateMembershipRoleMutation = { __typename?: 'Mutation', updateMembership?: { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } } | null };

export type RevokeInviteMutationVariables = Exact<{
  input: RevokeInviteInput;
}>;


export type RevokeInviteMutation = { __typename?: 'Mutation', revokeInvite?: { __typename?: 'Invite', id: string } | null };

export type RevokeMembershipMutationVariables = Exact<{
  input: RevokeMembershipInput;
}>;


export type RevokeMembershipMutation = { __typename?: 'Mutation', revokeMembership?: { __typename?: 'Membership', id: string } | null };

export type InviteForRolePickerFieldFragment = { __typename?: 'Invite', id: string, role: MembershipRole };

export type RemoveSubscriptionEntitlementMutationVariables = Exact<{
  input: RemoveSubscriptionEntitlementInput;
}>;


export type RemoveSubscriptionEntitlementMutation = { __typename?: 'Mutation', removeSubscriptionEntitlement?: { __typename?: 'RemoveSubscriptionEntitlementPayload', featureCode?: string | null } | null };

export type SubscriptionActivityLogsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
}>;


export type SubscriptionActivityLogsQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogCollection', collection: Array<{ __typename?: 'ActivityLog', activityId: string, activityType: ActivityTypeEnum, activityObject?: any | null, loggedAt: any, externalCustomerId?: string | null, externalSubscriptionId?: string | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetAlertsOfSubscriptionQueryVariables = Exact<{
  subscriptionExternalId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetAlertsOfSubscriptionQuery = { __typename?: 'Query', alerts: { __typename?: 'AlertCollection', collection: Array<{ __typename?: 'Alert', id: string, code: string, createdAt: any, name?: string | null }> } };

export type CustomerForSubscriptionUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
}>;


export type CustomerForSubscriptionUsageQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } | null };

export type SubscrptionForSubscriptionUsageQueryVariables = Exact<{
  subscription: Scalars['ID']['input'];
}>;


export type SubscrptionForSubscriptionUsageQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, plan: { __typename?: 'Plan', id: string, name: string, code: string }, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } } | null };

export type SubscriptionCurrentUsageTableComponentCustomerUsageFragment = { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null }> | null }> }> };

export type SubscriptionCurrentUsageTableComponentCustomerProjectedUsageFragment = { __typename?: 'CustomerProjectedUsage', amountCents: any, projectedAmountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ProjectedChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, projectedUnits: number, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null }> | null, groupedUsage: Array<{ __typename?: 'ProjectedGroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, projectedUnits: number, projectedAmountCents: any, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null }> | null }> }> };

export type UsageForSubscriptionUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  subscriptionId: Scalars['ID']['input'];
}>;


export type UsageForSubscriptionUsageQuery = { __typename?: 'Query', customerUsage: { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, id: string, pricingUnitAmountCents?: any | null, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null }> | null }> }> } };

export type ProjectedUsageForSubscriptionUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  subscriptionId: Scalars['ID']['input'];
}>;


export type ProjectedUsageForSubscriptionUsageQuery = { __typename?: 'Query', customerProjectedUsage: { __typename?: 'CustomerProjectedUsage', amountCents: any, projectedAmountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ProjectedChargeUsage', id: string, units: number, amountCents: any, pricingUnitAmountCents?: any | null, projectedUnits: number, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', id: string, pricingUnit: { __typename?: 'PricingUnit', id: string, shortName: string } } | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null, groupedUsage: Array<{ __typename?: 'ProjectedGroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, projectedUnits: number, projectedAmountCents: any, id: string, pricingUnitAmountCents?: any | null, pricingUnitProjectedAmountCents?: any | null, filters?: Array<{ __typename?: 'ProjectedChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null, pricingUnitAmountCents?: any | null, projectedAmountCents: any, pricingUnitProjectedAmountCents?: any | null, projectedUnits: number }> | null }> }> } };

export type GetSubscriptionForDetailsOverviewQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsOverviewQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, terminatedAt?: any | null, nextSubscriptionAt?: any | null, nextSubscriptionType?: NextSubscriptionTypeEnum | null, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null }, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string } } | null };

export type GetEntitlementsForSubscriptionDetailsQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetEntitlementsForSubscriptionDetailsQuery = { __typename?: 'Query', subscriptionEntitlements: { __typename?: 'SubscriptionEntitlementCollection', collection: Array<{ __typename?: 'SubscriptionEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'SubscriptionEntitlementPrivilegeObject', code: string, name?: string | null, value?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> } };

export type SubscriptionForSubscriptionInformationsFragment = { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, terminatedAt?: any | null, nextSubscriptionAt?: any | null, nextSubscriptionType?: NextSubscriptionTypeEnum | null, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string }, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null } };

export type SubscriptionUsageLifetimeGraphForLifetimeGraphFragment = { __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string } };

export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForSubscriptionUsageLifetimeGraphQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string } } | null };

export type GetCustomerFromSubscriptionQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetCustomerFromSubscriptionQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', customer: { __typename?: 'Customer', id: string } } | null };

export type DestroySubscriptionAlertMutationVariables = Exact<{
  input: DestroySubscriptionAlertInput;
}>;


export type DestroySubscriptionAlertMutation = { __typename?: 'Mutation', destroySubscriptionAlert?: { __typename?: 'Alert', id: string } | null };

export type DeleteTaxFragment = { __typename?: 'Tax', id: string, name: string, customersCount: number };

export type DeleteTaxMutationVariables = Exact<{
  input: DestroyTaxInput;
}>;


export type DeleteTaxMutation = { __typename?: 'Mutation', destroyTax?: { __typename?: 'DestroyTaxPayload', id?: string | null } | null };

export type TaxForTaxesSelectorSectionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type GetTaxesForTaxesSelectorSectionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxesForTaxesSelectorSectionQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type CustomerWalletFragment = { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, lastOngoingBalanceSyncAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> | null } | null, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', expirationAt?: any | null, grantedCredits: string, interval?: RecurringTransactionIntervalEnum | null, invoiceRequiresSuccessfulPayment: boolean, lagoId: string, method: RecurringTransactionMethodEnum, paidCredits: string, startedAt?: any | null, targetOngoingBalance?: string | null, thresholdCredits?: string | null, transactionName?: string | null, trigger: RecurringTransactionTriggerEnum, ignorePaidTopUpLimits: boolean, transactionMetadata?: Array<{ __typename?: 'TransactionMetadata', key: string, value: string }> | null }> | null };

export type GetCustomerWalletListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetCustomerWalletListQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletCollection', metadata: { __typename?: 'WalletCollectionMetadata', currentPage: number, totalPages: number, customerActiveWalletsCount: number }, collection: Array<{ __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, lastOngoingBalanceSyncAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> | null } | null, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', expirationAt?: any | null, grantedCredits: string, interval?: RecurringTransactionIntervalEnum | null, invoiceRequiresSuccessfulPayment: boolean, lagoId: string, method: RecurringTransactionMethodEnum, paidCredits: string, startedAt?: any | null, targetOngoingBalance?: string | null, thresholdCredits?: string | null, transactionName?: string | null, trigger: RecurringTransactionTriggerEnum, ignorePaidTopUpLimits: boolean, transactionMetadata?: Array<{ __typename?: 'TransactionMetadata', key: string, value: string }> | null }> | null }> } };

export type TerminateCustomerWalletMutationVariables = Exact<{
  input: TerminateCustomerWalletInput;
}>;


export type TerminateCustomerWalletMutation = { __typename?: 'Mutation', terminateCustomerWallet?: { __typename?: 'Wallet', id: string, status: WalletStatusEnum, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, lastOngoingBalanceSyncAt?: any | null, name?: string | null, rateAmount: number, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, priority: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type CreateCustomerWalletTransactionMutationVariables = Exact<{
  input: CreateCustomerWalletTransactionInput;
}>;


export type CreateCustomerWalletTransactionMutation = { __typename?: 'Mutation', createCustomerWalletTransaction?: { __typename?: 'WalletTransactionCollection', collection: Array<{ __typename?: 'WalletTransaction', id: string }> } | null };

export type WalletForVoidTransactionFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, creditsBalance: number };

export type WalletAccordionFragment = { __typename?: 'Wallet', id: string, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, lastOngoingBalanceSyncAt?: any | null, name?: string | null, rateAmount: number, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, priority: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type WalletTransactionDetailsFragment = { __typename?: 'WalletTransaction', id: string, name?: string | null, amount: string, createdAt: any, transactionType: WalletTransactionTransactionTypeEnum, creditAmount: string, settledAt?: any | null, failedAt?: any | null, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, source: WalletTransactionSourceEnum, invoiceRequiresSuccessfulPayment: boolean, metadata?: Array<{ __typename?: 'WalletTransactionMetadataObject', key: string, value: string }> | null, invoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, customer: { __typename?: 'Customer', id: string }, payments?: Array<{ __typename?: 'Payment', id: string, providerPaymentId?: string | null, paymentProviderType?: ProviderTypeEnum | null, payablePaymentStatus?: PayablePaymentStatusEnum | null }> | null } | null };

export type GetWalletTransactionDetailsQueryVariables = Exact<{
  transactionId: Scalars['ID']['input'];
}>;


export type GetWalletTransactionDetailsQuery = { __typename?: 'Query', walletTransaction?: { __typename?: 'WalletTransaction', id: string, name?: string | null, amount: string, createdAt: any, transactionType: WalletTransactionTransactionTypeEnum, creditAmount: string, settledAt?: any | null, failedAt?: any | null, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, source: WalletTransactionSourceEnum, invoiceRequiresSuccessfulPayment: boolean, metadata?: Array<{ __typename?: 'WalletTransactionMetadataObject', key: string, value: string }> | null, invoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, customer: { __typename?: 'Customer', id: string }, payments?: Array<{ __typename?: 'Payment', id: string, providerPaymentId?: string | null, paymentProviderType?: ProviderTypeEnum | null, payablePaymentStatus?: PayablePaymentStatusEnum | null }> | null } | null } | null };

export type WalletInfosForTransactionsFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, status: WalletStatusEnum, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type GetWalletTransactionsQueryVariables = Exact<{
  walletId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWalletTransactionsQuery = { __typename?: 'Query', walletTransactions: { __typename?: 'WalletTransactionCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'WalletTransaction', id: string, amount: string, createdAt: any, creditAmount: string, failedAt?: any | null, name?: string | null, settledAt?: any | null, source: WalletTransactionSourceEnum, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null }> } };

export type WalletTransactionForTransactionListItemFragment = { __typename?: 'WalletTransaction', id: string, amount: string, createdAt: any, creditAmount: string, failedAt?: any | null, name?: string | null, settledAt?: any | null, source: WalletTransactionSourceEnum, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null };

export type CurrentUserFragment = { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null, accessibleByCurrentSession: boolean }> };

export type GetCurrentUserInfosForLoginQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserInfosForLoginQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null, accessibleByCurrentSession: boolean }> } };

export type InvoiceSubscriptionFormatingFragment = { __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval } } | null }> | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, chargeAmountCents: any, progressiveBillingCreditAmountCents: any } };

export type FeeForInvoiceFeesToFeeInputFragment = { __typename?: 'Fee', id: string, description?: string | null, invoiceDisplayName?: string | null, itemName: string, preciseUnitAmount: number, addOn?: { __typename?: 'AddOn', id: string } | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null };

export type CreateSubscriptionMutationVariables = Exact<{
  input: CreateSubscriptionInput;
}>;


export type CreateSubscriptionMutation = { __typename?: 'Mutation', createSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, accountType: CustomerAccountTypeEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null } } | null };

export type UpdateSubscriptionMutationVariables = Exact<{
  input: UpdateSubscriptionInput;
}>;


export type UpdateSubscriptionMutation = { __typename?: 'Mutation', updateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, accountType: CustomerAccountTypeEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null }, plan: { __typename?: 'Plan', id: string } } | null };

export type DownloadPaymentReceiptMutationVariables = Exact<{
  input: DownloadPaymentReceiptInput;
}>;


export type DownloadPaymentReceiptMutation = { __typename?: 'Mutation', downloadPaymentReceipt?: { __typename?: 'PaymentReceipt', id: string, fileUrl?: string | null } | null };

export type GetCustomPricingUnitsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetCustomPricingUnitsQuery = { __typename?: 'Query', pricingUnits: { __typename?: 'PricingUnitCollection', collection: Array<{ __typename?: 'PricingUnit', id: string, name: string, code: string, shortName: string }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type GetSinglePlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSinglePlanQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, hasOverriddenPlans?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', conversionRate: number, pricingUnit: { __typename?: 'PricingUnit', id: string, code: string, name: string, shortName: string } } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null } | null };

export type CreatePlanMutationVariables = Exact<{
  input: CreatePlanInput;
}>;


export type CreatePlanMutation = { __typename?: 'Mutation', createPlan?: { __typename?: 'Plan', id: string } | null };

export type UpdatePlanMutationVariables = Exact<{
  input: UpdatePlanInput;
}>;


export type UpdatePlanMutation = { __typename?: 'Mutation', updatePlan?: { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, hasOverriddenPlans?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', conversionRate: number, pricingUnit: { __typename?: 'PricingUnit', id: string, code: string, name: string, shortName: string } } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null } | null };

export type InvoiceFeeFragment = { __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null };

export type InvoiceCreateCreditNoteFragment = { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, totalPaidAmountCents: any, totalAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, succeededAt?: any | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null };

export type GetInvoiceCreateCreditNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceCreateCreditNoteQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, totalPaidAmountCents: any, totalAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, succeededAt?: any | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null } | null };

export type CreateCreditNoteMutationVariables = Exact<{
  input: CreateCreditNoteInput;
}>;


export type CreateCreditNoteMutation = { __typename?: 'Mutation', createCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type EditAddOnFragment = { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetSingleAddOnQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleAddOnQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null };

export type CreateAddOnMutationVariables = Exact<{
  input: CreateAddOnInput;
}>;


export type CreateAddOnMutation = { __typename?: 'Mutation', createAddOn?: { __typename?: 'AddOn', id: string } | null };

export type UpdateAddOnMutationVariables = Exact<{
  input: UpdateAddOnInput;
}>;


export type UpdateAddOnMutation = { __typename?: 'Mutation', updateAddOn?: { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any } | null };

export type GetSingleBillableMetricQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleBillableMetricQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, expression?: string | null, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, hasSubscriptions: boolean, hasPlans: boolean, recurring: boolean, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null } | null };

export type CreateBillableMetricMutationVariables = Exact<{
  input: CreateBillableMetricInput;
}>;


export type CreateBillableMetricMutation = { __typename?: 'Mutation', createBillableMetric?: { __typename?: 'BillableMetric', id: string } | null };

export type UpdateBillableMetricMutationVariables = Exact<{
  input: UpdateBillableMetricInput;
}>;


export type UpdateBillableMetricMutation = { __typename?: 'Mutation', updateBillableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any } | null };

export type BillingEntityItemFragment = { __typename?: 'BillingEntity', id: string, code: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null, timezone?: TimezoneEnum | null, isDefault: boolean, defaultCurrency: CurrencyEnum, euTaxManagement: boolean, selectedInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string } | null };

export type GetBillingEntitiesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetBillingEntitiesQuery = { __typename?: 'Query', billingEntities: { __typename?: 'BillingEntityCollection', collection: Array<{ __typename?: 'BillingEntity', id: string, code: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null, timezone?: TimezoneEnum | null, isDefault: boolean, defaultCurrency: CurrencyEnum, euTaxManagement: boolean, selectedInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string } | null }> } };

export type GetBillingEntityQueryVariables = Exact<{
  code: Scalars['String']['input'];
}>;


export type GetBillingEntityQuery = { __typename?: 'Query', billingEntity?: { __typename?: 'BillingEntity', id: string, code: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null, timezone?: TimezoneEnum | null, isDefault: boolean, defaultCurrency: CurrencyEnum, euTaxManagement: boolean, selectedInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string } | null } | null };

export type CreateBillingEntityMutationVariables = Exact<{
  input: CreateBillingEntityInput;
}>;


export type CreateBillingEntityMutation = { __typename?: 'Mutation', createBillingEntity?: { __typename?: 'BillingEntity', id: string, code: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null, timezone?: TimezoneEnum | null, isDefault: boolean, defaultCurrency: CurrencyEnum, euTaxManagement: boolean, selectedInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string } | null } | null };

export type UpdateBillingEntityMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, code: string, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null, timezone?: TimezoneEnum | null, isDefault: boolean, defaultCurrency: CurrencyEnum, euTaxManagement: boolean, selectedInvoiceCustomSections?: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string }> | null, appliedDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string } | null } | null };

export type EditCouponFragment = { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null };

export type GetSingleCouponQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleCouponQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null } | null };

export type CreateCouponMutationVariables = Exact<{
  input: CreateCouponInput;
}>;


export type CreateCouponMutation = { __typename?: 'Mutation', createCoupon?: { __typename?: 'Coupon', id: string } | null };

export type UpdateCouponMutationVariables = Exact<{
  input: UpdateCouponInput;
}>;


export type UpdateCouponMutation = { __typename?: 'Mutation', updateCoupon?: { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null } | null };

export type CustomerForExternalAppsAccordionFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, currency?: CurrencyEnum | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null };

export type AddCustomerDrawerFragment = { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', code: string, name: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null };

export type CreateCustomerMutationVariables = Exact<{
  input: CreateCustomerInput;
}>;


export type CreateCustomerMutation = { __typename?: 'Mutation', createCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, displayName: string, createdAt: any, activeSubscriptionsCount: number, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null } | null };

export type UpdateCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, displayName: string, createdAt: any, activeSubscriptionsCount: number, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null } | null };

export type GetSingleCustomerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleCustomerQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', code: string, name: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null } | null };

export type DunningCampaignFormFragment = { __typename?: 'DunningCampaign', name: string, code: string, description?: string | null, daysBetweenAttempts: number, maxAttempts: number, appliedToOrganization: boolean, bccEmails?: Array<string> | null, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', amountCents: any, currency: CurrencyEnum }> };

export type GetSingleCampaignQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleCampaignQuery = { __typename?: 'Query', dunningCampaign: { __typename?: 'DunningCampaign', id: string, name: string, code: string, description?: string | null, daysBetweenAttempts: number, maxAttempts: number, appliedToOrganization: boolean, bccEmails?: Array<string> | null, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', amountCents: any, currency: CurrencyEnum }> } };

export type CreateDunningCampaignPaymentProviderQueryVariables = Exact<{ [key: string]: never; }>;


export type CreateDunningCampaignPaymentProviderQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename: 'AdyenProvider' }
      | { __typename: 'CashfreeProvider' }
      | { __typename: 'FlutterwaveProvider' }
      | { __typename: 'GocardlessProvider' }
      | { __typename: 'MoneyhashProvider' }
      | { __typename: 'StripeProvider' }
    > } | null };

export type CreateDunningCampaignMutationVariables = Exact<{
  input: CreateDunningCampaignInput;
}>;


export type CreateDunningCampaignMutation = { __typename?: 'Mutation', createDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string, description?: string | null, daysBetweenAttempts: number, maxAttempts: number, appliedToOrganization: boolean, bccEmails?: Array<string> | null, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', amountCents: any, currency: CurrencyEnum }> } | null };

export type UpdateDunningCampaignMutationVariables = Exact<{
  input: UpdateDunningCampaignInput;
}>;


export type UpdateDunningCampaignMutation = { __typename?: 'Mutation', updateDunningCampaign?: { __typename?: 'DunningCampaign', id: string, name: string, code: string, description?: string | null, daysBetweenAttempts: number, maxAttempts: number, appliedToOrganization: boolean, bccEmails?: Array<string> | null, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', amountCents: any, currency: CurrencyEnum }> } | null };

export type InvoiceCustomSectionFormFragment = { __typename?: 'InvoiceCustomSection', name: string, code: string, description?: string | null, details?: string | null, displayName?: string | null };

export type GetSingleInvoiceCustomSectionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleInvoiceCustomSectionQuery = { __typename?: 'Query', invoiceCustomSection: { __typename?: 'InvoiceCustomSection', id: string, name: string, code: string, description?: string | null, details?: string | null, displayName?: string | null } };

export type CreateInvoiceCustomSectionMutationVariables = Exact<{
  input: CreateInvoiceCustomSectionInput;
}>;


export type CreateInvoiceCustomSectionMutation = { __typename?: 'Mutation', createInvoiceCustomSection?: { __typename?: 'InvoiceCustomSection', id: string, name: string, code: string, description?: string | null, details?: string | null, displayName?: string | null } | null };

export type UpdateInvoiceCustomSectionMutationVariables = Exact<{
  input: UpdateInvoiceCustomSectionInput;
}>;


export type UpdateInvoiceCustomSectionMutation = { __typename?: 'Mutation', updateInvoiceCustomSection?: { __typename?: 'InvoiceCustomSection', id: string, name: string, code: string, description?: string | null, details?: string | null, displayName?: string | null } | null };

export type TaxFormFragment = { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type TaxFormQueryShapeFragment = { __typename?: 'Tax', autoGenerated: boolean, id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type GetSingleTaxQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleTaxQuery = { __typename?: 'Query', tax?: { __typename?: 'Tax', id: string, autoGenerated: boolean, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CreateTaxMutationVariables = Exact<{
  input: TaxCreateInput;
}>;


export type CreateTaxMutation = { __typename?: 'Mutation', createTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type UpdateTaxMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type UpdateTaxMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CurrentUserInfosFragment = { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null, accessibleByCurrentSession: boolean }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> };

export type GetCurrentUserInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserInfosQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null, accessibleByCurrentSession: boolean }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> } };

export type UpdateBillingEntityEmailSettingMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityEmailSettingMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, emailSettings?: Array<BillingEntityEmailSettingsEnum> | null } | null };

export type GetTaxProviderPresenceQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetTaxProviderPresenceQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration', id: string }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type MainOrganizationInfosFragment = { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum>, canCreateBillingEntity: boolean, authenticationMethods: Array<AuthenticationMethodsEnum>, authenticatedMethod: AuthenticationMethodsEnum };

export type GetOrganizationInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfosQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum>, canCreateBillingEntity: boolean, authenticationMethods: Array<AuthenticationMethodsEnum>, authenticatedMethod: AuthenticationMethodsEnum } | null };

export type MembershipPermissionsFragment = { __typename?: 'Membership', id: string, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type SideNavInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type SideNavInfosQuery = { __typename?: 'Query', currentVersion: { __typename?: 'CurrentVersion', githubUrl: string, number: string } };

export type GetAddOnForDetailsQueryVariables = Exact<{
  addOn: Scalars['ID']['input'];
}>;


export type GetAddOnForDetailsQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, amountCents: any, amountCurrency: CurrencyEnum, code: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null };

export type AddOnItemFragment = { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any };

export type AddOnsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type AddOnsQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any }> } };

export type GetSubscriptionInfosQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSubscriptionInfosQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, externalId: string, plan: { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum } } | null };

export type GetSubscriptionAlertToEditQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSubscriptionAlertToEditQuery = { __typename?: 'Query', alert?: { __typename?: 'Alert', id: string, alertType: AlertTypeEnum, code: string, name?: string | null, billableMetric?: { __typename?: 'BillableMetric', id: string, code: string, name: string } | null, thresholds?: Array<{ __typename?: 'AlertThreshold', code?: string | null, recurring: boolean, value: string }> | null } | null };

export type GetExistingAlertsOfSubscriptionQueryVariables = Exact<{
  subscriptionExternalId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetExistingAlertsOfSubscriptionQuery = { __typename?: 'Query', alerts: { __typename?: 'AlertCollection', collection: Array<{ __typename?: 'Alert', id: string, alertType: AlertTypeEnum, billableMetricId?: string | null }> } };

export type GetSubscriptionBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  planId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetSubscriptionBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> } };

export type CreateSubscriptionAlertMutationVariables = Exact<{
  input: CreateSubscriptionAlertInput;
}>;


export type CreateSubscriptionAlertMutation = { __typename?: 'Mutation', createSubscriptionAlert?: { __typename?: 'Alert', id: string } | null };

export type UpdateSubscriptionAlertMutationVariables = Exact<{
  input: UpdateSubscriptionAlertInput;
}>;


export type UpdateSubscriptionAlertMutation = { __typename?: 'Mutation', updateSubscriptionAlert?: { __typename?: 'Alert', id: string } | null };

export type GetBillableMetricForHeaderDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBillableMetricForHeaderDetailsQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string } | null };

export type BillableMetricItemFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any };

export type BillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type BillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any }> } };

export type CouponDetailsForHeaderFragment = { __typename?: 'Coupon', name: string, status: CouponStatusEnum, couponType: CouponTypeEnum, percentageRate?: number | null, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, frequency: CouponFrequency };

export type GetCouponForDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCouponForDetailsQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, name: string, status: CouponStatusEnum, couponType: CouponTypeEnum, percentageRate?: number | null, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, frequency: CouponFrequency, appliedCouponsCount: number } | null };

export type CouponItemFragment = { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type CouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type CouponsQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, appliedCouponsCount: number }> } };

export type EditBillableMetricFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, expression?: string | null, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, hasSubscriptions: boolean, hasPlans: boolean, recurring: boolean, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null };

export type CreateCreditNoteInvoiceFragment = { __typename?: 'Invoice', id: string, currency?: CurrencyEnum | null, number: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, totalPaidAmountCents: any, totalAmountCents: any, paymentDisputeLostAt?: any | null, invoiceType: InvoiceTypeEnum, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null }> | null };

export type TaxInfosForCreateInvoiceFragment = { __typename?: 'Tax', id: string, name: string, code: string, rate: number };

export type GetInvoiceFeesForCreateInvoiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceFeesForCreateInvoiceQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, itemName: string, description?: string | null, groupedBy: any, units: number, preciseUnitAmount: number, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string, tax?: { __typename?: 'Tax', id: string, name: string, rate: number, code: string } | null }> | null, addOn?: { __typename?: 'AddOn', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> | null } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null }> | null } | null };

export type GetInfosForCreateInvoiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInfosForCreateInvoiceQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, name?: string | null, displayName: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, state?: string | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, billingEntity: { __typename?: 'BillingEntity', code: string }, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string } | null } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> } };

export type GetAddonListForInfoiceQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetAddonListForInfoiceQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null }> } };

export type FetchDraftInvoiceTaxesMutationVariables = Exact<{
  input: FetchDraftInvoiceTaxesInput;
}>;


export type FetchDraftInvoiceTaxesMutation = { __typename?: 'Mutation', fetchDraftInvoiceTaxes?: { __typename?: 'TaxFeeObjectCollection', collection: Array<{ __typename?: 'TaxFeeObject', amountCents?: any | null, itemId?: string | null, taxAmountCents?: any | null, taxBreakdown?: Array<{ __typename?: 'TaxBreakdownObject', name?: string | null, rate?: number | null, taxAmount?: any | null, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null }> } | null };

export type CreateInvoiceMutationVariables = Exact<{
  input: CreateInvoiceInput;
}>;


export type CreateInvoiceMutation = { __typename?: 'Mutation', createInvoice?: { __typename?: 'Invoice', id: string } | null };

export type GetPayableInvoicesQueryVariables = Exact<{
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type GetPayableInvoicesQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, number: string, currency?: CurrencyEnum | null }> } };

export type GetPayableInvoiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetPayableInvoiceQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalDueAmountCents: any, issuingDate: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum } | null };

export type CreatePaymentMutationVariables = Exact<{
  input: CreatePaymentInput;
}>;


export type CreatePaymentMutation = { __typename?: 'Mutation', createPayment?: { __typename?: 'Payment', id: string } | null };

export type TaxForPlanAndChargesInPlanFormFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type BillableMetricForPlanFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type EditPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, hasOverriddenPlans?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, appliedPricingUnit?: { __typename?: 'AppliedPricingUnit', conversionRate: number, pricingUnit: { __typename?: 'PricingUnit', id: string, code: string, name: string, shortName: string } } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, pricingGroupKeys?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null };

export type GetCreditNoteForDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCreditNoteForDetailsQuery = { __typename?: 'Query', creditNote?: { __typename?: 'CreditNote', id: string, number: string, canBeVoided: boolean, totalAmountCents: any, currency: CurrencyEnum, integrationSyncable: boolean, taxProviderSyncable: boolean, externalIntegrationId?: string | null, taxProviderId?: string | null, customer: { __typename?: 'Customer', anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalAccountId?: string | null } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null } | null } } | null };

export type SyncIntegrationCreditNoteMutationVariables = Exact<{
  input: SyncIntegrationCreditNoteInput;
}>;


export type SyncIntegrationCreditNoteMutation = { __typename?: 'Mutation', syncIntegrationCreditNote?: { __typename?: 'SyncIntegrationCreditNotePayload', creditNoteId?: string | null } | null };

export type RetryTaxReportingMutationVariables = Exact<{
  input: RetryTaxReportingInput;
}>;


export type RetryTaxReportingMutation = { __typename?: 'Mutation', retryTaxReporting?: { __typename?: 'CreditNote', id: string } | null };

export type GetCreditNotesListQueryVariables = Exact<{
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  creditStatus?: InputMaybe<Array<CreditNoteCreditStatusEnum> | CreditNoteCreditStatusEnum>;
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  reason?: InputMaybe<Array<CreditNoteReasonEnum> | CreditNoteReasonEnum>;
  refundStatus?: InputMaybe<Array<CreditNoteRefundStatusEnum> | CreditNoteRefundStatusEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
}>;


export type GetCreditNotesListQuery = { __typename?: 'Query', creditNotes: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }> } };

export type CreateCreditNotesDataExportMutationVariables = Exact<{
  input: CreateDataExportsCreditNotesInput;
}>;


export type CreateCreditNotesDataExportMutation = { __typename?: 'Mutation', createCreditNotesDataExport?: { __typename?: 'DataExport', id: string } | null };

export type CustomerDetailsFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, accountType: CustomerAccountTypeEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null };

export type GetCustomerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, accountType: CustomerAccountTypeEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null } | null };

export type GenerateCustomerPortalUrlMutationVariables = Exact<{
  input: GenerateCustomerPortalUrlInput;
}>;


export type GenerateCustomerPortalUrlMutation = { __typename?: 'Mutation', generateCustomerPortalUrl?: { __typename?: 'GenerateCustomerPortalUrlPayload', url: string } | null };

export type GetCustomerDraftInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerDraftInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type GetCustomerInfosForDraftInvoicesListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type GetCustomerInfosForDraftInvoicesListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } | null, customerInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } };

export type AllInvoiceDetailsForCustomerInvoiceDetailsFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, associatedActiveWalletPresent: boolean, voidedAt?: any | null, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, issuingDate: any, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, totalPaidAmountCents: any, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type CustomerForInvoiceDetailsFragment = { __typename?: 'Customer', id: string, name?: string | null, paymentProvider?: ProviderTypeEnum | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null } | null, salesforceCustomer?: { __typename?: 'SalesforceCustomer', id: string, integrationId?: string | null } | null };

export type GetInvoiceDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceDetailsQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, associatedActiveWalletPresent: boolean, voidedAt?: any | null, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, issuingDate: any, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, totalPaidAmountCents: any, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type GetInvoiceFeesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceFeesQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, walletTransaction?: { __typename?: 'WalletTransaction', id: string, name?: string | null, wallet?: { __typename?: 'Wallet', id: string, name?: string | null } | null } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string, taxRate: number }> | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null } | null };

export type GetInvoiceSubscriptionsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceSubscriptionsQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, acceptNewChargeFees: boolean, subscriptionAmountCents: any, invoice: { __typename?: 'Invoice', chargeAmountCents: any, progressiveBillingCreditAmountCents: any, id: string, status: InvoiceStatusTypeEnum }, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null, billChargesMonthly?: boolean | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, walletTransaction?: { __typename?: 'WalletTransaction', id: string, name?: string | null, wallet?: { __typename?: 'Wallet', id: string, name?: string | null } | null } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string, taxRate: number }> | null, properties?: { __typename?: 'FeeProperties', fromDatetime?: any | null, toDatetime?: any | null } | null, pricingUnitUsage?: { __typename?: 'PricingUnitUsage', amountCents: any, conversionRate: number, shortName: string, preciseUnitAmount: number } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null }> | null } | null };

export type GetInvoiceCustomerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceCustomerQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, paymentProvider?: ProviderTypeEnum | null, applicableTimezone: TimezoneEnum, accountType: CustomerAccountTypeEnum, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, salesforceCustomer?: { __typename?: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null } | null };

export type GetInvoiceNumberQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceNumberQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, number: string } | null };

export type GetInvoiceStatusQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceStatusQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } | null };

export type IntegrationsListForCustomerInvoiceDetailsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerInvoiceDetailsQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename: 'AvalaraIntegration', id: string, accountId?: string | null, companyId?: string | null }
      | { __typename: 'HubspotIntegration', id: string, portalId?: string | null, invoicesObjectTypeId?: string | null }
      | { __typename: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename: 'SalesforceIntegration', id: string, name: string, instanceId: string }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type DownloadInvoiceMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RefreshInvoiceMutationVariables = Exact<{
  input: RefreshInvoiceInput;
}>;


export type RefreshInvoiceMutation = { __typename?: 'Mutation', refreshInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, associatedActiveWalletPresent: boolean, voidedAt?: any | null, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, issuingDate: any, taxProviderId?: string | null, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, allChargesHaveFees: boolean, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, totalPaidAmountCents: any, couponsAmountCents: any, creditNotesAmountCents: any, totalDueAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null, accountType: CustomerAccountTypeEnum }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, taxCode: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type SyncIntegrationInvoiceMutationVariables = Exact<{
  input: SyncIntegrationInvoiceInput;
}>;


export type SyncIntegrationInvoiceMutation = { __typename?: 'Mutation', syncIntegrationInvoice?: { __typename?: 'SyncIntegrationInvoicePayload', invoiceId?: string | null } | null };

export type SyncHubspotIntegrationInvoiceMutationVariables = Exact<{
  input: SyncHubspotIntegrationInvoiceInput;
}>;


export type SyncHubspotIntegrationInvoiceMutation = { __typename?: 'Mutation', syncHubspotIntegrationInvoice?: { __typename?: 'SyncHubspotInvoicePayload', invoiceId?: string | null } | null };

export type SyncSalesforceInvoiceMutationVariables = Exact<{
  input: SyncSalesforceInvoiceInput;
}>;


export type SyncSalesforceInvoiceMutation = { __typename?: 'Mutation', syncSalesforceInvoice?: { __typename?: 'SyncSalesforceInvoicePayload', invoiceId?: string | null } | null };

export type RetryInvoiceMutationVariables = Exact<{
  input: RetryInvoiceInput;
}>;


export type RetryInvoiceMutation = { __typename?: 'Mutation', retryInvoice?: { __typename?: 'Invoice', id: string } | null };

export type RetryTaxProviderVoidingMutationVariables = Exact<{
  input: RetryTaxProviderVoidingInput;
}>;


export type RetryTaxProviderVoidingMutation = { __typename?: 'Mutation', retryTaxProviderVoiding?: { __typename?: 'Invoice', id: string } | null };

export type FeeForCustomerInvoiceRegenerateFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxCode: string }> | null };

export type RegenerateInvoiceMutationVariables = Exact<{
  input: RegenerateInvoiceInput;
}>;


export type RegenerateInvoiceMutation = { __typename?: 'Mutation', regenerateFromVoided?: { __typename?: 'Invoice', id: string } | null };

export type PreviewAdjustedFeeMutationVariables = Exact<{
  input: PreviewAdjustedFeeInput;
}>;


export type PreviewAdjustedFeeMutation = { __typename?: 'Mutation', previewAdjustedFee?: { __typename?: 'Fee', id: string, feeType: FeeTypesEnum, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, preciseUnitAmount: number, addOn?: { __typename?: 'AddOn', id: string } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, amountCents: any, taxRate: number, taxName: string }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, toValue?: any | null, units?: string | null, perUnitTotalAmount?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', flatUnitAmount?: string | null, fromValue?: any | null, rate?: string | null, toValue?: any | null, units?: string | null, perUnitTotalAmount?: string | null }> | null } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, chargeModel: ChargeModelEnum, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null } | null };

export type CustomerForRequestOverduePaymentFormFragment = { __typename?: 'Customer', email?: string | null };

export type InvoicesForRequestOverduePaymentFormFragment = { __typename?: 'Invoice', id: string, number: string, totalDueAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any };

export type LastPaymentRequestFragment = { __typename?: 'PaymentRequest', createdAt: any };

export type GetRequestOverduePaymentInfosQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetRequestOverduePaymentInfosQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', defaultCurrency: CurrencyEnum, name: string, logoUrl?: string | null, email?: string | null, netPaymentTerm: number, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', documentLocale?: string | null } | null } | null, customer?: { __typename?: 'Customer', externalId: string, currency?: CurrencyEnum | null, email?: string | null, displayName: string, paymentProvider?: ProviderTypeEnum | null, netPaymentTerm?: number | null, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', documentLocale?: string | null } | null } | null, paymentRequests: { __typename?: 'PaymentRequestCollection', collection: Array<{ __typename?: 'PaymentRequest', createdAt: any }> }, invoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, number: string, totalDueAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any }> } };

export type CreatePaymentRequestMutationVariables = Exact<{
  input: PaymentRequestCreateInput;
}>;


export type CreatePaymentRequestMutation = { __typename?: 'Mutation', createPaymentRequest?: { __typename?: 'PaymentRequest', id: string } | null };

export type CustomerItemFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', code: string, name: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null };

export type CustomersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  accountType?: InputMaybe<Array<CustomerAccountTypeEnum> | CustomerAccountTypeEnum>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
  activeSubscriptionsCountFrom?: InputMaybe<Scalars['Int']['input']>;
  activeSubscriptionsCountTo?: InputMaybe<Scalars['Int']['input']>;
  countries?: InputMaybe<Array<CountryCode> | CountryCode>;
  zipcodes?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  states?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  currencies?: InputMaybe<Array<CurrencyEnum> | CurrencyEnum>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  hasTaxIdentificationNumber?: InputMaybe<Scalars['Boolean']['input']>;
  hasCustomerType?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataFilter> | CustomerMetadataFilter>;
}>;


export type CustomersQuery = { __typename?: 'Query', customers: { __typename?: 'CustomerCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, accountType: CustomerAccountTypeEnum, url?: string | null, paymentProvider?: ProviderTypeEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null, billingEntity: { __typename?: 'BillingEntity', code: string, name: string }, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, avalaraCustomer?: { __typename: 'AvalaraCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, salesforceCustomer?: { __typename: 'SalesforceCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null }> } };

export type GetinviteQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetinviteQuery = { __typename?: 'Query', invite?: { __typename?: 'Invite', id: string, email: string, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type AcceptInviteMutationVariables = Exact<{
  input: AcceptInviteInput;
}>;


export type AcceptInviteMutation = { __typename?: 'Mutation', acceptInvite?: { __typename?: 'RegisterUser', token: string } | null };

export type GoogleAcceptInviteMutationVariables = Exact<{
  input: GoogleAcceptInviteInput;
}>;


export type GoogleAcceptInviteMutation = { __typename?: 'Mutation', googleAcceptInvite?: { __typename?: 'RegisterUser', token: string } | null };

export type FetchOktaAuthorizeUrlMutationVariables = Exact<{
  input: OktaAuthorizeInput;
}>;


export type FetchOktaAuthorizeUrlMutation = { __typename?: 'Mutation', oktaAuthorize?: { __typename?: 'Authorize', url: string } | null };

export type OktaAcceptInviteMutationVariables = Exact<{
  input: OktaAcceptInviteInput;
}>;


export type OktaAcceptInviteMutation = { __typename?: 'Mutation', oktaAcceptInvite?: { __typename?: 'LoginUser', token: string } | null };

export type InvoiceDetailsForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, issuingDate: any, externalIntegrationId?: string | null, taxProviderId?: string | null, taxProviderVoidable: boolean, integrationHubspotSyncable: boolean, externalHubspotIntegrationId?: string | null, integrationSalesforceSyncable: boolean, externalSalesforceIntegrationId?: string | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, addOn?: { __typename?: 'AddOn', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval, name: string } } | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } };

export type CustomerForInvoiceOverviewFragment = { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, accountType: CustomerAccountTypeEnum, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, avalaraCustomer?: { __typename?: 'AvalaraCustomer', id: string, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', externalCustomerId?: string | null } | null, salesforceCustomer?: { __typename?: 'SalesforceCustomer', externalCustomerId?: string | null } | null };

export type NetsuiteIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string };

export type HubspotIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'HubspotIntegration', id: string, portalId?: string | null, invoicesObjectTypeId?: string | null };

export type SalesforceIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'SalesforceIntegration', id: string, name: string, instanceId: string };

export type AvalaraIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'AvalaraIntegration', id: string, accountId?: string | null, companyId?: string | null };

export type GetInvoicesListQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum> | InvoiceTypeEnum>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  partiallyPaid?: InputMaybe<Scalars['Boolean']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum> | InvoicePaymentStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  amountFrom?: InputMaybe<Scalars['Int']['input']>;
  amountTo?: InputMaybe<Scalars['Int']['input']>;
  selfBilled?: InputMaybe<Scalars['Boolean']['input']>;
  billingEntityIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
}>;


export type GetInvoicesListQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, taxStatus?: InvoiceTaxStatusTypeEnum | null, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, totalDueAmountCents: any, totalPaidAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, creditableAmountCents: any, refundableAmountCents: any, associatedActiveWalletPresent: boolean, voidedInvoiceId?: string | null, regeneratedInvoiceId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum, paymentProvider?: ProviderTypeEnum | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, billingEntity: { __typename?: 'BillingEntity', name: string, code: string } }> } };

export type RetryAllInvoicePaymentsMutationVariables = Exact<{
  input: RetryAllInvoicePaymentsInput;
}>;


export type RetryAllInvoicePaymentsMutation = { __typename?: 'Mutation', retryAllInvoicePayments?: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } | null };

export type CreateInvoicesDataExportMutationVariables = Exact<{
  input: CreateDataExportsInvoicesInput;
}>;


export type CreateInvoicesDataExportMutation = { __typename?: 'Mutation', createInvoicesDataExport?: { __typename?: 'DataExport', id: string } | null };

export type InvoiceForPaymentDetailsFragment = { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, totalAmountCents: any, issuingDate: any, currency?: CurrencyEnum | null, paymentOverdue: boolean, totalPaidAmountCents: any, paymentDisputeLostAt?: any | null };

export type GetPaymentDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetPaymentDetailsQuery = { __typename?: 'Query', payment?: { __typename?: 'Payment', id: string, amountCents: any, amountCurrency: CurrencyEnum, createdAt: any, updatedAt?: any | null, reference?: string | null, paymentType: PaymentTypeEnum, paymentProviderType?: ProviderTypeEnum | null, payablePaymentStatus?: PayablePaymentStatusEnum | null, providerPaymentId?: string | null, customer: { __typename?: 'Customer', deletedAt?: any | null, id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, payable:
      | { __typename?: 'Invoice', id: string, payableType: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, totalAmountCents: any, issuingDate: any, currency?: CurrencyEnum | null, paymentOverdue: boolean, totalPaidAmountCents: any, paymentDisputeLostAt?: any | null }
      | { __typename?: 'PaymentRequest', id: string, payableType: string, invoices: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, totalAmountCents: any, issuingDate: any, currency?: CurrencyEnum | null, paymentOverdue: boolean, totalPaidAmountCents: any, paymentDisputeLostAt?: any | null }> }
    , paymentReceipt?: { __typename?: 'PaymentReceipt', id: string } | null } | null };

export type GetPaymentsListQueryVariables = Exact<{
  invoiceId?: InputMaybe<Scalars['ID']['input']>;
  externalCustomerId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPaymentsListQuery = { __typename?: 'Query', payments: { __typename?: 'PaymentCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Payment', amountCents: any, amountCurrency: CurrencyEnum, createdAt: any, id: string, payablePaymentStatus?: PayablePaymentStatusEnum | null, paymentProviderType?: ProviderTypeEnum | null, paymentType: PaymentTypeEnum, providerPaymentId?: string | null, reference?: string | null, payable:
        | { __typename?: 'Invoice', id: string, number: string, payableType: string }
        | { __typename?: 'PaymentRequest', payableType: string, invoices: Array<{ __typename?: 'Invoice', id: string }> }
      , customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, paymentReceipt?: { __typename?: 'PaymentReceipt', id: string } | null }> } };

export type GetPlanForDetailsQueryVariables = Exact<{
  planId: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, draftInvoicesCount: number, activeSubscriptionsCount: number, parent?: { __typename?: 'Plan', id: string } | null } | null };

export type PlanItemFragment = { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number };

export type PlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type PlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number }> } };

export type SubscriptionForSubscriptionsListFragment = { __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextSubscriptionAt?: any | null, nextSubscriptionType?: NextSubscriptionTypeEnum | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, terminatedAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string, isOverridden: boolean, payInAdvance: boolean, amountCurrency: CurrencyEnum, name: string, interval: PlanInterval }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval } | null, nextSubscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, status?: StatusTypeEnum | null } | null };

export type GetSubscriptionsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum> | StatusTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  overriden?: InputMaybe<Scalars['Boolean']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetSubscriptionsListQuery = { __typename?: 'Query', subscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextSubscriptionAt?: any | null, nextSubscriptionType?: NextSubscriptionTypeEnum | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, terminatedAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string, isOverridden: boolean, payInAdvance: boolean, amountCurrency: CurrencyEnum, name: string, interval: PlanInterval }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval } | null, nextSubscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, status?: StatusTypeEnum | null } | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number } } };

export type GetInvoiceCollectionsForAnalyticsQueryVariables = Exact<{
  currency: CurrencyEnum;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetInvoiceCollectionsForAnalyticsQuery = { __typename?: 'Query', invoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', paymentStatus?: InvoicePaymentStatusTypeEnum | null, invoicesCount: any, amountCents: any, currency?: CurrencyEnum | null, month: any }> } };

export type GetOverdueForAnalyticsQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months: Scalars['Int']['input'];
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetOverdueForAnalyticsQuery = { __typename?: 'Query', overdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, month: any, lagoInvoiceIds: Array<string> }> } };

export type CreatePasswordResetMutationVariables = Exact<{
  input: CreatePasswordResetInput;
}>;


export type CreatePasswordResetMutation = { __typename?: 'Mutation', createPasswordReset?: { __typename?: 'CreatePasswordResetPayload', id: string } | null };

export type GoogleLoginUserMutationVariables = Exact<{
  input: GoogleLoginUserInput;
}>;


export type GoogleLoginUserMutation = { __typename?: 'Mutation', googleLoginUser?: { __typename?: 'LoginUser', token: string } | null };

export type LoginUserMutationVariables = Exact<{
  input: LoginUserInput;
}>;


export type LoginUserMutation = { __typename?: 'Mutation', loginUser?: { __typename?: 'LoginUser', token: string } | null };

export type OktaLoginUserMutationVariables = Exact<{
  input: OktaLoginInput;
}>;


export type OktaLoginUserMutation = { __typename?: 'Mutation', oktaLogin?: { __typename?: 'LoginUser', token: string } | null };

export type GetPasswordResetQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetPasswordResetQuery = { __typename?: 'Query', passwordReset: { __typename?: 'ResetPassword', id: string, user: { __typename?: 'User', id: string, email?: string | null } } };

export type ResetPasswordMutationVariables = Exact<{
  input: ResetPasswordInput;
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword?: { __typename?: 'LoginUser', token: string } | null };

export type SignupMutationVariables = Exact<{
  input: RegisterUserInput;
}>;


export type SignupMutation = { __typename?: 'Mutation', registerUser?: { __typename?: 'RegisterUser', token: string } | null };

export type GoogleRegisterMutationVariables = Exact<{
  input: GoogleRegisterUserInput;
}>;


export type GoogleRegisterMutation = { __typename?: 'Mutation', googleRegisterUser?: { __typename?: 'RegisterUser', token: string } | null };

export type GetPortalOrgaInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalOrgaInfosQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'CustomerPortalOrganization', id: string, name: string, logoUrl?: string | null, premiumIntegrations: Array<PremiumIntegrationTypeEnum> } | null };

export type GetApiKeyToEditQueryVariables = Exact<{
  apiKeyId: Scalars['ID']['input'];
}>;


export type GetApiKeyToEditQuery = { __typename?: 'Query', apiKey: { __typename?: 'ApiKey', id: string, name?: string | null, lastUsedAt?: any | null, permissions: any } };

export type CreateApiKeyMutationVariables = Exact<{
  input: CreateApiKeyInput;
}>;


export type CreateApiKeyMutation = { __typename?: 'Mutation', createApiKey?: { __typename?: 'ApiKey', id: string } | null };

export type UpdateApiKeyMutationVariables = Exact<{
  input: UpdateApiKeyInput;
}>;


export type UpdateApiKeyMutation = { __typename?: 'Mutation', updateApiKey?: { __typename?: 'ApiKey', id: string } | null };

export type GetFeatureForDetailsQueryVariables = Exact<{
  feature: Scalars['ID']['input'];
}>;


export type GetFeatureForDetailsQuery = { __typename?: 'Query', feature: { __typename?: 'FeatureObject', id: string, name?: string | null, code: string } };

export type FeatureForFeatureFormFragment = { __typename?: 'FeatureObject', id: string, name?: string | null, code: string, description?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, code: string, name?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> };

export type GetFeatureQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetFeatureQuery = { __typename?: 'Query', feature: { __typename?: 'FeatureObject', id: string, name?: string | null, code: string, description?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', id: string, code: string, name?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> } };

export type CreateFeatureMutationVariables = Exact<{
  input: CreateFeatureInput;
}>;


export type CreateFeatureMutation = { __typename?: 'Mutation', createFeature?: { __typename?: 'FeatureObject', id: string } | null };

export type UpdateFeatureMutationVariables = Exact<{
  input: UpdateFeatureInput;
}>;


export type UpdateFeatureMutation = { __typename?: 'Mutation', updateFeature?: { __typename?: 'FeatureObject', id: string } | null };

export type FeatureForFeaturesListFragment = { __typename?: 'FeatureObject', id: string, name?: string | null, code: string, createdAt: any, subscriptionsCount: number };

export type GetFeaturesListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetFeaturesListQuery = { __typename?: 'Query', features: { __typename?: 'FeatureObjectCollection', collection: Array<{ __typename?: 'FeatureObject', id: string, name?: string | null, code: string, createdAt: any, subscriptionsCount: number }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type GetForecastsQueryVariables = Exact<{
  billableMetricCode?: InputMaybe<Scalars['String']['input']>;
  billingEntityCode?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerCountry?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  isCustomerTinEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  externalSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  fromDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  toDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  timeGranularity?: InputMaybe<TimeGranularityEnum>;
}>;


export type GetForecastsQuery = { __typename?: 'Query', dataApiUsagesForecasted: { __typename?: 'DataApiUsageForecastedCollection', collection: Array<{ __typename?: 'DataApiUsageForecasted', amountCents: any, units: number, amountCentsForecastConservative: any, amountCentsForecastRealistic: any, amountCentsForecastOptimistic: any, unitsForecastConservative: number, unitsForecastRealistic: number, unitsForecastOptimistic: number, amountCurrency: CurrencyEnum, endOfPeriodDt: any, startOfPeriodDt: any }> } };

export type AdyenIntegrationDetailsFragment = { __typename?: 'AdyenProvider', id: string, apiKey?: any | null, code: string, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null, name: string };

export type GetAdyenIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider', id: string, apiKey?: any | null, code: string, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null, name: string }
    | { __typename?: 'CashfreeProvider' }
    | { __typename?: 'FlutterwaveProvider' }
    | { __typename?: 'GocardlessProvider' }
    | { __typename?: 'MoneyhashProvider' }
    | { __typename?: 'StripeProvider' }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider', id: string }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type AdyenIntegrationsFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string };

export type GetAdyenIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: any | null, hmacKey?: any | null, livePrefix?: string | null, merchantAccount?: string | null }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type AnrokIntegrationDetailsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any };

export type GetAnrokIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetAnrokIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration', id: string }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type AnrokIntegrationsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any };

export type GetAnrokIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetAnrokIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: any }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type GetAuthIntegrationsQueryVariables = Exact<{
  limit: Scalars['Int']['input'];
}>;


export type GetAuthIntegrationsQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration', id: string, domain: string, clientId?: string | null, clientSecret?: any | null, organizationName: string, name: string }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type OktaIntegrationDetailsFragment = { __typename?: 'OktaIntegration', id: string, clientId?: string | null, clientSecret?: any | null, code: string, organizationName: string, domain: string, name: string };

export type GetOktaIntegrationQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetOktaIntegrationQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration', id: string, clientId?: string | null, clientSecret?: any | null, code: string, organizationName: string, domain: string, name: string }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null };

export type UpdateOrganizationAuthenticationMethodsMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationAuthenticationMethodsMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, authenticationMethods: Array<AuthenticationMethodsEnum> } | null };

export type AvalaraIntegrationDetailsFragment = { __typename?: 'AvalaraIntegration', id: string, name: string, accountId?: string | null, code: string, companyCode: string, licenseKey: any };

export type GetAvalaraIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetAvalaraIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration', id: string, name: string, accountId?: string | null, code: string, companyCode: string, licenseKey: any }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration', id: string }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type AvalaraIntegrationsFragment = { __typename?: 'AvalaraIntegration', id: string, name: string, code: string, accountId?: string | null, companyCode: string, licenseKey: any };

export type GetAvalaraIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetAvalaraIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration', id: string, name: string, code: string, accountId?: string | null, companyCode: string, licenseKey: any }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type GetBillingEntitySettingsQueryVariables = Exact<{
  code: Scalars['String']['input'];
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetBillingEntitySettingsQuery = { __typename?: 'Query', billingEntity?: { __typename?: 'BillingEntity', id: string, code: string, name: string, netPaymentTerm: number, defaultCurrency: CurrencyEnum, documentNumbering: BillingEntityDocumentNumberingEnum, documentNumberPrefix: string, finalizeZeroAmountInvoice: boolean, billingConfiguration?: { __typename?: 'BillingEntityBillingConfiguration', id: string, invoiceGracePeriod: number, invoiceFooter?: string | null, documentLocale?: string | null } | null } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> }, invoiceCustomSections?: { __typename?: 'InvoiceCustomSectionCollection', collection: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string, code: string }> } | null };

export type ApplyBillingEntityDunningCampaignMutationVariables = Exact<{
  input: BillingEntityUpdateAppliedDunningCampaignInput;
}>;


export type ApplyBillingEntityDunningCampaignMutation = { __typename?: 'Mutation', billingEntityUpdateAppliedDunningCampaign?: { __typename?: 'BillingEntity', id: string } | null };

export type RemoveBillingEntityDunningCampaignMutationVariables = Exact<{
  input: BillingEntityUpdateAppliedDunningCampaignInput;
}>;


export type RemoveBillingEntityDunningCampaignMutation = { __typename?: 'Mutation', billingEntityUpdateAppliedDunningCampaign?: { __typename?: 'BillingEntity', id: string } | null };

export type UpdateBillingEntityTimezoneMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type UpdateBillingEntityTimezoneMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string, timezone?: TimezoneEnum | null } | null };

export type ApplyBillingEntityInvoiceCustomSectionMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type ApplyBillingEntityInvoiceCustomSectionMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string } | null };

export type RemoveBillingEntityInvoiceCustomSectionMutationVariables = Exact<{
  input: UpdateBillingEntityInput;
}>;


export type RemoveBillingEntityInvoiceCustomSectionMutation = { __typename?: 'Mutation', updateBillingEntity?: { __typename?: 'BillingEntity', id: string } | null };

export type TaxItemForApplyTaxFragment = { __typename?: 'Tax', id: string, code: string, name: string };

export type GetTaxesForApplyTaxQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxesForApplyTaxQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string }> } };

export type ApplyBillingEntityTaxesMutationVariables = Exact<{
  input: ApplyTaxesInput;
}>;


export type ApplyBillingEntityTaxesMutation = { __typename?: 'Mutation', billingEntityApplyTaxes?: { __typename: 'ApplyTaxesPayload' } | null };

export type GetBillingEntityTaxesQueryVariables = Exact<{
  billingEntityId: Scalars['ID']['input'];
}>;


export type GetBillingEntityTaxesQuery = { __typename?: 'Query', billingEntityTaxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> } };

export type RemoveBillingEntityTaxesMutationVariables = Exact<{
  input: RemoveTaxesInput;
}>;


export type RemoveBillingEntityTaxesMutation = { __typename?: 'Mutation', billingEntityRemoveTaxes?: { __typename: 'RemoveTaxesPayload' } | null };

export type CashfreeIntegrationDetailsFragment = { __typename?: 'CashfreeProvider', id: string, code: string, name: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null };

export type GetCashfreeIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetCashfreeIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider' }
    | { __typename?: 'CashfreeProvider', id: string, code: string, name: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null }
    | { __typename?: 'FlutterwaveProvider' }
    | { __typename?: 'GocardlessProvider' }
    | { __typename?: 'MoneyhashProvider' }
    | { __typename?: 'StripeProvider' }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider', id: string }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type CashfreeIntegrationsFragment = { __typename?: 'CashfreeProvider', id: string, name: string, code: string };

export type GetCashfreeIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetCashfreeIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider', id: string, name: string, code: string, clientId?: string | null, clientSecret?: string | null, successRedirectUrl?: string | null }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type DunningCampaignItemFragment = { __typename?: 'DunningCampaign', id: string, name: string, code: string, appliedToOrganization: boolean };

export type GetDunningCampaignsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetDunningCampaignsQuery = { __typename?: 'Query', dunningCampaigns: { __typename?: 'DunningCampaignCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'DunningCampaign', id: string, name: string, code: string, appliedToOrganization: boolean }> } };

export type UpdateDunningCampaignStatusMutationVariables = Exact<{
  input: UpdateDunningCampaignInput;
}>;


export type UpdateDunningCampaignStatusMutation = { __typename?: 'Mutation', updateDunningCampaign?: { __typename?: 'DunningCampaign', id: string, appliedToOrganization: boolean } | null };

export type FlutterwaveIntegrationDetailsFragment = { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string, secretKey?: any | null, webhookSecret?: string | null, successRedirectUrl?: string | null };

export type FlutterwaveIntegrationDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type FlutterwaveIntegrationDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider' }
    | { __typename?: 'CashfreeProvider' }
    | { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string, secretKey?: any | null, webhookSecret?: string | null, successRedirectUrl?: string | null }
    | { __typename?: 'GocardlessProvider' }
    | { __typename?: 'MoneyhashProvider' }
    | { __typename?: 'StripeProvider' }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider', id: string }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type FlutterwaveIntegrationsFragment = { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string };

export type GetFlutterwaveIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetFlutterwaveIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider', id: string, name: string, code: string }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type GocardlessIntegrationDetailsFragment = { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null };

export type GetGocardlessIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider' }
    | { __typename?: 'CashfreeProvider' }
    | { __typename?: 'FlutterwaveProvider' }
    | { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null }
    | { __typename?: 'MoneyhashProvider' }
    | { __typename?: 'StripeProvider' }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider', id: string }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type GocardlessIntegrationOauthCallbackFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type AddGocardlessApiKeyMutationVariables = Exact<{
  input: AddGocardlessPaymentProviderInput;
}>;


export type AddGocardlessApiKeyMutation = { __typename?: 'Mutation', addGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | null };

export type GocardlessIntegrationsFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetGocardlessIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider', id: string, name: string, code: string }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type HubspotIntegrationDetailsFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type GetHubspotIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetHubspotIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration', id: string }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type HubspotIntegrationsFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type GetHubspotIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetHubspotIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type IntegrationsSettingQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsSettingQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider', id: string }
      | { __typename?: 'CashfreeProvider', id: string }
      | { __typename?: 'FlutterwaveProvider', id: string }
      | { __typename?: 'GocardlessProvider', id: string }
      | { __typename?: 'MoneyhashProvider', id: string }
      | { __typename?: 'StripeProvider', id: string }
    > } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration', id: string }
      | { __typename?: 'AvalaraIntegration', id: string }
      | { __typename?: 'HubspotIntegration', id: string }
      | { __typename?: 'NetsuiteIntegration', id: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration', id: string }
      | { __typename?: 'XeroIntegration', id: string }
    > } | null };

export type PricingUnitFragment = { __typename?: 'PricingUnit', id: string, name: string, code: string, description?: string | null, shortName: string };

export type GetSinglePricingUnitQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSinglePricingUnitQuery = { __typename?: 'Query', pricingUnit: { __typename?: 'PricingUnit', id: string, name: string, code: string, description?: string | null, shortName: string } };

export type CreatePricingUnitMutationVariables = Exact<{
  input: CreatePricingUnitInput;
}>;


export type CreatePricingUnitMutation = { __typename?: 'Mutation', createPricingUnit?: { __typename?: 'PricingUnit', id: string, name: string, code: string, description?: string | null, shortName: string } | null };

export type UpdatePricingUnitMutationVariables = Exact<{
  input: UpdatePricingUnitInput;
}>;


export type UpdatePricingUnitMutation = { __typename?: 'Mutation', updatePricingUnit?: { __typename?: 'PricingUnit', id: string, name: string, code: string, description?: string | null, shortName: string } | null };

export type GetOrganizationSettingsInvoiceSectionsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetOrganizationSettingsInvoiceSectionsQuery = { __typename?: 'Query', invoiceCustomSections?: { __typename?: 'InvoiceCustomSectionCollection', collection: Array<{ __typename?: 'InvoiceCustomSection', id: string, name: string, code: string }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetOrganizationSettingsPricingUnitsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetOrganizationSettingsPricingUnitsQuery = { __typename?: 'Query', pricingUnits: { __typename?: 'PricingUnitCollection', collection: Array<{ __typename?: 'PricingUnit', id: string, name: string, shortName: string }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTaxesForTaxManagementIntegrationDetailsPageQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type InviteItemForMembersSettingsFragment = { __typename?: 'Invite', id: string, email: string, token: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } };

export type MembershipItemForMembershipSettingsFragment = { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, organization: { __typename?: 'Organization', id: string, name: string }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type GetInvitesQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvitesQuery = { __typename?: 'Query', invites: { __typename?: 'InviteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invite', id: string, email: string, token: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } }> } };

export type GetMembersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetMembersQuery = { __typename?: 'Query', memberships: { __typename?: 'MembershipCollection', metadata: { __typename?: 'Metadata', currentPage: number, totalPages: number, totalCount: number, adminCount: number }, collection: Array<{ __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, organization: { __typename?: 'Organization', id: string, name: string }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, auditLogsView: boolean, authenticationMethodsView: boolean, authenticationMethodsUpdate: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, billingEntitiesView: boolean, billingEntitiesCreate: boolean, billingEntitiesUpdate: boolean, billingEntitiesDelete: boolean, billingEntitiesInvoicesView: boolean, billingEntitiesInvoicesUpdate: boolean, billingEntitiesTaxesView: boolean, billingEntitiesTaxesUpdate: boolean, billingEntitiesEmailsView: boolean, billingEntitiesEmailsUpdate: boolean, billingEntitiesDunningCampaignsUpdate: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, dataApiView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, featuresCreate: boolean, featuresDelete: boolean, featuresUpdate: boolean, featuresView: boolean, invoiceCustomSectionsCreate: boolean, invoiceCustomSectionsUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, paymentsCreate: boolean, paymentsView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, pricingUnitsCreate: boolean, pricingUnitsUpdate: boolean, pricingUnitsView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> } };

export type MoneyhashIntegrationDetailsFragment = { __typename?: 'MoneyhashProvider', id: string, apiKey?: string | null, code: string, flowId?: string | null, name: string };

export type GetMoneyhashIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetMoneyhashIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider' }
    | { __typename?: 'CashfreeProvider' }
    | { __typename?: 'FlutterwaveProvider' }
    | { __typename?: 'GocardlessProvider' }
    | { __typename?: 'MoneyhashProvider', id: string, apiKey?: string | null, code: string, flowId?: string | null, name: string, successRedirectUrl?: string | null }
    | { __typename?: 'StripeProvider' }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider', id: string }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type MoneyhashIntegrationsFragment = { __typename?: 'MoneyhashProvider', id: string, name: string, code: string };

export type GetMoneyhashIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetMoneyhashIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider', id: string, name: string, code: string, apiKey?: string | null, flowId?: string | null }
      | { __typename?: 'StripeProvider' }
    > } | null };

export type NetsuiteIntegrationDetailsFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null };

export type GetNetsuiteIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetNetsuiteIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, code: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration', id: string }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type NetsuiteIntegrationsFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string, code: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null };

export type GetNetsuiteIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetNetsuiteIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration', id: string, name: string, code: string, accountId?: string | null, clientId?: string | null, clientSecret?: any | null, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, tokenId?: string | null, tokenSecret?: any | null }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type SalesforceIntegrationDetailsFragment = { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string };

export type GetSalesforceIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetSalesforceIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string }
    | { __typename?: 'XeroIntegration' }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration', id: string }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type SalesforceIntegrationsFragment = { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string };

export type GetSalesforceIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetSalesforceIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration', id: string, name: string, code: string, instanceId: string }
      | { __typename?: 'XeroIntegration' }
    > } | null };

export type StripeIntegrationDetailsFragment = { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: any | null, successRedirectUrl?: string | null };

export type GetStripeIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?:
    | { __typename?: 'AdyenProvider' }
    | { __typename?: 'CashfreeProvider' }
    | { __typename?: 'FlutterwaveProvider' }
    | { __typename?: 'GocardlessProvider' }
    | { __typename?: 'MoneyhashProvider' }
    | { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: any | null, successRedirectUrl?: string | null }
   | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider', id: string }
    > } | null };

export type StripeIntegrationsFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string };

export type GetStripeIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<
      | { __typename?: 'AdyenProvider' }
      | { __typename?: 'CashfreeProvider' }
      | { __typename?: 'FlutterwaveProvider' }
      | { __typename?: 'GocardlessProvider' }
      | { __typename?: 'MoneyhashProvider' }
      | { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: any | null }
    > } | null };

export type TaxItemForTaxSettingsFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number };

export type GetTaxesSettingsInformationsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesSettingsInformationsQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number }> } };

export type XeroIntegrationDetailsFragment = { __typename?: 'XeroIntegration', id: string, name: string, connectionId: string, code: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetXeroIntegrationsDetailsQuery = { __typename?: 'Query', integration?:
    | { __typename?: 'AnrokIntegration' }
    | { __typename?: 'AvalaraIntegration' }
    | { __typename?: 'HubspotIntegration' }
    | { __typename?: 'NetsuiteIntegration' }
    | { __typename?: 'OktaIntegration' }
    | { __typename?: 'SalesforceIntegration' }
    | { __typename?: 'XeroIntegration', id: string, name: string, connectionId: string, code: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null }
   | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration', id: string }
    > } | null };

export type XeroIntegrationsFragment = { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<Array<IntegrationTypeEnum> | IntegrationTypeEnum>;
}>;


export type GetXeroIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<
      | { __typename?: 'AnrokIntegration' }
      | { __typename?: 'AvalaraIntegration' }
      | { __typename?: 'HubspotIntegration' }
      | { __typename?: 'NetsuiteIntegration' }
      | { __typename?: 'OktaIntegration' }
      | { __typename?: 'SalesforceIntegration' }
      | { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null }
    > } | null };

export type AddSubscriptionPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null };

export type GetPlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null }> } };

export type GetCustomerForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerForCreateSubscriptionQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null, displayName: string, externalId: string } | null };

export type GetSubscriptionForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSubscriptionForCreateSubscriptionQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, billingTime?: BillingTimeEnum | null, periodEndDate?: any | null, status?: StatusTypeEnum | null, startedAt?: any | null, plan: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval, parent?: { __typename?: 'Plan', id: string } | null, entitlements?: Array<{ __typename?: 'PlanEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'PlanEntitlementPrivilegeObject', code: string, name?: string | null, value: string, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> | null } } | null };

export type GetSubscriptionForDetailsQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, externalId: string, plan: { __typename?: 'Plan', id: string, name: string, code: string, payInAdvance: boolean, parent?: { __typename?: 'Plan', id: string, name: string, code: string } | null }, customer: { __typename?: 'Customer', id: string } } | null };

export type GetSubscriptionDataForEntitlementFormQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionDataForEntitlementFormQuery = { __typename?: 'Query', subscriptionEntitlements: { __typename?: 'SubscriptionEntitlementCollection', collection: Array<{ __typename?: 'SubscriptionEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'SubscriptionEntitlementPrivilegeObject', code: string, name?: string | null, value?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> }, features: { __typename?: 'FeatureObjectCollection', collection: Array<{ __typename?: 'FeatureObject', code: string, name?: string | null, privileges: Array<{ __typename?: 'PrivilegeObject', code: string, name?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> }> } };

export type GetSubscriptionEntitlementToEditQueryVariables = Exact<{
  featureCode: Scalars['String']['input'];
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionEntitlementToEditQuery = { __typename?: 'Query', subscriptionEntitlement: { __typename?: 'SubscriptionEntitlement', code: string, name: string, privileges: Array<{ __typename?: 'SubscriptionEntitlementPrivilegeObject', code: string, name?: string | null, value?: string | null, valueType: PrivilegeValueTypeEnum, config: { __typename?: 'PrivilegeConfigObject', selectOptions?: Array<string> | null } }> } };

export type CreateOrUpdateSubscriptionEntitlementMutationVariables = Exact<{
  input: CreateOrUpdateSubscriptionEntitlementInput;
}>;


export type CreateOrUpdateSubscriptionEntitlementMutation = { __typename?: 'Mutation', createOrUpdateSubscriptionEntitlement?: { __typename?: 'SubscriptionEntitlement', code: string } | null };

export type WalletForUpdateFragment = { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> | null } | null, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', expirationAt?: any | null, grantedCredits: string, interval?: RecurringTransactionIntervalEnum | null, invoiceRequiresSuccessfulPayment: boolean, lagoId: string, method: RecurringTransactionMethodEnum, paidCredits: string, startedAt?: any | null, targetOngoingBalance?: string | null, thresholdCredits?: string | null, transactionName?: string | null, trigger: RecurringTransactionTriggerEnum, ignorePaidTopUpLimits: boolean, transactionMetadata?: Array<{ __typename?: 'TransactionMetadata', key: string, value: string }> | null }> | null };

export type GetCustomerInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerInfosForWalletFormQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, timezone?: TimezoneEnum | null } | null };

export type GetWalletInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWalletInfosForWalletFormQuery = { __typename?: 'Query', wallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> | null } | null, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', expirationAt?: any | null, grantedCredits: string, interval?: RecurringTransactionIntervalEnum | null, invoiceRequiresSuccessfulPayment: boolean, lagoId: string, method: RecurringTransactionMethodEnum, paidCredits: string, startedAt?: any | null, targetOngoingBalance?: string | null, thresholdCredits?: string | null, transactionName?: string | null, trigger: RecurringTransactionTriggerEnum, ignorePaidTopUpLimits: boolean, transactionMetadata?: Array<{ __typename?: 'TransactionMetadata', key: string, value: string }> | null }> | null } | null };

export type CreateCustomerWalletMutationVariables = Exact<{
  input: CreateCustomerWalletInput;
}>;


export type CreateCustomerWalletMutation = { __typename?: 'Mutation', createCustomerWallet?: { __typename?: 'Wallet', id: string, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type UpdateCustomerWalletMutationVariables = Exact<{
  input: UpdateCustomerWalletInput;
}>;


export type UpdateCustomerWalletMutation = { __typename?: 'Mutation', updateCustomerWallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, code: string, name: string }> | null } | null, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', expirationAt?: any | null, grantedCredits: string, interval?: RecurringTransactionIntervalEnum | null, invoiceRequiresSuccessfulPayment: boolean, lagoId: string, method: RecurringTransactionMethodEnum, paidCredits: string, startedAt?: any | null, targetOngoingBalance?: string | null, thresholdCredits?: string | null, transactionName?: string | null, trigger: RecurringTransactionTriggerEnum, ignorePaidTopUpLimits: boolean, transactionMetadata?: Array<{ __typename?: 'TransactionMetadata', key: string, value: string }> | null }> | null } | null };

export type GetWalletForTopUpQueryVariables = Exact<{
  walletId: Scalars['ID']['input'];
}>;


export type GetWalletForTopUpQuery = { __typename?: 'Query', wallet?: { __typename?: 'Wallet', id: string, name?: string | null, currency: CurrencyEnum, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number } | null };

export type WalletForTopUpFragment = { __typename?: 'Wallet', id: string, name?: string | null, currency: CurrencyEnum, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, paidTopUpMinAmountCents?: any | null, paidTopUpMaxAmountCents?: any | null, priority: number };

export type BillableMetricForWalletScopeSectionFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string };

export type WalletForScopeSectionFragment = { __typename?: 'Wallet', id: string, appliesTo?: { __typename?: 'WalletAppliesTo', feeTypes?: Array<FeeTypesEnum> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null } | null };

export type GetBillableMetricsForWalletQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetBillableMetricsForWalletQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }>, metadata: { __typename?: 'CollectionMetadata', totalCount: number } } };

export const ActivityLogsTableDataFragmentDoc = gql`
    fragment ActivityLogsTableData on ActivityLog {
  activityId
  activityType
  activityObject
  loggedAt
  externalCustomerId
  externalSubscriptionId
}
    `;
export const DeleteAddOnFragmentDoc = gql`
    fragment DeleteAddOn on AddOn {
  id
  name
}
    `;
export const MrrDataForOverviewSectionFragmentDoc = gql`
    fragment MrrDataForOverviewSection on DataApiMrr {
  endOfPeriodDt
  endingMrr
  mrrChange
  mrrChurn
  mrrContraction
  mrrExpansion
  mrrNew
  startOfPeriodDt
  startingMrr
}
    `;
export const PrepaidCreditsDataForOverviewSectionFragmentDoc = gql`
    fragment PrepaidCreditsDataForOverviewSection on DataApiPrepaidCredit {
  amountCurrency
  consumedAmount
  consumedCreditsQuantity
  endOfPeriodDt
  offeredAmount
  offeredCreditsQuantity
  purchasedAmount
  purchasedCreditsQuantity
  startOfPeriodDt
  voidedAmount
  voidedCreditsQuantity
}
    `;
export const RevenueStreamDataForOverviewSectionFragmentDoc = gql`
    fragment RevenueStreamDataForOverviewSection on DataApiRevenueStream {
  commitmentFeeAmountCents
  couponsAmountCents
  endOfPeriodDt
  grossRevenueAmountCents
  netRevenueAmountCents
  oneOffFeeAmountCents
  startOfPeriodDt
  subscriptionFeeAmountCents
  usageBasedFeeAmountCents
  contraRevenueAmountCents
  creditNotesCreditsAmountCents
  freeCreditsAmountCents
  prepaidCreditsAmountCents
  progressiveBillingCreditAmountCents
}
    `;
export const BillableMetricDetailsFragmentDoc = gql`
    fragment BillableMetricDetails on BillableMetric {
  name
  code
  description
  aggregationType
  fieldName
  recurring
  expression
  weightedInterval
  roundingFunction
  roundingPrecision
  filters {
    id
    key
    values
  }
}
    `;
export const DeleteBillableMetricDialogFragmentDoc = gql`
    fragment DeleteBillableMetricDialog on BillableMetric {
  id
  name
  hasDraftInvoices
  hasActiveSubscriptions
}
    `;
export const CouponCaptionFragmentDoc = gql`
    fragment CouponCaption on Coupon {
  id
  amountCurrency
  amountCents
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const CouponDetailsForOverviewFragmentDoc = gql`
    fragment CouponDetailsForOverview on Coupon {
  name
  code
  couponType
  amountCurrency
  status
  frequency
  reusable
  expirationAt
  amountCents
  amountCurrency
  percentageRate
  billableMetrics {
    id
    name
  }
  plans {
    id
    name
  }
}
    `;
export const DeleteCouponFragmentDoc = gql`
    fragment DeleteCoupon on Coupon {
  id
  name
  appliedCouponsCount
}
    `;
export const TerminateCouponFragmentDoc = gql`
    fragment TerminateCoupon on Coupon {
  id
  name
}
    `;
export const CustomerForCreditNoteDetailsExternalSyncFragmentDoc = gql`
    fragment CustomerForCreditNoteDetailsExternalSync on Customer {
  anrokCustomer {
    id
    integrationId
    externalAccountId
  }
  avalaraCustomer {
    id
    integrationId
  }
  netsuiteCustomer {
    id
    integrationId
  }
  xeroCustomer {
    id
    integrationId
  }
}
    `;
export const CreditNoteDetailsForOverviewTableFragmentDoc = gql`
    fragment CreditNoteDetailsForOverviewTable on CreditNote {
  id
  invoice {
    id
    invoiceType
    number
  }
  items {
    amountCents
    amountCurrency
    fee {
      id
      amountCents
      eventsCount
      units
      feeType
      itemName
      groupedBy
      invoiceName
      appliedTaxes {
        id
        taxRate
      }
      trueUpParentFee {
        id
      }
      charge {
        id
        billableMetric {
          id
          name
          aggregationType
        }
      }
      subscription {
        id
        name
        plan {
          id
          name
          invoiceDisplayName
        }
      }
      chargeFilter {
        invoiceDisplayName
        values
      }
    }
  }
  couponsAdjustmentAmountCents
  currency
  subTotalExcludingTaxesAmountCents
  appliedTaxes {
    id
    amountCents
    baseAmountCents
    taxRate
    taxName
  }
  creditAmountCents
  refundAmountCents
  totalAmountCents
}
    `;
export const CreditNoteTableItemFragmentDoc = gql`
    fragment CreditNoteTableItem on CreditNote {
  id
  number
  totalAmountCents
  refundAmountCents
  creditAmountCents
  currency
  createdAt
  canBeVoided
  voidedAt
  taxProviderSyncable
  errorDetails {
    id
    errorCode
    errorDetails
  }
  invoice {
    id
    number
    customer {
      id
      name
      displayName
      applicableTimezone
    }
  }
  billingEntity {
    name
    code
  }
}
    `;
export const CreditNotesForTableFragmentDoc = gql`
    fragment CreditNotesForTable on CreditNoteCollection {
  metadata {
    currentPage
    totalPages
    totalCount
  }
  collection {
    id
    ...CreditNoteTableItem
  }
}
    ${CreditNoteTableItemFragmentDoc}`;
export const PortalInvoiceListItemFragmentDoc = gql`
    fragment PortalInvoiceListItem on Invoice {
  id
  paymentStatus
  paymentOverdue
  paymentDisputeLostAt
  number
  issuingDate
  totalAmountCents
  currency
  invoiceType
}
    `;
export const SubscriptionForPortalUsageFragmentDoc = gql`
    fragment SubscriptionForPortalUsage on Subscription {
  id
  currentBillingPeriodEndingAt
  name
  plan {
    id
    name
    invoiceDisplayName
    code
    amountCents
    amountCurrency
    interval
  }
  customer {
    id
    currency
    applicableTimezone
  }
  lifetimeUsage {
    lastThresholdAmountCents
    nextThresholdAmountCents
    totalUsageAmountCents
    totalUsageFromDatetime
    totalUsageToDatetime
  }
}
    `;
export const CustomerPortalWalletInfoFragmentDoc = gql`
    fragment CustomerPortalWalletInfo on CustomerPortalWallet {
  id
  name
  currency
  balanceCents
  creditsBalance
  expirationAt
  consumedCredits
  consumedAmountCents
  status
  creditsOngoingBalance
  ongoingBalanceCents
  rateAmount
  lastBalanceSyncAt
  paidTopUpMinAmountCents
  paidTopUpMaxAmountCents
}
    `;
export const CouponPlansForCustomerFragmentDoc = gql`
    fragment CouponPlansForCustomer on Plan {
  id
  name
}
    `;
export const CouponBillableMetricsForCustomerFragmentDoc = gql`
    fragment CouponBillableMetricsForCustomer on BillableMetric {
  id
  name
}
    `;
export const InvoiceForFinalizeInvoiceFragmentDoc = gql`
    fragment InvoiceForFinalizeInvoice on Invoice {
  id
  issuingDate
  customer {
    id
    applicableTimezone
  }
}
    `;
export const InvoiceForUpdateInvoicePaymentStatusFragmentDoc = gql`
    fragment InvoiceForUpdateInvoicePaymentStatus on Invoice {
  id
  paymentStatus
}
    `;
export const InvoiceListItemFragmentDoc = gql`
    fragment InvoiceListItem on Invoice {
  id
  status
  taxStatus
  paymentStatus
  paymentOverdue
  number
  issuingDate
  totalAmountCents
  totalDueAmountCents
  totalPaidAmountCents
  currency
  voidable
  paymentDisputeLostAt
  taxProviderVoidable
  invoiceType
  creditableAmountCents
  refundableAmountCents
  associatedActiveWalletPresent
  voidedInvoiceId
  regeneratedInvoiceId
  customer {
    id
    name
    displayName
    applicableTimezone
    paymentProvider
  }
  errorDetails {
    errorCode
    errorDetails
  }
  billingEntity {
    name
    code
  }
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
}
    ${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}`;
export const InvoiceForInvoiceListFragmentDoc = gql`
    fragment InvoiceForInvoiceList on InvoiceCollection {
  collection {
    id
    customer {
      id
      applicableTimezone
    }
    ...InvoiceListItem
  }
  metadata {
    currentPage
    totalCount
    totalPages
  }
}
    ${InvoiceListItemFragmentDoc}`;
export const CustomerAppliedTaxRatesForSettingsFragmentDoc = gql`
    fragment CustomerAppliedTaxRatesForSettings on Customer {
  id
  taxes {
    id
    name
    code
    rate
    autoGenerated
  }
}
    `;
export const CustomerAppliedDunningCampaignForSettingsFragmentDoc = gql`
    fragment CustomerAppliedDunningCampaignForSettings on Customer {
  currency
  appliedDunningCampaign {
    id
    appliedToOrganization
    code
    name
    thresholds {
      currency
    }
  }
  excludeFromDunningCampaign
}
    `;
export const CustomerAppliedInvoiceCustomSectionsFragmentDoc = gql`
    fragment CustomerAppliedInvoiceCustomSections on Customer {
  configurableInvoiceCustomSections {
    id
    name
  }
  skipInvoiceCustomSections
}
    `;
export const DeleteCustomerDialogFragmentDoc = gql`
    fragment DeleteCustomerDialog on Customer {
  id
  name
  displayName
}
    `;
export const DeleteCustomerDocumentLocaleFragmentDoc = gql`
    fragment DeleteCustomerDocumentLocale on Customer {
  id
  name
  displayName
  externalId
}
    `;
export const DeleteCustomerFinalizeZeroAmountInvoiceFragmentDoc = gql`
    fragment DeleteCustomerFinalizeZeroAmountInvoice on Customer {
  id
  externalId
  name
  displayName
  finalizeZeroAmountInvoice
}
    `;
export const DeleteCustomerGracePeriodFragmentDoc = gql`
    fragment DeleteCustomerGracePeriod on Customer {
  id
  name
  displayName
}
    `;
export const DeleteCustomerNetPaymentTermFragmentDoc = gql`
    fragment DeleteCustomerNetPaymentTerm on Customer {
  id
  externalId
  name
  displayName
  netPaymentTerm
}
    `;
export const CustomerForDeleteVatRateDialogFragmentDoc = gql`
    fragment CustomerForDeleteVatRateDialog on Customer {
  id
  name
  externalId
  taxes {
    id
    code
  }
}
    `;
export const TaxRateForDeleteCustomerVatRateDialogFragmentDoc = gql`
    fragment TaxRateForDeleteCustomerVatRateDialog on Tax {
  id
  name
}
    `;
export const EditCustomerDocumentLocaleFragmentDoc = gql`
    fragment EditCustomerDocumentLocale on Customer {
  id
  name
  displayName
  externalId
  billingConfiguration {
    id
    documentLocale
  }
}
    `;
export const EditCustomerDunningCampaignFragmentDoc = gql`
    fragment EditCustomerDunningCampaign on Customer {
  id
  externalId
  currency
  appliedDunningCampaign {
    id
  }
  excludeFromDunningCampaign
}
    `;
export const EditCustomerInvoiceCustomSectionFragmentDoc = gql`
    fragment EditCustomerInvoiceCustomSection on Customer {
  id
  externalId
  configurableInvoiceCustomSections {
    id
  }
  hasOverwrittenInvoiceCustomSectionsSelection
  skipInvoiceCustomSections
}
    `;
export const EditCustomerInvoiceGracePeriodFragmentDoc = gql`
    fragment EditCustomerInvoiceGracePeriod on Customer {
  id
  invoiceGracePeriod
}
    `;
export const EditCustomerVatRateFragmentDoc = gql`
    fragment EditCustomerVatRate on Customer {
  id
  name
  displayName
  externalId
  taxes {
    id
    code
  }
}
    `;
export const CreditNoteForVoidCreditNoteDialogFragmentDoc = gql`
    fragment CreditNoteForVoidCreditNoteDialog on CreditNote {
  id
  totalAmountCents
  currency
}
    `;
export const AppliedCouponCaptionFragmentDoc = gql`
    fragment AppliedCouponCaption on AppliedCoupon {
  id
  amountCurrency
  amountCents
  amountCentsRemaining
  percentageRate
  frequency
  frequencyDuration
  frequencyDurationRemaining
}
    `;
export const CustomerCouponFragmentDoc = gql`
    fragment CustomerCoupon on AppliedCoupon {
  id
  ...AppliedCouponCaption
  coupon {
    id
    name
    code
  }
}
    ${AppliedCouponCaptionFragmentDoc}`;
export const CustomerAppliedCouponsFragmentDoc = gql`
    fragment CustomerAppliedCoupons on Customer {
  id
  appliedCoupons {
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export const CustomerUsageForUsageDetailsFragmentDoc = gql`
    fragment CustomerUsageForUsageDetails on CustomerUsage {
  fromDatetime
  toDatetime
  chargesUsage {
    id
    pricingUnitAmountCents
    charge {
      id
      invoiceDisplayName
      appliedPricingUnit {
        id
        pricingUnit {
          id
          shortName
        }
      }
    }
    billableMetric {
      name
    }
    filters {
      id
      amountCents
      units
      values
      invoiceDisplayName
      pricingUnitAmountCents
    }
    groupedUsage {
      id
      amountCents
      groupedBy
      eventsCount
      units
      pricingUnitAmountCents
      filters {
        id
        amountCents
        units
        values
        invoiceDisplayName
        pricingUnitAmountCents
      }
    }
  }
}
    `;
export const CustomerProjectedUsageForUsageDetailsFragmentDoc = gql`
    fragment CustomerProjectedUsageForUsageDetails on CustomerProjectedUsage {
  fromDatetime
  toDatetime
  chargesUsage {
    id
    pricingUnitAmountCents
    pricingUnitProjectedAmountCents
    charge {
      id
      invoiceDisplayName
      appliedPricingUnit {
        id
        pricingUnit {
          id
          shortName
        }
      }
    }
    billableMetric {
      name
    }
    filters {
      id
      amountCents
      units
      values
      invoiceDisplayName
      pricingUnitAmountCents
      projectedAmountCents
      pricingUnitProjectedAmountCents
      projectedUnits
    }
    groupedUsage {
      id
      amountCents
      groupedBy
      eventsCount
      units
      pricingUnitAmountCents
      projectedAmountCents
      pricingUnitProjectedAmountCents
      projectedUnits
      filters {
        id
        amountCents
        units
        values
        invoiceDisplayName
        pricingUnitAmountCents
        projectedAmountCents
        pricingUnitProjectedAmountCents
        projectedUnits
      }
    }
  }
}
    `;
export const ActivityLogDetailsFragmentDoc = gql`
    fragment ActivityLogDetails on ActivityLog {
  activityType
  activitySource
  activityObject
  activityObjectChanges
  apiKey {
    value
    name
  }
  resource {
    ... on BillableMetric {
      id
    }
    ... on BillingEntity {
      id
      code
    }
    ... on Coupon {
      id
    }
    ... on CreditNote {
      id
      customer {
        id
      }
      invoice {
        id
      }
    }
    ... on Customer {
      id
    }
    ... on Invoice {
      id
      customer {
        id
      }
    }
    ... on FeatureObject {
      id
    }
    ... on Plan {
      id
    }
    ... on PaymentRequest {
      id
    }
    ... on Subscription {
      id
    }
    ... on Wallet {
      id
      walletCustomer: customer {
        id
      }
    }
  }
  loggedAt
  userEmail
  externalSubscriptionId
  externalCustomerId
}
    `;
export const ActivityItemFragmentDoc = gql`
    fragment ActivityItem on ActivityLog {
  activityId
  activityType
  activityObject
  externalCustomerId
  externalSubscriptionId
  loggedAt
}
    `;
export const ApiKeyRevealedForApiKeysListFragmentDoc = gql`
    fragment ApiKeyRevealedForApiKeysList on ApiKey {
  id
  value
}
    `;
export const ApiKeyForDeleteApiKeyDialogFragmentDoc = gql`
    fragment ApiKeyForDeleteApiKeyDialog on SanitizedApiKey {
  id
  lastUsedAt
}
    `;
export const ApiKeyForRotateApiKeyDialogFragmentDoc = gql`
    fragment ApiKeyForRotateApiKeyDialog on SanitizedApiKey {
  id
  lastUsedAt
  name
}
    `;
export const ApiLogDetailsFragmentDoc = gql`
    fragment ApiLogDetails on ApiLog {
  apiVersion
  client
  httpMethod
  httpStatus
  loggedAt
  requestBody
  requestId
  requestOrigin
  requestPath
  requestResponse
  apiKey {
    name
    value
  }
}
    `;
export const ApiLogItemFragmentDoc = gql`
    fragment ApiLogItem on ApiLog {
  requestId
  httpMethod
  httpStatus
  requestPath
  loggedAt
}
    `;
export const EventDetailsFragmentDoc = gql`
    fragment EventDetails on Event {
  id
  code
  transactionId
  timestamp
  receivedAt
  payload
  billableMetricName
  matchBillableMetric
  matchCustomField
  apiClient
  ipAddress
  externalSubscriptionId
  customerTimezone
}
    `;
export const EventItemFragmentDoc = gql`
    fragment EventItem on Event {
  id
  transactionId
  code
  receivedAt
}
    `;
export const WebhookForCreateAndEditFragmentDoc = gql`
    fragment WebhookForCreateAndEdit on WebhookEndpoint {
  id
  webhookUrl
  signatureAlgo
}
    `;
export const WebhookLogDetailsFragmentDoc = gql`
    fragment WebhookLogDetails on Webhook {
  id
  webhookType
  status
  payload
  response
  httpStatus
  endpoint
  retries
  updatedAt
}
    `;
export const WebhookLogFragmentDoc = gql`
    fragment WebhookLog on Webhook {
  id
  status
  webhookType
  createdAt
  updatedAt
  endpoint
}
    `;
export const CustomerForDunningEmailFragmentDoc = gql`
    fragment CustomerForDunningEmail on Customer {
  displayName
  paymentProvider
  netPaymentTerm
  billingConfiguration {
    documentLocale
  }
}
    `;
export const OrganizationForDunningEmailFragmentDoc = gql`
    fragment OrganizationForDunningEmail on CurrentOrganization {
  name
  logoUrl
  email
  netPaymentTerm
  billingConfiguration {
    documentLocale
  }
}
    `;
export const InvoicesForDunningEmailFragmentDoc = gql`
    fragment InvoicesForDunningEmail on Invoice {
  id
  number
  totalDueAmountCents
  currency
}
    `;
export const FeatureForDeleteFeatureDialogFragmentDoc = gql`
    fragment FeatureForDeleteFeatureDialog on FeatureObject {
  id
}
    `;
export const FeatureDetailsFragmentDoc = gql`
    fragment FeatureDetails on FeatureObject {
  id
  name
  code
  description
  privileges {
    id
    name
    code
    valueType
    config {
      selectOptions
    }
  }
}
    `;
export const InvoiceMetadatasForMetadataDrawerFragmentDoc = gql`
    fragment InvoiceMetadatasForMetadataDrawer on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const TaxForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment TaxForInvoiceEditTaxDialog on Tax {
  id
  name
  rate
  code
}
    `;
export const AddOnForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment AddOnForInvoiceEditTaxDialog on AddOn {
  id
  taxes {
    id
    ...TaxForInvoiceEditTaxDialog
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;
export const CustomerMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment CustomerMetadatasForInvoiceOverview on Customer {
  id
  metadata {
    id
    displayInInvoice
    key
    value
  }
}
    `;
export const InvoiceMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceMetadatasForInvoiceOverview on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const PaymentForPaymentsListFragmentDoc = gql`
    fragment PaymentForPaymentsList on Payment {
  amountCents
  amountCurrency
  createdAt
  id
  payable {
    ... on Invoice {
      id
      number
      payableType
    }
    ... on PaymentRequest {
      payableType
      invoices {
        id
      }
    }
  }
  payablePaymentStatus
  paymentProviderType
  paymentType
  providerPaymentId
  reference
  customer {
    id
    name
    displayName
    applicableTimezone
  }
  paymentReceipt {
    id
  }
}
    `;
export const InvoiceForVoidInvoiceDialogFragmentDoc = gql`
    fragment InvoiceForVoidInvoiceDialog on Invoice {
  id
  number
}
    `;
export const InvoiceSubscriptionForCreateFeeDrawerFragmentDoc = gql`
    fragment InvoiceSubscriptionForCreateFeeDrawer on InvoiceSubscription {
  subscription {
    id
    plan {
      id
      charges {
        id
        invoiceDisplayName
        chargeModel
        prorated
        properties {
          amount
        }
        filters {
          id
          invoiceDisplayName
          values
        }
        billableMetric {
          id
          name
          code
        }
      }
    }
  }
  fees {
    id
    charge {
      id
      filters {
        id
        values
      }
      properties {
        graduatedRanges {
          flatAmount
          fromValue
          perUnitAmount
          toValue
        }
        graduatedPercentageRanges {
          flatAmount
          fromValue
          rate
          toValue
        }
      }
    }
    chargeFilter {
      id
    }
    pricingUnitUsage {
      shortName
    }
  }
}
    `;
export const FeeForCustomerInvoiceRegenerateFragmentDoc = gql`
    fragment FeeForCustomerInvoiceRegenerate on Fee {
  id
  appliedTaxes {
    id
    taxCode
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduated on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedRanges {
      flatUnitAmount
      fromValue
      perUnitAmount
      perUnitTotalAmount
      toValue
      totalWithFlatAmount
      units
    }
  }
  pricingUnitUsage {
    shortName
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduatedPercentage on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedPercentageRanges {
      flatUnitAmount
      fromValue
      perUnitTotalAmount
      rate
      toValue
      totalWithFlatAmount
      units
    }
  }
  pricingUnitUsage {
    shortName
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineVolume on Fee {
  id
  units
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    flatUnitAmount
    perUnitAmount
    perUnitTotalAmount
  }
  pricingUnitUsage {
    shortName
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePackage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    paidUnits
    perPackageSize
    perPackageUnitAmount
  }
  pricingUnitUsage {
    amountCents
    shortName
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePercentage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    fixedFeeTotalAmount
    fixedFeeUnitAmount
    freeEvents
    freeUnits
    minMaxAdjustmentTotalAmount
    paidEvents
    paidUnits
    perUnitTotalAmount
    rate
    units
  }
  pricingUnitUsage {
    shortName
  }
}
    `;
export const FeeForEditfeeDrawerFragmentDoc = gql`
    fragment FeeForEditfeeDrawer on Fee {
  id
  currency
  charge {
    id
    chargeModel
    prorated
  }
}
    `;
export const FeeForDeleteAdjustmentFeeDialogFragmentDoc = gql`
    fragment FeeForDeleteAdjustmentFeeDialog on Fee {
  id
}
    `;
export const FeeForInvoiceDetailsTableBodyLineFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLine on Fee {
  id
  units
  preciseUnitAmount
  amountCents
  eventsCount
  adjustedFee
  adjustedFeeType
  succeededAt
  properties {
    fromDatetime
    toDatetime
  }
  pricingUnitUsage {
    amountCents
    conversionRate
    shortName
    preciseUnitAmount
  }
  charge {
    id
    chargeModel
    minAmountCents
    payInAdvance
    prorated
    billableMetric {
      id
      recurring
    }
  }
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    fixedFeeUnitAmount
    flatUnitAmount
    graduatedRanges {
      toValue
    }
    graduatedPercentageRanges {
      toValue
    }
  }
  ...FeeForInvoiceDetailsTableBodyLineGraduated
  ...FeeForInvoiceDetailsTableBodyLineGraduatedPercentage
  ...FeeForInvoiceDetailsTableBodyLineVolume
  ...FeeForInvoiceDetailsTableBodyLinePackage
  ...FeeForInvoiceDetailsTableBodyLinePercentage
  ...FeeForEditfeeDrawer
  ...FeeForDeleteAdjustmentFeeDialog
}
    ${FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}`;
export const FeeForInvoiceFeeArrearsDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeArrearsDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeAdvanceDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTable on Fee {
  id
  amountCents
  description
  feeType
  invoiceDisplayName
  invoiceName
  itemName
  units
  preciseUnitAmount
  charge {
    id
    payInAdvance
    invoiceDisplayName
    billableMetric {
      id
      name
      aggregationType
    }
  }
  chargeFilter {
    invoiceDisplayName
    values
  }
  walletTransaction {
    id
    name
    wallet {
      id
      name
    }
  }
  ...FeeForCustomerInvoiceRegenerate
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForInvoiceFeeArrearsDetailsTable
  ...FeeForInvoiceFeeAdvanceDetailsTable
}
    ${FeeForCustomerInvoiceRegenerateFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForInvoiceFeeArrearsDetailsTableFragmentDoc}
${FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc}`;
export const InvoiceSubscriptionFormatingFragmentDoc = gql`
    fragment InvoiceSubscriptionFormating on InvoiceSubscription {
  fromDatetime
  toDatetime
  chargesFromDatetime
  chargesToDatetime
  inAdvanceChargesFromDatetime
  inAdvanceChargesToDatetime
  fees {
    id
    amountCents
    invoiceName
    invoiceDisplayName
    units
    groupedBy
    charge {
      id
      payInAdvance
      minAmountCents
      billableMetric {
        id
        name
      }
    }
    chargeFilter {
      invoiceDisplayName
      values
    }
    subscription {
      id
      plan {
        id
        interval
      }
    }
  }
  subscription {
    id
    name
    plan {
      id
      name
      invoiceDisplayName
    }
  }
  invoice {
    id
    status
    chargeAmountCents
    progressiveBillingCreditAmountCents
  }
}
    `;
export const InvoiceSubscriptionForInvoiceDetailsTableFragmentDoc = gql`
    fragment InvoiceSubscriptionForInvoiceDetailsTable on InvoiceSubscription {
  fromDatetime
  toDatetime
  chargesFromDatetime
  chargesToDatetime
  inAdvanceChargesFromDatetime
  inAdvanceChargesToDatetime
  acceptNewChargeFees
  subscriptionAmountCents
  invoice {
    chargeAmountCents
    progressiveBillingCreditAmountCents
  }
  subscription {
    id
    name
    plan {
      id
      name
      interval
      amountCents
      amountCurrency
      invoiceDisplayName
      billChargesMonthly
    }
  }
  fees {
    id
    subscription {
      id
      name
      plan {
        id
        name
        invoiceDisplayName
      }
    }
    ...FeeForInvoiceDetailsTable
  }
  ...InvoiceSubscriptionFormating
}
    ${FeeForInvoiceDetailsTableFragmentDoc}
${InvoiceSubscriptionFormatingFragmentDoc}`;
export const FeatureObjectEntitlementPrivilegeForPlanFragmentDoc = gql`
    fragment FeatureObjectEntitlementPrivilegeForPlan on FeatureObject {
  id
  code
  name
  privileges {
    id
    name
    code
    valueType
    config {
      selectOptions
    }
  }
}
    `;
export const BillableMetricForUsageChargeSectionFragmentDoc = gql`
    fragment BillableMetricForUsageChargeSection on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const AddOnForFixedChargesSectionFragmentDoc = gql`
    fragment AddOnForFixedChargesSection on AddOn {
  id
  name
  code
}
    `;
export const DeleteOktaIntegrationDialogFragmentDoc = gql`
    fragment DeleteOktaIntegrationDialog on OktaIntegration {
  id
  name
}
    `;
export const AddOktaIntegrationDialogFragmentDoc = gql`
    fragment AddOktaIntegrationDialog on OktaIntegration {
  id
  domain
  clientId
  clientSecret
  organizationName
  ...DeleteOktaIntegrationDialog
}
    ${DeleteOktaIntegrationDialogFragmentDoc}`;
export const DeleteCampaignFragmentDoc = gql`
    fragment DeleteCampaign on DunningCampaign {
  id
  appliedToOrganization
}
    `;
export const OrganizationInfoForPreviewDunningCampaignFragmentDoc = gql`
    fragment OrganizationInfoForPreviewDunningCampaign on CurrentOrganization {
  name
  email
  logoUrl
}
    `;
export const AddAdyenProviderDialogFragmentDoc = gql`
    fragment AddAdyenProviderDialog on AdyenProvider {
  id
  name
  code
  apiKey
  hmacKey
  livePrefix
  merchantAccount
}
    `;
export const AddCashfreeProviderDialogFragmentDoc = gql`
    fragment AddCashfreeProviderDialog on CashfreeProvider {
  id
  name
  code
  clientId
  clientSecret
  successRedirectUrl
}
    `;
export const AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment AdyenForCreateAndEditSuccessRedirectUrl on AdyenProvider {
  id
  successRedirectUrl
}
    `;
export const CashfreeForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment CashfreeForCreateAndEditSuccessRedirectUrl on CashfreeProvider {
  id
  successRedirectUrl
}
    `;
export const FlutterwaveForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment FlutterwaveForCreateAndEditSuccessRedirectUrl on FlutterwaveProvider {
  id
  successRedirectUrl
}
    `;
export const GocardlessForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment gocardlessForCreateAndEditSuccessRedirectUrl on GocardlessProvider {
  id
  successRedirectUrl
}
    `;
export const StripeForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment StripeForCreateAndEditSuccessRedirectUrl on StripeProvider {
  id
  successRedirectUrl
}
    `;
export const MoneyhashForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment MoneyhashForCreateAndEditSuccessRedirectUrl on MoneyhashProvider {
  id
  flowId
  successRedirectUrl
}
    `;
export const AddFlutterwaveProviderDialogFragmentDoc = gql`
    fragment AddFlutterwaveProviderDialog on FlutterwaveProvider {
  id
  name
  code
  secretKey
  webhookSecret
  successRedirectUrl
}
    `;
export const AddGocardlessProviderDialogFragmentDoc = gql`
    fragment AddGocardlessProviderDialog on GocardlessProvider {
  id
  name
  code
}
    `;
export const AddMoneyhashProviderDialogFragmentDoc = gql`
    fragment AddMoneyhashProviderDialog on MoneyhashProvider {
  id
  name
  code
  apiKey
  flowId
}
    `;
export const AddStripeProviderDialogFragmentDoc = gql`
    fragment AddStripeProviderDialog on StripeProvider {
  id
  name
  code
  secretKey
}
    `;
export const AnrokIntegrationItemsListAddonsFragmentDoc = gql`
    fragment AnrokIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AnrokIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment AnrokIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AnrokIntegrationItemsListDefaultFragmentDoc = gql`
    fragment AnrokIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
}
    `;
export const AnrokIntegrationMapItemDialogFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialog on IntegrationItem {
  id
  externalId
  externalName
  externalAccountCode
  itemType
}
    `;
export const AnrokIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AnrokIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AnrokIntegrationSettingsFragmentDoc = gql`
    fragment AnrokIntegrationSettings on AnrokIntegration {
  id
  name
  code
  apiKey
  hasMappingsConfigured
  failedInvoicesCount
}
    `;
export const AvalaraIntegrationItemsFragmentDoc = gql`
    fragment AvalaraIntegrationItems on AvalaraIntegration {
  id
}
    `;
export const AvalaraIntegrationItemsListAddonsFragmentDoc = gql`
    fragment AvalaraIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AvalaraIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment AvalaraIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AvalaraIntegrationItemsListDefaultFragmentDoc = gql`
    fragment AvalaraIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
}
    `;
export const AvalaraIntegrationMapItemDialogFragmentDoc = gql`
    fragment AvalaraIntegrationMapItemDialog on IntegrationItem {
  id
  externalId
  externalName
  externalAccountCode
  itemType
}
    `;
export const AvalaraIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment AvalaraIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AvalaraIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment AvalaraIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AvalaraIntegrationSettingsFragmentDoc = gql`
    fragment AvalaraIntegrationSettings on AvalaraIntegration {
  id
  accountId
  code
  companyCode
  failedInvoicesCount
  hasMappingsConfigured
  licenseKey
  name
}
    `;
export const DeleteAdyenIntegrationDialogFragmentDoc = gql`
    fragment DeleteAdyenIntegrationDialog on AdyenProvider {
  id
  name
}
    `;
export const DeleteCashfreeIntegrationDialogFragmentDoc = gql`
    fragment DeleteCashfreeIntegrationDialog on CashfreeProvider {
  id
  name
}
    `;
export const DeleteFlutterwaveIntegrationDialogFragmentDoc = gql`
    fragment DeleteFlutterwaveIntegrationDialog on FlutterwaveProvider {
  id
  name
}
    `;
export const DeleteGocardlessIntegrationDialogFragmentDoc = gql`
    fragment DeleteGocardlessIntegrationDialog on GocardlessProvider {
  id
  name
}
    `;
export const DeleteMoneyhashIntegrationDialogFragmentDoc = gql`
    fragment DeleteMoneyhashIntegrationDialog on MoneyhashProvider {
  id
  name
}
    `;
export const DeleteStripeIntegrationDialogFragmentDoc = gql`
    fragment DeleteStripeIntegrationDialog on StripeProvider {
  id
  name
}
    `;
export const NetsuiteIntegrationItemsListAddonsFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const NetsuiteIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const NetsuiteIntegrationItemsListDefaultFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
  taxCode
  taxNexus
  taxType
}
    `;
export const NetsuiteIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment NetsuiteIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const NetsuiteIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment NetsuiteIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const NetsuiteIntegrationSettingsFragmentDoc = gql`
    fragment NetsuiteIntegrationSettings on NetsuiteIntegration {
  id
  accountId
  clientId
  clientSecret
  code
  hasMappingsConfigured
  name
  scriptEndpointUrl
  syncCreditNotes
  syncInvoices
  syncPayments
}
    `;
export const XeroIntegrationItemsListAddonsFragmentDoc = gql`
    fragment XeroIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const XeroIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment XeroIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const XeroIntegrationItemsListDefaultFragmentDoc = gql`
    fragment XeroIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
}
    `;
export const XeroIntegrationMapItemDialogFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialog on IntegrationItem {
  id
  externalId
  externalName
  externalAccountCode
  itemType
}
    `;
export const XeroIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const XeroIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const XeroIntegrationSettingsFragmentDoc = gql`
    fragment XeroIntegrationSettings on XeroIntegration {
  id
  code
  connectionId
  hasMappingsConfigured
  name
  syncCreditNotes
  syncInvoices
  syncPayments
}
    `;
export const DeleteCustomSectionFragmentDoc = gql`
    fragment DeleteCustomSection on InvoiceCustomSection {
  id
}
    `;
export const EditBillingEntityInvoiceNumberingDialogFragmentDoc = gql`
    fragment EditBillingEntityInvoiceNumberingDialog on BillingEntity {
  id
  documentNumbering
  documentNumberPrefix
}
    `;
export const EditBillingEntityInvoiceTemplateDialogFragmentDoc = gql`
    fragment EditBillingEntityInvoiceTemplateDialog on BillingEntity {
  billingConfiguration {
    id
    invoiceFooter
  }
}
    `;
export const EditBillingEntityDefaultCurrencyForDialogFragmentDoc = gql`
    fragment EditBillingEntityDefaultCurrencyForDialog on BillingEntity {
  id
  defaultCurrency
}
    `;
export const EditCustomerFinalizeZeroAmountInvoiceForDialogFragmentDoc = gql`
    fragment EditCustomerFinalizeZeroAmountInvoiceForDialog on Customer {
  id
  externalId
  name
  finalizeZeroAmountInvoice
}
    `;
export const EditBillingEntityFinalizeZeroAmountInvoiceForDialogFragmentDoc = gql`
    fragment EditBillingEntityFinalizeZeroAmountInvoiceForDialog on BillingEntity {
  id
  finalizeZeroAmountInvoice
}
    `;
export const EditCustomerNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditCustomerNetPaymentTermForDialog on Customer {
  id
  externalId
  name
  netPaymentTerm
}
    `;
export const EditBillingEntityNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditBillingEntityNetPaymentTermForDialog on BillingEntity {
  id
  netPaymentTerm
}
    `;
export const InviteForRolePickerFieldFragmentDoc = gql`
    fragment InviteForRolePickerField on Invite {
  id
  role
}
    `;
export const SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc = gql`
    fragment SubscriptionCurrentUsageTableComponentCustomerUsage on CustomerUsage {
  amountCents
  currency
  fromDatetime
  toDatetime
  chargesUsage {
    id
    units
    amountCents
    pricingUnitAmountCents
    charge {
      id
      invoiceDisplayName
      appliedPricingUnit {
        id
        pricingUnit {
          id
          shortName
        }
      }
    }
    billableMetric {
      id
      code
      name
    }
    filters {
      id
    }
    groupedUsage {
      amountCents
      groupedBy
      eventsCount
      units
      filters {
        id
      }
    }
  }
}
    `;
export const SubscriptionCurrentUsageTableComponentCustomerProjectedUsageFragmentDoc = gql`
    fragment SubscriptionCurrentUsageTableComponentCustomerProjectedUsage on CustomerProjectedUsage {
  amountCents
  projectedAmountCents
  currency
  fromDatetime
  toDatetime
  chargesUsage {
    id
    units
    amountCents
    pricingUnitAmountCents
    projectedUnits
    projectedAmountCents
    pricingUnitProjectedAmountCents
    charge {
      id
      invoiceDisplayName
      appliedPricingUnit {
        id
        pricingUnit {
          id
          shortName
        }
      }
    }
    billableMetric {
      id
      code
      name
    }
    filters {
      id
    }
    groupedUsage {
      amountCents
      groupedBy
      eventsCount
      units
      projectedUnits
      projectedAmountCents
      filters {
        id
      }
    }
  }
}
    `;
export const SubscriptionForSubscriptionInformationsFragmentDoc = gql`
    fragment SubscriptionForSubscriptionInformations on Subscription {
  id
  externalId
  status
  subscriptionAt
  endingAt
  terminatedAt
  nextSubscriptionAt
  nextSubscriptionType
  nextPlan {
    id
    name
  }
  customer {
    id
    name
    displayName
  }
  plan {
    id
    name
    parent {
      id
      name
    }
  }
}
    `;
export const SubscriptionUsageLifetimeGraphForLifetimeGraphFragmentDoc = gql`
    fragment SubscriptionUsageLifetimeGraphForLifetimeGraph on Subscription {
  id
  status
  lifetimeUsage {
    lastThresholdAmountCents
    nextThresholdAmountCents
    totalUsageAmountCents
    totalUsageFromDatetime
    totalUsageToDatetime
  }
  customer {
    id
    currency
    applicableTimezone
  }
  plan {
    id
  }
}
    `;
export const BillableMetricForWalletScopeSectionFragmentDoc = gql`
    fragment BillableMetricForWalletScopeSection on BillableMetric {
  id
  name
  code
}
    `;
export const WalletForScopeSectionFragmentDoc = gql`
    fragment WalletForScopeSection on Wallet {
  id
  appliesTo {
    feeTypes
    billableMetrics {
      ...BillableMetricForWalletScopeSection
    }
  }
}
    ${BillableMetricForWalletScopeSectionFragmentDoc}`;
export const WalletForUpdateFragmentDoc = gql`
    fragment WalletForUpdate on Wallet {
  id
  expirationAt
  name
  rateAmount
  invoiceRequiresSuccessfulPayment
  paidTopUpMinAmountCents
  paidTopUpMaxAmountCents
  priority
  appliesTo {
    feeTypes
    billableMetrics {
      id
    }
  }
  recurringTransactionRules {
    expirationAt
    grantedCredits
    interval
    invoiceRequiresSuccessfulPayment
    lagoId
    method
    paidCredits
    startedAt
    targetOngoingBalance
    thresholdCredits
    transactionName
    trigger
    ignorePaidTopUpLimits
    transactionMetadata {
      key
      value
    }
  }
  ...WalletForScopeSection
}
    ${WalletForScopeSectionFragmentDoc}`;
export const WalletInfosForTransactionsFragmentDoc = gql`
    fragment WalletInfosForTransactions on Wallet {
  id
  currency
  status
  ongoingUsageBalanceCents
  creditsOngoingUsageBalance
}
    `;
export const WalletAccordionFragmentDoc = gql`
    fragment WalletAccordion on Wallet {
  id
  balanceCents
  consumedAmountCents
  consumedCredits
  createdAt
  creditsBalance
  currency
  expirationAt
  lastBalanceSyncAt
  lastConsumedCreditAt
  lastOngoingBalanceSyncAt
  name
  rateAmount
  status
  terminatedAt
  ongoingBalanceCents
  creditsOngoingBalance
  priority
  ...WalletInfosForTransactions
}
    ${WalletInfosForTransactionsFragmentDoc}`;
export const CustomerWalletFragmentDoc = gql`
    fragment CustomerWallet on Wallet {
  ...WalletForUpdate
  ...WalletAccordion
  ...WalletInfosForTransactions
}
    ${WalletForUpdateFragmentDoc}
${WalletAccordionFragmentDoc}
${WalletInfosForTransactionsFragmentDoc}`;
export const WalletForVoidTransactionFragmentDoc = gql`
    fragment WalletForVoidTransaction on Wallet {
  id
  currency
  rateAmount
  creditsBalance
}
    `;
export const WalletTransactionDetailsFragmentDoc = gql`
    fragment WalletTransactionDetails on WalletTransaction {
  id
  name
  amount
  createdAt
  transactionType
  creditAmount
  settledAt
  failedAt
  status
  transactionStatus
  source
  invoiceRequiresSuccessfulPayment
  metadata {
    key
    value
  }
  invoice {
    id
    status
    invoiceType
    number
    paymentStatus
    customer {
      id
    }
    payments {
      id
      providerPaymentId
      paymentProviderType
      payablePaymentStatus
    }
  }
}
    `;
export const WalletTransactionForTransactionListItemFragmentDoc = gql`
    fragment WalletTransactionForTransactionListItem on WalletTransaction {
  id
  amount
  createdAt
  creditAmount
  failedAt
  name
  settledAt
  source
  status
  transactionStatus
  transactionType
  wallet {
    id
    currency
  }
}
    `;
export const CurrentUserFragmentDoc = gql`
    fragment CurrentUser on User {
  id
  organizations {
    id
    name
    timezone
    accessibleByCurrentSession
  }
}
    `;
export const FeeForInvoiceFeesToFeeInputFragmentDoc = gql`
    fragment FeeForInvoiceFeesToFeeInput on Fee {
  id
  description
  invoiceDisplayName
  itemName
  preciseUnitAmount
  addOn {
    id
  }
  properties {
    fromDatetime
    toDatetime
  }
}
    `;
export const InvoiceFeeFragmentDoc = gql`
    fragment InvoiceFee on Fee {
  id
  amountCurrency
  feeType
  invoiceName
  invoiceDisplayName
  groupedBy
  succeededAt
  appliedTaxes {
    id
    taxName
    taxRate
  }
  creditableAmountCents
  trueUpFee {
    id
  }
  charge {
    id
    billableMetric {
      id
      name
    }
  }
  chargeFilter {
    id
    invoiceDisplayName
    values
  }
}
    `;
export const InvoiceForCreditNoteFormCalculationFragmentDoc = gql`
    fragment InvoiceForCreditNoteFormCalculation on Invoice {
  id
  couponsAmountCents
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  feesAmountCents
  currency
  versionNumber
  paymentDisputeLostAt
  totalPaidAmountCents
  fees {
    id
    appliedTaxes {
      id
      taxName
      taxRate
    }
  }
}
    `;
export const CreateCreditNoteInvoiceFragmentDoc = gql`
    fragment CreateCreditNoteInvoice on Invoice {
  id
  currency
  number
  status
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  subTotalIncludingTaxesAmountCents
  availableToCreditAmountCents
  totalPaidAmountCents
  totalAmountCents
  paymentDisputeLostAt
  invoiceType
  ...InvoiceForCreditNoteFormCalculation
  ...InvoiceForCreditNoteFormCalculation
}
    ${InvoiceForCreditNoteFormCalculationFragmentDoc}`;
export const InvoiceCreateCreditNoteFragmentDoc = gql`
    fragment InvoiceCreateCreditNote on Invoice {
  id
  refundableAmountCents
  creditableAmountCents
  invoiceType
  fees {
    id
    amountCurrency
    itemCode
    itemName
    invoiceName
    invoiceDisplayName
    creditableAmountCents
    succeededAt
    appliedTaxes {
      id
      taxName
      taxRate
    }
    trueUpFee {
      id
    }
  }
  invoiceSubscriptions {
    subscription {
      id
      name
      plan {
        id
        name
        invoiceDisplayName
      }
    }
    fees {
      ...InvoiceFee
    }
  }
  ...CreateCreditNoteInvoice
}
    ${InvoiceFeeFragmentDoc}
${CreateCreditNoteInvoiceFragmentDoc}`;
export const TaxForTaxesSelectorSectionFragmentDoc = gql`
    fragment TaxForTaxesSelectorSection on Tax {
  id
  code
  name
  rate
}
    `;
export const EditAddOnFragmentDoc = gql`
    fragment EditAddOn on AddOn {
  id
  name
  code
  description
  amountCents
  amountCurrency
  taxes {
    id
    ...TaxForTaxesSelectorSection
  }
}
    ${TaxForTaxesSelectorSectionFragmentDoc}`;
export const BillingEntityItemFragmentDoc = gql`
    fragment BillingEntityItem on BillingEntity {
  id
  code
  documentNumbering
  documentNumberPrefix
  logoUrl
  name
  legalName
  legalNumber
  taxIdentificationNumber
  email
  addressLine1
  addressLine2
  zipcode
  city
  state
  country
  emailSettings
  timezone
  isDefault
  defaultCurrency
  euTaxManagement
  selectedInvoiceCustomSections {
    id
    name
  }
  appliedDunningCampaign {
    id
    name
    code
  }
}
    `;
export const PlansForCouponsFragmentDoc = gql`
    fragment PlansForCoupons on Plan {
  id
  name
  code
}
    `;
export const BillableMetricsForCouponsFragmentDoc = gql`
    fragment BillableMetricsForCoupons on BillableMetric {
  id
  name
  code
}
    `;
export const EditCouponFragmentDoc = gql`
    fragment EditCoupon on Coupon {
  id
  amountCents
  amountCurrency
  appliedCouponsCount
  code
  couponType
  description
  expiration
  expirationAt
  frequency
  frequencyDuration
  limitedBillableMetrics
  limitedPlans
  name
  percentageRate
  reusable
  plans {
    ...PlansForCoupons
  }
  billableMetrics {
    ...BillableMetricsForCoupons
  }
}
    ${PlansForCouponsFragmentDoc}
${BillableMetricsForCouponsFragmentDoc}`;
export const DunningCampaignFormFragmentDoc = gql`
    fragment DunningCampaignForm on DunningCampaign {
  name
  code
  description
  thresholds {
    amountCents
    currency
  }
  daysBetweenAttempts
  maxAttempts
  appliedToOrganization
  bccEmails
}
    `;
export const InvoiceCustomSectionFormFragmentDoc = gql`
    fragment InvoiceCustomSectionForm on InvoiceCustomSection {
  name
  code
  description
  details
  displayName
}
    `;
export const TaxFormFragmentDoc = gql`
    fragment TaxForm on Tax {
  id
  code
  description
  name
  rate
  customersCount
}
    `;
export const TaxFormQueryShapeFragmentDoc = gql`
    fragment TaxFormQueryShape on Tax {
  ...TaxForm
  autoGenerated
}
    ${TaxFormFragmentDoc}`;
export const MembershipPermissionsFragmentDoc = gql`
    fragment MembershipPermissions on Membership {
  id
  permissions {
    addonsCreate
    addonsDelete
    addonsUpdate
    addonsView
    analyticsView
    analyticsOverdueBalancesView
    auditLogsView
    authenticationMethodsView
    authenticationMethodsUpdate
    billableMetricsCreate
    billableMetricsDelete
    billableMetricsUpdate
    billableMetricsView
    billingEntitiesView
    billingEntitiesCreate
    billingEntitiesUpdate
    billingEntitiesDelete
    billingEntitiesInvoicesView
    billingEntitiesInvoicesUpdate
    billingEntitiesTaxesView
    billingEntitiesTaxesUpdate
    billingEntitiesEmailsView
    billingEntitiesEmailsUpdate
    billingEntitiesDunningCampaignsUpdate
    couponsAttach
    couponsCreate
    couponsDelete
    couponsDetach
    couponsUpdate
    couponsView
    creditNotesCreate
    creditNotesView
    creditNotesVoid
    customerSettingsUpdateGracePeriod
    customerSettingsUpdateLang
    customerSettingsUpdatePaymentTerms
    customerSettingsUpdateTaxRates
    customerSettingsView
    customersCreate
    customersDelete
    customersUpdate
    customersView
    dataApiView
    developersKeysManage
    developersManage
    draftInvoicesUpdate
    dunningCampaignsCreate
    dunningCampaignsUpdate
    dunningCampaignsView
    featuresCreate
    featuresDelete
    featuresUpdate
    featuresView
    invoiceCustomSectionsCreate
    invoiceCustomSectionsUpdate
    invoicesCreate
    invoicesSend
    invoicesUpdate
    invoicesView
    invoicesVoid
    organizationEmailsUpdate
    organizationEmailsView
    organizationIntegrationsCreate
    organizationIntegrationsDelete
    organizationIntegrationsUpdate
    organizationIntegrationsView
    organizationInvoicesUpdate
    organizationInvoicesView
    organizationMembersCreate
    organizationMembersDelete
    organizationMembersUpdate
    organizationMembersView
    organizationTaxesUpdate
    organizationTaxesView
    organizationUpdate
    organizationView
    paymentsCreate
    paymentsView
    plansCreate
    plansDelete
    plansUpdate
    plansView
    pricingUnitsCreate
    pricingUnitsUpdate
    pricingUnitsView
    subscriptionsCreate
    subscriptionsUpdate
    subscriptionsView
    walletsCreate
    walletsTerminate
    walletsTopUp
    walletsUpdate
  }
}
    `;
export const CurrentUserInfosFragmentDoc = gql`
    fragment CurrentUserInfos on User {
  id
  email
  premium
  memberships {
    id
    ...MembershipPermissions
    organization {
      id
      name
      logoUrl
      accessibleByCurrentSession
    }
  }
}
    ${MembershipPermissionsFragmentDoc}`;
export const OrganizationForDatePickerFragmentDoc = gql`
    fragment OrganizationForDatePicker on CurrentOrganization {
  id
  timezone
}
    `;
export const MainOrganizationInfosFragmentDoc = gql`
    fragment MainOrganizationInfos on CurrentOrganization {
  id
  name
  logoUrl
  timezone
  defaultCurrency
  premiumIntegrations
  canCreateBillingEntity
  authenticationMethods
  authenticatedMethod
  ...OrganizationForDatePicker
}
    ${OrganizationForDatePickerFragmentDoc}`;
export const AddOnItemFragmentDoc = gql`
    fragment AddOnItem on AddOn {
  id
  name
  amountCurrency
  amountCents
  customersCount
  createdAt
}
    `;
export const BillableMetricItemFragmentDoc = gql`
    fragment BillableMetricItem on BillableMetric {
  id
  name
  code
  createdAt
}
    `;
export const CouponDetailsForHeaderFragmentDoc = gql`
    fragment CouponDetailsForHeader on Coupon {
  name
  status
  couponType
  percentageRate
  amountCents
  amountCurrency
  frequency
}
    `;
export const CouponItemFragmentDoc = gql`
    fragment CouponItem on Coupon {
  id
  name
  customersCount
  status
  amountCurrency
  amountCents
  expiration
  expirationAt
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const EditBillableMetricFragmentDoc = gql`
    fragment EditBillableMetric on BillableMetric {
  id
  name
  code
  expression
  description
  aggregationType
  fieldName
  hasSubscriptions
  hasPlans
  recurring
  roundingFunction
  roundingPrecision
  filters {
    key
    values
  }
}
    `;
export const TaxInfosForCreateInvoiceFragmentDoc = gql`
    fragment TaxInfosForCreateInvoice on Tax {
  id
  name
  code
  rate
}
    `;
export const TaxForPlanAndChargesInPlanFormFragmentDoc = gql`
    fragment TaxForPlanAndChargesInPlanForm on Tax {
  id
  code
  name
  rate
}
    `;
export const BillableMetricForPlanFragmentDoc = gql`
    fragment BillableMetricForPlan on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const GraduatedChargeFragmentDoc = gql`
    fragment GraduatedCharge on GraduatedRange {
  flatAmount
  fromValue
  perUnitAmount
  toValue
}
    `;
export const GraduatedPercentageChargeFragmentDoc = gql`
    fragment GraduatedPercentageCharge on GraduatedPercentageRange {
  flatAmount
  fromValue
  rate
  toValue
}
    `;
export const VolumeRangesFragmentDoc = gql`
    fragment VolumeRanges on VolumeRange {
  flatAmount
  fromValue
  perUnitAmount
  toValue
}
    `;
export const PackageChargeFragmentDoc = gql`
    fragment PackageCharge on Properties {
  amount
  packageSize
  freeUnits
}
    `;
export const StandardChargeFragmentDoc = gql`
    fragment StandardCharge on Properties {
  amount
  pricingGroupKeys
}
    `;
export const PercentageChargeFragmentDoc = gql`
    fragment PercentageCharge on Properties {
  fixedAmount
  freeUnitsPerEvents
  freeUnitsPerTotalAggregation
  rate
  perTransactionMinAmount
  perTransactionMaxAmount
}
    `;
export const CustomChargeFragmentDoc = gql`
    fragment CustomCharge on Properties {
  customProperties
}
    `;
export const PricingGroupKeysFragmentDoc = gql`
    fragment PricingGroupKeys on Properties {
  pricingGroupKeys
}
    `;
export const ChargeForUsageChargeOptionsAccordionFragmentDoc = gql`
    fragment ChargeForUsageChargeOptionsAccordion on Charge {
  id
  invoiceable
  minAmountCents
  payInAdvance
  regroupPaidFees
}
    `;
export const UsageChargeAccordionFragmentDoc = gql`
    fragment UsageChargeAccordion on Charge {
  id
  chargeModel
  invoiceable
  minAmountCents
  payInAdvance
  prorated
  invoiceDisplayName
  regroupPaidFees
  properties {
    graduatedRanges {
      ...GraduatedCharge
    }
    graduatedPercentageRanges {
      ...GraduatedPercentageCharge
    }
    volumeRanges {
      ...VolumeRanges
    }
    ...PackageCharge
    ...StandardCharge
    ...PercentageCharge
    ...CustomCharge
    ...PricingGroupKeys
  }
  filters {
    invoiceDisplayName
    values
    properties {
      graduatedRanges {
        ...GraduatedCharge
      }
      graduatedPercentageRanges {
        ...GraduatedPercentageCharge
      }
      volumeRanges {
        ...VolumeRanges
      }
      ...PackageCharge
      ...StandardCharge
      ...PercentageCharge
      ...CustomCharge
      ...PricingGroupKeys
    }
  }
  billableMetric {
    id
    name
    aggregationType
    recurring
    filters {
      key
      values
    }
  }
  taxes {
    ...TaxForTaxesSelectorSection
  }
  ...ChargeForUsageChargeOptionsAccordion
}
    ${GraduatedChargeFragmentDoc}
${GraduatedPercentageChargeFragmentDoc}
${VolumeRangesFragmentDoc}
${PackageChargeFragmentDoc}
${StandardChargeFragmentDoc}
${PercentageChargeFragmentDoc}
${CustomChargeFragmentDoc}
${PricingGroupKeysFragmentDoc}
${TaxForTaxesSelectorSectionFragmentDoc}
${ChargeForUsageChargeOptionsAccordionFragmentDoc}`;
export const PlanForUsageChargeAccordionFragmentDoc = gql`
    fragment PlanForUsageChargeAccordion on Plan {
  billChargesMonthly
}
    `;
export const TaxForPlanSettingsSectionFragmentDoc = gql`
    fragment TaxForPlanSettingsSection on Tax {
  id
  code
  name
  rate
}
    `;
export const PlanForSettingsSectionFragmentDoc = gql`
    fragment PlanForSettingsSection on Plan {
  id
  amountCurrency
  code
  description
  interval
  name
  taxes {
    ...TaxForPlanSettingsSection
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;
export const PlanForSubscriptionFeeSectionFragmentDoc = gql`
    fragment PlanForSubscriptionFeeSection on Plan {
  id
  amountCents
  payInAdvance
  trialPeriod
  invoiceDisplayName
}
    `;
export const FeatureEntitlementPrivilegeForPlanFragmentDoc = gql`
    fragment FeatureEntitlementPrivilegeForPlan on PlanEntitlementPrivilegeObject {
  code
  name
  value
  valueType
  config {
    selectOptions
  }
}
    `;
export const FeatureEntitlementForPlanFragmentDoc = gql`
    fragment FeatureEntitlementForPlan on Plan {
  entitlements {
    code
    name
    privileges {
      ...FeatureEntitlementPrivilegeForPlan
    }
  }
}
    ${FeatureEntitlementPrivilegeForPlanFragmentDoc}`;
export const EditPlanFragmentDoc = gql`
    fragment EditPlan on Plan {
  id
  name
  code
  description
  interval
  payInAdvance
  invoiceDisplayName
  amountCents
  amountCurrency
  trialPeriod
  subscriptionsCount
  billChargesMonthly
  hasOverriddenPlans
  minimumCommitment {
    amountCents
    commitmentType
    invoiceDisplayName
    taxes {
      id
      ...TaxForPlanAndChargesInPlanForm
    }
  }
  taxes {
    ...TaxForPlanAndChargesInPlanForm
  }
  charges {
    id
    minAmountCents
    payInAdvance
    appliedPricingUnit {
      conversionRate
      pricingUnit {
        id
        code
        name
        shortName
      }
    }
    taxes {
      ...TaxForPlanAndChargesInPlanForm
    }
    billableMetric {
      id
      code
      ...BillableMetricForPlan
    }
    ...UsageChargeAccordion
    chargeModel
  }
  usageThresholds {
    id
    amountCents
    recurring
    thresholdDisplayName
  }
  ...PlanForUsageChargeAccordion
  ...PlanForSettingsSection
  ...PlanForSubscriptionFeeSection
  ...FeatureEntitlementForPlan
}
    ${TaxForPlanAndChargesInPlanFormFragmentDoc}
${BillableMetricForPlanFragmentDoc}
${UsageChargeAccordionFragmentDoc}
${PlanForUsageChargeAccordionFragmentDoc}
${PlanForSettingsSectionFragmentDoc}
${PlanForSubscriptionFeeSectionFragmentDoc}
${FeatureEntitlementForPlanFragmentDoc}`;
export const CustomerForExternalAppsAccordionFragmentDoc = gql`
    fragment CustomerForExternalAppsAccordion on Customer {
  id
  customerType
  currency
  paymentProvider
  paymentProviderCode
  netsuiteCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    subsidiaryId
    syncWithProvider
  }
  anrokCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  avalaraCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  xeroCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  hubspotCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
    targetedObject
  }
  salesforceCustomer {
    __typename
    id
    integrationId
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  providerCustomer {
    id
    providerCustomerId
    syncWithProvider
    providerPaymentMethods
  }
}
    `;
export const AddCustomerDrawerFragmentDoc = gql`
    fragment AddCustomerDrawer on Customer {
  id
  addressLine1
  addressLine2
  applicableTimezone
  canEditAttributes
  city
  country
  currency
  email
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  customerType
  name
  firstname
  lastname
  phone
  state
  timezone
  zipcode
  accountType
  shippingAddress {
    addressLine1
    addressLine2
    city
    country
    state
    zipcode
  }
  url
  metadata {
    id
    key
    value
    displayInInvoice
  }
  billingEntity {
    code
    name
  }
  ...CustomerForExternalAppsAccordion
}
    ${CustomerForExternalAppsAccordionFragmentDoc}`;
export const CustomerMainInfosFragmentDoc = gql`
    fragment CustomerMainInfos on Customer {
  id
  customerType
  name
  firstname
  lastname
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  phone
  email
  currency
  addressLine1
  addressLine2
  state
  country
  city
  url
  zipcode
  shippingAddress {
    addressLine1
    addressLine2
    city
    country
    state
    zipcode
  }
  paymentProvider
  timezone
  anrokCustomer {
    id
    integrationId
    externalCustomerId
  }
  avalaraCustomer {
    id
    integrationId
    externalCustomerId
  }
  netsuiteCustomer {
    id
    integrationId
    externalCustomerId
  }
  paymentProviderCode
  providerCustomer {
    id
    providerCustomerId
    providerPaymentMethods
  }
  xeroCustomer {
    id
    integrationId
    externalCustomerId
  }
  hubspotCustomer {
    id
    integrationId
    externalCustomerId
    targetedObject
  }
  salesforceCustomer {
    id
    integrationId
    externalCustomerId
  }
  metadata {
    id
    key
    value
  }
  billingEntity {
    name
    code
  }
}
    `;
export const CustomerDetailsFragmentDoc = gql`
    fragment CustomerDetails on Customer {
  id
  customerType
  name
  displayName
  firstname
  lastname
  externalId
  hasActiveWallet
  currency
  hasCreditNotes
  creditNotesCreditsAvailableCount
  creditNotesBalanceAmountCents
  applicableTimezone
  hasOverdueInvoices
  accountType
  ...AddCustomerDrawer
  ...CustomerMainInfos
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerMainInfosFragmentDoc}`;
export const InvoiceDetailsForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceDetailsForInvoiceOverview on Invoice {
  id
  invoiceType
  status
  taxStatus
  issuingDate
  externalIntegrationId
  taxProviderId
  taxProviderVoidable
  integrationHubspotSyncable
  externalHubspotIntegrationId
  integrationSalesforceSyncable
  externalSalesforceIntegrationId
  fees {
    id
    addOn {
      id
    }
    amountCents
    invoiceName
    invoiceDisplayName
    units
    groupedBy
    charge {
      id
      payInAdvance
      minAmountCents
      billableMetric {
        id
        name
      }
    }
    chargeFilter {
      invoiceDisplayName
      values
    }
    subscription {
      id
      plan {
        id
        interval
        name
      }
    }
  }
  billingEntity {
    name
    code
  }
}
    `;
export const InvoiceForCreditNotesTableFragmentDoc = gql`
    fragment InvoiceForCreditNotesTable on Invoice {
  id
  customer {
    id
  }
  creditNotes {
    id
    couponsAdjustmentAmountCents
    number
    subTotalExcludingTaxesAmountCents
    currency
    totalAmountCents
    appliedTaxes {
      id
      amountCents
      baseAmountCents
      taxRate
      taxName
    }
    items {
      amountCents
      amountCurrency
      fee {
        id
        amountCents
        eventsCount
        units
        feeType
        groupedBy
        itemName
        invoiceName
        appliedTaxes {
          id
          taxRate
        }
        trueUpParentFee {
          id
        }
        charge {
          id
          billableMetric {
            id
            name
            aggregationType
          }
        }
        subscription {
          id
          name
          plan {
            id
            name
            invoiceDisplayName
          }
        }
        chargeFilter {
          invoiceDisplayName
          values
        }
      }
    }
  }
}
    `;
export const InvoiceForDetailsTableFooterFragmentDoc = gql`
    fragment InvoiceForDetailsTableFooter on Invoice {
  couponsAmountCents
  creditNotesAmountCents
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  totalDueAmountCents
  totalPaidAmountCents
  currency
  invoiceType
  status
  taxStatus
  prepaidCreditAmountCents
  progressiveBillingCreditAmountCents
  versionNumber
  appliedTaxes {
    id
    amountCents
    feesAmountCents
    taxableAmountCents
    taxRate
    taxName
    taxCode
    enumedTaxCode
  }
}
    `;
export const InvoiceForDetailsTableFragmentDoc = gql`
    fragment InvoiceForDetailsTable on Invoice {
  id
  invoiceType
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  currency
  issuingDate
  allChargesHaveFees
  versionNumber
  errorDetails {
    errorCode
    errorDetails
  }
  ...InvoiceForDetailsTableFooter
}
    ${InvoiceForDetailsTableFooterFragmentDoc}`;
export const InvoiceForInvoiceInfosFragmentDoc = gql`
    fragment InvoiceForInvoiceInfos on Invoice {
  number
  issuingDate
  paymentDueDate
  paymentOverdue
  status
  totalPaidAmountCents
  totalAmountCents
  paymentStatus
  paymentDisputeLostAt
  taxProviderVoidable
  errorDetails {
    errorCode
    errorDetails
  }
  customer {
    id
    name
    displayName
    legalNumber
    legalName
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
    applicableTimezone
    deletedAt
    accountType
  }
}
    `;
export const AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc = gql`
    fragment AllInvoiceDetailsForCustomerInvoiceDetails on Invoice {
  id
  invoiceType
  number
  paymentStatus
  status
  taxStatus
  totalAmountCents
  currency
  refundableAmountCents
  creditableAmountCents
  voidable
  paymentDisputeLostAt
  integrationSyncable
  externalIntegrationId
  taxProviderVoidable
  integrationHubspotSyncable
  associatedActiveWalletPresent
  voidedAt
  voidedInvoiceId
  regeneratedInvoiceId
  errorDetails {
    errorCode
    errorDetails
  }
  customer {
    id
  }
  ...InvoiceDetailsForInvoiceOverview
  ...InvoiceForCreditNotesTable
  ...InvoiceForDetailsTable
  ...InvoiceForInvoiceInfos
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
}
    ${InvoiceDetailsForInvoiceOverviewFragmentDoc}
${InvoiceForCreditNotesTableFragmentDoc}
${InvoiceForDetailsTableFragmentDoc}
${InvoiceForInvoiceInfosFragmentDoc}
${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}`;
export const CustomerForInvoiceDetailsFragmentDoc = gql`
    fragment CustomerForInvoiceDetails on Customer {
  id
  name
  paymentProvider
  avalaraCustomer {
    id
    integrationId
  }
  netsuiteCustomer {
    id
    integrationId
    externalCustomerId
  }
  xeroCustomer {
    id
    integrationId
  }
  hubspotCustomer {
    id
    integrationId
  }
  salesforceCustomer {
    id
    integrationId
  }
}
    `;
export const CustomerForRequestOverduePaymentFormFragmentDoc = gql`
    fragment CustomerForRequestOverduePaymentForm on Customer {
  email
}
    `;
export const InvoicesForRequestOverduePaymentFormFragmentDoc = gql`
    fragment InvoicesForRequestOverduePaymentForm on Invoice {
  id
  number
  totalDueAmountCents
  currency
  issuingDate
}
    `;
export const LastPaymentRequestFragmentDoc = gql`
    fragment LastPaymentRequest on PaymentRequest {
  createdAt
}
    `;
export const CustomerItemFragmentDoc = gql`
    fragment CustomerItem on Customer {
  id
  name
  displayName
  firstname
  lastname
  externalId
  createdAt
  activeSubscriptionsCount
  ...AddCustomerDrawer
}
    ${AddCustomerDrawerFragmentDoc}`;
export const CustomerForInvoiceOverviewFragmentDoc = gql`
    fragment CustomerForInvoiceOverview on Customer {
  id
  applicableTimezone
  accountType
  anrokCustomer {
    id
    externalAccountId
  }
  avalaraCustomer {
    id
    externalCustomerId
  }
  xeroCustomer {
    externalCustomerId
  }
  hubspotCustomer {
    externalCustomerId
  }
  salesforceCustomer {
    externalCustomerId
  }
}
    `;
export const NetsuiteIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment NetsuiteIntegrationInfosForInvoiceOverview on NetsuiteIntegration {
  id
  accountId
  name
}
    `;
export const HubspotIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment HubspotIntegrationInfosForInvoiceOverview on HubspotIntegration {
  id
  portalId
  invoicesObjectTypeId
}
    `;
export const SalesforceIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment SalesforceIntegrationInfosForInvoiceOverview on SalesforceIntegration {
  id
  name
  instanceId
}
    `;
export const AvalaraIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment AvalaraIntegrationInfosForInvoiceOverview on AvalaraIntegration {
  id
  accountId
  companyId
}
    `;
export const InvoiceForPaymentDetailsFragmentDoc = gql`
    fragment InvoiceForPaymentDetails on Invoice {
  id
  status
  paymentStatus
  number
  totalAmountCents
  issuingDate
  currency
  paymentOverdue
  totalPaidAmountCents
  paymentDisputeLostAt
}
    `;
export const DeletePlanDialogFragmentDoc = gql`
    fragment DeletePlanDialog on Plan {
  id
  name
  draftInvoicesCount
  activeSubscriptionsCount
}
    `;
export const PlanItemFragmentDoc = gql`
    fragment PlanItem on Plan {
  id
  name
  code
  chargesCount
  activeSubscriptionsCount
  createdAt
  ...DeletePlanDialog
}
    ${DeletePlanDialogFragmentDoc}`;
export const SubscriptionForSubscriptionsListFragmentDoc = gql`
    fragment SubscriptionForSubscriptionsList on Subscription {
  id
  status
  startedAt
  nextSubscriptionAt
  nextSubscriptionType
  name
  nextName
  externalId
  subscriptionAt
  endingAt
  terminatedAt
  customer {
    id
    name
    displayName
    applicableTimezone
  }
  plan {
    id
    isOverridden
    payInAdvance
    amountCurrency
    name
    interval
  }
  nextPlan {
    id
    name
    code
    interval
  }
  nextSubscription {
    id
    name
    externalId
    status
  }
}
    `;
export const FeaturePrivilegeAccordionFragmentDoc = gql`
    fragment FeaturePrivilegeAccordion on PrivilegeObject {
  id
  code
  name
  valueType
  config {
    selectOptions
  }
}
    `;
export const FeatureForFeatureFormFragmentDoc = gql`
    fragment FeatureForFeatureForm on FeatureObject {
  id
  name
  code
  description
  privileges {
    ...FeaturePrivilegeAccordion
  }
}
    ${FeaturePrivilegeAccordionFragmentDoc}`;
export const FeatureForFeaturesListFragmentDoc = gql`
    fragment FeatureForFeaturesList on FeatureObject {
  id
  name
  code
  createdAt
  subscriptionsCount
}
    `;
export const AdyenIntegrationDetailsFragmentDoc = gql`
    fragment AdyenIntegrationDetails on AdyenProvider {
  id
  apiKey
  code
  hmacKey
  livePrefix
  merchantAccount
  successRedirectUrl
  name
}
    `;
export const AdyenIntegrationsFragmentDoc = gql`
    fragment AdyenIntegrations on AdyenProvider {
  id
  name
  code
}
    `;
export const DeleteAnrokIntegrationDialogFragmentDoc = gql`
    fragment DeleteAnrokIntegrationDialog on AnrokIntegration {
  id
  name
}
    `;
export const AddAnrokIntegrationDialogFragmentDoc = gql`
    fragment AddAnrokIntegrationDialog on AnrokIntegration {
  id
  name
  code
  apiKey
}
    `;
export const AnrokIntegrationItemsFragmentDoc = gql`
    fragment AnrokIntegrationItems on AnrokIntegration {
  id
}
    `;
export const AnrokIntegrationDetailsFragmentDoc = gql`
    fragment AnrokIntegrationDetails on AnrokIntegration {
  id
  name
  ...DeleteAnrokIntegrationDialog
  ...AddAnrokIntegrationDialog
  ...AnrokIntegrationItems
}
    ${DeleteAnrokIntegrationDialogFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationItemsFragmentDoc}`;
export const AnrokIntegrationsFragmentDoc = gql`
    fragment AnrokIntegrations on AnrokIntegration {
  id
  name
  code
  ...AddAnrokIntegrationDialog
}
    ${AddAnrokIntegrationDialogFragmentDoc}`;
export const OktaIntegrationDetailsFragmentDoc = gql`
    fragment OktaIntegrationDetails on OktaIntegration {
  id
  clientId
  clientSecret
  code
  organizationName
  domain
  name
}
    `;
export const DeleteAvalaraIntegrationDialogFragmentDoc = gql`
    fragment DeleteAvalaraIntegrationDialog on AvalaraIntegration {
  id
  name
}
    `;
export const AddAvalaraIntegrationDialogFragmentDoc = gql`
    fragment AddAvalaraIntegrationDialog on AvalaraIntegration {
  id
  accountId
  code
  companyCode
  licenseKey
  name
}
    `;
export const AvalaraIntegrationDetailsFragmentDoc = gql`
    fragment AvalaraIntegrationDetails on AvalaraIntegration {
  id
  name
  ...DeleteAvalaraIntegrationDialog
  ...AddAvalaraIntegrationDialog
}
    ${DeleteAvalaraIntegrationDialogFragmentDoc}
${AddAvalaraIntegrationDialogFragmentDoc}`;
export const AvalaraIntegrationsFragmentDoc = gql`
    fragment AvalaraIntegrations on AvalaraIntegration {
  id
  name
  code
  ...AddAvalaraIntegrationDialog
}
    ${AddAvalaraIntegrationDialogFragmentDoc}`;
export const TaxItemForApplyTaxFragmentDoc = gql`
    fragment TaxItemForApplyTax on Tax {
  id
  code
  name
}
    `;
export const CashfreeIntegrationDetailsFragmentDoc = gql`
    fragment CashfreeIntegrationDetails on CashfreeProvider {
  id
  code
  name
  clientId
  clientSecret
  successRedirectUrl
}
    `;
export const CashfreeIntegrationsFragmentDoc = gql`
    fragment CashfreeIntegrations on CashfreeProvider {
  id
  name
  code
}
    `;
export const DunningCampaignItemFragmentDoc = gql`
    fragment DunningCampaignItem on DunningCampaign {
  id
  name
  code
  appliedToOrganization
}
    `;
export const FlutterwaveIntegrationDetailsFragmentDoc = gql`
    fragment FlutterwaveIntegrationDetails on FlutterwaveProvider {
  id
  name
  code
  secretKey
  webhookSecret
  successRedirectUrl
}
    `;
export const FlutterwaveIntegrationsFragmentDoc = gql`
    fragment FlutterwaveIntegrations on FlutterwaveProvider {
  id
  name
  code
}
    `;
export const GocardlessIntegrationDetailsFragmentDoc = gql`
    fragment GocardlessIntegrationDetails on GocardlessProvider {
  id
  code
  name
  successRedirectUrl
  webhookSecret
}
    `;
export const GocardlessIntegrationOauthCallbackFragmentDoc = gql`
    fragment GocardlessIntegrationOauthCallback on GocardlessProvider {
  id
  name
  code
}
    `;
export const GocardlessIntegrationsFragmentDoc = gql`
    fragment GocardlessIntegrations on GocardlessProvider {
  id
  name
  code
}
    `;
export const DeleteHubspotIntegrationDialogFragmentDoc = gql`
    fragment DeleteHubspotIntegrationDialog on HubspotIntegration {
  id
  name
}
    `;
export const HubspotForCreateDialogFragmentDoc = gql`
    fragment HubspotForCreateDialog on HubspotIntegration {
  id
  name
  code
  defaultTargetedObject
  syncInvoices
  syncSubscriptions
  ...DeleteHubspotIntegrationDialog
}
    ${DeleteHubspotIntegrationDialogFragmentDoc}`;
export const HubspotIntegrationDetailsFragmentDoc = gql`
    fragment HubspotIntegrationDetails on HubspotIntegration {
  id
  name
  code
  defaultTargetedObject
  syncInvoices
  syncSubscriptions
  ...HubspotForCreateDialog
  ...DeleteHubspotIntegrationDialog
}
    ${HubspotForCreateDialogFragmentDoc}
${DeleteHubspotIntegrationDialogFragmentDoc}`;
export const HubspotIntegrationsFragmentDoc = gql`
    fragment HubspotIntegrations on HubspotIntegration {
  id
  name
  code
  ...HubspotForCreateDialog
}
    ${HubspotForCreateDialogFragmentDoc}`;
export const PricingUnitFragmentDoc = gql`
    fragment PricingUnit on PricingUnit {
  id
  name
  code
  description
  shortName
}
    `;
export const InviteForEditRoleForDialogFragmentDoc = gql`
    fragment InviteForEditRoleForDialog on Invite {
  id
  role
  email
}
    `;
export const InviteItemForMembersSettingsFragmentDoc = gql`
    fragment InviteItemForMembersSettings on Invite {
  id
  email
  token
  role
  organization {
    id
    name
  }
  ...InviteForEditRoleForDialog
}
    ${InviteForEditRoleForDialogFragmentDoc}`;
export const MemberForEditRoleForDialogFragmentDoc = gql`
    fragment MemberForEditRoleForDialog on Membership {
  id
  role
  user {
    id
    email
  }
  ...MembershipPermissions
}
    ${MembershipPermissionsFragmentDoc}`;
export const MembershipItemForMembershipSettingsFragmentDoc = gql`
    fragment MembershipItemForMembershipSettings on Membership {
  id
  role
  user {
    id
    email
  }
  organization {
    id
    name
  }
  ...MemberForEditRoleForDialog
}
    ${MemberForEditRoleForDialogFragmentDoc}`;
export const MoneyhashIntegrationDetailsFragmentDoc = gql`
    fragment MoneyhashIntegrationDetails on MoneyhashProvider {
  id
  apiKey
  code
  flowId
  name
}
    `;
export const MoneyhashIntegrationsFragmentDoc = gql`
    fragment MoneyhashIntegrations on MoneyhashProvider {
  id
  name
  code
}
    `;
export const DeleteNetsuiteIntegrationDialogFragmentDoc = gql`
    fragment DeleteNetsuiteIntegrationDialog on NetsuiteIntegration {
  id
  name
}
    `;
export const NetsuiteForCreateDialogDialogFragmentDoc = gql`
    fragment NetsuiteForCreateDialogDialog on NetsuiteIntegration {
  id
  accountId
  clientId
  clientSecret
  code
  name
  scriptEndpointUrl
  syncCreditNotes
  syncInvoices
  syncPayments
  tokenId
  tokenSecret
}
    `;
export const NetsuiteIntegrationItemsFragmentDoc = gql`
    fragment NetsuiteIntegrationItems on NetsuiteIntegration {
  id
}
    `;
export const NetsuiteIntegrationDetailsFragmentDoc = gql`
    fragment NetsuiteIntegrationDetails on NetsuiteIntegration {
  id
  name
  ...DeleteNetsuiteIntegrationDialog
  ...NetsuiteForCreateDialogDialog
  ...NetsuiteIntegrationItems
}
    ${DeleteNetsuiteIntegrationDialogFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}
${NetsuiteIntegrationItemsFragmentDoc}`;
export const NetsuiteIntegrationsFragmentDoc = gql`
    fragment NetsuiteIntegrations on NetsuiteIntegration {
  id
  name
  code
  ...NetsuiteForCreateDialogDialog
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export const DeleteSalesforceIntegrationDialogFragmentDoc = gql`
    fragment DeleteSalesforceIntegrationDialog on SalesforceIntegration {
  id
  name
}
    `;
export const SalesforceForCreateDialogFragmentDoc = gql`
    fragment SalesforceForCreateDialog on SalesforceIntegration {
  id
  name
  code
  instanceId
  ...DeleteSalesforceIntegrationDialog
}
    ${DeleteSalesforceIntegrationDialogFragmentDoc}`;
export const SalesforceIntegrationDetailsFragmentDoc = gql`
    fragment SalesforceIntegrationDetails on SalesforceIntegration {
  id
  name
  code
  instanceId
  ...SalesforceForCreateDialog
  ...DeleteSalesforceIntegrationDialog
}
    ${SalesforceForCreateDialogFragmentDoc}
${DeleteSalesforceIntegrationDialogFragmentDoc}`;
export const SalesforceIntegrationsFragmentDoc = gql`
    fragment SalesforceIntegrations on SalesforceIntegration {
  id
  name
  code
  ...SalesforceForCreateDialog
  ...DeleteSalesforceIntegrationDialog
}
    ${SalesforceForCreateDialogFragmentDoc}
${DeleteSalesforceIntegrationDialogFragmentDoc}`;
export const StripeIntegrationDetailsFragmentDoc = gql`
    fragment StripeIntegrationDetails on StripeProvider {
  id
  code
  name
  secretKey
  successRedirectUrl
}
    `;
export const StripeIntegrationsFragmentDoc = gql`
    fragment StripeIntegrations on StripeProvider {
  id
  name
  code
}
    `;
export const DeleteTaxFragmentDoc = gql`
    fragment DeleteTax on Tax {
  id
  name
  customersCount
}
    `;
export const TaxItemForTaxSettingsFragmentDoc = gql`
    fragment TaxItemForTaxSettings on Tax {
  id
  code
  name
  rate
  autoGenerated
  ...DeleteTax
}
    ${DeleteTaxFragmentDoc}`;
export const DeleteXeroIntegrationDialogFragmentDoc = gql`
    fragment DeleteXeroIntegrationDialog on XeroIntegration {
  id
  name
}
    `;
export const XeroForCreateDialogDialogFragmentDoc = gql`
    fragment XeroForCreateDialogDialog on XeroIntegration {
  id
  code
  connectionId
  hasMappingsConfigured
  name
  syncCreditNotes
  syncInvoices
  syncPayments
}
    `;
export const XeroIntegrationItemsFragmentDoc = gql`
    fragment XeroIntegrationItems on XeroIntegration {
  id
}
    `;
export const XeroIntegrationDetailsFragmentDoc = gql`
    fragment XeroIntegrationDetails on XeroIntegration {
  id
  name
  connectionId
  ...DeleteXeroIntegrationDialog
  ...XeroForCreateDialogDialog
  ...XeroIntegrationItems
}
    ${DeleteXeroIntegrationDialogFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}
${XeroIntegrationItemsFragmentDoc}`;
export const XeroIntegrationsFragmentDoc = gql`
    fragment XeroIntegrations on XeroIntegration {
  id
  name
  code
  ...XeroForCreateDialogDialog
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export const AddSubscriptionPlanFragmentDoc = gql`
    fragment AddSubscriptionPlan on Plan {
  id
  name
  code
  interval
  ...FeatureEntitlementForPlan
}
    ${FeatureEntitlementForPlanFragmentDoc}`;
export const WalletForTopUpFragmentDoc = gql`
    fragment WalletForTopUp on Wallet {
  id
  name
  currency
  rateAmount
  invoiceRequiresSuccessfulPayment
  paidTopUpMinAmountCents
  paidTopUpMaxAmountCents
  priority
}
    `;
export const UserIdentifierDocument = gql`
    query UserIdentifier {
  me: currentUser {
    id
    email
    ...CurrentUserInfos
  }
  organization {
    ...MainOrganizationInfos
  }
}
    ${CurrentUserInfosFragmentDoc}
${MainOrganizationInfosFragmentDoc}`;

/**
 * __useUserIdentifierQuery__
 *
 * To run a query within a React component, call `useUserIdentifierQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserIdentifierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserIdentifierQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserIdentifierQuery(baseOptions?: Apollo.QueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
      }
export function useUserIdentifierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export function useUserIdentifierSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export type UserIdentifierQueryHookResult = ReturnType<typeof useUserIdentifierQuery>;
export type UserIdentifierLazyQueryHookResult = ReturnType<typeof useUserIdentifierLazyQuery>;
export type UserIdentifierSuspenseQueryHookResult = ReturnType<typeof useUserIdentifierSuspenseQuery>;
export type UserIdentifierQueryResult = Apollo.QueryResult<UserIdentifierQuery, UserIdentifierQueryVariables>;
export const DeleteAddOnDocument = gql`
    mutation deleteAddOn($input: DestroyAddOnInput!) {
  destroyAddOn(input: $input) {
    id
  }
}
    `;
export type DeleteAddOnMutationFn = Apollo.MutationFunction<DeleteAddOnMutation, DeleteAddOnMutationVariables>;

/**
 * __useDeleteAddOnMutation__
 *
 * To run a mutation, you first call `useDeleteAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAddOnMutation, { data, loading, error }] = useDeleteAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAddOnMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAddOnMutation, DeleteAddOnMutationVariables>(DeleteAddOnDocument, options);
      }
export type DeleteAddOnMutationHookResult = ReturnType<typeof useDeleteAddOnMutation>;
export type DeleteAddOnMutationResult = Apollo.MutationResult<DeleteAddOnMutation>;
export type DeleteAddOnMutationOptions = Apollo.BaseMutationOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>;
export const GetMrrPlanBreakdownDocument = gql`
    query getMrrPlanBreakdown($currency: CurrencyEnum, $limit: Int, $page: Int) {
  dataApiMrrsPlans(currency: $currency, limit: $limit, page: $page) {
    collection {
      activeCustomersCount
      activeCustomersShare
      amountCurrency
      mrr
      mrrShare
      planCode
      planDeletedAt
      planId
      planInterval
      planName
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetMrrPlanBreakdownQuery__
 *
 * To run a query within a React component, call `useGetMrrPlanBreakdownQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMrrPlanBreakdownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMrrPlanBreakdownQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetMrrPlanBreakdownQuery(baseOptions?: Apollo.QueryHookOptions<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>(GetMrrPlanBreakdownDocument, options);
      }
export function useGetMrrPlanBreakdownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>(GetMrrPlanBreakdownDocument, options);
        }
export function useGetMrrPlanBreakdownSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>(GetMrrPlanBreakdownDocument, options);
        }
export type GetMrrPlanBreakdownQueryHookResult = ReturnType<typeof useGetMrrPlanBreakdownQuery>;
export type GetMrrPlanBreakdownLazyQueryHookResult = ReturnType<typeof useGetMrrPlanBreakdownLazyQuery>;
export type GetMrrPlanBreakdownSuspenseQueryHookResult = ReturnType<typeof useGetMrrPlanBreakdownSuspenseQuery>;
export type GetMrrPlanBreakdownQueryResult = Apollo.QueryResult<GetMrrPlanBreakdownQuery, GetMrrPlanBreakdownQueryVariables>;
export const GetMrrsDocument = gql`
    query getMrrs($currency: CurrencyEnum, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $externalCustomerId: String, $fromDate: ISO8601Date, $planCode: String, $timeGranularity: TimeGranularityEnum, $toDate: ISO8601Date, $billingEntityCode: String, $isCustomerTinEmpty: Boolean) {
  dataApiMrrs(
    currency: $currency
    customerCountry: $customerCountry
    customerType: $customerType
    externalCustomerId: $externalCustomerId
    fromDate: $fromDate
    planCode: $planCode
    timeGranularity: $timeGranularity
    toDate: $toDate
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
  ) {
    collection {
      ...MrrDataForOverviewSection
    }
  }
}
    ${MrrDataForOverviewSectionFragmentDoc}`;

/**
 * __useGetMrrsQuery__
 *
 * To run a query within a React component, call `useGetMrrsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMrrsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMrrsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      fromDate: // value for 'fromDate'
 *      planCode: // value for 'planCode'
 *      timeGranularity: // value for 'timeGranularity'
 *      toDate: // value for 'toDate'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *   },
 * });
 */
export function useGetMrrsQuery(baseOptions?: Apollo.QueryHookOptions<GetMrrsQuery, GetMrrsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMrrsQuery, GetMrrsQueryVariables>(GetMrrsDocument, options);
      }
export function useGetMrrsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMrrsQuery, GetMrrsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMrrsQuery, GetMrrsQueryVariables>(GetMrrsDocument, options);
        }
export function useGetMrrsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMrrsQuery, GetMrrsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMrrsQuery, GetMrrsQueryVariables>(GetMrrsDocument, options);
        }
export type GetMrrsQueryHookResult = ReturnType<typeof useGetMrrsQuery>;
export type GetMrrsLazyQueryHookResult = ReturnType<typeof useGetMrrsLazyQuery>;
export type GetMrrsSuspenseQueryHookResult = ReturnType<typeof useGetMrrsSuspenseQuery>;
export type GetMrrsQueryResult = Apollo.QueryResult<GetMrrsQuery, GetMrrsQueryVariables>;
export const GetPrepaidCreditsDocument = gql`
    query getPrepaidCredits($currency: CurrencyEnum, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $externalCustomerId: String, $externalSubscriptionId: String, $fromDate: ISO8601Date, $planCode: String, $timeGranularity: TimeGranularityEnum, $toDate: ISO8601Date, $billingEntityCode: String, $isCustomerTinEmpty: Boolean) {
  dataApiPrepaidCredits(
    currency: $currency
    customerCountry: $customerCountry
    customerType: $customerType
    externalCustomerId: $externalCustomerId
    externalSubscriptionId: $externalSubscriptionId
    fromDate: $fromDate
    planCode: $planCode
    timeGranularity: $timeGranularity
    toDate: $toDate
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
  ) {
    collection {
      ...PrepaidCreditsDataForOverviewSection
    }
  }
}
    ${PrepaidCreditsDataForOverviewSectionFragmentDoc}`;

/**
 * __useGetPrepaidCreditsQuery__
 *
 * To run a query within a React component, call `useGetPrepaidCreditsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPrepaidCreditsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPrepaidCreditsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *      fromDate: // value for 'fromDate'
 *      planCode: // value for 'planCode'
 *      timeGranularity: // value for 'timeGranularity'
 *      toDate: // value for 'toDate'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *   },
 * });
 */
export function useGetPrepaidCreditsQuery(baseOptions?: Apollo.QueryHookOptions<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>(GetPrepaidCreditsDocument, options);
      }
export function useGetPrepaidCreditsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>(GetPrepaidCreditsDocument, options);
        }
export function useGetPrepaidCreditsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>(GetPrepaidCreditsDocument, options);
        }
export type GetPrepaidCreditsQueryHookResult = ReturnType<typeof useGetPrepaidCreditsQuery>;
export type GetPrepaidCreditsLazyQueryHookResult = ReturnType<typeof useGetPrepaidCreditsLazyQuery>;
export type GetPrepaidCreditsSuspenseQueryHookResult = ReturnType<typeof useGetPrepaidCreditsSuspenseQuery>;
export type GetPrepaidCreditsQueryResult = Apollo.QueryResult<GetPrepaidCreditsQuery, GetPrepaidCreditsQueryVariables>;
export const GetRevenueStreamsCustomerBreakdownDocument = gql`
    query getRevenueStreamsCustomerBreakdown($currency: CurrencyEnum, $limit: Int, $page: Int) {
  dataApiRevenueStreamsCustomers(currency: $currency, limit: $limit, page: $page) {
    collection {
      amountCurrency
      customerDeletedAt
      customerName
      externalCustomerId
      grossRevenueAmountCents
      grossRevenueShare
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetRevenueStreamsCustomerBreakdownQuery__
 *
 * To run a query within a React component, call `useGetRevenueStreamsCustomerBreakdownQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRevenueStreamsCustomerBreakdownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRevenueStreamsCustomerBreakdownQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetRevenueStreamsCustomerBreakdownQuery(baseOptions?: Apollo.QueryHookOptions<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>(GetRevenueStreamsCustomerBreakdownDocument, options);
      }
export function useGetRevenueStreamsCustomerBreakdownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>(GetRevenueStreamsCustomerBreakdownDocument, options);
        }
export function useGetRevenueStreamsCustomerBreakdownSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>(GetRevenueStreamsCustomerBreakdownDocument, options);
        }
export type GetRevenueStreamsCustomerBreakdownQueryHookResult = ReturnType<typeof useGetRevenueStreamsCustomerBreakdownQuery>;
export type GetRevenueStreamsCustomerBreakdownLazyQueryHookResult = ReturnType<typeof useGetRevenueStreamsCustomerBreakdownLazyQuery>;
export type GetRevenueStreamsCustomerBreakdownSuspenseQueryHookResult = ReturnType<typeof useGetRevenueStreamsCustomerBreakdownSuspenseQuery>;
export type GetRevenueStreamsCustomerBreakdownQueryResult = Apollo.QueryResult<GetRevenueStreamsCustomerBreakdownQuery, GetRevenueStreamsCustomerBreakdownQueryVariables>;
export const GetRevenueStreamsPlanBreakdownDocument = gql`
    query getRevenueStreamsPlanBreakdown($currency: CurrencyEnum, $limit: Int, $page: Int) {
  dataApiRevenueStreamsPlans(currency: $currency, limit: $limit, page: $page) {
    collection {
      amountCurrency
      customersCount
      customersShare
      netRevenueAmountCents
      netRevenueShare
      planCode
      planDeletedAt
      planId
      planInterval
      planName
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetRevenueStreamsPlanBreakdownQuery__
 *
 * To run a query within a React component, call `useGetRevenueStreamsPlanBreakdownQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRevenueStreamsPlanBreakdownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRevenueStreamsPlanBreakdownQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetRevenueStreamsPlanBreakdownQuery(baseOptions?: Apollo.QueryHookOptions<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>(GetRevenueStreamsPlanBreakdownDocument, options);
      }
export function useGetRevenueStreamsPlanBreakdownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>(GetRevenueStreamsPlanBreakdownDocument, options);
        }
export function useGetRevenueStreamsPlanBreakdownSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>(GetRevenueStreamsPlanBreakdownDocument, options);
        }
export type GetRevenueStreamsPlanBreakdownQueryHookResult = ReturnType<typeof useGetRevenueStreamsPlanBreakdownQuery>;
export type GetRevenueStreamsPlanBreakdownLazyQueryHookResult = ReturnType<typeof useGetRevenueStreamsPlanBreakdownLazyQuery>;
export type GetRevenueStreamsPlanBreakdownSuspenseQueryHookResult = ReturnType<typeof useGetRevenueStreamsPlanBreakdownSuspenseQuery>;
export type GetRevenueStreamsPlanBreakdownQueryResult = Apollo.QueryResult<GetRevenueStreamsPlanBreakdownQuery, GetRevenueStreamsPlanBreakdownQueryVariables>;
export const GetRevenueStreamsDocument = gql`
    query getRevenueStreams($currency: CurrencyEnum, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $isCustomerTinEmpty: Boolean, $externalCustomerId: String, $externalSubscriptionId: String, $fromDate: ISO8601Date, $planCode: String, $timeGranularity: TimeGranularityEnum, $toDate: ISO8601Date, $billingEntityCode: String) {
  dataApiRevenueStreams(
    currency: $currency
    customerCountry: $customerCountry
    customerType: $customerType
    externalCustomerId: $externalCustomerId
    externalSubscriptionId: $externalSubscriptionId
    fromDate: $fromDate
    planCode: $planCode
    timeGranularity: $timeGranularity
    toDate: $toDate
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
  ) {
    collection {
      ...RevenueStreamDataForOverviewSection
    }
  }
}
    ${RevenueStreamDataForOverviewSectionFragmentDoc}`;

/**
 * __useGetRevenueStreamsQuery__
 *
 * To run a query within a React component, call `useGetRevenueStreamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRevenueStreamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRevenueStreamsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *      fromDate: // value for 'fromDate'
 *      planCode: // value for 'planCode'
 *      timeGranularity: // value for 'timeGranularity'
 *      toDate: // value for 'toDate'
 *      billingEntityCode: // value for 'billingEntityCode'
 *   },
 * });
 */
export function useGetRevenueStreamsQuery(baseOptions?: Apollo.QueryHookOptions<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>(GetRevenueStreamsDocument, options);
      }
export function useGetRevenueStreamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>(GetRevenueStreamsDocument, options);
        }
export function useGetRevenueStreamsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>(GetRevenueStreamsDocument, options);
        }
export type GetRevenueStreamsQueryHookResult = ReturnType<typeof useGetRevenueStreamsQuery>;
export type GetRevenueStreamsLazyQueryHookResult = ReturnType<typeof useGetRevenueStreamsLazyQuery>;
export type GetRevenueStreamsSuspenseQueryHookResult = ReturnType<typeof useGetRevenueStreamsSuspenseQuery>;
export type GetRevenueStreamsQueryResult = Apollo.QueryResult<GetRevenueStreamsQuery, GetRevenueStreamsQueryVariables>;
export const GetUsageBillableMetricDocument = gql`
    query getUsageBillableMetric($currency: CurrencyEnum, $timeGranularity: TimeGranularityEnum, $fromDate: ISO8601Date, $toDate: ISO8601Date, $billableMetricCode: String) {
  dataApiUsages(
    currency: $currency
    timeGranularity: $timeGranularity
    fromDate: $fromDate
    toDate: $toDate
    billableMetricCode: $billableMetricCode
  ) {
    collection {
      amountCents
      amountCurrency
      endOfPeriodDt
      startOfPeriodDt
      units
    }
  }
}
    `;

/**
 * __useGetUsageBillableMetricQuery__
 *
 * To run a query within a React component, call `useGetUsageBillableMetricQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsageBillableMetricQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsageBillableMetricQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      timeGranularity: // value for 'timeGranularity'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      billableMetricCode: // value for 'billableMetricCode'
 *   },
 * });
 */
export function useGetUsageBillableMetricQuery(baseOptions?: Apollo.QueryHookOptions<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>(GetUsageBillableMetricDocument, options);
      }
export function useGetUsageBillableMetricLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>(GetUsageBillableMetricDocument, options);
        }
export function useGetUsageBillableMetricSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>(GetUsageBillableMetricDocument, options);
        }
export type GetUsageBillableMetricQueryHookResult = ReturnType<typeof useGetUsageBillableMetricQuery>;
export type GetUsageBillableMetricLazyQueryHookResult = ReturnType<typeof useGetUsageBillableMetricLazyQuery>;
export type GetUsageBillableMetricSuspenseQueryHookResult = ReturnType<typeof useGetUsageBillableMetricSuspenseQuery>;
export type GetUsageBillableMetricQueryResult = Apollo.QueryResult<GetUsageBillableMetricQuery, GetUsageBillableMetricQueryVariables>;
export const GetUsageBreakdownDocument = gql`
    query getUsageBreakdown($currency: CurrencyEnum, $timeGranularity: TimeGranularityEnum, $fromDate: ISO8601Date, $toDate: ISO8601Date, $isBillableMetricRecurring: Boolean, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $externalCustomerId: String, $planCode: String, $externalSubscriptionId: String) {
  dataApiUsages(
    currency: $currency
    timeGranularity: $timeGranularity
    fromDate: $fromDate
    toDate: $toDate
    isBillableMetricRecurring: $isBillableMetricRecurring
    customerCountry: $customerCountry
    customerType: $customerType
    externalCustomerId: $externalCustomerId
    planCode: $planCode
    externalSubscriptionId: $externalSubscriptionId
  ) {
    collection {
      startOfPeriodDt
      endOfPeriodDt
      amountCurrency
      amountCents
      billableMetricCode
      units
      isBillableMetricDeleted
    }
  }
}
    `;

/**
 * __useGetUsageBreakdownQuery__
 *
 * To run a query within a React component, call `useGetUsageBreakdownQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsageBreakdownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsageBreakdownQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      timeGranularity: // value for 'timeGranularity'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      isBillableMetricRecurring: // value for 'isBillableMetricRecurring'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      planCode: // value for 'planCode'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *   },
 * });
 */
export function useGetUsageBreakdownQuery(baseOptions?: Apollo.QueryHookOptions<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>(GetUsageBreakdownDocument, options);
      }
export function useGetUsageBreakdownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>(GetUsageBreakdownDocument, options);
        }
export function useGetUsageBreakdownSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>(GetUsageBreakdownDocument, options);
        }
export type GetUsageBreakdownQueryHookResult = ReturnType<typeof useGetUsageBreakdownQuery>;
export type GetUsageBreakdownLazyQueryHookResult = ReturnType<typeof useGetUsageBreakdownLazyQuery>;
export type GetUsageBreakdownSuspenseQueryHookResult = ReturnType<typeof useGetUsageBreakdownSuspenseQuery>;
export type GetUsageBreakdownQueryResult = Apollo.QueryResult<GetUsageBreakdownQuery, GetUsageBreakdownQueryVariables>;
export const GetUsageOverviewDocument = gql`
    query getUsageOverview($currency: CurrencyEnum, $timeGranularity: TimeGranularityEnum, $fromDate: ISO8601Date, $toDate: ISO8601Date, $billingEntityCode: String, $isCustomerTinEmpty: Boolean, $planCode: String, $externalCustomerId: String, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $externalSubscriptionId: String) {
  dataApiUsagesAggregatedAmounts(
    currency: $currency
    timeGranularity: $timeGranularity
    fromDate: $fromDate
    toDate: $toDate
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
    planCode: $planCode
    externalCustomerId: $externalCustomerId
    customerCountry: $customerCountry
    customerType: $customerType
    externalSubscriptionId: $externalSubscriptionId
  ) {
    collection {
      amountCents
      amountCurrency
      endOfPeriodDt
      startOfPeriodDt
    }
  }
}
    `;

/**
 * __useGetUsageOverviewQuery__
 *
 * To run a query within a React component, call `useGetUsageOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsageOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsageOverviewQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      timeGranularity: // value for 'timeGranularity'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *      planCode: // value for 'planCode'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *   },
 * });
 */
export function useGetUsageOverviewQuery(baseOptions?: Apollo.QueryHookOptions<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>(GetUsageOverviewDocument, options);
      }
export function useGetUsageOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>(GetUsageOverviewDocument, options);
        }
export function useGetUsageOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>(GetUsageOverviewDocument, options);
        }
export type GetUsageOverviewQueryHookResult = ReturnType<typeof useGetUsageOverviewQuery>;
export type GetUsageOverviewLazyQueryHookResult = ReturnType<typeof useGetUsageOverviewLazyQuery>;
export type GetUsageOverviewSuspenseQueryHookResult = ReturnType<typeof useGetUsageOverviewSuspenseQuery>;
export type GetUsageOverviewQueryResult = Apollo.QueryResult<GetUsageOverviewQuery, GetUsageOverviewQueryVariables>;
export const GetGoogleAuthUrlDocument = gql`
    query getGoogleAuthUrl {
  googleAuthUrl {
    url
  }
}
    `;

/**
 * __useGetGoogleAuthUrlQuery__
 *
 * To run a query within a React component, call `useGetGoogleAuthUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGoogleAuthUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGoogleAuthUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetGoogleAuthUrlQuery(baseOptions?: Apollo.QueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
      }
export function useGetGoogleAuthUrlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export function useGetGoogleAuthUrlSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export type GetGoogleAuthUrlQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlQuery>;
export type GetGoogleAuthUrlLazyQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlLazyQuery>;
export type GetGoogleAuthUrlSuspenseQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlSuspenseQuery>;
export type GetGoogleAuthUrlQueryResult = Apollo.QueryResult<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>;
export const BillableMetricActivityLogsDocument = gql`
    query BillableMetricActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useBillableMetricActivityLogsQuery__
 *
 * To run a query within a React component, call `useBillableMetricActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillableMetricActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillableMetricActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function useBillableMetricActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>(BillableMetricActivityLogsDocument, options);
      }
export function useBillableMetricActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>(BillableMetricActivityLogsDocument, options);
        }
export function useBillableMetricActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>(BillableMetricActivityLogsDocument, options);
        }
export type BillableMetricActivityLogsQueryHookResult = ReturnType<typeof useBillableMetricActivityLogsQuery>;
export type BillableMetricActivityLogsLazyQueryHookResult = ReturnType<typeof useBillableMetricActivityLogsLazyQuery>;
export type BillableMetricActivityLogsSuspenseQueryHookResult = ReturnType<typeof useBillableMetricActivityLogsSuspenseQuery>;
export type BillableMetricActivityLogsQueryResult = Apollo.QueryResult<BillableMetricActivityLogsQuery, BillableMetricActivityLogsQueryVariables>;
export const GetBillableMetricForDetailsOverviewDocument = gql`
    query getBillableMetricForDetailsOverview($id: ID!) {
  billableMetric(id: $id) {
    id
    ...BillableMetricDetails
  }
}
    ${BillableMetricDetailsFragmentDoc}`;

/**
 * __useGetBillableMetricForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricForDetailsOverviewQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBillableMetricForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables> & ({ variables: GetBillableMetricForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>(GetBillableMetricForDetailsOverviewDocument, options);
      }
export function useGetBillableMetricForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>(GetBillableMetricForDetailsOverviewDocument, options);
        }
export function useGetBillableMetricForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>(GetBillableMetricForDetailsOverviewDocument, options);
        }
export type GetBillableMetricForDetailsOverviewQueryHookResult = ReturnType<typeof useGetBillableMetricForDetailsOverviewQuery>;
export type GetBillableMetricForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetBillableMetricForDetailsOverviewLazyQuery>;
export type GetBillableMetricForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricForDetailsOverviewSuspenseQuery>;
export type GetBillableMetricForDetailsOverviewQueryResult = Apollo.QueryResult<GetBillableMetricForDetailsOverviewQuery, GetBillableMetricForDetailsOverviewQueryVariables>;
export const GetBillableMetricToDeleteDocument = gql`
    query getBillableMetricToDelete($id: ID!) {
  billableMetric(id: $id) {
    ...DeleteBillableMetricDialog
  }
}
    ${DeleteBillableMetricDialogFragmentDoc}`;

/**
 * __useGetBillableMetricToDeleteQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricToDeleteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricToDeleteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricToDeleteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBillableMetricToDeleteQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables> & ({ variables: GetBillableMetricToDeleteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
      }
export function useGetBillableMetricToDeleteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
        }
export function useGetBillableMetricToDeleteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
        }
export type GetBillableMetricToDeleteQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteQuery>;
export type GetBillableMetricToDeleteLazyQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteLazyQuery>;
export type GetBillableMetricToDeleteSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteSuspenseQuery>;
export type GetBillableMetricToDeleteQueryResult = Apollo.QueryResult<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>;
export const DeleteBillableMetricDocument = gql`
    mutation deleteBillableMetric($input: DestroyBillableMetricInput!) {
  destroyBillableMetric(input: $input) {
    id
  }
}
    `;
export type DeleteBillableMetricMutationFn = Apollo.MutationFunction<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;

/**
 * __useDeleteBillableMetricMutation__
 *
 * To run a mutation, you first call `useDeleteBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBillableMetricMutation, { data, loading, error }] = useDeleteBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>(DeleteBillableMetricDocument, options);
      }
export type DeleteBillableMetricMutationHookResult = ReturnType<typeof useDeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationResult = Apollo.MutationResult<DeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationOptions = Apollo.BaseMutationOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;
export const GetBillableMetricsForCouponsDocument = gql`
    query getBillableMetricsForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...BillableMetricsForCoupons
    }
  }
}
    ${BillableMetricsForCouponsFragmentDoc}`;

/**
 * __useGetBillableMetricsForCouponsQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetBillableMetricsForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
      }
export function useGetBillableMetricsForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export function useGetBillableMetricsForCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export type GetBillableMetricsForCouponsQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsQuery>;
export type GetBillableMetricsForCouponsLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsLazyQuery>;
export type GetBillableMetricsForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsSuspenseQuery>;
export type GetBillableMetricsForCouponsQueryResult = Apollo.QueryResult<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>;
export const GetPlansForCouponsDocument = gql`
    query getPlansForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...PlansForCoupons
    }
  }
}
    ${PlansForCouponsFragmentDoc}`;

/**
 * __useGetPlansForCouponsQuery__
 *
 * To run a query within a React component, call `useGetPlansForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
      }
export function useGetPlansForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export function useGetPlansForCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export type GetPlansForCouponsQueryHookResult = ReturnType<typeof useGetPlansForCouponsQuery>;
export type GetPlansForCouponsLazyQueryHookResult = ReturnType<typeof useGetPlansForCouponsLazyQuery>;
export type GetPlansForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetPlansForCouponsSuspenseQuery>;
export type GetPlansForCouponsQueryResult = Apollo.QueryResult<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>;
export const CouponDetailsActivityLogsDocument = gql`
    query CouponDetailsActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useCouponDetailsActivityLogsQuery__
 *
 * To run a query within a React component, call `useCouponDetailsActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCouponDetailsActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCouponDetailsActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function useCouponDetailsActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>(CouponDetailsActivityLogsDocument, options);
      }
export function useCouponDetailsActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>(CouponDetailsActivityLogsDocument, options);
        }
export function useCouponDetailsActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>(CouponDetailsActivityLogsDocument, options);
        }
export type CouponDetailsActivityLogsQueryHookResult = ReturnType<typeof useCouponDetailsActivityLogsQuery>;
export type CouponDetailsActivityLogsLazyQueryHookResult = ReturnType<typeof useCouponDetailsActivityLogsLazyQuery>;
export type CouponDetailsActivityLogsSuspenseQueryHookResult = ReturnType<typeof useCouponDetailsActivityLogsSuspenseQuery>;
export type CouponDetailsActivityLogsQueryResult = Apollo.QueryResult<CouponDetailsActivityLogsQuery, CouponDetailsActivityLogsQueryVariables>;
export const GetCouponForDetailsOverviewDocument = gql`
    query getCouponForDetailsOverview($id: ID!) {
  coupon(id: $id) {
    id
    ...CouponDetailsForOverview
  }
}
    ${CouponDetailsForOverviewFragmentDoc}`;

/**
 * __useGetCouponForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetCouponForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForDetailsOverviewQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCouponForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables> & ({ variables: GetCouponForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>(GetCouponForDetailsOverviewDocument, options);
      }
export function useGetCouponForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>(GetCouponForDetailsOverviewDocument, options);
        }
export function useGetCouponForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>(GetCouponForDetailsOverviewDocument, options);
        }
export type GetCouponForDetailsOverviewQueryHookResult = ReturnType<typeof useGetCouponForDetailsOverviewQuery>;
export type GetCouponForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetCouponForDetailsOverviewLazyQuery>;
export type GetCouponForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetCouponForDetailsOverviewSuspenseQuery>;
export type GetCouponForDetailsOverviewQueryResult = Apollo.QueryResult<GetCouponForDetailsOverviewQuery, GetCouponForDetailsOverviewQueryVariables>;
export const GetCouponToDeleteDocument = gql`
    query getCouponToDelete($id: ID!) {
  coupon(id: $id) {
    ...DeleteCoupon
  }
}
    ${DeleteCouponFragmentDoc}`;

/**
 * __useGetCouponToDeleteQuery__
 *
 * To run a query within a React component, call `useGetCouponToDeleteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponToDeleteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponToDeleteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCouponToDeleteQuery(baseOptions: Apollo.QueryHookOptions<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables> & ({ variables: GetCouponToDeleteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>(GetCouponToDeleteDocument, options);
      }
export function useGetCouponToDeleteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>(GetCouponToDeleteDocument, options);
        }
export function useGetCouponToDeleteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>(GetCouponToDeleteDocument, options);
        }
export type GetCouponToDeleteQueryHookResult = ReturnType<typeof useGetCouponToDeleteQuery>;
export type GetCouponToDeleteLazyQueryHookResult = ReturnType<typeof useGetCouponToDeleteLazyQuery>;
export type GetCouponToDeleteSuspenseQueryHookResult = ReturnType<typeof useGetCouponToDeleteSuspenseQuery>;
export type GetCouponToDeleteQueryResult = Apollo.QueryResult<GetCouponToDeleteQuery, GetCouponToDeleteQueryVariables>;
export const DeleteCouponDocument = gql`
    mutation deleteCoupon($input: DestroyCouponInput!) {
  destroyCoupon(input: $input) {
    id
  }
}
    `;
export type DeleteCouponMutationFn = Apollo.MutationFunction<DeleteCouponMutation, DeleteCouponMutationVariables>;

/**
 * __useDeleteCouponMutation__
 *
 * To run a mutation, you first call `useDeleteCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCouponMutation, { data, loading, error }] = useDeleteCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCouponMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCouponMutation, DeleteCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCouponMutation, DeleteCouponMutationVariables>(DeleteCouponDocument, options);
      }
export type DeleteCouponMutationHookResult = ReturnType<typeof useDeleteCouponMutation>;
export type DeleteCouponMutationResult = Apollo.MutationResult<DeleteCouponMutation>;
export type DeleteCouponMutationOptions = Apollo.BaseMutationOptions<DeleteCouponMutation, DeleteCouponMutationVariables>;
export const TerminateCouponDocument = gql`
    mutation terminateCoupon($input: TerminateCouponInput!) {
  terminateCoupon(input: $input) {
    id
  }
}
    `;
export type TerminateCouponMutationFn = Apollo.MutationFunction<TerminateCouponMutation, TerminateCouponMutationVariables>;

/**
 * __useTerminateCouponMutation__
 *
 * To run a mutation, you first call `useTerminateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCouponMutation, { data, loading, error }] = useTerminateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCouponMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCouponMutation, TerminateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCouponMutation, TerminateCouponMutationVariables>(TerminateCouponDocument, options);
      }
export type TerminateCouponMutationHookResult = ReturnType<typeof useTerminateCouponMutation>;
export type TerminateCouponMutationResult = Apollo.MutationResult<TerminateCouponMutation>;
export type TerminateCouponMutationOptions = Apollo.BaseMutationOptions<TerminateCouponMutation, TerminateCouponMutationVariables>;
export const CreditNoteDetailsActivityLogsDocument = gql`
    query CreditNoteDetailsActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useCreditNoteDetailsActivityLogsQuery__
 *
 * To run a query within a React component, call `useCreditNoteDetailsActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreditNoteDetailsActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreditNoteDetailsActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function useCreditNoteDetailsActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>(CreditNoteDetailsActivityLogsDocument, options);
      }
export function useCreditNoteDetailsActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>(CreditNoteDetailsActivityLogsDocument, options);
        }
export function useCreditNoteDetailsActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>(CreditNoteDetailsActivityLogsDocument, options);
        }
export type CreditNoteDetailsActivityLogsQueryHookResult = ReturnType<typeof useCreditNoteDetailsActivityLogsQuery>;
export type CreditNoteDetailsActivityLogsLazyQueryHookResult = ReturnType<typeof useCreditNoteDetailsActivityLogsLazyQuery>;
export type CreditNoteDetailsActivityLogsSuspenseQueryHookResult = ReturnType<typeof useCreditNoteDetailsActivityLogsSuspenseQuery>;
export type CreditNoteDetailsActivityLogsQueryResult = Apollo.QueryResult<CreditNoteDetailsActivityLogsQuery, CreditNoteDetailsActivityLogsQueryVariables>;
export const GetCreditNoteForDetailsExternalSyncDocument = gql`
    query getCreditNoteForDetailsExternalSync($id: ID!) {
  creditNote(id: $id) {
    id
    taxProviderId
    taxProviderSyncable
    externalIntegrationId
    customer {
      ...CustomerForCreditNoteDetailsExternalSync
    }
  }
}
    ${CustomerForCreditNoteDetailsExternalSyncFragmentDoc}`;

/**
 * __useGetCreditNoteForDetailsExternalSyncQuery__
 *
 * To run a query within a React component, call `useGetCreditNoteForDetailsExternalSyncQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNoteForDetailsExternalSyncQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNoteForDetailsExternalSyncQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCreditNoteForDetailsExternalSyncQuery(baseOptions: Apollo.QueryHookOptions<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables> & ({ variables: GetCreditNoteForDetailsExternalSyncQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>(GetCreditNoteForDetailsExternalSyncDocument, options);
      }
export function useGetCreditNoteForDetailsExternalSyncLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>(GetCreditNoteForDetailsExternalSyncDocument, options);
        }
export function useGetCreditNoteForDetailsExternalSyncSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>(GetCreditNoteForDetailsExternalSyncDocument, options);
        }
export type GetCreditNoteForDetailsExternalSyncQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsExternalSyncQuery>;
export type GetCreditNoteForDetailsExternalSyncLazyQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsExternalSyncLazyQuery>;
export type GetCreditNoteForDetailsExternalSyncSuspenseQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsExternalSyncSuspenseQuery>;
export type GetCreditNoteForDetailsExternalSyncQueryResult = Apollo.QueryResult<GetCreditNoteForDetailsExternalSyncQuery, GetCreditNoteForDetailsExternalSyncQueryVariables>;
export const GetIntegrationsListForCreditNoteDetailsExternalSyncDocument = gql`
    query getIntegrationsListForCreditNoteDetailsExternalSync($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on AnrokIntegration {
        __typename
        id
      }
      ... on AvalaraIntegration {
        __typename
        id
        accountId
        companyId
      }
      ... on NetsuiteIntegration {
        __typename
        id
        accountId
        name
      }
      ... on XeroIntegration {
        __typename
        id
      }
    }
  }
}
    `;

/**
 * __useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery__
 *
 * To run a query within a React component, call `useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery(baseOptions?: Apollo.QueryHookOptions<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>(GetIntegrationsListForCreditNoteDetailsExternalSyncDocument, options);
      }
export function useGetIntegrationsListForCreditNoteDetailsExternalSyncLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>(GetIntegrationsListForCreditNoteDetailsExternalSyncDocument, options);
        }
export function useGetIntegrationsListForCreditNoteDetailsExternalSyncSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>(GetIntegrationsListForCreditNoteDetailsExternalSyncDocument, options);
        }
export type GetIntegrationsListForCreditNoteDetailsExternalSyncQueryHookResult = ReturnType<typeof useGetIntegrationsListForCreditNoteDetailsExternalSyncQuery>;
export type GetIntegrationsListForCreditNoteDetailsExternalSyncLazyQueryHookResult = ReturnType<typeof useGetIntegrationsListForCreditNoteDetailsExternalSyncLazyQuery>;
export type GetIntegrationsListForCreditNoteDetailsExternalSyncSuspenseQueryHookResult = ReturnType<typeof useGetIntegrationsListForCreditNoteDetailsExternalSyncSuspenseQuery>;
export type GetIntegrationsListForCreditNoteDetailsExternalSyncQueryResult = Apollo.QueryResult<GetIntegrationsListForCreditNoteDetailsExternalSyncQuery, GetIntegrationsListForCreditNoteDetailsExternalSyncQueryVariables>;
export const GetCreditNoteForDetailsOverviewDocument = gql`
    query getCreditNoteForDetailsOverview($id: ID!) {
  creditNote(id: $id) {
    id
    createdAt
    balanceAmountCents
    currency
    creditStatus
    refundStatus
    refundedAt
    refundAmountCents
    billingEntity {
      name
      code
    }
    customer {
      id
      name
      displayName
      deletedAt
      applicableTimezone
    }
    ...CreditNoteDetailsForOverviewTable
  }
}
    ${CreditNoteDetailsForOverviewTableFragmentDoc}`;

/**
 * __useGetCreditNoteForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetCreditNoteForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNoteForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNoteForDetailsOverviewQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCreditNoteForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables> & ({ variables: GetCreditNoteForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>(GetCreditNoteForDetailsOverviewDocument, options);
      }
export function useGetCreditNoteForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>(GetCreditNoteForDetailsOverviewDocument, options);
        }
export function useGetCreditNoteForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>(GetCreditNoteForDetailsOverviewDocument, options);
        }
export type GetCreditNoteForDetailsOverviewQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsOverviewQuery>;
export type GetCreditNoteForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsOverviewLazyQuery>;
export type GetCreditNoteForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsOverviewSuspenseQuery>;
export type GetCreditNoteForDetailsOverviewQueryResult = Apollo.QueryResult<GetCreditNoteForDetailsOverviewQuery, GetCreditNoteForDetailsOverviewQueryVariables>;
export const CreditNoteEstimateDocument = gql`
    query creditNoteEstimate($invoiceId: ID!, $items: [CreditNoteItemInput!]!) {
  creditNoteEstimate(invoiceId: $invoiceId, items: $items) {
    appliedTaxes {
      taxCode
      taxName
      taxRate
      amountCents
    }
    couponsAdjustmentAmountCents
    currency
    items {
      amountCents
      fee {
        id
      }
    }
    maxCreditableAmountCents
    maxRefundableAmountCents
    subTotalExcludingTaxesAmountCents
    taxesAmountCents
    taxesRate
  }
}
    `;

/**
 * __useCreditNoteEstimateQuery__
 *
 * To run a query within a React component, call `useCreditNoteEstimateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreditNoteEstimateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreditNoteEstimateQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      items: // value for 'items'
 *   },
 * });
 */
export function useCreditNoteEstimateQuery(baseOptions: Apollo.QueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables> & ({ variables: CreditNoteEstimateQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
      }
export function useCreditNoteEstimateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export function useCreditNoteEstimateSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export type CreditNoteEstimateQueryHookResult = ReturnType<typeof useCreditNoteEstimateQuery>;
export type CreditNoteEstimateLazyQueryHookResult = ReturnType<typeof useCreditNoteEstimateLazyQuery>;
export type CreditNoteEstimateSuspenseQueryHookResult = ReturnType<typeof useCreditNoteEstimateSuspenseQuery>;
export type CreditNoteEstimateQueryResult = Apollo.QueryResult<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>;
export const DownloadCreditNoteDocument = gql`
    mutation downloadCreditNote($input: DownloadCreditNoteInput!) {
  downloadCreditNote(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCreditNoteMutationFn = Apollo.MutationFunction<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;

/**
 * __useDownloadCreditNoteMutation__
 *
 * To run a mutation, you first call `useDownloadCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCreditNoteMutation, { data, loading, error }] = useDownloadCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>(DownloadCreditNoteDocument, options);
      }
export type DownloadCreditNoteMutationHookResult = ReturnType<typeof useDownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationResult = Apollo.MutationResult<DownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationOptions = Apollo.BaseMutationOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;
export const GetPortalCustomerInfosDocument = gql`
    query getPortalCustomerInfos {
  customerPortalUser {
    id
    customerType
    name
    firstname
    lastname
    legalName
    legalNumber
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
    shippingAddress {
      addressLine1
      addressLine2
      city
      country
      state
      zipcode
    }
  }
}
    `;

/**
 * __useGetPortalCustomerInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalCustomerInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalCustomerInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalCustomerInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalCustomerInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
      }
export function useGetPortalCustomerInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export function useGetPortalCustomerInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export type GetPortalCustomerInfosQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosQuery>;
export type GetPortalCustomerInfosLazyQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosLazyQuery>;
export type GetPortalCustomerInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosSuspenseQuery>;
export type GetPortalCustomerInfosQueryResult = Apollo.QueryResult<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>;
export const CustomerPortalInvoicesDocument = gql`
    query customerPortalInvoices($limit: Int, $page: Int, $searchTerm: String, $status: [InvoiceStatusTypeEnum!]) {
  customerPortalInvoices(
    limit: $limit
    page: $page
    searchTerm: $searchTerm
    status: $status
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...PortalInvoiceListItem
    }
  }
}
    ${PortalInvoiceListItemFragmentDoc}`;

/**
 * __useCustomerPortalInvoicesQuery__
 *
 * To run a query within a React component, call `useCustomerPortalInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerPortalInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerPortalInvoicesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useCustomerPortalInvoicesQuery(baseOptions?: Apollo.QueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
      }
export function useCustomerPortalInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export function useCustomerPortalInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export type CustomerPortalInvoicesQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesQuery>;
export type CustomerPortalInvoicesLazyQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesLazyQuery>;
export type CustomerPortalInvoicesSuspenseQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesSuspenseQuery>;
export type CustomerPortalInvoicesQueryResult = Apollo.QueryResult<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>;
export const DownloadCustomerPortalInvoiceDocument = gql`
    mutation downloadCustomerPortalInvoice($input: DownloadCustomerPortalInvoiceInput!) {
  downloadCustomerPortalInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCustomerPortalInvoiceMutationFn = Apollo.MutationFunction<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;

/**
 * __useDownloadCustomerPortalInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadCustomerPortalInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCustomerPortalInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCustomerPortalInvoiceMutation, { data, loading, error }] = useDownloadCustomerPortalInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCustomerPortalInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>(DownloadCustomerPortalInvoiceDocument, options);
      }
export type DownloadCustomerPortalInvoiceMutationHookResult = ReturnType<typeof useDownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationResult = Apollo.MutationResult<DownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;
export const GetCustomerPortalInvoicesCollectionDocument = gql`
    query getCustomerPortalInvoicesCollection($expireCache: Boolean) {
  customerPortalInvoiceCollections(expireCache: $expireCache) {
    collection {
      amountCents
      invoicesCount
      currency
    }
  }
}
    `;

/**
 * __useGetCustomerPortalInvoicesCollectionQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalInvoicesCollectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalInvoicesCollectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalInvoicesCollectionQuery({
 *   variables: {
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerPortalInvoicesCollectionQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
      }
export function useGetCustomerPortalInvoicesCollectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
        }
export function useGetCustomerPortalInvoicesCollectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
        }
export type GetCustomerPortalInvoicesCollectionQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionQuery>;
export type GetCustomerPortalInvoicesCollectionLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionLazyQuery>;
export type GetCustomerPortalInvoicesCollectionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionSuspenseQuery>;
export type GetCustomerPortalInvoicesCollectionQueryResult = Apollo.QueryResult<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>;
export const GetCustomerPortalOverdueBalancesDocument = gql`
    query getCustomerPortalOverdueBalances($expireCache: Boolean) {
  customerPortalOverdueBalances(expireCache: $expireCache) {
    collection {
      amountCents
      currency
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetCustomerPortalOverdueBalancesQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalOverdueBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalOverdueBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalOverdueBalancesQuery({
 *   variables: {
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerPortalOverdueBalancesQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
      }
export function useGetCustomerPortalOverdueBalancesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
        }
export function useGetCustomerPortalOverdueBalancesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
        }
export type GetCustomerPortalOverdueBalancesQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesQuery>;
export type GetCustomerPortalOverdueBalancesLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesLazyQuery>;
export type GetCustomerPortalOverdueBalancesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesSuspenseQuery>;
export type GetCustomerPortalOverdueBalancesQueryResult = Apollo.QueryResult<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>;
export const GetCustomerPortalUserCurrencyDocument = gql`
    query getCustomerPortalUserCurrency {
  customerPortalUser {
    currency
  }
}
    `;

/**
 * __useGetCustomerPortalUserCurrencyQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalUserCurrencyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalUserCurrencyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalUserCurrencyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCustomerPortalUserCurrencyQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
      }
export function useGetCustomerPortalUserCurrencyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
        }
export function useGetCustomerPortalUserCurrencySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
        }
export type GetCustomerPortalUserCurrencyQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencyQuery>;
export type GetCustomerPortalUserCurrencyLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencyLazyQuery>;
export type GetCustomerPortalUserCurrencySuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencySuspenseQuery>;
export type GetCustomerPortalUserCurrencyQueryResult = Apollo.QueryResult<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>;
export const GetPortalLocaleDocument = gql`
    query getPortalLocale {
  customerPortalOrganization {
    id
    premiumIntegrations
    billingConfiguration {
      id
      documentLocale
    }
  }
  customerPortalUser {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;

/**
 * __useGetPortalLocaleQuery__
 *
 * To run a query within a React component, call `useGetPortalLocaleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalLocaleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalLocaleQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalLocaleQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
      }
export function useGetPortalLocaleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export function useGetPortalLocaleSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export type GetPortalLocaleQueryHookResult = ReturnType<typeof useGetPortalLocaleQuery>;
export type GetPortalLocaleLazyQueryHookResult = ReturnType<typeof useGetPortalLocaleLazyQuery>;
export type GetPortalLocaleSuspenseQueryHookResult = ReturnType<typeof useGetPortalLocaleSuspenseQuery>;
export type GetPortalLocaleQueryResult = Apollo.QueryResult<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>;
export const UpdatePortalCustomerDocument = gql`
    mutation updatePortalCustomer($input: UpdateCustomerPortalCustomerInput!) {
  updateCustomerPortalCustomer(input: $input) {
    id
  }
}
    `;
export type UpdatePortalCustomerMutationFn = Apollo.MutationFunction<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>;

/**
 * __useUpdatePortalCustomerMutation__
 *
 * To run a mutation, you first call `useUpdatePortalCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePortalCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePortalCustomerMutation, { data, loading, error }] = useUpdatePortalCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePortalCustomerMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>(UpdatePortalCustomerDocument, options);
      }
export type UpdatePortalCustomerMutationHookResult = ReturnType<typeof useUpdatePortalCustomerMutation>;
export type UpdatePortalCustomerMutationResult = Apollo.MutationResult<UpdatePortalCustomerMutation>;
export type UpdatePortalCustomerMutationOptions = Apollo.BaseMutationOptions<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>;
export const GetSubscriptionForPortalDocument = gql`
    query getSubscriptionForPortal($subscriptionId: ID!) {
  customerPortalSubscription(id: $subscriptionId) {
    id
    ...SubscriptionForPortalUsage
  }
}
    ${SubscriptionForPortalUsageFragmentDoc}`;

/**
 * __useGetSubscriptionForPortalQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForPortalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForPortalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForPortalQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForPortalQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables> & ({ variables: GetSubscriptionForPortalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
      }
export function useGetSubscriptionForPortalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
        }
export function useGetSubscriptionForPortalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
        }
export type GetSubscriptionForPortalQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalQuery>;
export type GetSubscriptionForPortalLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalLazyQuery>;
export type GetSubscriptionForPortalSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalSuspenseQuery>;
export type GetSubscriptionForPortalQueryResult = Apollo.QueryResult<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>;
export const GetCustomerUsageForPortalDocument = gql`
    query getCustomerUsageForPortal($subscriptionId: ID!) {
  customerPortalCustomerUsage(subscriptionId: $subscriptionId) {
    amountCents
    ...SubscriptionCurrentUsageTableComponentCustomerUsage
    ...CustomerUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc}
${CustomerUsageForUsageDetailsFragmentDoc}`;

/**
 * __useGetCustomerUsageForPortalQuery__
 *
 * To run a query within a React component, call `useGetCustomerUsageForPortalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerUsageForPortalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerUsageForPortalQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetCustomerUsageForPortalQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables> & ({ variables: GetCustomerUsageForPortalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
      }
export function useGetCustomerUsageForPortalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
        }
export function useGetCustomerUsageForPortalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
        }
export type GetCustomerUsageForPortalQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalQuery>;
export type GetCustomerUsageForPortalLazyQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalLazyQuery>;
export type GetCustomerUsageForPortalSuspenseQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalSuspenseQuery>;
export type GetCustomerUsageForPortalQueryResult = Apollo.QueryResult<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>;
export const GetCustomerProjectedUsageForPortalDocument = gql`
    query getCustomerProjectedUsageForPortal($subscriptionId: ID!) {
  customerPortalCustomerProjectedUsage(subscriptionId: $subscriptionId) {
    amountCents
    ...SubscriptionCurrentUsageTableComponentCustomerProjectedUsage
    ...CustomerProjectedUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerProjectedUsageFragmentDoc}
${CustomerProjectedUsageForUsageDetailsFragmentDoc}`;

/**
 * __useGetCustomerProjectedUsageForPortalQuery__
 *
 * To run a query within a React component, call `useGetCustomerProjectedUsageForPortalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerProjectedUsageForPortalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerProjectedUsageForPortalQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetCustomerProjectedUsageForPortalQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables> & ({ variables: GetCustomerProjectedUsageForPortalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>(GetCustomerProjectedUsageForPortalDocument, options);
      }
export function useGetCustomerProjectedUsageForPortalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>(GetCustomerProjectedUsageForPortalDocument, options);
        }
export function useGetCustomerProjectedUsageForPortalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>(GetCustomerProjectedUsageForPortalDocument, options);
        }
export type GetCustomerProjectedUsageForPortalQueryHookResult = ReturnType<typeof useGetCustomerProjectedUsageForPortalQuery>;
export type GetCustomerProjectedUsageForPortalLazyQueryHookResult = ReturnType<typeof useGetCustomerProjectedUsageForPortalLazyQuery>;
export type GetCustomerProjectedUsageForPortalSuspenseQueryHookResult = ReturnType<typeof useGetCustomerProjectedUsageForPortalSuspenseQuery>;
export type GetCustomerProjectedUsageForPortalQueryResult = Apollo.QueryResult<GetCustomerProjectedUsageForPortalQuery, GetCustomerProjectedUsageForPortalQueryVariables>;
export const GetPortalUsageDocument = gql`
    query getPortalUsage($status: [StatusTypeEnum!]) {
  customerPortalSubscriptions(status: $status) {
    collection {
      id
      ...SubscriptionForPortalUsage
    }
  }
}
    ${SubscriptionForPortalUsageFragmentDoc}`;

/**
 * __useGetPortalUsageQuery__
 *
 * To run a query within a React component, call `useGetPortalUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalUsageQuery({
 *   variables: {
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetPortalUsageQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
      }
export function useGetPortalUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
        }
export function useGetPortalUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
        }
export type GetPortalUsageQueryHookResult = ReturnType<typeof useGetPortalUsageQuery>;
export type GetPortalUsageLazyQueryHookResult = ReturnType<typeof useGetPortalUsageLazyQuery>;
export type GetPortalUsageSuspenseQueryHookResult = ReturnType<typeof useGetPortalUsageSuspenseQuery>;
export type GetPortalUsageQueryResult = Apollo.QueryResult<GetPortalUsageQuery, GetPortalUsageQueryVariables>;
export const CustomerPortalWalletDocument = gql`
    query customerPortalWallet($id: ID!) {
  customerPortalWallet(id: $id) {
    id
    currency
    name
    rateAmount
    paidTopUpMinAmountCents
    paidTopUpMaxAmountCents
  }
}
    `;

/**
 * __useCustomerPortalWalletQuery__
 *
 * To run a query within a React component, call `useCustomerPortalWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerPortalWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerPortalWalletQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCustomerPortalWalletQuery(baseOptions: Apollo.QueryHookOptions<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables> & ({ variables: CustomerPortalWalletQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>(CustomerPortalWalletDocument, options);
      }
export function useCustomerPortalWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>(CustomerPortalWalletDocument, options);
        }
export function useCustomerPortalWalletSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>(CustomerPortalWalletDocument, options);
        }
export type CustomerPortalWalletQueryHookResult = ReturnType<typeof useCustomerPortalWalletQuery>;
export type CustomerPortalWalletLazyQueryHookResult = ReturnType<typeof useCustomerPortalWalletLazyQuery>;
export type CustomerPortalWalletSuspenseQueryHookResult = ReturnType<typeof useCustomerPortalWalletSuspenseQuery>;
export type CustomerPortalWalletQueryResult = Apollo.QueryResult<CustomerPortalWalletQuery, CustomerPortalWalletQueryVariables>;
export const TopUpPortalWalletDocument = gql`
    mutation TopUpPortalWallet($input: CreateCustomerPortalWalletTransactionInput!) {
  createCustomerPortalWalletTransaction(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type TopUpPortalWalletMutationFn = Apollo.MutationFunction<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>;

/**
 * __useTopUpPortalWalletMutation__
 *
 * To run a mutation, you first call `useTopUpPortalWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTopUpPortalWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [topUpPortalWalletMutation, { data, loading, error }] = useTopUpPortalWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTopUpPortalWalletMutation(baseOptions?: Apollo.MutationHookOptions<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>(TopUpPortalWalletDocument, options);
      }
export type TopUpPortalWalletMutationHookResult = ReturnType<typeof useTopUpPortalWalletMutation>;
export type TopUpPortalWalletMutationResult = Apollo.MutationResult<TopUpPortalWalletMutation>;
export type TopUpPortalWalletMutationOptions = Apollo.BaseMutationOptions<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>;
export const GetPortalCustomerDataDocument = gql`
    query getPortalCustomerData {
  customerPortalUser {
    applicableTimezone
    premium
  }
}
    `;

/**
 * __useGetPortalCustomerDataQuery__
 *
 * To run a query within a React component, call `useGetPortalCustomerDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalCustomerDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalCustomerDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalCustomerDataQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
      }
export function useGetPortalCustomerDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
        }
export function useGetPortalCustomerDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
        }
export type GetPortalCustomerDataQueryHookResult = ReturnType<typeof useGetPortalCustomerDataQuery>;
export type GetPortalCustomerDataLazyQueryHookResult = ReturnType<typeof useGetPortalCustomerDataLazyQuery>;
export type GetPortalCustomerDataSuspenseQueryHookResult = ReturnType<typeof useGetPortalCustomerDataSuspenseQuery>;
export type GetPortalCustomerDataQueryResult = Apollo.QueryResult<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>;
export const GetPortalWalletsDocument = gql`
    query getPortalWallets($limit: Int, $page: Int, $status: WalletStatusEnum) {
  customerPortalWallets(limit: $limit, page: $page, status: $status) {
    collection {
      ...CustomerPortalWalletInfo
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${CustomerPortalWalletInfoFragmentDoc}`;

/**
 * __useGetPortalWalletsQuery__
 *
 * To run a query within a React component, call `useGetPortalWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalWalletsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetPortalWalletsQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
      }
export function useGetPortalWalletsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
        }
export function useGetPortalWalletsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
        }
export type GetPortalWalletsQueryHookResult = ReturnType<typeof useGetPortalWalletsQuery>;
export type GetPortalWalletsLazyQueryHookResult = ReturnType<typeof useGetPortalWalletsLazyQuery>;
export type GetPortalWalletsSuspenseQueryHookResult = ReturnType<typeof useGetPortalWalletsSuspenseQuery>;
export type GetPortalWalletsQueryResult = Apollo.QueryResult<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>;
export const GetCouponForCustomerDocument = gql`
    query getCouponForCustomer($page: Int, $limit: Int, $status: CouponStatusEnum, $searchTerm: String) {
  coupons(page: $page, limit: $limit, status: $status, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      amountCurrency
      amountCents
      couponType
      percentageRate
      frequency
      frequencyDuration
      plans {
        ...CouponPlansForCustomer
      }
      billableMetrics {
        ...CouponBillableMetricsForCustomer
      }
      ...CouponCaption
    }
  }
}
    ${CouponPlansForCustomerFragmentDoc}
${CouponBillableMetricsForCustomerFragmentDoc}
${CouponCaptionFragmentDoc}`;

/**
 * __useGetCouponForCustomerQuery__
 *
 * To run a query within a React component, call `useGetCouponForCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForCustomerQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCouponForCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
      }
export function useGetCouponForCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export function useGetCouponForCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export type GetCouponForCustomerQueryHookResult = ReturnType<typeof useGetCouponForCustomerQuery>;
export type GetCouponForCustomerLazyQueryHookResult = ReturnType<typeof useGetCouponForCustomerLazyQuery>;
export type GetCouponForCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCouponForCustomerSuspenseQuery>;
export type GetCouponForCustomerQueryResult = Apollo.QueryResult<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>;
export const AddCouponDocument = gql`
    mutation addCoupon($input: CreateAppliedCouponInput!) {
  createAppliedCoupon(input: $input) {
    id
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export type AddCouponMutationFn = Apollo.MutationFunction<AddCouponMutation, AddCouponMutationVariables>;

/**
 * __useAddCouponMutation__
 *
 * To run a mutation, you first call `useAddCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCouponMutation, { data, loading, error }] = useAddCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddCouponMutation(baseOptions?: Apollo.MutationHookOptions<AddCouponMutation, AddCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCouponMutation, AddCouponMutationVariables>(AddCouponDocument, options);
      }
export type AddCouponMutationHookResult = ReturnType<typeof useAddCouponMutation>;
export type AddCouponMutationResult = Apollo.MutationResult<AddCouponMutation>;
export type AddCouponMutationOptions = Apollo.BaseMutationOptions<AddCouponMutation, AddCouponMutationVariables>;
export const CustomerActivityLogsDocument = gql`
    query CustomerActivityLogs($page: Int, $limit: Int, $externalCustomerId: String) {
  activityLogs(
    page: $page
    limit: $limit
    externalCustomerId: $externalCustomerId
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useCustomerActivityLogsQuery__
 *
 * To run a query within a React component, call `useCustomerActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      externalCustomerId: // value for 'externalCustomerId'
 *   },
 * });
 */
export function useCustomerActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>(CustomerActivityLogsDocument, options);
      }
export function useCustomerActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>(CustomerActivityLogsDocument, options);
        }
export function useCustomerActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>(CustomerActivityLogsDocument, options);
        }
export type CustomerActivityLogsQueryHookResult = ReturnType<typeof useCustomerActivityLogsQuery>;
export type CustomerActivityLogsLazyQueryHookResult = ReturnType<typeof useCustomerActivityLogsLazyQuery>;
export type CustomerActivityLogsSuspenseQueryHookResult = ReturnType<typeof useCustomerActivityLogsSuspenseQuery>;
export type CustomerActivityLogsQueryResult = Apollo.QueryResult<CustomerActivityLogsQuery, CustomerActivityLogsQueryVariables>;
export const GetCustomerCreditNotesDocument = gql`
    query getCustomerCreditNotes($customerId: ID!, $page: Int, $limit: Int, $searchTerm: String) {
  creditNotes(
    customerId: $customerId
    page: $page
    limit: $limit
    searchTerm: $searchTerm
  ) {
    ...CreditNotesForTable
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetCustomerCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetCustomerCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCreditNotesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables> & ({ variables: GetCustomerCreditNotesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
      }
export function useGetCustomerCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export function useGetCustomerCreditNotesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export type GetCustomerCreditNotesQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesQuery>;
export type GetCustomerCreditNotesLazyQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesLazyQuery>;
export type GetCustomerCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesSuspenseQuery>;
export type GetCustomerCreditNotesQueryResult = Apollo.QueryResult<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>;
export const DownloadInvoiceItemDocument = gql`
    mutation downloadInvoiceItem($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceItemMutationFn = Apollo.MutationFunction<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;

/**
 * __useDownloadInvoiceItemMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceItemMutation, { data, loading, error }] = useDownloadInvoiceItemMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceItemMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>(DownloadInvoiceItemDocument, options);
      }
export type DownloadInvoiceItemMutationHookResult = ReturnType<typeof useDownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationResult = Apollo.MutationResult<DownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;
export const RetryInvoicePaymentDocument = gql`
    mutation retryInvoicePayment($input: RetryInvoicePaymentInput!) {
  retryInvoicePayment(input: $input) {
    id
    ...InvoiceListItem
  }
}
    ${InvoiceListItemFragmentDoc}`;
export type RetryInvoicePaymentMutationFn = Apollo.MutationFunction<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;

/**
 * __useRetryInvoicePaymentMutation__
 *
 * To run a mutation, you first call `useRetryInvoicePaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryInvoicePaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryInvoicePaymentMutation, { data, loading, error }] = useRetryInvoicePaymentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryInvoicePaymentMutation(baseOptions?: Apollo.MutationHookOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>(RetryInvoicePaymentDocument, options);
      }
export type RetryInvoicePaymentMutationHookResult = ReturnType<typeof useRetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationResult = Apollo.MutationResult<RetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationOptions = Apollo.BaseMutationOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;
export const GeneratePaymentUrlDocument = gql`
    mutation generatePaymentUrl($input: GeneratePaymentUrlInput!) {
  generatePaymentUrl(input: $input) {
    paymentUrl
  }
}
    `;
export type GeneratePaymentUrlMutationFn = Apollo.MutationFunction<GeneratePaymentUrlMutation, GeneratePaymentUrlMutationVariables>;

/**
 * __useGeneratePaymentUrlMutation__
 *
 * To run a mutation, you first call `useGeneratePaymentUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGeneratePaymentUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generatePaymentUrlMutation, { data, loading, error }] = useGeneratePaymentUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGeneratePaymentUrlMutation(baseOptions?: Apollo.MutationHookOptions<GeneratePaymentUrlMutation, GeneratePaymentUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GeneratePaymentUrlMutation, GeneratePaymentUrlMutationVariables>(GeneratePaymentUrlDocument, options);
      }
export type GeneratePaymentUrlMutationHookResult = ReturnType<typeof useGeneratePaymentUrlMutation>;
export type GeneratePaymentUrlMutationResult = Apollo.MutationResult<GeneratePaymentUrlMutation>;
export type GeneratePaymentUrlMutationOptions = Apollo.BaseMutationOptions<GeneratePaymentUrlMutation, GeneratePaymentUrlMutationVariables>;
export const GetCustomerInvoicesDocument = gql`
    query getCustomerInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables> & ({ variables: GetCustomerInvoicesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
      }
export function useGetCustomerInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export function useGetCustomerInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export type GetCustomerInvoicesQueryHookResult = ReturnType<typeof useGetCustomerInvoicesQuery>;
export type GetCustomerInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerInvoicesLazyQuery>;
export type GetCustomerInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInvoicesSuspenseQuery>;
export type GetCustomerInvoicesQueryResult = Apollo.QueryResult<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>;
export const PaymentProvidersListForCustomerMainInfosDocument = gql`
    query paymentProvidersListForCustomerMainInfos($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        id
        name
        code
      }
      ... on GocardlessProvider {
        id
        name
        code
      }
      ... on FlutterwaveProvider {
        id
        name
        code
      }
      ... on CashfreeProvider {
        id
        name
        code
      }
      ... on MoneyhashProvider {
        id
        name
        code
      }
      ... on AdyenProvider {
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __usePaymentProvidersListForCustomerMainInfosQuery__
 *
 * To run a query within a React component, call `usePaymentProvidersListForCustomerMainInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentProvidersListForCustomerMainInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentProvidersListForCustomerMainInfosQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function usePaymentProvidersListForCustomerMainInfosQuery(baseOptions?: Apollo.QueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
      }
export function usePaymentProvidersListForCustomerMainInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
        }
export function usePaymentProvidersListForCustomerMainInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
        }
export type PaymentProvidersListForCustomerMainInfosQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosQuery>;
export type PaymentProvidersListForCustomerMainInfosLazyQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosLazyQuery>;
export type PaymentProvidersListForCustomerMainInfosSuspenseQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosSuspenseQuery>;
export type PaymentProvidersListForCustomerMainInfosQueryResult = Apollo.QueryResult<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>;
export const IntegrationsListForCustomerMainInfosDocument = gql`
    query integrationsListForCustomerMainInfos($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        name
        accountId
      }
      ... on AnrokIntegration {
        __typename
        id
        name
        apiKey
        externalAccountId
      }
      ... on AvalaraIntegration {
        __typename
        id
        name
        accountId
      }
      ... on XeroIntegration {
        __typename
        id
        name
      }
      ... on HubspotIntegration {
        __typename
        id
        name
        portalId
      }
      ... on SalesforceIntegration {
        __typename
        id
        name
        instanceId
      }
    }
  }
}
    `;

/**
 * __useIntegrationsListForCustomerMainInfosQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerMainInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerMainInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerMainInfosQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerMainInfosQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
      }
export function useIntegrationsListForCustomerMainInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export function useIntegrationsListForCustomerMainInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export type IntegrationsListForCustomerMainInfosQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosQuery>;
export type IntegrationsListForCustomerMainInfosLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosLazyQuery>;
export type IntegrationsListForCustomerMainInfosSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosSuspenseQuery>;
export type IntegrationsListForCustomerMainInfosQueryResult = Apollo.QueryResult<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>;
export const GetCustomerSettingsDocument = gql`
    query getCustomerSettings($id: ID!) {
  customer(id: $id) {
    id
    invoiceGracePeriod
    netPaymentTerm
    finalizeZeroAmountInvoice
    billingEntity {
      id
      netPaymentTerm
      finalizeZeroAmountInvoice
      billingConfiguration {
        id
        invoiceGracePeriod
        documentLocale
      }
      appliedDunningCampaign {
        id
        name
        code
        appliedToOrganization
        thresholds {
          currency
        }
      }
    }
    billingConfiguration {
      id
      documentLocale
    }
    ...CustomerAppliedTaxRatesForSettings
    ...CustomerAppliedDunningCampaignForSettings
    ...CustomerAppliedInvoiceCustomSections
    ...EditCustomerInvoiceCustomSection
    ...EditCustomerVatRate
    ...EditCustomerDocumentLocale
    ...EditCustomerDunningCampaign
    ...EditCustomerInvoiceGracePeriod
    ...DeleteCustomerGracePeriod
    ...DeleteCustomerDocumentLocale
    ...CustomerForDeleteVatRateDialog
    ...DeleteCustomerNetPaymentTerm
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}
${CustomerAppliedDunningCampaignForSettingsFragmentDoc}
${CustomerAppliedInvoiceCustomSectionsFragmentDoc}
${EditCustomerInvoiceCustomSectionFragmentDoc}
${EditCustomerVatRateFragmentDoc}
${EditCustomerDocumentLocaleFragmentDoc}
${EditCustomerDunningCampaignFragmentDoc}
${EditCustomerInvoiceGracePeriodFragmentDoc}
${DeleteCustomerGracePeriodFragmentDoc}
${DeleteCustomerDocumentLocaleFragmentDoc}
${CustomerForDeleteVatRateDialogFragmentDoc}
${DeleteCustomerNetPaymentTermFragmentDoc}`;

/**
 * __useGetCustomerSettingsQuery__
 *
 * To run a query within a React component, call `useGetCustomerSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables> & ({ variables: GetCustomerSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
      }
export function useGetCustomerSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export function useGetCustomerSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export type GetCustomerSettingsQueryHookResult = ReturnType<typeof useGetCustomerSettingsQuery>;
export type GetCustomerSettingsLazyQueryHookResult = ReturnType<typeof useGetCustomerSettingsLazyQuery>;
export type GetCustomerSettingsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSettingsSuspenseQuery>;
export type GetCustomerSettingsQueryResult = Apollo.QueryResult<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>;
export const DeleteCustomerDocument = gql`
    mutation deleteCustomer($input: DestroyCustomerInput!) {
  destroyCustomer(input: $input) {
    id
  }
}
    `;
export type DeleteCustomerMutationFn = Apollo.MutationFunction<DeleteCustomerMutation, DeleteCustomerMutationVariables>;

/**
 * __useDeleteCustomerMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerMutation, { data, loading, error }] = useDeleteCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerMutation, DeleteCustomerMutationVariables>(DeleteCustomerDocument, options);
      }
export type DeleteCustomerMutationHookResult = ReturnType<typeof useDeleteCustomerMutation>;
export type DeleteCustomerMutationResult = Apollo.MutationResult<DeleteCustomerMutation>;
export type DeleteCustomerMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>;
export const DeleteCustomerDocumentLocaleDocument = gql`
    mutation deleteCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type DeleteCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;

/**
 * __useDeleteCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerDocumentLocaleMutation, { data, loading, error }] = useDeleteCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>(DeleteCustomerDocumentLocaleDocument, options);
      }
export type DeleteCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useDeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationResult = Apollo.MutationResult<DeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;
export const DeleteCustomerFinalizeZeroAmountInvoiceDocument = gql`
    mutation deleteCustomerFinalizeZeroAmountInvoice($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...DeleteCustomerFinalizeZeroAmountInvoice
  }
}
    ${DeleteCustomerFinalizeZeroAmountInvoiceFragmentDoc}`;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useDeleteCustomerFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useDeleteCustomerFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>(DeleteCustomerFinalizeZeroAmountInvoiceDocument, options);
      }
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useDeleteCustomerFinalizeZeroAmountInvoiceMutation>;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<DeleteCustomerFinalizeZeroAmountInvoiceMutation>;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>;
export const DeleteCustomerGracePeriodDocument = gql`
    mutation deleteCustomerGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    invoiceGracePeriod
  }
}
    `;
export type DeleteCustomerGracePeriodMutationFn = Apollo.MutationFunction<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;

/**
 * __useDeleteCustomerGracePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerGracePeriodMutation, { data, loading, error }] = useDeleteCustomerGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>(DeleteCustomerGracePeriodDocument, options);
      }
export type DeleteCustomerGracePeriodMutationHookResult = ReturnType<typeof useDeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationResult = Apollo.MutationResult<DeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;
export const DeleteCustomerNetPaymentTermDocument = gql`
    mutation deleteCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...DeleteCustomerNetPaymentTerm
  }
}
    ${DeleteCustomerNetPaymentTermFragmentDoc}`;
export type DeleteCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;

/**
 * __useDeleteCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerNetPaymentTermMutation, { data, loading, error }] = useDeleteCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>(DeleteCustomerNetPaymentTermDocument, options);
      }
export type DeleteCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useDeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationResult = Apollo.MutationResult<DeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;
export const RemoveAppliedTaxRateOnCustomerDocument = gql`
    mutation removeAppliedTaxRateOnCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
  }
}
    `;
export type RemoveAppliedTaxRateOnCustomerMutationFn = Apollo.MutationFunction<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;

/**
 * __useRemoveAppliedTaxRateOnCustomerMutation__
 *
 * To run a mutation, you first call `useRemoveAppliedTaxRateOnCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveAppliedTaxRateOnCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeAppliedTaxRateOnCustomerMutation, { data, loading, error }] = useRemoveAppliedTaxRateOnCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveAppliedTaxRateOnCustomerMutation(baseOptions?: Apollo.MutationHookOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>(RemoveAppliedTaxRateOnCustomerDocument, options);
      }
export type RemoveAppliedTaxRateOnCustomerMutationHookResult = ReturnType<typeof useRemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationResult = Apollo.MutationResult<RemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationOptions = Apollo.BaseMutationOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;
export const UpdateCustomerDocumentLocaleDocument = gql`
    mutation updateCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;

/**
 * __useUpdateCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerDocumentLocaleMutation, { data, loading, error }] = useUpdateCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>(UpdateCustomerDocumentLocaleDocument, options);
      }
export type UpdateCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useUpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationResult = Apollo.MutationResult<UpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;
export const GetApplicableDunningCampaignsDocument = gql`
    query getApplicableDunningCampaigns($currency: [CurrencyEnum!]) {
  dunningCampaigns(currency: $currency) {
    collection {
      id
      name
      code
    }
  }
}
    `;

/**
 * __useGetApplicableDunningCampaignsQuery__
 *
 * To run a query within a React component, call `useGetApplicableDunningCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicableDunningCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicableDunningCampaignsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetApplicableDunningCampaignsQuery(baseOptions?: Apollo.QueryHookOptions<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>(GetApplicableDunningCampaignsDocument, options);
      }
export function useGetApplicableDunningCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>(GetApplicableDunningCampaignsDocument, options);
        }
export function useGetApplicableDunningCampaignsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>(GetApplicableDunningCampaignsDocument, options);
        }
export type GetApplicableDunningCampaignsQueryHookResult = ReturnType<typeof useGetApplicableDunningCampaignsQuery>;
export type GetApplicableDunningCampaignsLazyQueryHookResult = ReturnType<typeof useGetApplicableDunningCampaignsLazyQuery>;
export type GetApplicableDunningCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetApplicableDunningCampaignsSuspenseQuery>;
export type GetApplicableDunningCampaignsQueryResult = Apollo.QueryResult<GetApplicableDunningCampaignsQuery, GetApplicableDunningCampaignsQueryVariables>;
export const EditCustomerDunningCampaignDocument = gql`
    mutation editCustomerDunningCampaign($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    appliedDunningCampaign {
      id
    }
    excludeFromDunningCampaign
  }
}
    `;
export type EditCustomerDunningCampaignMutationFn = Apollo.MutationFunction<EditCustomerDunningCampaignMutation, EditCustomerDunningCampaignMutationVariables>;

/**
 * __useEditCustomerDunningCampaignMutation__
 *
 * To run a mutation, you first call `useEditCustomerDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCustomerDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCustomerDunningCampaignMutation, { data, loading, error }] = useEditCustomerDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditCustomerDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<EditCustomerDunningCampaignMutation, EditCustomerDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditCustomerDunningCampaignMutation, EditCustomerDunningCampaignMutationVariables>(EditCustomerDunningCampaignDocument, options);
      }
export type EditCustomerDunningCampaignMutationHookResult = ReturnType<typeof useEditCustomerDunningCampaignMutation>;
export type EditCustomerDunningCampaignMutationResult = Apollo.MutationResult<EditCustomerDunningCampaignMutation>;
export type EditCustomerDunningCampaignMutationOptions = Apollo.BaseMutationOptions<EditCustomerDunningCampaignMutation, EditCustomerDunningCampaignMutationVariables>;
export const GetInvoiceCustomSectionsDocument = gql`
    query getInvoiceCustomSections {
  invoiceCustomSections {
    collection {
      id
      name
      code
    }
  }
}
    `;

/**
 * __useGetInvoiceCustomSectionsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCustomSectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCustomSectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCustomSectionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetInvoiceCustomSectionsQuery(baseOptions?: Apollo.QueryHookOptions<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>(GetInvoiceCustomSectionsDocument, options);
      }
export function useGetInvoiceCustomSectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>(GetInvoiceCustomSectionsDocument, options);
        }
export function useGetInvoiceCustomSectionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>(GetInvoiceCustomSectionsDocument, options);
        }
export type GetInvoiceCustomSectionsQueryHookResult = ReturnType<typeof useGetInvoiceCustomSectionsQuery>;
export type GetInvoiceCustomSectionsLazyQueryHookResult = ReturnType<typeof useGetInvoiceCustomSectionsLazyQuery>;
export type GetInvoiceCustomSectionsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCustomSectionsSuspenseQuery>;
export type GetInvoiceCustomSectionsQueryResult = Apollo.QueryResult<GetInvoiceCustomSectionsQuery, GetInvoiceCustomSectionsQueryVariables>;
export const EditCustomerInvoiceCustomSectionDocument = gql`
    mutation editCustomerInvoiceCustomSection($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...CustomerAppliedInvoiceCustomSections
  }
}
    ${CustomerAppliedInvoiceCustomSectionsFragmentDoc}`;
export type EditCustomerInvoiceCustomSectionMutationFn = Apollo.MutationFunction<EditCustomerInvoiceCustomSectionMutation, EditCustomerInvoiceCustomSectionMutationVariables>;

/**
 * __useEditCustomerInvoiceCustomSectionMutation__
 *
 * To run a mutation, you first call `useEditCustomerInvoiceCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCustomerInvoiceCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCustomerInvoiceCustomSectionMutation, { data, loading, error }] = useEditCustomerInvoiceCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditCustomerInvoiceCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<EditCustomerInvoiceCustomSectionMutation, EditCustomerInvoiceCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditCustomerInvoiceCustomSectionMutation, EditCustomerInvoiceCustomSectionMutationVariables>(EditCustomerInvoiceCustomSectionDocument, options);
      }
export type EditCustomerInvoiceCustomSectionMutationHookResult = ReturnType<typeof useEditCustomerInvoiceCustomSectionMutation>;
export type EditCustomerInvoiceCustomSectionMutationResult = Apollo.MutationResult<EditCustomerInvoiceCustomSectionMutation>;
export type EditCustomerInvoiceCustomSectionMutationOptions = Apollo.BaseMutationOptions<EditCustomerInvoiceCustomSectionMutation, EditCustomerInvoiceCustomSectionMutationVariables>;
export const UpdateCustomerInvoiceGracePeriodDocument = gql`
    mutation updateCustomerInvoiceGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    ...EditCustomerInvoiceGracePeriod
  }
}
    ${EditCustomerInvoiceGracePeriodFragmentDoc}`;
export type UpdateCustomerInvoiceGracePeriodMutationFn = Apollo.MutationFunction<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;

/**
 * __useUpdateCustomerInvoiceGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerInvoiceGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerInvoiceGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerInvoiceGracePeriodMutation, { data, loading, error }] = useUpdateCustomerInvoiceGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerInvoiceGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>(UpdateCustomerInvoiceGracePeriodDocument, options);
      }
export type UpdateCustomerInvoiceGracePeriodMutationHookResult = ReturnType<typeof useUpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationResult = Apollo.MutationResult<UpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;
export const GetTaxRatesForEditCustomerDocument = gql`
    query getTaxRatesForEditCustomer($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
      code
    }
  }
}
    `;

/**
 * __useGetTaxRatesForEditCustomerQuery__
 *
 * To run a query within a React component, call `useGetTaxRatesForEditCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxRatesForEditCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxRatesForEditCustomerQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxRatesForEditCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
      }
export function useGetTaxRatesForEditCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export function useGetTaxRatesForEditCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export type GetTaxRatesForEditCustomerQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerQuery>;
export type GetTaxRatesForEditCustomerLazyQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerLazyQuery>;
export type GetTaxRatesForEditCustomerSuspenseQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerSuspenseQuery>;
export type GetTaxRatesForEditCustomerQueryResult = Apollo.QueryResult<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>;
export const CreateCustomerAppliedTaxDocument = gql`
    mutation createCustomerAppliedTax($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...CustomerAppliedTaxRatesForSettings
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}`;
export type CreateCustomerAppliedTaxMutationFn = Apollo.MutationFunction<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;

/**
 * __useCreateCustomerAppliedTaxMutation__
 *
 * To run a mutation, you first call `useCreateCustomerAppliedTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerAppliedTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerAppliedTaxMutation, { data, loading, error }] = useCreateCustomerAppliedTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerAppliedTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>(CreateCustomerAppliedTaxDocument, options);
      }
export type CreateCustomerAppliedTaxMutationHookResult = ReturnType<typeof useCreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationResult = Apollo.MutationResult<CreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationOptions = Apollo.BaseMutationOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;
export const GetAccountingIntegrationsForExternalAppsAccordionDocument = gql`
    query getAccountingIntegrationsForExternalAppsAccordion($limit: Int, $page: Int) {
  integrations(limit: $limit, page: $page) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        code
        name
      }
      ... on XeroIntegration {
        __typename
        id
        code
        name
      }
    }
  }
}
    `;

/**
 * __useGetAccountingIntegrationsForExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useGetAccountingIntegrationsForExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAccountingIntegrationsForExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAccountingIntegrationsForExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetAccountingIntegrationsForExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>(GetAccountingIntegrationsForExternalAppsAccordionDocument, options);
      }
export function useGetAccountingIntegrationsForExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>(GetAccountingIntegrationsForExternalAppsAccordionDocument, options);
        }
export function useGetAccountingIntegrationsForExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>(GetAccountingIntegrationsForExternalAppsAccordionDocument, options);
        }
export type GetAccountingIntegrationsForExternalAppsAccordionQueryHookResult = ReturnType<typeof useGetAccountingIntegrationsForExternalAppsAccordionQuery>;
export type GetAccountingIntegrationsForExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useGetAccountingIntegrationsForExternalAppsAccordionLazyQuery>;
export type GetAccountingIntegrationsForExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useGetAccountingIntegrationsForExternalAppsAccordionSuspenseQuery>;
export type GetAccountingIntegrationsForExternalAppsAccordionQueryResult = Apollo.QueryResult<GetAccountingIntegrationsForExternalAppsAccordionQuery, GetAccountingIntegrationsForExternalAppsAccordionQueryVariables>;
export const SubsidiariesListForExternalAppsAccordionDocument = gql`
    query subsidiariesListForExternalAppsAccordion($integrationId: ID) {
  integrationSubsidiaries(integrationId: $integrationId) {
    collection {
      externalId
      externalName
    }
  }
}
    `;

/**
 * __useSubsidiariesListForExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useSubsidiariesListForExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubsidiariesListForExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubsidiariesListForExternalAppsAccordionQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useSubsidiariesListForExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>(SubsidiariesListForExternalAppsAccordionDocument, options);
      }
export function useSubsidiariesListForExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>(SubsidiariesListForExternalAppsAccordionDocument, options);
        }
export function useSubsidiariesListForExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>(SubsidiariesListForExternalAppsAccordionDocument, options);
        }
export type SubsidiariesListForExternalAppsAccordionQueryHookResult = ReturnType<typeof useSubsidiariesListForExternalAppsAccordionQuery>;
export type SubsidiariesListForExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useSubsidiariesListForExternalAppsAccordionLazyQuery>;
export type SubsidiariesListForExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useSubsidiariesListForExternalAppsAccordionSuspenseQuery>;
export type SubsidiariesListForExternalAppsAccordionQueryResult = Apollo.QueryResult<SubsidiariesListForExternalAppsAccordionQuery, SubsidiariesListForExternalAppsAccordionQueryVariables>;
export const GetCrmIntegrationsForExternalAppsAccordionDocument = gql`
    query getCrmIntegrationsForExternalAppsAccordion($limit: Int, $page: Int) {
  integrations(limit: $limit, page: $page) {
    collection {
      ... on HubspotIntegration {
        __typename
        id
        code
        name
        defaultTargetedObject
      }
      ... on SalesforceIntegration {
        __typename
        id
        code
        name
      }
    }
  }
}
    `;

/**
 * __useGetCrmIntegrationsForExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useGetCrmIntegrationsForExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCrmIntegrationsForExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCrmIntegrationsForExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetCrmIntegrationsForExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>(GetCrmIntegrationsForExternalAppsAccordionDocument, options);
      }
export function useGetCrmIntegrationsForExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>(GetCrmIntegrationsForExternalAppsAccordionDocument, options);
        }
export function useGetCrmIntegrationsForExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>(GetCrmIntegrationsForExternalAppsAccordionDocument, options);
        }
export type GetCrmIntegrationsForExternalAppsAccordionQueryHookResult = ReturnType<typeof useGetCrmIntegrationsForExternalAppsAccordionQuery>;
export type GetCrmIntegrationsForExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useGetCrmIntegrationsForExternalAppsAccordionLazyQuery>;
export type GetCrmIntegrationsForExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useGetCrmIntegrationsForExternalAppsAccordionSuspenseQuery>;
export type GetCrmIntegrationsForExternalAppsAccordionQueryResult = Apollo.QueryResult<GetCrmIntegrationsForExternalAppsAccordionQuery, GetCrmIntegrationsForExternalAppsAccordionQueryVariables>;
export const PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument = gql`
    query paymentProvidersListForCustomerCreateEditExternalAppsAccordion($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on CashfreeProvider {
        __typename
        id
        name
        code
      }
      ... on FlutterwaveProvider {
        __typename
        id
        name
        code
      }
      ... on StripeProvider {
        __typename
        id
        name
        code
      }
      ... on GocardlessProvider {
        __typename
        id
        name
        code
      }
      ... on AdyenProvider {
        __typename
        id
        name
        code
      }
      ... on MoneyhashProvider {
        __typename
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
      }
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryResult = Apollo.QueryResult<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>;
export const GetTaxIntegrationsForExternalAppsAccordionDocument = gql`
    query getTaxIntegrationsForExternalAppsAccordion($limit: Int, $page: Int) {
  integrations(limit: $limit, page: $page) {
    collection {
      ... on AnrokIntegration {
        __typename
        id
        code
        name
      }
      ... on AvalaraIntegration {
        __typename
        id
        code
        name
      }
    }
  }
}
    `;

/**
 * __useGetTaxIntegrationsForExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useGetTaxIntegrationsForExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxIntegrationsForExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxIntegrationsForExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxIntegrationsForExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>(GetTaxIntegrationsForExternalAppsAccordionDocument, options);
      }
export function useGetTaxIntegrationsForExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>(GetTaxIntegrationsForExternalAppsAccordionDocument, options);
        }
export function useGetTaxIntegrationsForExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>(GetTaxIntegrationsForExternalAppsAccordionDocument, options);
        }
export type GetTaxIntegrationsForExternalAppsAccordionQueryHookResult = ReturnType<typeof useGetTaxIntegrationsForExternalAppsAccordionQuery>;
export type GetTaxIntegrationsForExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useGetTaxIntegrationsForExternalAppsAccordionLazyQuery>;
export type GetTaxIntegrationsForExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useGetTaxIntegrationsForExternalAppsAccordionSuspenseQuery>;
export type GetTaxIntegrationsForExternalAppsAccordionQueryResult = Apollo.QueryResult<GetTaxIntegrationsForExternalAppsAccordionQuery, GetTaxIntegrationsForExternalAppsAccordionQueryVariables>;
export const VoidCreditNoteDocument = gql`
    mutation voidCreditNote($input: VoidCreditNoteInput!) {
  voidCreditNote(input: $input) {
    id
  }
}
    `;
export type VoidCreditNoteMutationFn = Apollo.MutationFunction<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;

/**
 * __useVoidCreditNoteMutation__
 *
 * To run a mutation, you first call `useVoidCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidCreditNoteMutation, { data, loading, error }] = useVoidCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>(VoidCreditNoteDocument, options);
      }
export type VoidCreditNoteMutationHookResult = ReturnType<typeof useVoidCreditNoteMutation>;
export type VoidCreditNoteMutationResult = Apollo.MutationResult<VoidCreditNoteMutation>;
export type VoidCreditNoteMutationOptions = Apollo.BaseMutationOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;
export const GetCustomerCouponsDocument = gql`
    query getCustomerCoupons($id: ID!) {
  customer(id: $id) {
    id
    name
    displayName
    ...CustomerAppliedCoupons
  }
}
    ${CustomerAppliedCouponsFragmentDoc}`;

/**
 * __useGetCustomerCouponsQuery__
 *
 * To run a query within a React component, call `useGetCustomerCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCouponsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerCouponsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables> & ({ variables: GetCustomerCouponsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
      }
export function useGetCustomerCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export function useGetCustomerCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export type GetCustomerCouponsQueryHookResult = ReturnType<typeof useGetCustomerCouponsQuery>;
export type GetCustomerCouponsLazyQueryHookResult = ReturnType<typeof useGetCustomerCouponsLazyQuery>;
export type GetCustomerCouponsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCouponsSuspenseQuery>;
export type GetCustomerCouponsQueryResult = Apollo.QueryResult<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>;
export const RemoveCouponDocument = gql`
    mutation removeCoupon($input: TerminateAppliedCouponInput!) {
  terminateAppliedCoupon(input: $input) {
    id
  }
}
    `;
export type RemoveCouponMutationFn = Apollo.MutationFunction<RemoveCouponMutation, RemoveCouponMutationVariables>;

/**
 * __useRemoveCouponMutation__
 *
 * To run a mutation, you first call `useRemoveCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCouponMutation, { data, loading, error }] = useRemoveCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveCouponMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCouponMutation, RemoveCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCouponMutation, RemoveCouponMutationVariables>(RemoveCouponDocument, options);
      }
export type RemoveCouponMutationHookResult = ReturnType<typeof useRemoveCouponMutation>;
export type RemoveCouponMutationResult = Apollo.MutationResult<RemoveCouponMutation>;
export type RemoveCouponMutationOptions = Apollo.BaseMutationOptions<RemoveCouponMutation, RemoveCouponMutationVariables>;
export const GetCustomerOverdueBalancesDocument = gql`
    query getCustomerOverdueBalances($externalCustomerId: String!, $currency: CurrencyEnum, $expireCache: Boolean) {
  paymentRequests(externalCustomerId: $externalCustomerId) {
    collection {
      createdAt
    }
  }
  overdueBalances(
    externalCustomerId: $externalCustomerId
    currency: $currency
    expireCache: $expireCache
  ) {
    collection {
      amountCents
      currency
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetCustomerOverdueBalancesQuery__
 *
 * To run a query within a React component, call `useGetCustomerOverdueBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerOverdueBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerOverdueBalancesQuery({
 *   variables: {
 *      externalCustomerId: // value for 'externalCustomerId'
 *      currency: // value for 'currency'
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerOverdueBalancesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables> & ({ variables: GetCustomerOverdueBalancesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
      }
export function useGetCustomerOverdueBalancesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
        }
export function useGetCustomerOverdueBalancesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
        }
export type GetCustomerOverdueBalancesQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesQuery>;
export type GetCustomerOverdueBalancesLazyQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesLazyQuery>;
export type GetCustomerOverdueBalancesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesSuspenseQuery>;
export type GetCustomerOverdueBalancesQueryResult = Apollo.QueryResult<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>;
export const GetCustomerGrossRevenuesDocument = gql`
    query getCustomerGrossRevenues($externalCustomerId: String!, $currency: CurrencyEnum, $expireCache: Boolean) {
  grossRevenues(
    externalCustomerId: $externalCustomerId
    currency: $currency
    expireCache: $expireCache
  ) {
    collection {
      amountCents
      currency
      invoicesCount
      month
    }
  }
}
    `;

/**
 * __useGetCustomerGrossRevenuesQuery__
 *
 * To run a query within a React component, call `useGetCustomerGrossRevenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerGrossRevenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerGrossRevenuesQuery({
 *   variables: {
 *      externalCustomerId: // value for 'externalCustomerId'
 *      currency: // value for 'currency'
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerGrossRevenuesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables> & ({ variables: GetCustomerGrossRevenuesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
      }
export function useGetCustomerGrossRevenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
        }
export function useGetCustomerGrossRevenuesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
        }
export type GetCustomerGrossRevenuesQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesQuery>;
export type GetCustomerGrossRevenuesLazyQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesLazyQuery>;
export type GetCustomerGrossRevenuesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesSuspenseQuery>;
export type GetCustomerGrossRevenuesQueryResult = Apollo.QueryResult<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>;
export const GetCustomerSubscriptionForListDocument = gql`
    query getCustomerSubscriptionForList($id: ID!) {
  customer(id: $id) {
    id
    applicableTimezone
    subscriptions {
      id
      status
      startedAt
      nextSubscriptionAt
      nextSubscriptionType
      name
      nextName
      externalId
      subscriptionAt
      endingAt
      terminatedAt
      plan {
        id
        isOverridden
        amountCurrency
        name
        interval
        payInAdvance
        parent {
          id
        }
      }
      nextPlan {
        id
        name
        code
        interval
      }
      nextSubscription {
        id
        name
        externalId
        status
      }
    }
  }
}
    `;

/**
 * __useGetCustomerSubscriptionForListQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForListQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables> & ({ variables: GetCustomerSubscriptionForListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
      }
export function useGetCustomerSubscriptionForListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export function useGetCustomerSubscriptionForListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export type GetCustomerSubscriptionForListQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListQuery>;
export type GetCustomerSubscriptionForListLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListLazyQuery>;
export type GetCustomerSubscriptionForListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListSuspenseQuery>;
export type GetCustomerSubscriptionForListQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>;
export const TerminateCustomerSubscriptionDocument = gql`
    mutation terminateCustomerSubscription($input: TerminateSubscriptionInput!) {
  terminateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
    }
  }
}
    `;
export type TerminateCustomerSubscriptionMutationFn = Apollo.MutationFunction<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;

/**
 * __useTerminateCustomerSubscriptionMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerSubscriptionMutation, { data, loading, error }] = useTerminateCustomerSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>(TerminateCustomerSubscriptionDocument, options);
      }
export type TerminateCustomerSubscriptionMutationHookResult = ReturnType<typeof useTerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationResult = Apollo.MutationResult<TerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;
export const GetInvoicesForTerminationDocument = gql`
    query getInvoicesForTermination($subscriptionId: ID!, $invoiceType: [InvoiceTypeEnum!], $limit: Int) {
  invoices(
    subscriptionId: $subscriptionId
    invoiceType: $invoiceType
    limit: $limit
  ) {
    collection {
      id
      number
      currency
      invoiceType
      refundableAmountCents
    }
  }
}
    `;

/**
 * __useGetInvoicesForTerminationQuery__
 *
 * To run a query within a React component, call `useGetInvoicesForTerminationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicesForTerminationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicesForTerminationQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *      invoiceType: // value for 'invoiceType'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvoicesForTerminationQuery(baseOptions: Apollo.QueryHookOptions<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables> & ({ variables: GetInvoicesForTerminationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>(GetInvoicesForTerminationDocument, options);
      }
export function useGetInvoicesForTerminationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>(GetInvoicesForTerminationDocument, options);
        }
export function useGetInvoicesForTerminationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>(GetInvoicesForTerminationDocument, options);
        }
export type GetInvoicesForTerminationQueryHookResult = ReturnType<typeof useGetInvoicesForTerminationQuery>;
export type GetInvoicesForTerminationLazyQueryHookResult = ReturnType<typeof useGetInvoicesForTerminationLazyQuery>;
export type GetInvoicesForTerminationSuspenseQueryHookResult = ReturnType<typeof useGetInvoicesForTerminationSuspenseQuery>;
export type GetInvoicesForTerminationQueryResult = Apollo.QueryResult<GetInvoicesForTerminationQuery, GetInvoicesForTerminationQueryVariables>;
export const GetCustomerSubscriptionForUsageDocument = gql`
    query getCustomerSubscriptionForUsage($id: ID!) {
  customer(id: $id) {
    id
    externalId
    currency
  }
}
    `;

/**
 * __useGetCustomerSubscriptionForUsageQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForUsageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForUsageQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables> & ({ variables: GetCustomerSubscriptionForUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
      }
export function useGetCustomerSubscriptionForUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export function useGetCustomerSubscriptionForUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export type GetCustomerSubscriptionForUsageQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageQuery>;
export type GetCustomerSubscriptionForUsageLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageLazyQuery>;
export type GetCustomerSubscriptionForUsageSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageSuspenseQuery>;
export type GetCustomerSubscriptionForUsageQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>;
export const GetApiKeyIdsForFilterItemApiKeyIdsDocument = gql`
    query getApiKeyIdsForFilterItemApiKeyIds {
  apiKeys {
    collection {
      id
      value
    }
  }
}
    `;

/**
 * __useGetApiKeyIdsForFilterItemApiKeyIdsQuery__
 *
 * To run a query within a React component, call `useGetApiKeyIdsForFilterItemApiKeyIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiKeyIdsForFilterItemApiKeyIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiKeyIdsForFilterItemApiKeyIdsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetApiKeyIdsForFilterItemApiKeyIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>(GetApiKeyIdsForFilterItemApiKeyIdsDocument, options);
      }
export function useGetApiKeyIdsForFilterItemApiKeyIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>(GetApiKeyIdsForFilterItemApiKeyIdsDocument, options);
        }
export function useGetApiKeyIdsForFilterItemApiKeyIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>(GetApiKeyIdsForFilterItemApiKeyIdsDocument, options);
        }
export type GetApiKeyIdsForFilterItemApiKeyIdsQueryHookResult = ReturnType<typeof useGetApiKeyIdsForFilterItemApiKeyIdsQuery>;
export type GetApiKeyIdsForFilterItemApiKeyIdsLazyQueryHookResult = ReturnType<typeof useGetApiKeyIdsForFilterItemApiKeyIdsLazyQuery>;
export type GetApiKeyIdsForFilterItemApiKeyIdsSuspenseQueryHookResult = ReturnType<typeof useGetApiKeyIdsForFilterItemApiKeyIdsSuspenseQuery>;
export type GetApiKeyIdsForFilterItemApiKeyIdsQueryResult = Apollo.QueryResult<GetApiKeyIdsForFilterItemApiKeyIdsQuery, GetApiKeyIdsForFilterItemApiKeyIdsQueryVariables>;
export const GetCustomersForFilterItemCustomerDocument = gql`
    query getCustomersForFilterItemCustomer($page: Int, $limit: Int, $searchTerm: String) {
  customers(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    withDeleted: true
  ) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      displayName
      externalId
      deletedAt
    }
  }
}
    `;

/**
 * __useGetCustomersForFilterItemCustomerQuery__
 *
 * To run a query within a React component, call `useGetCustomersForFilterItemCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomersForFilterItemCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomersForFilterItemCustomerQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomersForFilterItemCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
      }
export function useGetCustomersForFilterItemCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
        }
export function useGetCustomersForFilterItemCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
        }
export type GetCustomersForFilterItemCustomerQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerQuery>;
export type GetCustomersForFilterItemCustomerLazyQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerLazyQuery>;
export type GetCustomersForFilterItemCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerSuspenseQuery>;
export type GetCustomersForFilterItemCustomerQueryResult = Apollo.QueryResult<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>;
export const GetInvoiceNumbersForFilterItemInvoiceNumbersDocument = gql`
    query getInvoiceNumbersForFilterItemInvoiceNumbers($page: Int, $limit: Int, $searchTerm: String) {
  invoices(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      number
    }
  }
}
    `;

/**
 * __useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery__
 *
 * To run a query within a React component, call `useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery(baseOptions?: Apollo.QueryHookOptions<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>(GetInvoiceNumbersForFilterItemInvoiceNumbersDocument, options);
      }
export function useGetInvoiceNumbersForFilterItemInvoiceNumbersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>(GetInvoiceNumbersForFilterItemInvoiceNumbersDocument, options);
        }
export function useGetInvoiceNumbersForFilterItemInvoiceNumbersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>(GetInvoiceNumbersForFilterItemInvoiceNumbersDocument, options);
        }
export type GetInvoiceNumbersForFilterItemInvoiceNumbersQueryHookResult = ReturnType<typeof useGetInvoiceNumbersForFilterItemInvoiceNumbersQuery>;
export type GetInvoiceNumbersForFilterItemInvoiceNumbersLazyQueryHookResult = ReturnType<typeof useGetInvoiceNumbersForFilterItemInvoiceNumbersLazyQuery>;
export type GetInvoiceNumbersForFilterItemInvoiceNumbersSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceNumbersForFilterItemInvoiceNumbersSuspenseQuery>;
export type GetInvoiceNumbersForFilterItemInvoiceNumbersQueryResult = Apollo.QueryResult<GetInvoiceNumbersForFilterItemInvoiceNumbersQuery, GetInvoiceNumbersForFilterItemInvoiceNumbersQueryVariables>;
export const GetPlansForFiltersItemPlanCodeDocument = gql`
    query getPlansForFiltersItemPlanCode($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm, withDeleted: true) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      code
      deletedAt
    }
  }
}
    `;

/**
 * __useGetPlansForFiltersItemPlanCodeQuery__
 *
 * To run a query within a React component, call `useGetPlansForFiltersItemPlanCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansForFiltersItemPlanCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansForFiltersItemPlanCodeQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansForFiltersItemPlanCodeQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>(GetPlansForFiltersItemPlanCodeDocument, options);
      }
export function useGetPlansForFiltersItemPlanCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>(GetPlansForFiltersItemPlanCodeDocument, options);
        }
export function useGetPlansForFiltersItemPlanCodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>(GetPlansForFiltersItemPlanCodeDocument, options);
        }
export type GetPlansForFiltersItemPlanCodeQueryHookResult = ReturnType<typeof useGetPlansForFiltersItemPlanCodeQuery>;
export type GetPlansForFiltersItemPlanCodeLazyQueryHookResult = ReturnType<typeof useGetPlansForFiltersItemPlanCodeLazyQuery>;
export type GetPlansForFiltersItemPlanCodeSuspenseQueryHookResult = ReturnType<typeof useGetPlansForFiltersItemPlanCodeSuspenseQuery>;
export type GetPlansForFiltersItemPlanCodeQueryResult = Apollo.QueryResult<GetPlansForFiltersItemPlanCodeQuery, GetPlansForFiltersItemPlanCodeQueryVariables>;
export const GetSingleActivityLogDocument = gql`
    query getSingleActivityLog($id: ID!) {
  activityLog(activityId: $id) {
    activityId
    ...ActivityLogDetails
  }
}
    ${ActivityLogDetailsFragmentDoc}`;

/**
 * __useGetSingleActivityLogQuery__
 *
 * To run a query within a React component, call `useGetSingleActivityLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleActivityLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleActivityLogQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleActivityLogQuery(baseOptions: Apollo.QueryHookOptions<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables> & ({ variables: GetSingleActivityLogQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>(GetSingleActivityLogDocument, options);
      }
export function useGetSingleActivityLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>(GetSingleActivityLogDocument, options);
        }
export function useGetSingleActivityLogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>(GetSingleActivityLogDocument, options);
        }
export type GetSingleActivityLogQueryHookResult = ReturnType<typeof useGetSingleActivityLogQuery>;
export type GetSingleActivityLogLazyQueryHookResult = ReturnType<typeof useGetSingleActivityLogLazyQuery>;
export type GetSingleActivityLogSuspenseQueryHookResult = ReturnType<typeof useGetSingleActivityLogSuspenseQuery>;
export type GetSingleActivityLogQueryResult = Apollo.QueryResult<GetSingleActivityLogQuery, GetSingleActivityLogQueryVariables>;
export const GetCustomerIdForActivityLogDetailsDocument = gql`
    query getCustomerIdForActivityLogDetails($externalId: ID) {
  customer(externalId: $externalId) {
    id
  }
}
    `;

/**
 * __useGetCustomerIdForActivityLogDetailsQuery__
 *
 * To run a query within a React component, call `useGetCustomerIdForActivityLogDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerIdForActivityLogDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerIdForActivityLogDetailsQuery({
 *   variables: {
 *      externalId: // value for 'externalId'
 *   },
 * });
 */
export function useGetCustomerIdForActivityLogDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>(GetCustomerIdForActivityLogDetailsDocument, options);
      }
export function useGetCustomerIdForActivityLogDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>(GetCustomerIdForActivityLogDetailsDocument, options);
        }
export function useGetCustomerIdForActivityLogDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>(GetCustomerIdForActivityLogDetailsDocument, options);
        }
export type GetCustomerIdForActivityLogDetailsQueryHookResult = ReturnType<typeof useGetCustomerIdForActivityLogDetailsQuery>;
export type GetCustomerIdForActivityLogDetailsLazyQueryHookResult = ReturnType<typeof useGetCustomerIdForActivityLogDetailsLazyQuery>;
export type GetCustomerIdForActivityLogDetailsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerIdForActivityLogDetailsSuspenseQuery>;
export type GetCustomerIdForActivityLogDetailsQueryResult = Apollo.QueryResult<GetCustomerIdForActivityLogDetailsQuery, GetCustomerIdForActivityLogDetailsQueryVariables>;
export const GetSubscriptionIdForActivityLogDetailsDocument = gql`
    query getSubscriptionIdForActivityLogDetails($externalId: ID) {
  subscription(externalId: $externalId) {
    id
  }
}
    `;

/**
 * __useGetSubscriptionIdForActivityLogDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionIdForActivityLogDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionIdForActivityLogDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionIdForActivityLogDetailsQuery({
 *   variables: {
 *      externalId: // value for 'externalId'
 *   },
 * });
 */
export function useGetSubscriptionIdForActivityLogDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>(GetSubscriptionIdForActivityLogDetailsDocument, options);
      }
export function useGetSubscriptionIdForActivityLogDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>(GetSubscriptionIdForActivityLogDetailsDocument, options);
        }
export function useGetSubscriptionIdForActivityLogDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>(GetSubscriptionIdForActivityLogDetailsDocument, options);
        }
export type GetSubscriptionIdForActivityLogDetailsQueryHookResult = ReturnType<typeof useGetSubscriptionIdForActivityLogDetailsQuery>;
export type GetSubscriptionIdForActivityLogDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscriptionIdForActivityLogDetailsLazyQuery>;
export type GetSubscriptionIdForActivityLogDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionIdForActivityLogDetailsSuspenseQuery>;
export type GetSubscriptionIdForActivityLogDetailsQueryResult = Apollo.QueryResult<GetSubscriptionIdForActivityLogDetailsQuery, GetSubscriptionIdForActivityLogDetailsQueryVariables>;
export const ActivityLogsDocument = gql`
    query activityLogs($page: Int, $limit: Int, $activityIds: [String!], $activitySources: [ActivitySourceEnum!], $activityTypes: [ActivityTypeEnum!], $apiKeyIds: [String!], $externalCustomerId: String, $externalSubscriptionId: String, $fromDate: ISO8601DateTime, $resourceIds: [String!], $resourceTypes: [ResourceTypeEnum!], $toDate: ISO8601DateTime, $userEmails: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    activityIds: $activityIds
    activitySources: $activitySources
    activityTypes: $activityTypes
    apiKeyIds: $apiKeyIds
    externalCustomerId: $externalCustomerId
    externalSubscriptionId: $externalSubscriptionId
    fromDatetime: $fromDate
    resourceIds: $resourceIds
    resourceTypes: $resourceTypes
    toDatetime: $toDate
    userEmails: $userEmails
  ) {
    collection {
      ...ActivityItem
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityItemFragmentDoc}`;

/**
 * __useActivityLogsQuery__
 *
 * To run a query within a React component, call `useActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      activityIds: // value for 'activityIds'
 *      activitySources: // value for 'activitySources'
 *      activityTypes: // value for 'activityTypes'
 *      apiKeyIds: // value for 'apiKeyIds'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *      fromDate: // value for 'fromDate'
 *      resourceIds: // value for 'resourceIds'
 *      resourceTypes: // value for 'resourceTypes'
 *      toDate: // value for 'toDate'
 *      userEmails: // value for 'userEmails'
 *   },
 * });
 */
export function useActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<ActivityLogsQuery, ActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActivityLogsQuery, ActivityLogsQueryVariables>(ActivityLogsDocument, options);
      }
export function useActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivityLogsQuery, ActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActivityLogsQuery, ActivityLogsQueryVariables>(ActivityLogsDocument, options);
        }
export function useActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ActivityLogsQuery, ActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ActivityLogsQuery, ActivityLogsQueryVariables>(ActivityLogsDocument, options);
        }
export type ActivityLogsQueryHookResult = ReturnType<typeof useActivityLogsQuery>;
export type ActivityLogsLazyQueryHookResult = ReturnType<typeof useActivityLogsLazyQuery>;
export type ActivityLogsSuspenseQueryHookResult = ReturnType<typeof useActivityLogsSuspenseQuery>;
export type ActivityLogsQueryResult = Apollo.QueryResult<ActivityLogsQuery, ActivityLogsQueryVariables>;
export const GetOrganizationInfosForApiKeyDocument = gql`
    query getOrganizationInfosForApiKey {
  organization {
    id
    name
    createdAt
  }
}
    `;

/**
 * __useGetOrganizationInfosForApiKeyQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfosForApiKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfosForApiKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfosForApiKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfosForApiKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>(GetOrganizationInfosForApiKeyDocument, options);
      }
export function useGetOrganizationInfosForApiKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>(GetOrganizationInfosForApiKeyDocument, options);
        }
export function useGetOrganizationInfosForApiKeySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>(GetOrganizationInfosForApiKeyDocument, options);
        }
export type GetOrganizationInfosForApiKeyQueryHookResult = ReturnType<typeof useGetOrganizationInfosForApiKeyQuery>;
export type GetOrganizationInfosForApiKeyLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfosForApiKeyLazyQuery>;
export type GetOrganizationInfosForApiKeySuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfosForApiKeySuspenseQuery>;
export type GetOrganizationInfosForApiKeyQueryResult = Apollo.QueryResult<GetOrganizationInfosForApiKeyQuery, GetOrganizationInfosForApiKeyQueryVariables>;
export const GetApiKeysDocument = gql`
    query getApiKeys($page: Int, $limit: Int) {
  apiKeys(page: $page, limit: $limit) {
    collection {
      id
      createdAt
      expiresAt
      lastUsedAt
      name
      value
      ...ApiKeyForRotateApiKeyDialog
      ...ApiKeyForDeleteApiKeyDialog
    }
    metadata {
      currentPage
      totalPages
      totalCount
    }
  }
}
    ${ApiKeyForRotateApiKeyDialogFragmentDoc}
${ApiKeyForDeleteApiKeyDialogFragmentDoc}`;

/**
 * __useGetApiKeysQuery__
 *
 * To run a query within a React component, call `useGetApiKeysQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiKeysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiKeysQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetApiKeysQuery(baseOptions?: Apollo.QueryHookOptions<GetApiKeysQuery, GetApiKeysQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiKeysQuery, GetApiKeysQueryVariables>(GetApiKeysDocument, options);
      }
export function useGetApiKeysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiKeysQuery, GetApiKeysQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiKeysQuery, GetApiKeysQueryVariables>(GetApiKeysDocument, options);
        }
export function useGetApiKeysSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiKeysQuery, GetApiKeysQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiKeysQuery, GetApiKeysQueryVariables>(GetApiKeysDocument, options);
        }
export type GetApiKeysQueryHookResult = ReturnType<typeof useGetApiKeysQuery>;
export type GetApiKeysLazyQueryHookResult = ReturnType<typeof useGetApiKeysLazyQuery>;
export type GetApiKeysSuspenseQueryHookResult = ReturnType<typeof useGetApiKeysSuspenseQuery>;
export type GetApiKeysQueryResult = Apollo.QueryResult<GetApiKeysQuery, GetApiKeysQueryVariables>;
export const GetApiKeyValueDocument = gql`
    query getApiKeyValue($id: ID!) {
  apiKey(id: $id) {
    id
    ...ApiKeyRevealedForApiKeysList
  }
}
    ${ApiKeyRevealedForApiKeysListFragmentDoc}`;

/**
 * __useGetApiKeyValueQuery__
 *
 * To run a query within a React component, call `useGetApiKeyValueQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiKeyValueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiKeyValueQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetApiKeyValueQuery(baseOptions: Apollo.QueryHookOptions<GetApiKeyValueQuery, GetApiKeyValueQueryVariables> & ({ variables: GetApiKeyValueQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>(GetApiKeyValueDocument, options);
      }
export function useGetApiKeyValueLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>(GetApiKeyValueDocument, options);
        }
export function useGetApiKeyValueSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>(GetApiKeyValueDocument, options);
        }
export type GetApiKeyValueQueryHookResult = ReturnType<typeof useGetApiKeyValueQuery>;
export type GetApiKeyValueLazyQueryHookResult = ReturnType<typeof useGetApiKeyValueLazyQuery>;
export type GetApiKeyValueSuspenseQueryHookResult = ReturnType<typeof useGetApiKeyValueSuspenseQuery>;
export type GetApiKeyValueQueryResult = Apollo.QueryResult<GetApiKeyValueQuery, GetApiKeyValueQueryVariables>;
export const DestroyApiKeyDocument = gql`
    mutation destroyApiKey($input: DestroyApiKeyInput!) {
  destroyApiKey(input: $input) {
    id
  }
}
    `;
export type DestroyApiKeyMutationFn = Apollo.MutationFunction<DestroyApiKeyMutation, DestroyApiKeyMutationVariables>;

/**
 * __useDestroyApiKeyMutation__
 *
 * To run a mutation, you first call `useDestroyApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyApiKeyMutation, { data, loading, error }] = useDestroyApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<DestroyApiKeyMutation, DestroyApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyApiKeyMutation, DestroyApiKeyMutationVariables>(DestroyApiKeyDocument, options);
      }
export type DestroyApiKeyMutationHookResult = ReturnType<typeof useDestroyApiKeyMutation>;
export type DestroyApiKeyMutationResult = Apollo.MutationResult<DestroyApiKeyMutation>;
export type DestroyApiKeyMutationOptions = Apollo.BaseMutationOptions<DestroyApiKeyMutation, DestroyApiKeyMutationVariables>;
export const RotateApiKeyDocument = gql`
    mutation rotateApiKey($input: RotateApiKeyInput!) {
  rotateApiKey(input: $input) {
    id
    ...ApiKeyRevealedForApiKeysList
  }
}
    ${ApiKeyRevealedForApiKeysListFragmentDoc}`;
export type RotateApiKeyMutationFn = Apollo.MutationFunction<RotateApiKeyMutation, RotateApiKeyMutationVariables>;

/**
 * __useRotateApiKeyMutation__
 *
 * To run a mutation, you first call `useRotateApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRotateApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rotateApiKeyMutation, { data, loading, error }] = useRotateApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRotateApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<RotateApiKeyMutation, RotateApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RotateApiKeyMutation, RotateApiKeyMutationVariables>(RotateApiKeyDocument, options);
      }
export type RotateApiKeyMutationHookResult = ReturnType<typeof useRotateApiKeyMutation>;
export type RotateApiKeyMutationResult = Apollo.MutationResult<RotateApiKeyMutation>;
export type RotateApiKeyMutationOptions = Apollo.BaseMutationOptions<RotateApiKeyMutation, RotateApiKeyMutationVariables>;
export const GetApiLogDetailsDocument = gql`
    query getApiLogDetails($requestId: ID!) {
  apiLog(requestId: $requestId) {
    ...ApiLogDetails
  }
}
    ${ApiLogDetailsFragmentDoc}`;

/**
 * __useGetApiLogDetailsQuery__
 *
 * To run a query within a React component, call `useGetApiLogDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiLogDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiLogDetailsQuery({
 *   variables: {
 *      requestId: // value for 'requestId'
 *   },
 * });
 */
export function useGetApiLogDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables> & ({ variables: GetApiLogDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>(GetApiLogDetailsDocument, options);
      }
export function useGetApiLogDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>(GetApiLogDetailsDocument, options);
        }
export function useGetApiLogDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>(GetApiLogDetailsDocument, options);
        }
export type GetApiLogDetailsQueryHookResult = ReturnType<typeof useGetApiLogDetailsQuery>;
export type GetApiLogDetailsLazyQueryHookResult = ReturnType<typeof useGetApiLogDetailsLazyQuery>;
export type GetApiLogDetailsSuspenseQueryHookResult = ReturnType<typeof useGetApiLogDetailsSuspenseQuery>;
export type GetApiLogDetailsQueryResult = Apollo.QueryResult<GetApiLogDetailsQuery, GetApiLogDetailsQueryVariables>;
export const GetApiLogsDocument = gql`
    query getApiLogs($page: Int, $limit: Int, $requestIds: [String!], $fromDate: ISO8601DateTime, $toDate: ISO8601DateTime, $apiKeyIds: [String!], $httpMethods: [HttpMethodEnum!], $httpStatuses: [HttpStatus!], $requestPaths: [String!]) {
  apiLogs(
    page: $page
    limit: $limit
    fromDatetime: $fromDate
    toDatetime: $toDate
    apiKeyIds: $apiKeyIds
    httpMethods: $httpMethods
    httpStatuses: $httpStatuses
    requestIds: $requestIds
    requestPaths: $requestPaths
  ) {
    collection {
      ...ApiLogItem
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ApiLogItemFragmentDoc}`;

/**
 * __useGetApiLogsQuery__
 *
 * To run a query within a React component, call `useGetApiLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      requestIds: // value for 'requestIds'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      apiKeyIds: // value for 'apiKeyIds'
 *      httpMethods: // value for 'httpMethods'
 *      httpStatuses: // value for 'httpStatuses'
 *      requestPaths: // value for 'requestPaths'
 *   },
 * });
 */
export function useGetApiLogsQuery(baseOptions?: Apollo.QueryHookOptions<GetApiLogsQuery, GetApiLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiLogsQuery, GetApiLogsQueryVariables>(GetApiLogsDocument, options);
      }
export function useGetApiLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiLogsQuery, GetApiLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiLogsQuery, GetApiLogsQueryVariables>(GetApiLogsDocument, options);
        }
export function useGetApiLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiLogsQuery, GetApiLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiLogsQuery, GetApiLogsQueryVariables>(GetApiLogsDocument, options);
        }
export type GetApiLogsQueryHookResult = ReturnType<typeof useGetApiLogsQuery>;
export type GetApiLogsLazyQueryHookResult = ReturnType<typeof useGetApiLogsLazyQuery>;
export type GetApiLogsSuspenseQueryHookResult = ReturnType<typeof useGetApiLogsSuspenseQuery>;
export type GetApiLogsQueryResult = Apollo.QueryResult<GetApiLogsQuery, GetApiLogsQueryVariables>;
export const GetSingleEventDocument = gql`
    query getSingleEvent($transactionId: ID!) {
  event(transactionId: $transactionId) {
    id
    ...EventDetails
  }
}
    ${EventDetailsFragmentDoc}`;

/**
 * __useGetSingleEventQuery__
 *
 * To run a query within a React component, call `useGetSingleEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleEventQuery({
 *   variables: {
 *      transactionId: // value for 'transactionId'
 *   },
 * });
 */
export function useGetSingleEventQuery(baseOptions: Apollo.QueryHookOptions<GetSingleEventQuery, GetSingleEventQueryVariables> & ({ variables: GetSingleEventQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleEventQuery, GetSingleEventQueryVariables>(GetSingleEventDocument, options);
      }
export function useGetSingleEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleEventQuery, GetSingleEventQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleEventQuery, GetSingleEventQueryVariables>(GetSingleEventDocument, options);
        }
export function useGetSingleEventSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleEventQuery, GetSingleEventQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleEventQuery, GetSingleEventQueryVariables>(GetSingleEventDocument, options);
        }
export type GetSingleEventQueryHookResult = ReturnType<typeof useGetSingleEventQuery>;
export type GetSingleEventLazyQueryHookResult = ReturnType<typeof useGetSingleEventLazyQuery>;
export type GetSingleEventSuspenseQueryHookResult = ReturnType<typeof useGetSingleEventSuspenseQuery>;
export type GetSingleEventQueryResult = Apollo.QueryResult<GetSingleEventQuery, GetSingleEventQueryVariables>;
export const EventsDocument = gql`
    query events($page: Int, $limit: Int) {
  events(page: $page, limit: $limit) {
    collection {
      ...EventItem
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${EventItemFragmentDoc}`;

/**
 * __useEventsQuery__
 *
 * To run a query within a React component, call `useEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useEventsQuery(baseOptions?: Apollo.QueryHookOptions<EventsQuery, EventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
      }
export function useEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export function useEventsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export type EventsQueryHookResult = ReturnType<typeof useEventsQuery>;
export type EventsLazyQueryHookResult = ReturnType<typeof useEventsLazyQuery>;
export type EventsSuspenseQueryHookResult = ReturnType<typeof useEventsSuspenseQuery>;
export type EventsQueryResult = Apollo.QueryResult<EventsQuery, EventsQueryVariables>;
export const CreateWebhookEndpointDocument = gql`
    mutation createWebhookEndpoint($input: WebhookEndpointCreateInput!) {
  createWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type CreateWebhookEndpointMutationFn = Apollo.MutationFunction<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;

/**
 * __useCreateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useCreateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createWebhookEndpointMutation, { data, loading, error }] = useCreateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>(CreateWebhookEndpointDocument, options);
      }
export type CreateWebhookEndpointMutationHookResult = ReturnType<typeof useCreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationResult = Apollo.MutationResult<CreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;
export const UpdateWebhookEndpointDocument = gql`
    mutation updateWebhookEndpoint($input: WebhookEndpointUpdateInput!) {
  updateWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type UpdateWebhookEndpointMutationFn = Apollo.MutationFunction<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;

/**
 * __useUpdateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useUpdateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWebhookEndpointMutation, { data, loading, error }] = useUpdateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>(UpdateWebhookEndpointDocument, options);
      }
export type UpdateWebhookEndpointMutationHookResult = ReturnType<typeof useUpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationResult = Apollo.MutationResult<UpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;
export const DeleteWebhookDocument = gql`
    mutation deleteWebhook($input: DestroyWebhookEndpointInput!) {
  destroyWebhookEndpoint(input: $input) {
    id
  }
}
    `;
export type DeleteWebhookMutationFn = Apollo.MutationFunction<DeleteWebhookMutation, DeleteWebhookMutationVariables>;

/**
 * __useDeleteWebhookMutation__
 *
 * To run a mutation, you first call `useDeleteWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWebhookMutation, { data, loading, error }] = useDeleteWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteWebhookMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWebhookMutation, DeleteWebhookMutationVariables>(DeleteWebhookDocument, options);
      }
export type DeleteWebhookMutationHookResult = ReturnType<typeof useDeleteWebhookMutation>;
export type DeleteWebhookMutationResult = Apollo.MutationResult<DeleteWebhookMutation>;
export type DeleteWebhookMutationOptions = Apollo.BaseMutationOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>;
export const RetryWebhookDocument = gql`
    mutation retryWebhook($input: RetryWebhookInput!) {
  retryWebhook(input: $input) {
    id
  }
}
    `;
export type RetryWebhookMutationFn = Apollo.MutationFunction<RetryWebhookMutation, RetryWebhookMutationVariables>;

/**
 * __useRetryWebhookMutation__
 *
 * To run a mutation, you first call `useRetryWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryWebhookMutation, { data, loading, error }] = useRetryWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryWebhookMutation(baseOptions?: Apollo.MutationHookOptions<RetryWebhookMutation, RetryWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryWebhookMutation, RetryWebhookMutationVariables>(RetryWebhookDocument, options);
      }
export type RetryWebhookMutationHookResult = ReturnType<typeof useRetryWebhookMutation>;
export type RetryWebhookMutationResult = Apollo.MutationResult<RetryWebhookMutation>;
export type RetryWebhookMutationOptions = Apollo.BaseMutationOptions<RetryWebhookMutation, RetryWebhookMutationVariables>;
export const GetSingleWebhookLogDocument = gql`
    query getSingleWebhookLog($id: ID!) {
  webhook(id: $id) {
    id
    ...WebhookLogDetails
  }
}
    ${WebhookLogDetailsFragmentDoc}`;

/**
 * __useGetSingleWebhookLogQuery__
 *
 * To run a query within a React component, call `useGetSingleWebhookLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleWebhookLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleWebhookLogQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleWebhookLogQuery(baseOptions: Apollo.QueryHookOptions<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables> & ({ variables: GetSingleWebhookLogQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>(GetSingleWebhookLogDocument, options);
      }
export function useGetSingleWebhookLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>(GetSingleWebhookLogDocument, options);
        }
export function useGetSingleWebhookLogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>(GetSingleWebhookLogDocument, options);
        }
export type GetSingleWebhookLogQueryHookResult = ReturnType<typeof useGetSingleWebhookLogQuery>;
export type GetSingleWebhookLogLazyQueryHookResult = ReturnType<typeof useGetSingleWebhookLogLazyQuery>;
export type GetSingleWebhookLogSuspenseQueryHookResult = ReturnType<typeof useGetSingleWebhookLogSuspenseQuery>;
export type GetSingleWebhookLogQueryResult = Apollo.QueryResult<GetSingleWebhookLogQuery, GetSingleWebhookLogQueryVariables>;
export const GetWebhookInformationsDocument = gql`
    query getWebhookInformations($id: ID!) {
  webhookEndpoint(id: $id) {
    id
    webhookUrl
  }
}
    `;

/**
 * __useGetWebhookInformationsQuery__
 *
 * To run a query within a React component, call `useGetWebhookInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookInformationsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWebhookInformationsQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables> & ({ variables: GetWebhookInformationsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
      }
export function useGetWebhookInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export function useGetWebhookInformationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export type GetWebhookInformationsQueryHookResult = ReturnType<typeof useGetWebhookInformationsQuery>;
export type GetWebhookInformationsLazyQueryHookResult = ReturnType<typeof useGetWebhookInformationsLazyQuery>;
export type GetWebhookInformationsSuspenseQueryHookResult = ReturnType<typeof useGetWebhookInformationsSuspenseQuery>;
export type GetWebhookInformationsQueryResult = Apollo.QueryResult<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>;
export const GetWebhookLogDocument = gql`
    query getWebhookLog($page: Int, $limit: Int, $webhookEndpointId: String!, $status: WebhookStatusEnum, $searchTerm: String) {
  webhooks(
    page: $page
    limit: $limit
    webhookEndpointId: $webhookEndpointId
    status: $status
    searchTerm: $searchTerm
  ) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...WebhookLog
    }
  }
}
    ${WebhookLogFragmentDoc}`;

/**
 * __useGetWebhookLogQuery__
 *
 * To run a query within a React component, call `useGetWebhookLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookLogQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      webhookEndpointId: // value for 'webhookEndpointId'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetWebhookLogQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables> & ({ variables: GetWebhookLogQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
      }
export function useGetWebhookLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export function useGetWebhookLogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export type GetWebhookLogQueryHookResult = ReturnType<typeof useGetWebhookLogQuery>;
export type GetWebhookLogLazyQueryHookResult = ReturnType<typeof useGetWebhookLogLazyQuery>;
export type GetWebhookLogSuspenseQueryHookResult = ReturnType<typeof useGetWebhookLogSuspenseQuery>;
export type GetWebhookLogQueryResult = Apollo.QueryResult<GetWebhookLogQuery, GetWebhookLogQueryVariables>;
export const GetOrganizationHmacDataDocument = gql`
    query getOrganizationHmacData {
  organization {
    id
    hmacKey
  }
}
    `;

/**
 * __useGetOrganizationHmacDataQuery__
 *
 * To run a query within a React component, call `useGetOrganizationHmacDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationHmacDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationHmacDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationHmacDataQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>(GetOrganizationHmacDataDocument, options);
      }
export function useGetOrganizationHmacDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>(GetOrganizationHmacDataDocument, options);
        }
export function useGetOrganizationHmacDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>(GetOrganizationHmacDataDocument, options);
        }
export type GetOrganizationHmacDataQueryHookResult = ReturnType<typeof useGetOrganizationHmacDataQuery>;
export type GetOrganizationHmacDataLazyQueryHookResult = ReturnType<typeof useGetOrganizationHmacDataLazyQuery>;
export type GetOrganizationHmacDataSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationHmacDataSuspenseQuery>;
export type GetOrganizationHmacDataQueryResult = Apollo.QueryResult<GetOrganizationHmacDataQuery, GetOrganizationHmacDataQueryVariables>;
export const GetWebhookListDocument = gql`
    query getWebhookList($limit: Int) {
  webhookEndpoints(limit: $limit) {
    collection {
      id
      webhookUrl
      ...WebhookForCreateAndEdit
    }
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;

/**
 * __useGetWebhookListQuery__
 *
 * To run a query within a React component, call `useGetWebhookListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWebhookListQuery(baseOptions?: Apollo.QueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
      }
export function useGetWebhookListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export function useGetWebhookListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export type GetWebhookListQueryHookResult = ReturnType<typeof useGetWebhookListQuery>;
export type GetWebhookListLazyQueryHookResult = ReturnType<typeof useGetWebhookListLazyQuery>;
export type GetWebhookListSuspenseQueryHookResult = ReturnType<typeof useGetWebhookListSuspenseQuery>;
export type GetWebhookListQueryResult = Apollo.QueryResult<GetWebhookListQuery, GetWebhookListQueryVariables>;
export const DestroyFeatureDocument = gql`
    mutation destroyFeature($input: DestroyFeatureInput!) {
  destroyFeature(input: $input) {
    id
  }
}
    `;
export type DestroyFeatureMutationFn = Apollo.MutationFunction<DestroyFeatureMutation, DestroyFeatureMutationVariables>;

/**
 * __useDestroyFeatureMutation__
 *
 * To run a mutation, you first call `useDestroyFeatureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyFeatureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyFeatureMutation, { data, loading, error }] = useDestroyFeatureMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyFeatureMutation(baseOptions?: Apollo.MutationHookOptions<DestroyFeatureMutation, DestroyFeatureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyFeatureMutation, DestroyFeatureMutationVariables>(DestroyFeatureDocument, options);
      }
export type DestroyFeatureMutationHookResult = ReturnType<typeof useDestroyFeatureMutation>;
export type DestroyFeatureMutationResult = Apollo.MutationResult<DestroyFeatureMutation>;
export type DestroyFeatureMutationOptions = Apollo.BaseMutationOptions<DestroyFeatureMutation, DestroyFeatureMutationVariables>;
export const FeatureDetailsActivityLogsDocument = gql`
    query FeatureDetailsActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useFeatureDetailsActivityLogsQuery__
 *
 * To run a query within a React component, call `useFeatureDetailsActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeatureDetailsActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureDetailsActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function useFeatureDetailsActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>(FeatureDetailsActivityLogsDocument, options);
      }
export function useFeatureDetailsActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>(FeatureDetailsActivityLogsDocument, options);
        }
export function useFeatureDetailsActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>(FeatureDetailsActivityLogsDocument, options);
        }
export type FeatureDetailsActivityLogsQueryHookResult = ReturnType<typeof useFeatureDetailsActivityLogsQuery>;
export type FeatureDetailsActivityLogsLazyQueryHookResult = ReturnType<typeof useFeatureDetailsActivityLogsLazyQuery>;
export type FeatureDetailsActivityLogsSuspenseQueryHookResult = ReturnType<typeof useFeatureDetailsActivityLogsSuspenseQuery>;
export type FeatureDetailsActivityLogsQueryResult = Apollo.QueryResult<FeatureDetailsActivityLogsQuery, FeatureDetailsActivityLogsQueryVariables>;
export const GetFeatureForDetailsOverviewDocument = gql`
    query getFeatureForDetailsOverview($id: ID!) {
  feature(id: $id) {
    ...FeatureDetails
  }
}
    ${FeatureDetailsFragmentDoc}`;

/**
 * __useGetFeatureForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetFeatureForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeatureForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeatureForDetailsOverviewQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetFeatureForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables> & ({ variables: GetFeatureForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>(GetFeatureForDetailsOverviewDocument, options);
      }
export function useGetFeatureForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>(GetFeatureForDetailsOverviewDocument, options);
        }
export function useGetFeatureForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>(GetFeatureForDetailsOverviewDocument, options);
        }
export type GetFeatureForDetailsOverviewQueryHookResult = ReturnType<typeof useGetFeatureForDetailsOverviewQuery>;
export type GetFeatureForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetFeatureForDetailsOverviewLazyQuery>;
export type GetFeatureForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetFeatureForDetailsOverviewSuspenseQuery>;
export type GetFeatureForDetailsOverviewQueryResult = Apollo.QueryResult<GetFeatureForDetailsOverviewQuery, GetFeatureForDetailsOverviewQueryVariables>;
export const GetGrossRevenuesDocument = gql`
    query getGrossRevenues($currency: CurrencyEnum!, $externalCustomerId: String, $months: Int) {
  grossRevenues(
    currency: $currency
    externalCustomerId: $externalCustomerId
    months: $months
  ) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetGrossRevenuesQuery__
 *
 * To run a query within a React component, call `useGetGrossRevenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGrossRevenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGrossRevenuesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      months: // value for 'months'
 *   },
 * });
 */
export function useGetGrossRevenuesQuery(baseOptions: Apollo.QueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables> & ({ variables: GetGrossRevenuesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
      }
export function useGetGrossRevenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export function useGetGrossRevenuesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export type GetGrossRevenuesQueryHookResult = ReturnType<typeof useGetGrossRevenuesQuery>;
export type GetGrossRevenuesLazyQueryHookResult = ReturnType<typeof useGetGrossRevenuesLazyQuery>;
export type GetGrossRevenuesSuspenseQueryHookResult = ReturnType<typeof useGetGrossRevenuesSuspenseQuery>;
export type GetGrossRevenuesQueryResult = Apollo.QueryResult<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>;
export const GetInvoiceCollectionsDocument = gql`
    query getInvoiceCollections($currency: CurrencyEnum!) {
  invoiceCollections(currency: $currency) {
    collection {
      paymentStatus
      invoicesCount
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetInvoiceCollectionsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCollectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCollectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCollectionsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoiceCollectionsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables> & ({ variables: GetInvoiceCollectionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
      }
export function useGetInvoiceCollectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export function useGetInvoiceCollectionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export type GetInvoiceCollectionsQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsQuery>;
export type GetInvoiceCollectionsLazyQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsLazyQuery>;
export type GetInvoiceCollectionsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsSuspenseQuery>;
export type GetInvoiceCollectionsQueryResult = Apollo.QueryResult<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>;
export const GetMrrDocument = gql`
    query getMrr($currency: CurrencyEnum!) {
  mrrs(currency: $currency) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetMrrQuery__
 *
 * To run a query within a React component, call `useGetMrrQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMrrQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMrrQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetMrrQuery(baseOptions: Apollo.QueryHookOptions<GetMrrQuery, GetMrrQueryVariables> & ({ variables: GetMrrQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
      }
export function useGetMrrLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export function useGetMrrSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export type GetMrrQueryHookResult = ReturnType<typeof useGetMrrQuery>;
export type GetMrrLazyQueryHookResult = ReturnType<typeof useGetMrrLazyQuery>;
export type GetMrrSuspenseQueryHookResult = ReturnType<typeof useGetMrrSuspenseQuery>;
export type GetMrrQueryResult = Apollo.QueryResult<GetMrrQuery, GetMrrQueryVariables>;
export const GetOverdueDocument = gql`
    query getOverdue($currency: CurrencyEnum!, $externalCustomerId: String, $months: Int!) {
  overdueBalances(
    currency: $currency
    externalCustomerId: $externalCustomerId
    months: $months
  ) {
    collection {
      amountCents
      currency
      month
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetOverdueQuery__
 *
 * To run a query within a React component, call `useGetOverdueQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOverdueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOverdueQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      months: // value for 'months'
 *   },
 * });
 */
export function useGetOverdueQuery(baseOptions: Apollo.QueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables> & ({ variables: GetOverdueQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
      }
export function useGetOverdueLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
        }
export function useGetOverdueSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
        }
export type GetOverdueQueryHookResult = ReturnType<typeof useGetOverdueQuery>;
export type GetOverdueLazyQueryHookResult = ReturnType<typeof useGetOverdueLazyQuery>;
export type GetOverdueSuspenseQueryHookResult = ReturnType<typeof useGetOverdueSuspenseQuery>;
export type GetOverdueQueryResult = Apollo.QueryResult<GetOverdueQuery, GetOverdueQueryVariables>;
export const GetInvoicedUsagesDocument = gql`
    query getInvoicedUsages($currency: CurrencyEnum!) {
  invoicedUsages(currency: $currency) {
    collection {
      amountCents
      month
      currency
      code
    }
  }
}
    `;

/**
 * __useGetInvoicedUsagesQuery__
 *
 * To run a query within a React component, call `useGetInvoicedUsagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicedUsagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicedUsagesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoicedUsagesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables> & ({ variables: GetInvoicedUsagesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
      }
export function useGetInvoicedUsagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export function useGetInvoicedUsagesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export type GetInvoicedUsagesQueryHookResult = ReturnType<typeof useGetInvoicedUsagesQuery>;
export type GetInvoicedUsagesLazyQueryHookResult = ReturnType<typeof useGetInvoicedUsagesLazyQuery>;
export type GetInvoicedUsagesSuspenseQueryHookResult = ReturnType<typeof useGetInvoicedUsagesSuspenseQuery>;
export type GetInvoicedUsagesQueryResult = Apollo.QueryResult<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>;
export const UpdateInvoiceMetadataDocument = gql`
    mutation updateInvoiceMetadata($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceMetadatasForMetadataDrawer
  }
}
    ${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;
export type UpdateInvoiceMetadataMutationFn = Apollo.MutationFunction<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;

/**
 * __useUpdateInvoiceMetadataMutation__
 *
 * To run a mutation, you first call `useUpdateInvoiceMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoiceMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoiceMetadataMutation, { data, loading, error }] = useUpdateInvoiceMetadataMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoiceMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>(UpdateInvoiceMetadataDocument, options);
      }
export type UpdateInvoiceMetadataMutationHookResult = ReturnType<typeof useUpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationResult = Apollo.MutationResult<UpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationOptions = Apollo.BaseMutationOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;
export const GetInvoiceMetadataForEditionDocument = gql`
    query getInvoiceMetadataForEdition($id: ID!) {
  invoice(id: $id) {
    id
    ...InvoiceMetadatasForMetadataDrawer
  }
}
    ${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;

/**
 * __useGetInvoiceMetadataForEditionQuery__
 *
 * To run a query within a React component, call `useGetInvoiceMetadataForEditionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceMetadataForEditionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceMetadataForEditionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceMetadataForEditionQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables> & ({ variables: GetInvoiceMetadataForEditionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>(GetInvoiceMetadataForEditionDocument, options);
      }
export function useGetInvoiceMetadataForEditionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>(GetInvoiceMetadataForEditionDocument, options);
        }
export function useGetInvoiceMetadataForEditionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>(GetInvoiceMetadataForEditionDocument, options);
        }
export type GetInvoiceMetadataForEditionQueryHookResult = ReturnType<typeof useGetInvoiceMetadataForEditionQuery>;
export type GetInvoiceMetadataForEditionLazyQueryHookResult = ReturnType<typeof useGetInvoiceMetadataForEditionLazyQuery>;
export type GetInvoiceMetadataForEditionSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceMetadataForEditionSuspenseQuery>;
export type GetInvoiceMetadataForEditionQueryResult = Apollo.QueryResult<GetInvoiceMetadataForEditionQuery, GetInvoiceMetadataForEditionQueryVariables>;
export const DisputeInvoiceDocument = gql`
    mutation disputeInvoice($input: LoseInvoiceDisputeInput!) {
  loseInvoiceDispute(input: $input) {
    id
    status
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type DisputeInvoiceMutationFn = Apollo.MutationFunction<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;

/**
 * __useDisputeInvoiceMutation__
 *
 * To run a mutation, you first call `useDisputeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDisputeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [disputeInvoiceMutation, { data, loading, error }] = useDisputeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDisputeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>(DisputeInvoiceDocument, options);
      }
export type DisputeInvoiceMutationHookResult = ReturnType<typeof useDisputeInvoiceMutation>;
export type DisputeInvoiceMutationResult = Apollo.MutationResult<DisputeInvoiceMutation>;
export type DisputeInvoiceMutationOptions = Apollo.BaseMutationOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;
export const GetTaxesForInvoiceEditTaxDialogDocument = gql`
    query getTaxesForInvoiceEditTaxDialog($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForInvoiceEditTaxDialog
    }
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;

/**
 * __useGetTaxesForInvoiceEditTaxDialogQuery__
 *
 * To run a query within a React component, call `useGetTaxesForInvoiceEditTaxDialogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForInvoiceEditTaxDialogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForInvoiceEditTaxDialogQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForInvoiceEditTaxDialogQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
      }
export function useGetTaxesForInvoiceEditTaxDialogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export function useGetTaxesForInvoiceEditTaxDialogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export type GetTaxesForInvoiceEditTaxDialogQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogQuery>;
export type GetTaxesForInvoiceEditTaxDialogLazyQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogLazyQuery>;
export type GetTaxesForInvoiceEditTaxDialogSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogSuspenseQuery>;
export type GetTaxesForInvoiceEditTaxDialogQueryResult = Apollo.QueryResult<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>;
export const UpdateInvoicePaymentStatusDocument = gql`
    mutation updateInvoicePaymentStatus($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceForUpdateInvoicePaymentStatus
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}
${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type UpdateInvoicePaymentStatusMutationFn = Apollo.MutationFunction<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;

/**
 * __useUpdateInvoicePaymentStatusMutation__
 *
 * To run a mutation, you first call `useUpdateInvoicePaymentStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoicePaymentStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoicePaymentStatusMutation, { data, loading, error }] = useUpdateInvoicePaymentStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoicePaymentStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>(UpdateInvoicePaymentStatusDocument, options);
      }
export type UpdateInvoicePaymentStatusMutationHookResult = ReturnType<typeof useUpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationResult = Apollo.MutationResult<UpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationOptions = Apollo.BaseMutationOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;
export const FinalizeInvoiceDocument = gql`
    mutation finalizeInvoice($input: FinalizeInvoiceInput!) {
  finalizeInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type FinalizeInvoiceMutationFn = Apollo.MutationFunction<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;

/**
 * __useFinalizeInvoiceMutation__
 *
 * To run a mutation, you first call `useFinalizeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinalizeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finalizeInvoiceMutation, { data, loading, error }] = useFinalizeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFinalizeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>(FinalizeInvoiceDocument, options);
      }
export type FinalizeInvoiceMutationHookResult = ReturnType<typeof useFinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationResult = Apollo.MutationResult<FinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationOptions = Apollo.BaseMutationOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;
export const InvoiceActivityLogsDocument = gql`
    query InvoiceActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useInvoiceActivityLogsQuery__
 *
 * To run a query within a React component, call `useInvoiceActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvoiceActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvoiceActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function useInvoiceActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>(InvoiceActivityLogsDocument, options);
      }
export function useInvoiceActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>(InvoiceActivityLogsDocument, options);
        }
export function useInvoiceActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>(InvoiceActivityLogsDocument, options);
        }
export type InvoiceActivityLogsQueryHookResult = ReturnType<typeof useInvoiceActivityLogsQuery>;
export type InvoiceActivityLogsLazyQueryHookResult = ReturnType<typeof useInvoiceActivityLogsLazyQuery>;
export type InvoiceActivityLogsSuspenseQueryHookResult = ReturnType<typeof useInvoiceActivityLogsSuspenseQuery>;
export type InvoiceActivityLogsQueryResult = Apollo.QueryResult<InvoiceActivityLogsQuery, InvoiceActivityLogsQueryVariables>;
export const GetInvoiceCreditNotesDocument = gql`
    query getInvoiceCreditNotes($invoiceId: ID!, $page: Int, $limit: Int) {
  invoiceCreditNotes(invoiceId: $invoiceId, page: $page, limit: $limit) {
    ...CreditNotesForTable
  }
  invoice(id: $invoiceId) {
    id
    invoiceType
    associatedActiveWalletPresent
    paymentStatus
    refundableAmountCents
    creditableAmountCents
    totalPaidAmountCents
    totalDueAmountCents
    status
    customer {
      id
      applicableTimezone
      displayName
    }
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetInvoiceCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreditNotesQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvoiceCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables> & ({ variables: GetInvoiceCreditNotesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
      }
export function useGetInvoiceCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export function useGetInvoiceCreditNotesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export type GetInvoiceCreditNotesQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesQuery>;
export type GetInvoiceCreditNotesLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesLazyQuery>;
export type GetInvoiceCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesSuspenseQuery>;
export type GetInvoiceCreditNotesQueryResult = Apollo.QueryResult<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>;
export const GetInvoiceMetadatasDocument = gql`
    query getInvoiceMetadatas($id: ID!) {
  invoice(id: $id) {
    id
    ...InvoiceMetadatasForInvoiceOverview
    ...InvoiceMetadatasForMetadataDrawer
    customer {
      ...CustomerMetadatasForInvoiceOverview
    }
  }
}
    ${InvoiceMetadatasForInvoiceOverviewFragmentDoc}
${InvoiceMetadatasForMetadataDrawerFragmentDoc}
${CustomerMetadatasForInvoiceOverviewFragmentDoc}`;

/**
 * __useGetInvoiceMetadatasQuery__
 *
 * To run a query within a React component, call `useGetInvoiceMetadatasQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceMetadatasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceMetadatasQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceMetadatasQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables> & ({ variables: GetInvoiceMetadatasQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>(GetInvoiceMetadatasDocument, options);
      }
export function useGetInvoiceMetadatasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>(GetInvoiceMetadatasDocument, options);
        }
export function useGetInvoiceMetadatasSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>(GetInvoiceMetadatasDocument, options);
        }
export type GetInvoiceMetadatasQueryHookResult = ReturnType<typeof useGetInvoiceMetadatasQuery>;
export type GetInvoiceMetadatasLazyQueryHookResult = ReturnType<typeof useGetInvoiceMetadatasLazyQuery>;
export type GetInvoiceMetadatasSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceMetadatasSuspenseQuery>;
export type GetInvoiceMetadatasQueryResult = Apollo.QueryResult<GetInvoiceMetadatasQuery, GetInvoiceMetadatasQueryVariables>;
export const VoidInvoiceDocument = gql`
    mutation voidInvoice($input: VoidInvoiceInput!) {
  voidInvoice(input: $input) {
    id
    status
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type VoidInvoiceMutationFn = Apollo.MutationFunction<VoidInvoiceMutation, VoidInvoiceMutationVariables>;

/**
 * __useVoidInvoiceMutation__
 *
 * To run a mutation, you first call `useVoidInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidInvoiceMutation, { data, loading, error }] = useVoidInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidInvoiceMutation, VoidInvoiceMutationVariables>(VoidInvoiceDocument, options);
      }
export type VoidInvoiceMutationHookResult = ReturnType<typeof useVoidInvoiceMutation>;
export type VoidInvoiceMutationResult = Apollo.MutationResult<VoidInvoiceMutation>;
export type VoidInvoiceMutationOptions = Apollo.BaseMutationOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>;
export const DestroyAdjustedFeeDocument = gql`
    mutation destroyAdjustedFee($input: DestroyAdjustedFeeInput!) {
  destroyAdjustedFee(input: $input) {
    id
  }
}
    `;
export type DestroyAdjustedFeeMutationFn = Apollo.MutationFunction<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;

/**
 * __useDestroyAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useDestroyAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyAdjustedFeeMutation, { data, loading, error }] = useDestroyAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>(DestroyAdjustedFeeDocument, options);
      }
export type DestroyAdjustedFeeMutationHookResult = ReturnType<typeof useDestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationResult = Apollo.MutationResult<DestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;
export const GetInvoiceDetailsForCreateFeeDrawerDocument = gql`
    query getInvoiceDetailsForCreateFeeDrawer($invoiceId: ID!) {
  invoice(id: $invoiceId) {
    id
    invoiceSubscriptions {
      ...InvoiceSubscriptionForCreateFeeDrawer
    }
  }
}
    ${InvoiceSubscriptionForCreateFeeDrawerFragmentDoc}`;

/**
 * __useGetInvoiceDetailsForCreateFeeDrawerQuery__
 *
 * To run a query within a React component, call `useGetInvoiceDetailsForCreateFeeDrawerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceDetailsForCreateFeeDrawerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceDetailsForCreateFeeDrawerQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *   },
 * });
 */
export function useGetInvoiceDetailsForCreateFeeDrawerQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables> & ({ variables: GetInvoiceDetailsForCreateFeeDrawerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>(GetInvoiceDetailsForCreateFeeDrawerDocument, options);
      }
export function useGetInvoiceDetailsForCreateFeeDrawerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>(GetInvoiceDetailsForCreateFeeDrawerDocument, options);
        }
export function useGetInvoiceDetailsForCreateFeeDrawerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>(GetInvoiceDetailsForCreateFeeDrawerDocument, options);
        }
export type GetInvoiceDetailsForCreateFeeDrawerQueryHookResult = ReturnType<typeof useGetInvoiceDetailsForCreateFeeDrawerQuery>;
export type GetInvoiceDetailsForCreateFeeDrawerLazyQueryHookResult = ReturnType<typeof useGetInvoiceDetailsForCreateFeeDrawerLazyQuery>;
export type GetInvoiceDetailsForCreateFeeDrawerSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceDetailsForCreateFeeDrawerSuspenseQuery>;
export type GetInvoiceDetailsForCreateFeeDrawerQueryResult = Apollo.QueryResult<GetInvoiceDetailsForCreateFeeDrawerQuery, GetInvoiceDetailsForCreateFeeDrawerQueryVariables>;
export const CreateAdjustedFeeDocument = gql`
    mutation createAdjustedFee($input: CreateAdjustedFeeInput!) {
  createAdjustedFee(input: $input) {
    id
  }
}
    `;
export type CreateAdjustedFeeMutationFn = Apollo.MutationFunction<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;

/**
 * __useCreateAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useCreateAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAdjustedFeeMutation, { data, loading, error }] = useCreateAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>(CreateAdjustedFeeDocument, options);
      }
export type CreateAdjustedFeeMutationHookResult = ReturnType<typeof useCreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationResult = Apollo.MutationResult<CreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;
export const GetTaxesForCommitmentsDocument = gql`
    query getTaxesForCommitments($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForTaxesSelectorSection
    }
  }
}
    ${TaxForTaxesSelectorSectionFragmentDoc}`;

/**
 * __useGetTaxesForCommitmentsQuery__
 *
 * To run a query within a React component, call `useGetTaxesForCommitmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForCommitmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForCommitmentsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForCommitmentsQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
      }
export function useGetTaxesForCommitmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export function useGetTaxesForCommitmentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export type GetTaxesForCommitmentsQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsQuery>;
export type GetTaxesForCommitmentsLazyQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsLazyQuery>;
export type GetTaxesForCommitmentsSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsSuspenseQuery>;
export type GetTaxesForCommitmentsQueryResult = Apollo.QueryResult<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>;
export const DeletePlanDocument = gql`
    mutation deletePlan($input: DestroyPlanInput!) {
  destroyPlan(input: $input) {
    id
  }
}
    `;
export type DeletePlanMutationFn = Apollo.MutationFunction<DeletePlanMutation, DeletePlanMutationVariables>;

/**
 * __useDeletePlanMutation__
 *
 * To run a mutation, you first call `useDeletePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePlanMutation, { data, loading, error }] = useDeletePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeletePlanMutation(baseOptions?: Apollo.MutationHookOptions<DeletePlanMutation, DeletePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePlanMutation, DeletePlanMutationVariables>(DeletePlanDocument, options);
      }
export type DeletePlanMutationHookResult = ReturnType<typeof useDeletePlanMutation>;
export type DeletePlanMutationResult = Apollo.MutationResult<DeletePlanMutation>;
export type DeletePlanMutationOptions = Apollo.BaseMutationOptions<DeletePlanMutation, DeletePlanMutationVariables>;
export const GetFeaturesListForPlanSectionDocument = gql`
    query getFeaturesListForPlanSection($limit: Int, $page: Int, $searchTerm: String) {
  features(limit: $limit, page: $page, searchTerm: $searchTerm) {
    collection {
      id
      name
      code
      ...FeatureObjectEntitlementPrivilegeForPlan
    }
  }
}
    ${FeatureObjectEntitlementPrivilegeForPlanFragmentDoc}`;

/**
 * __useGetFeaturesListForPlanSectionQuery__
 *
 * To run a query within a React component, call `useGetFeaturesListForPlanSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeaturesListForPlanSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeaturesListForPlanSectionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetFeaturesListForPlanSectionQuery(baseOptions?: Apollo.QueryHookOptions<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>(GetFeaturesListForPlanSectionDocument, options);
      }
export function useGetFeaturesListForPlanSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>(GetFeaturesListForPlanSectionDocument, options);
        }
export function useGetFeaturesListForPlanSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>(GetFeaturesListForPlanSectionDocument, options);
        }
export type GetFeaturesListForPlanSectionQueryHookResult = ReturnType<typeof useGetFeaturesListForPlanSectionQuery>;
export type GetFeaturesListForPlanSectionLazyQueryHookResult = ReturnType<typeof useGetFeaturesListForPlanSectionLazyQuery>;
export type GetFeaturesListForPlanSectionSuspenseQueryHookResult = ReturnType<typeof useGetFeaturesListForPlanSectionSuspenseQuery>;
export type GetFeaturesListForPlanSectionQueryResult = Apollo.QueryResult<GetFeaturesListForPlanSectionQuery, GetFeaturesListForPlanSectionQueryVariables>;
export const GetFeatureDetailsForFeatureEntitlementPrivilegeSectionDocument = gql`
    query getFeatureDetailsForFeatureEntitlementPrivilegeSection($code: String) {
  feature(code: $code) {
    ...FeatureObjectEntitlementPrivilegeForPlan
  }
}
    ${FeatureObjectEntitlementPrivilegeForPlanFragmentDoc}`;

/**
 * __useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery__
 *
 * To run a query within a React component, call `useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery(baseOptions?: Apollo.QueryHookOptions<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>(GetFeatureDetailsForFeatureEntitlementPrivilegeSectionDocument, options);
      }
export function useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>(GetFeatureDetailsForFeatureEntitlementPrivilegeSectionDocument, options);
        }
export function useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>(GetFeatureDetailsForFeatureEntitlementPrivilegeSectionDocument, options);
        }
export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryHookResult = ReturnType<typeof useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery>;
export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionLazyQueryHookResult = ReturnType<typeof useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionLazyQuery>;
export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionSuspenseQueryHookResult = ReturnType<typeof useGetFeatureDetailsForFeatureEntitlementPrivilegeSectionSuspenseQuery>;
export type GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryResult = Apollo.QueryResult<GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQuery, GetFeatureDetailsForFeatureEntitlementPrivilegeSectionQueryVariables>;
export const GetTaxesForPlanDocument = gql`
    query getTaxesForPlan($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanSettingsSection
    }
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;

/**
 * __useGetTaxesForPlanQuery__
 *
 * To run a query within a React component, call `useGetTaxesForPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForPlanQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxesForPlanQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
      }
export function useGetTaxesForPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export function useGetTaxesForPlanSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export type GetTaxesForPlanQueryHookResult = ReturnType<typeof useGetTaxesForPlanQuery>;
export type GetTaxesForPlanLazyQueryHookResult = ReturnType<typeof useGetTaxesForPlanLazyQuery>;
export type GetTaxesForPlanSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForPlanSuspenseQuery>;
export type GetTaxesForPlanQueryResult = Apollo.QueryResult<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>;
export const GetMeteredBillableMetricsDocument = gql`
    query getMeteredBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: false
  ) {
    collection {
      id
      ...BillableMetricForUsageChargeSection
    }
  }
}
    ${BillableMetricForUsageChargeSectionFragmentDoc}`;

/**
 * __useGetMeteredBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetMeteredBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMeteredBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMeteredBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetMeteredBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
      }
export function useGetMeteredBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export function useGetMeteredBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export type GetMeteredBillableMetricsQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsQuery>;
export type GetMeteredBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsLazyQuery>;
export type GetMeteredBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsSuspenseQuery>;
export type GetMeteredBillableMetricsQueryResult = Apollo.QueryResult<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>;
export const GetRecurringBillableMetricsDocument = gql`
    query getRecurringBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: true
  ) {
    collection {
      id
      ...BillableMetricForUsageChargeSection
    }
  }
}
    ${BillableMetricForUsageChargeSectionFragmentDoc}`;

/**
 * __useGetRecurringBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetRecurringBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRecurringBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRecurringBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetRecurringBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
      }
export function useGetRecurringBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export function useGetRecurringBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export type GetRecurringBillableMetricsQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsQuery>;
export type GetRecurringBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsLazyQuery>;
export type GetRecurringBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsSuspenseQuery>;
export type GetRecurringBillableMetricsQueryResult = Apollo.QueryResult<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>;
export const PlanDetailsActivityLogsDocument = gql`
    query PlanDetailsActivityLogs($page: Int, $limit: Int, $resourceTypes: [ResourceTypeEnum!], $resourceIds: [String!]) {
  activityLogs(
    page: $page
    limit: $limit
    resourceTypes: $resourceTypes
    resourceIds: $resourceIds
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __usePlanDetailsActivityLogsQuery__
 *
 * To run a query within a React component, call `usePlanDetailsActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlanDetailsActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlanDetailsActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      resourceTypes: // value for 'resourceTypes'
 *      resourceIds: // value for 'resourceIds'
 *   },
 * });
 */
export function usePlanDetailsActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>(PlanDetailsActivityLogsDocument, options);
      }
export function usePlanDetailsActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>(PlanDetailsActivityLogsDocument, options);
        }
export function usePlanDetailsActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>(PlanDetailsActivityLogsDocument, options);
        }
export type PlanDetailsActivityLogsQueryHookResult = ReturnType<typeof usePlanDetailsActivityLogsQuery>;
export type PlanDetailsActivityLogsLazyQueryHookResult = ReturnType<typeof usePlanDetailsActivityLogsLazyQuery>;
export type PlanDetailsActivityLogsSuspenseQueryHookResult = ReturnType<typeof usePlanDetailsActivityLogsSuspenseQuery>;
export type PlanDetailsActivityLogsQueryResult = Apollo.QueryResult<PlanDetailsActivityLogsQuery, PlanDetailsActivityLogsQueryVariables>;
export const GetPlanForDetailsOverviewSectionDocument = gql`
    query getPlanForDetailsOverviewSection($plan: ID!) {
  plan(id: $plan) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetPlanForDetailsOverviewSectionQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsOverviewSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsOverviewSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsOverviewSectionQuery({
 *   variables: {
 *      plan: // value for 'plan'
 *   },
 * });
 */
export function useGetPlanForDetailsOverviewSectionQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables> & ({ variables: GetPlanForDetailsOverviewSectionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
      }
export function useGetPlanForDetailsOverviewSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export function useGetPlanForDetailsOverviewSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export type GetPlanForDetailsOverviewSectionQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionQuery>;
export type GetPlanForDetailsOverviewSectionLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionLazyQuery>;
export type GetPlanForDetailsOverviewSectionSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionSuspenseQuery>;
export type GetPlanForDetailsOverviewSectionQueryResult = Apollo.QueryResult<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>;
export const GetSubscribtionsForPlanDetailsDocument = gql`
    query getSubscribtionsForPlanDetails($page: Int, $limit: Int, $planCode: String, $status: [StatusTypeEnum!]) {
  subscriptions(page: $page, limit: $limit, planCode: $planCode, status: $status) {
    collection {
      id
      endingAt
      subscriptionAt
      plan {
        id
        parent {
          id
        }
      }
      customer {
        id
        name
        displayName
        externalId
      }
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetSubscribtionsForPlanDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscribtionsForPlanDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscribtionsForPlanDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscribtionsForPlanDetailsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      planCode: // value for 'planCode'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetSubscribtionsForPlanDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
      }
export function useGetSubscribtionsForPlanDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export function useGetSubscribtionsForPlanDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export type GetSubscribtionsForPlanDetailsQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsQuery>;
export type GetSubscribtionsForPlanDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsLazyQuery>;
export type GetSubscribtionsForPlanDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsSuspenseQuery>;
export type GetSubscribtionsForPlanDetailsQueryResult = Apollo.QueryResult<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>;
export const DestroyIntegrationDocument = gql`
    mutation DestroyIntegration($input: DestroyIntegrationInput!) {
  destroyIntegration(input: $input) {
    id
  }
}
    `;
export type DestroyIntegrationMutationFn = Apollo.MutationFunction<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>;

/**
 * __useDestroyIntegrationMutation__
 *
 * To run a mutation, you first call `useDestroyIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyIntegrationMutation, { data, loading, error }] = useDestroyIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>(DestroyIntegrationDocument, options);
      }
export type DestroyIntegrationMutationHookResult = ReturnType<typeof useDestroyIntegrationMutation>;
export type DestroyIntegrationMutationResult = Apollo.MutationResult<DestroyIntegrationMutation>;
export type DestroyIntegrationMutationOptions = Apollo.BaseMutationOptions<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>;
export const CreateOktaIntegrationDocument = gql`
    mutation createOktaIntegration($input: CreateOktaIntegrationInput!) {
  createOktaIntegration(input: $input) {
    id
  }
}
    `;
export type CreateOktaIntegrationMutationFn = Apollo.MutationFunction<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>;

/**
 * __useCreateOktaIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateOktaIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOktaIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOktaIntegrationMutation, { data, loading, error }] = useCreateOktaIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOktaIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>(CreateOktaIntegrationDocument, options);
      }
export type CreateOktaIntegrationMutationHookResult = ReturnType<typeof useCreateOktaIntegrationMutation>;
export type CreateOktaIntegrationMutationResult = Apollo.MutationResult<CreateOktaIntegrationMutation>;
export type CreateOktaIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>;
export const UpdateOktaIntegrationDocument = gql`
    mutation updateOktaIntegration($input: UpdateOktaIntegrationInput!) {
  updateOktaIntegration(input: $input) {
    id
  }
}
    `;
export type UpdateOktaIntegrationMutationFn = Apollo.MutationFunction<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>;

/**
 * __useUpdateOktaIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateOktaIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOktaIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOktaIntegrationMutation, { data, loading, error }] = useUpdateOktaIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOktaIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>(UpdateOktaIntegrationDocument, options);
      }
export type UpdateOktaIntegrationMutationHookResult = ReturnType<typeof useUpdateOktaIntegrationMutation>;
export type UpdateOktaIntegrationMutationResult = Apollo.MutationResult<UpdateOktaIntegrationMutation>;
export type UpdateOktaIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>;
export const DeleteDunningCampaignDocument = gql`
    mutation deleteDunningCampaign($input: DestroyDunningCampaignInput!) {
  destroyDunningCampaign(input: $input) {
    id
  }
}
    `;
export type DeleteDunningCampaignMutationFn = Apollo.MutationFunction<DeleteDunningCampaignMutation, DeleteDunningCampaignMutationVariables>;

/**
 * __useDeleteDunningCampaignMutation__
 *
 * To run a mutation, you first call `useDeleteDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDunningCampaignMutation, { data, loading, error }] = useDeleteDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDunningCampaignMutation, DeleteDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDunningCampaignMutation, DeleteDunningCampaignMutationVariables>(DeleteDunningCampaignDocument, options);
      }
export type DeleteDunningCampaignMutationHookResult = ReturnType<typeof useDeleteDunningCampaignMutation>;
export type DeleteDunningCampaignMutationResult = Apollo.MutationResult<DeleteDunningCampaignMutation>;
export type DeleteDunningCampaignMutationOptions = Apollo.BaseMutationOptions<DeleteDunningCampaignMutation, DeleteDunningCampaignMutationVariables>;
export const GetOrganizationInfoForPreviewDunningCampaignDocument = gql`
    query getOrganizationInfoForPreviewDunningCampaign {
  organization {
    ...OrganizationInfoForPreviewDunningCampaign
  }
}
    ${OrganizationInfoForPreviewDunningCampaignFragmentDoc}`;

/**
 * __useGetOrganizationInfoForPreviewDunningCampaignQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfoForPreviewDunningCampaignQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfoForPreviewDunningCampaignQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfoForPreviewDunningCampaignQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfoForPreviewDunningCampaignQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
      }
export function useGetOrganizationInfoForPreviewDunningCampaignLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
        }
export function useGetOrganizationInfoForPreviewDunningCampaignSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
        }
export type GetOrganizationInfoForPreviewDunningCampaignQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignLazyQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignSuspenseQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignQueryResult = Apollo.QueryResult<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>;
export const UpdateBillingEntityLogoDocument = gql`
    mutation updateBillingEntityLogo($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    logoUrl
  }
}
    `;
export type UpdateBillingEntityLogoMutationFn = Apollo.MutationFunction<UpdateBillingEntityLogoMutation, UpdateBillingEntityLogoMutationVariables>;

/**
 * __useUpdateBillingEntityLogoMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityLogoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityLogoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityLogoMutation, { data, loading, error }] = useUpdateBillingEntityLogoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityLogoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityLogoMutation, UpdateBillingEntityLogoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityLogoMutation, UpdateBillingEntityLogoMutationVariables>(UpdateBillingEntityLogoDocument, options);
      }
export type UpdateBillingEntityLogoMutationHookResult = ReturnType<typeof useUpdateBillingEntityLogoMutation>;
export type UpdateBillingEntityLogoMutationResult = Apollo.MutationResult<UpdateBillingEntityLogoMutation>;
export type UpdateBillingEntityLogoMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityLogoMutation, UpdateBillingEntityLogoMutationVariables>;
export const GetProviderByCodeForAdyenDocument = gql`
    query getProviderByCodeForAdyen($code: String) {
  paymentProvider(code: $code) {
    ... on AdyenProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on FlutterwaveProvider {
      id
    }
    ... on CashfreeProvider {
      id
    }
    ... on StripeProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForAdyenQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForAdyenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForAdyenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForAdyenQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForAdyenQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
      }
export function useGetProviderByCodeForAdyenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export function useGetProviderByCodeForAdyenSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export type GetProviderByCodeForAdyenQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenQuery>;
export type GetProviderByCodeForAdyenLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenLazyQuery>;
export type GetProviderByCodeForAdyenSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenSuspenseQuery>;
export type GetProviderByCodeForAdyenQueryResult = Apollo.QueryResult<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>;
export const AddAdyenApiKeyDocument = gql`
    mutation addAdyenApiKey($input: AddAdyenPaymentProviderInput!) {
  addAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type AddAdyenApiKeyMutationFn = Apollo.MutationFunction<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;

/**
 * __useAddAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useAddAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAdyenApiKeyMutation, { data, loading, error }] = useAddAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>(AddAdyenApiKeyDocument, options);
      }
export type AddAdyenApiKeyMutationHookResult = ReturnType<typeof useAddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationResult = Apollo.MutationResult<AddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;
export const UpdateAdyenApiKeyDocument = gql`
    mutation updateAdyenApiKey($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type UpdateAdyenApiKeyMutationFn = Apollo.MutationFunction<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;

/**
 * __useUpdateAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenApiKeyMutation, { data, loading, error }] = useUpdateAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>(UpdateAdyenApiKeyDocument, options);
      }
export type UpdateAdyenApiKeyMutationHookResult = ReturnType<typeof useUpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationResult = Apollo.MutationResult<UpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;
export const CreateAnrokIntegrationDocument = gql`
    mutation createAnrokIntegration($input: CreateAnrokIntegrationInput!) {
  createAnrokIntegration(input: $input) {
    id
    ...AddAnrokIntegrationDialog
    ...AnrokIntegrationDetails
  }
}
    ${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationDetailsFragmentDoc}`;
export type CreateAnrokIntegrationMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>;

/**
 * __useCreateAnrokIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationMutation, { data, loading, error }] = useCreateAnrokIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>(CreateAnrokIntegrationDocument, options);
      }
export type CreateAnrokIntegrationMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationMutation>;
export type CreateAnrokIntegrationMutationResult = Apollo.MutationResult<CreateAnrokIntegrationMutation>;
export type CreateAnrokIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>;
export const UpdateAnrokIntegrationDocument = gql`
    mutation updateAnrokIntegration($input: UpdateAnrokIntegrationInput!) {
  updateAnrokIntegration(input: $input) {
    id
    ...AddAnrokIntegrationDialog
    ...AnrokIntegrationDetails
  }
}
    ${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationDetailsFragmentDoc}`;
export type UpdateAnrokIntegrationMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>;

/**
 * __useUpdateAnrokIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationMutation, { data, loading, error }] = useUpdateAnrokIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>(UpdateAnrokIntegrationDocument, options);
      }
export type UpdateAnrokIntegrationMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationMutation>;
export type UpdateAnrokIntegrationMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationMutation>;
export type UpdateAnrokIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>;
export const CreateAvalaraIntegrationDocument = gql`
    mutation createAvalaraIntegration($input: CreateAvalaraIntegrationInput!) {
  createAvalaraIntegration(input: $input) {
    ...AddAvalaraIntegrationDialog
    ...AvalaraIntegrationDetails
  }
}
    ${AddAvalaraIntegrationDialogFragmentDoc}
${AvalaraIntegrationDetailsFragmentDoc}`;
export type CreateAvalaraIntegrationMutationFn = Apollo.MutationFunction<CreateAvalaraIntegrationMutation, CreateAvalaraIntegrationMutationVariables>;

/**
 * __useCreateAvalaraIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateAvalaraIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAvalaraIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAvalaraIntegrationMutation, { data, loading, error }] = useCreateAvalaraIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAvalaraIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateAvalaraIntegrationMutation, CreateAvalaraIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAvalaraIntegrationMutation, CreateAvalaraIntegrationMutationVariables>(CreateAvalaraIntegrationDocument, options);
      }
export type CreateAvalaraIntegrationMutationHookResult = ReturnType<typeof useCreateAvalaraIntegrationMutation>;
export type CreateAvalaraIntegrationMutationResult = Apollo.MutationResult<CreateAvalaraIntegrationMutation>;
export type CreateAvalaraIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateAvalaraIntegrationMutation, CreateAvalaraIntegrationMutationVariables>;
export const UpdateAvalaraIntegrationDocument = gql`
    mutation updateAvalaraIntegration($input: UpdateAvalaraIntegrationInput!) {
  updateAvalaraIntegration(input: $input) {
    id
    ...AddAvalaraIntegrationDialog
    ...AvalaraIntegrationDetails
  }
}
    ${AddAvalaraIntegrationDialogFragmentDoc}
${AvalaraIntegrationDetailsFragmentDoc}`;
export type UpdateAvalaraIntegrationMutationFn = Apollo.MutationFunction<UpdateAvalaraIntegrationMutation, UpdateAvalaraIntegrationMutationVariables>;

/**
 * __useUpdateAvalaraIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateAvalaraIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvalaraIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvalaraIntegrationMutation, { data, loading, error }] = useUpdateAvalaraIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAvalaraIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvalaraIntegrationMutation, UpdateAvalaraIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvalaraIntegrationMutation, UpdateAvalaraIntegrationMutationVariables>(UpdateAvalaraIntegrationDocument, options);
      }
export type UpdateAvalaraIntegrationMutationHookResult = ReturnType<typeof useUpdateAvalaraIntegrationMutation>;
export type UpdateAvalaraIntegrationMutationResult = Apollo.MutationResult<UpdateAvalaraIntegrationMutation>;
export type UpdateAvalaraIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateAvalaraIntegrationMutation, UpdateAvalaraIntegrationMutationVariables>;
export const GetProviderByCodeForCashfreeDocument = gql`
    query getProviderByCodeForCashfree($code: String) {
  paymentProvider(code: $code) {
    ... on CashfreeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on FlutterwaveProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on StripeProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForCashfreeQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForCashfreeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForCashfreeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForCashfreeQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForCashfreeQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>(GetProviderByCodeForCashfreeDocument, options);
      }
export function useGetProviderByCodeForCashfreeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>(GetProviderByCodeForCashfreeDocument, options);
        }
export function useGetProviderByCodeForCashfreeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>(GetProviderByCodeForCashfreeDocument, options);
        }
export type GetProviderByCodeForCashfreeQueryHookResult = ReturnType<typeof useGetProviderByCodeForCashfreeQuery>;
export type GetProviderByCodeForCashfreeLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForCashfreeLazyQuery>;
export type GetProviderByCodeForCashfreeSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForCashfreeSuspenseQuery>;
export type GetProviderByCodeForCashfreeQueryResult = Apollo.QueryResult<GetProviderByCodeForCashfreeQuery, GetProviderByCodeForCashfreeQueryVariables>;
export const AddCashfreeApiKeyDocument = gql`
    mutation addCashfreeApiKey($input: AddCashfreePaymentProviderInput!) {
  addCashfreePaymentProvider(input: $input) {
    id
    ...AddCashfreeProviderDialog
    ...CashfreeIntegrationDetails
  }
}
    ${AddCashfreeProviderDialogFragmentDoc}
${CashfreeIntegrationDetailsFragmentDoc}`;
export type AddCashfreeApiKeyMutationFn = Apollo.MutationFunction<AddCashfreeApiKeyMutation, AddCashfreeApiKeyMutationVariables>;

/**
 * __useAddCashfreeApiKeyMutation__
 *
 * To run a mutation, you first call `useAddCashfreeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCashfreeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCashfreeApiKeyMutation, { data, loading, error }] = useAddCashfreeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddCashfreeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddCashfreeApiKeyMutation, AddCashfreeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCashfreeApiKeyMutation, AddCashfreeApiKeyMutationVariables>(AddCashfreeApiKeyDocument, options);
      }
export type AddCashfreeApiKeyMutationHookResult = ReturnType<typeof useAddCashfreeApiKeyMutation>;
export type AddCashfreeApiKeyMutationResult = Apollo.MutationResult<AddCashfreeApiKeyMutation>;
export type AddCashfreeApiKeyMutationOptions = Apollo.BaseMutationOptions<AddCashfreeApiKeyMutation, AddCashfreeApiKeyMutationVariables>;
export const UpdateCashfreeApiKeyDocument = gql`
    mutation updateCashfreeApiKey($input: UpdateCashfreePaymentProviderInput!) {
  updateCashfreePaymentProvider(input: $input) {
    id
    ...AddCashfreeProviderDialog
    ...CashfreeIntegrationDetails
  }
}
    ${AddCashfreeProviderDialogFragmentDoc}
${CashfreeIntegrationDetailsFragmentDoc}`;
export type UpdateCashfreeApiKeyMutationFn = Apollo.MutationFunction<UpdateCashfreeApiKeyMutation, UpdateCashfreeApiKeyMutationVariables>;

/**
 * __useUpdateCashfreeApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateCashfreeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCashfreeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCashfreeApiKeyMutation, { data, loading, error }] = useUpdateCashfreeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCashfreeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCashfreeApiKeyMutation, UpdateCashfreeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCashfreeApiKeyMutation, UpdateCashfreeApiKeyMutationVariables>(UpdateCashfreeApiKeyDocument, options);
      }
export type UpdateCashfreeApiKeyMutationHookResult = ReturnType<typeof useUpdateCashfreeApiKeyMutation>;
export type UpdateCashfreeApiKeyMutationResult = Apollo.MutationResult<UpdateCashfreeApiKeyMutation>;
export type UpdateCashfreeApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateCashfreeApiKeyMutation, UpdateCashfreeApiKeyMutationVariables>;
export const UpdateAdyenPaymentProviderDocument = gql`
    mutation updateAdyenPaymentProvider($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateAdyenPaymentProviderMutationFn = Apollo.MutationFunction<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;

/**
 * __useUpdateAdyenPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenPaymentProviderMutation, { data, loading, error }] = useUpdateAdyenPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>(UpdateAdyenPaymentProviderDocument, options);
      }
export type UpdateAdyenPaymentProviderMutationHookResult = ReturnType<typeof useUpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationResult = Apollo.MutationResult<UpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;
export const UpdateCashfreePaymentProviderDocument = gql`
    mutation updateCashfreePaymentProvider($input: UpdateCashfreePaymentProviderInput!) {
  updateCashfreePaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateCashfreePaymentProviderMutationFn = Apollo.MutationFunction<UpdateCashfreePaymentProviderMutation, UpdateCashfreePaymentProviderMutationVariables>;

/**
 * __useUpdateCashfreePaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateCashfreePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCashfreePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCashfreePaymentProviderMutation, { data, loading, error }] = useUpdateCashfreePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCashfreePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCashfreePaymentProviderMutation, UpdateCashfreePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCashfreePaymentProviderMutation, UpdateCashfreePaymentProviderMutationVariables>(UpdateCashfreePaymentProviderDocument, options);
      }
export type UpdateCashfreePaymentProviderMutationHookResult = ReturnType<typeof useUpdateCashfreePaymentProviderMutation>;
export type UpdateCashfreePaymentProviderMutationResult = Apollo.MutationResult<UpdateCashfreePaymentProviderMutation>;
export type UpdateCashfreePaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateCashfreePaymentProviderMutation, UpdateCashfreePaymentProviderMutationVariables>;
export const UpdateFlutterwavePaymentProviderSuccessRedirectUrlDocument = gql`
    mutation updateFlutterwavePaymentProviderSuccessRedirectUrl($input: UpdateFlutterwavePaymentProviderInput!) {
  updateFlutterwavePaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationFn = Apollo.MutationFunction<UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation, UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationVariables>;

/**
 * __useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation__
 *
 * To run a mutation, you first call `useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFlutterwavePaymentProviderSuccessRedirectUrlMutation, { data, loading, error }] = useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation, UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation, UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationVariables>(UpdateFlutterwavePaymentProviderSuccessRedirectUrlDocument, options);
      }
export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationHookResult = ReturnType<typeof useUpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation>;
export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationResult = Apollo.MutationResult<UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation>;
export type UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationOptions = Apollo.BaseMutationOptions<UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutation, UpdateFlutterwavePaymentProviderSuccessRedirectUrlMutationVariables>;
export const UpdateGocardlessPaymentProviderDocument = gql`
    mutation updateGocardlessPaymentProvider($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateGocardlessPaymentProviderMutationFn = Apollo.MutationFunction<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;

/**
 * __useUpdateGocardlessPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessPaymentProviderMutation, { data, loading, error }] = useUpdateGocardlessPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>(UpdateGocardlessPaymentProviderDocument, options);
      }
export type UpdateGocardlessPaymentProviderMutationHookResult = ReturnType<typeof useUpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationResult = Apollo.MutationResult<UpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;
export const UpdateStripePaymentProviderDocument = gql`
    mutation updateStripePaymentProvider($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateStripePaymentProviderMutationFn = Apollo.MutationFunction<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;

/**
 * __useUpdateStripePaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateStripePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripePaymentProviderMutation, { data, loading, error }] = useUpdateStripePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>(UpdateStripePaymentProviderDocument, options);
      }
export type UpdateStripePaymentProviderMutationHookResult = ReturnType<typeof useUpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationResult = Apollo.MutationResult<UpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;
export const UpdateMoneyhashPaymentProviderDocument = gql`
    mutation updateMoneyhashPaymentProvider($input: UpdateMoneyhashPaymentProviderInput!) {
  updateMoneyhashPaymentProvider(input: $input) {
    id
    flowId
  }
}
    `;
export type UpdateMoneyhashPaymentProviderMutationFn = Apollo.MutationFunction<UpdateMoneyhashPaymentProviderMutation, UpdateMoneyhashPaymentProviderMutationVariables>;

/**
 * __useUpdateMoneyhashPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateMoneyhashPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMoneyhashPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMoneyhashPaymentProviderMutation, { data, loading, error }] = useUpdateMoneyhashPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMoneyhashPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMoneyhashPaymentProviderMutation, UpdateMoneyhashPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMoneyhashPaymentProviderMutation, UpdateMoneyhashPaymentProviderMutationVariables>(UpdateMoneyhashPaymentProviderDocument, options);
      }
export type UpdateMoneyhashPaymentProviderMutationHookResult = ReturnType<typeof useUpdateMoneyhashPaymentProviderMutation>;
export type UpdateMoneyhashPaymentProviderMutationResult = Apollo.MutationResult<UpdateMoneyhashPaymentProviderMutation>;
export type UpdateMoneyhashPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateMoneyhashPaymentProviderMutation, UpdateMoneyhashPaymentProviderMutationVariables>;
export const GetProviderByCodeForFlutterwaveDocument = gql`
    query getProviderByCodeForFlutterwave($code: String) {
  paymentProvider(code: $code) {
    ... on FlutterwaveProvider {
      id
    }
    ... on CashfreeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on StripeProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForFlutterwaveQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForFlutterwaveQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForFlutterwaveQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForFlutterwaveQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForFlutterwaveQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>(GetProviderByCodeForFlutterwaveDocument, options);
      }
export function useGetProviderByCodeForFlutterwaveLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>(GetProviderByCodeForFlutterwaveDocument, options);
        }
export function useGetProviderByCodeForFlutterwaveSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>(GetProviderByCodeForFlutterwaveDocument, options);
        }
export type GetProviderByCodeForFlutterwaveQueryHookResult = ReturnType<typeof useGetProviderByCodeForFlutterwaveQuery>;
export type GetProviderByCodeForFlutterwaveLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForFlutterwaveLazyQuery>;
export type GetProviderByCodeForFlutterwaveSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForFlutterwaveSuspenseQuery>;
export type GetProviderByCodeForFlutterwaveQueryResult = Apollo.QueryResult<GetProviderByCodeForFlutterwaveQuery, GetProviderByCodeForFlutterwaveQueryVariables>;
export const AddFlutterwavePaymentProviderDocument = gql`
    mutation addFlutterwavePaymentProvider($input: AddFlutterwavePaymentProviderInput!) {
  addFlutterwavePaymentProvider(input: $input) {
    id
    ...AddFlutterwaveProviderDialog
  }
}
    ${AddFlutterwaveProviderDialogFragmentDoc}`;
export type AddFlutterwavePaymentProviderMutationFn = Apollo.MutationFunction<AddFlutterwavePaymentProviderMutation, AddFlutterwavePaymentProviderMutationVariables>;

/**
 * __useAddFlutterwavePaymentProviderMutation__
 *
 * To run a mutation, you first call `useAddFlutterwavePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddFlutterwavePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addFlutterwavePaymentProviderMutation, { data, loading, error }] = useAddFlutterwavePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddFlutterwavePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<AddFlutterwavePaymentProviderMutation, AddFlutterwavePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddFlutterwavePaymentProviderMutation, AddFlutterwavePaymentProviderMutationVariables>(AddFlutterwavePaymentProviderDocument, options);
      }
export type AddFlutterwavePaymentProviderMutationHookResult = ReturnType<typeof useAddFlutterwavePaymentProviderMutation>;
export type AddFlutterwavePaymentProviderMutationResult = Apollo.MutationResult<AddFlutterwavePaymentProviderMutation>;
export type AddFlutterwavePaymentProviderMutationOptions = Apollo.BaseMutationOptions<AddFlutterwavePaymentProviderMutation, AddFlutterwavePaymentProviderMutationVariables>;
export const UpdateFlutterwavePaymentProviderDocument = gql`
    mutation updateFlutterwavePaymentProvider($input: UpdateFlutterwavePaymentProviderInput!) {
  updateFlutterwavePaymentProvider(input: $input) {
    id
    ...AddFlutterwaveProviderDialog
  }
}
    ${AddFlutterwaveProviderDialogFragmentDoc}`;
export type UpdateFlutterwavePaymentProviderMutationFn = Apollo.MutationFunction<UpdateFlutterwavePaymentProviderMutation, UpdateFlutterwavePaymentProviderMutationVariables>;

/**
 * __useUpdateFlutterwavePaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateFlutterwavePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFlutterwavePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFlutterwavePaymentProviderMutation, { data, loading, error }] = useUpdateFlutterwavePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFlutterwavePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFlutterwavePaymentProviderMutation, UpdateFlutterwavePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFlutterwavePaymentProviderMutation, UpdateFlutterwavePaymentProviderMutationVariables>(UpdateFlutterwavePaymentProviderDocument, options);
      }
export type UpdateFlutterwavePaymentProviderMutationHookResult = ReturnType<typeof useUpdateFlutterwavePaymentProviderMutation>;
export type UpdateFlutterwavePaymentProviderMutationResult = Apollo.MutationResult<UpdateFlutterwavePaymentProviderMutation>;
export type UpdateFlutterwavePaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateFlutterwavePaymentProviderMutation, UpdateFlutterwavePaymentProviderMutationVariables>;
export const GetProviderByCodeForGocardlessDocument = gql`
    query getProviderByCodeForGocardless($code: String) {
  paymentProvider(code: $code) {
    ... on GocardlessProvider {
      id
    }
    ... on CashfreeProvider {
      id
    }
    ... on FlutterwaveProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on StripeProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForGocardlessQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForGocardlessQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForGocardlessQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForGocardlessQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForGocardlessQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
      }
export function useGetProviderByCodeForGocardlessLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export function useGetProviderByCodeForGocardlessSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export type GetProviderByCodeForGocardlessQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessQuery>;
export type GetProviderByCodeForGocardlessLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessLazyQuery>;
export type GetProviderByCodeForGocardlessSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessSuspenseQuery>;
export type GetProviderByCodeForGocardlessQueryResult = Apollo.QueryResult<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>;
export const UpdateGocardlessApiKeyDocument = gql`
    mutation updateGocardlessApiKey($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationDetails
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationDetailsFragmentDoc}`;
export type UpdateGocardlessApiKeyMutationFn = Apollo.MutationFunction<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;

/**
 * __useUpdateGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessApiKeyMutation, { data, loading, error }] = useUpdateGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>(UpdateGocardlessApiKeyDocument, options);
      }
export type UpdateGocardlessApiKeyMutationHookResult = ReturnType<typeof useUpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationResult = Apollo.MutationResult<UpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;
export const CreateHubspotIntegrationDocument = gql`
    mutation createHubspotIntegration($input: CreateHubspotIntegrationInput!) {
  createHubspotIntegration(input: $input) {
    ...HubspotForCreateDialog
  }
}
    ${HubspotForCreateDialogFragmentDoc}`;
export type CreateHubspotIntegrationMutationFn = Apollo.MutationFunction<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>;

/**
 * __useCreateHubspotIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateHubspotIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateHubspotIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createHubspotIntegrationMutation, { data, loading, error }] = useCreateHubspotIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateHubspotIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>(CreateHubspotIntegrationDocument, options);
      }
export type CreateHubspotIntegrationMutationHookResult = ReturnType<typeof useCreateHubspotIntegrationMutation>;
export type CreateHubspotIntegrationMutationResult = Apollo.MutationResult<CreateHubspotIntegrationMutation>;
export type CreateHubspotIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>;
export const UpdateHubspotIntegrationDocument = gql`
    mutation updateHubspotIntegration($input: UpdateHubspotIntegrationInput!) {
  updateHubspotIntegration(input: $input) {
    ...HubspotForCreateDialog
  }
}
    ${HubspotForCreateDialogFragmentDoc}`;
export type UpdateHubspotIntegrationMutationFn = Apollo.MutationFunction<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>;

/**
 * __useUpdateHubspotIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateHubspotIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHubspotIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHubspotIntegrationMutation, { data, loading, error }] = useUpdateHubspotIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateHubspotIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>(UpdateHubspotIntegrationDocument, options);
      }
export type UpdateHubspotIntegrationMutationHookResult = ReturnType<typeof useUpdateHubspotIntegrationMutation>;
export type UpdateHubspotIntegrationMutationResult = Apollo.MutationResult<UpdateHubspotIntegrationMutation>;
export type UpdateHubspotIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>;
export const GetProviderByCodeForMoneyhashDocument = gql`
    query getProviderByCodeForMoneyhash($code: String) {
  paymentProvider(code: $code) {
    ... on AdyenProvider {
      id
    }
    ... on CashfreeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on FlutterwaveProvider {
      id
    }
    ... on StripeProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForMoneyhashQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForMoneyhashQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForMoneyhashQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForMoneyhashQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForMoneyhashQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>(GetProviderByCodeForMoneyhashDocument, options);
      }
export function useGetProviderByCodeForMoneyhashLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>(GetProviderByCodeForMoneyhashDocument, options);
        }
export function useGetProviderByCodeForMoneyhashSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>(GetProviderByCodeForMoneyhashDocument, options);
        }
export type GetProviderByCodeForMoneyhashQueryHookResult = ReturnType<typeof useGetProviderByCodeForMoneyhashQuery>;
export type GetProviderByCodeForMoneyhashLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForMoneyhashLazyQuery>;
export type GetProviderByCodeForMoneyhashSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForMoneyhashSuspenseQuery>;
export type GetProviderByCodeForMoneyhashQueryResult = Apollo.QueryResult<GetProviderByCodeForMoneyhashQuery, GetProviderByCodeForMoneyhashQueryVariables>;
export const AddMoneyhashApiKeyDocument = gql`
    mutation addMoneyhashApiKey($input: AddMoneyhashPaymentProviderInput!) {
  addMoneyhashPaymentProvider(input: $input) {
    id
    ...AddMoneyhashProviderDialog
    ...MoneyhashIntegrationDetails
  }
}
    ${AddMoneyhashProviderDialogFragmentDoc}
${MoneyhashIntegrationDetailsFragmentDoc}`;
export type AddMoneyhashApiKeyMutationFn = Apollo.MutationFunction<AddMoneyhashApiKeyMutation, AddMoneyhashApiKeyMutationVariables>;

/**
 * __useAddMoneyhashApiKeyMutation__
 *
 * To run a mutation, you first call `useAddMoneyhashApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddMoneyhashApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addMoneyhashApiKeyMutation, { data, loading, error }] = useAddMoneyhashApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddMoneyhashApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddMoneyhashApiKeyMutation, AddMoneyhashApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddMoneyhashApiKeyMutation, AddMoneyhashApiKeyMutationVariables>(AddMoneyhashApiKeyDocument, options);
      }
export type AddMoneyhashApiKeyMutationHookResult = ReturnType<typeof useAddMoneyhashApiKeyMutation>;
export type AddMoneyhashApiKeyMutationResult = Apollo.MutationResult<AddMoneyhashApiKeyMutation>;
export type AddMoneyhashApiKeyMutationOptions = Apollo.BaseMutationOptions<AddMoneyhashApiKeyMutation, AddMoneyhashApiKeyMutationVariables>;
export const UpdateMoneyhashApiKeyDocument = gql`
    mutation updateMoneyhashApiKey($input: UpdateMoneyhashPaymentProviderInput!) {
  updateMoneyhashPaymentProvider(input: $input) {
    id
    ...AddMoneyhashProviderDialog
    ...MoneyhashIntegrationDetails
  }
}
    ${AddMoneyhashProviderDialogFragmentDoc}
${MoneyhashIntegrationDetailsFragmentDoc}`;
export type UpdateMoneyhashApiKeyMutationFn = Apollo.MutationFunction<UpdateMoneyhashApiKeyMutation, UpdateMoneyhashApiKeyMutationVariables>;

/**
 * __useUpdateMoneyhashApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateMoneyhashApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMoneyhashApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMoneyhashApiKeyMutation, { data, loading, error }] = useUpdateMoneyhashApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMoneyhashApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMoneyhashApiKeyMutation, UpdateMoneyhashApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMoneyhashApiKeyMutation, UpdateMoneyhashApiKeyMutationVariables>(UpdateMoneyhashApiKeyDocument, options);
      }
export type UpdateMoneyhashApiKeyMutationHookResult = ReturnType<typeof useUpdateMoneyhashApiKeyMutation>;
export type UpdateMoneyhashApiKeyMutationResult = Apollo.MutationResult<UpdateMoneyhashApiKeyMutation>;
export type UpdateMoneyhashApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateMoneyhashApiKeyMutation, UpdateMoneyhashApiKeyMutationVariables>;
export const CreateNetsuiteIntegrationDocument = gql`
    mutation createNetsuiteIntegration($input: CreateNetsuiteIntegrationInput!) {
  createNetsuiteIntegration(input: $input) {
    ...NetsuiteForCreateDialogDialog
  }
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export type CreateNetsuiteIntegrationMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationMutation, { data, loading, error }] = useCreateNetsuiteIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>(CreateNetsuiteIntegrationDocument, options);
      }
export type CreateNetsuiteIntegrationMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationMutation>;
export type CreateNetsuiteIntegrationMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationMutation>;
export type CreateNetsuiteIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>;
export const UpdateNetsuiteIntegrationDocument = gql`
    mutation updateNetsuiteIntegration($input: UpdateNetsuiteIntegrationInput!) {
  updateNetsuiteIntegration(input: $input) {
    ...NetsuiteForCreateDialogDialog
  }
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export type UpdateNetsuiteIntegrationMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>(UpdateNetsuiteIntegrationDocument, options);
      }
export type UpdateNetsuiteIntegrationMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationMutation>;
export type UpdateNetsuiteIntegrationMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationMutation>;
export type UpdateNetsuiteIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>;
export const CreateSalesforceIntegrationDocument = gql`
    mutation createSalesforceIntegration($input: CreateSalesforceIntegrationInput!) {
  createSalesforceIntegration(input: $input) {
    ...SalesforceForCreateDialog
  }
}
    ${SalesforceForCreateDialogFragmentDoc}`;
export type CreateSalesforceIntegrationMutationFn = Apollo.MutationFunction<CreateSalesforceIntegrationMutation, CreateSalesforceIntegrationMutationVariables>;

/**
 * __useCreateSalesforceIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateSalesforceIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSalesforceIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSalesforceIntegrationMutation, { data, loading, error }] = useCreateSalesforceIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSalesforceIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateSalesforceIntegrationMutation, CreateSalesforceIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSalesforceIntegrationMutation, CreateSalesforceIntegrationMutationVariables>(CreateSalesforceIntegrationDocument, options);
      }
export type CreateSalesforceIntegrationMutationHookResult = ReturnType<typeof useCreateSalesforceIntegrationMutation>;
export type CreateSalesforceIntegrationMutationResult = Apollo.MutationResult<CreateSalesforceIntegrationMutation>;
export type CreateSalesforceIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateSalesforceIntegrationMutation, CreateSalesforceIntegrationMutationVariables>;
export const UpdateSalesforceIntegrationDocument = gql`
    mutation updateSalesforceIntegration($input: UpdateSalesforceIntegrationInput!) {
  updateSalesforceIntegration(input: $input) {
    ...SalesforceForCreateDialog
  }
}
    ${SalesforceForCreateDialogFragmentDoc}`;
export type UpdateSalesforceIntegrationMutationFn = Apollo.MutationFunction<UpdateSalesforceIntegrationMutation, UpdateSalesforceIntegrationMutationVariables>;

/**
 * __useUpdateSalesforceIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateSalesforceIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSalesforceIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSalesforceIntegrationMutation, { data, loading, error }] = useUpdateSalesforceIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSalesforceIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSalesforceIntegrationMutation, UpdateSalesforceIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSalesforceIntegrationMutation, UpdateSalesforceIntegrationMutationVariables>(UpdateSalesforceIntegrationDocument, options);
      }
export type UpdateSalesforceIntegrationMutationHookResult = ReturnType<typeof useUpdateSalesforceIntegrationMutation>;
export type UpdateSalesforceIntegrationMutationResult = Apollo.MutationResult<UpdateSalesforceIntegrationMutation>;
export type UpdateSalesforceIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateSalesforceIntegrationMutation, UpdateSalesforceIntegrationMutationVariables>;
export const GetProviderByCodeForStripeDocument = gql`
    query getProviderByCodeForStripe($code: String) {
  paymentProvider(code: $code) {
    ... on StripeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on FlutterwaveProvider {
      id
    }
    ... on CashfreeProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on MoneyhashProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForStripeQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForStripeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForStripeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForStripeQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForStripeQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
      }
export function useGetProviderByCodeForStripeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export function useGetProviderByCodeForStripeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export type GetProviderByCodeForStripeQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeQuery>;
export type GetProviderByCodeForStripeLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeLazyQuery>;
export type GetProviderByCodeForStripeSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeSuspenseQuery>;
export type GetProviderByCodeForStripeQueryResult = Apollo.QueryResult<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>;
export const AddStripeApiKeyDocument = gql`
    mutation addStripeApiKey($input: AddStripePaymentProviderInput!) {
  addStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type AddStripeApiKeyMutationFn = Apollo.MutationFunction<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;

/**
 * __useAddStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useAddStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addStripeApiKeyMutation, { data, loading, error }] = useAddStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>(AddStripeApiKeyDocument, options);
      }
export type AddStripeApiKeyMutationHookResult = ReturnType<typeof useAddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationResult = Apollo.MutationResult<AddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;
export const UpdateStripeApiKeyDocument = gql`
    mutation updateStripeApiKey($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type UpdateStripeApiKeyMutationFn = Apollo.MutationFunction<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;

/**
 * __useUpdateStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripeApiKeyMutation, { data, loading, error }] = useUpdateStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>(UpdateStripeApiKeyDocument, options);
      }
export type UpdateStripeApiKeyMutationHookResult = ReturnType<typeof useUpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationResult = Apollo.MutationResult<UpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;
export const CreateXeroIntegrationDocument = gql`
    mutation createXeroIntegration($input: CreateXeroIntegrationInput!) {
  createXeroIntegration(input: $input) {
    ...XeroForCreateDialogDialog
  }
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export type CreateXeroIntegrationMutationFn = Apollo.MutationFunction<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>;

/**
 * __useCreateXeroIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationMutation, { data, loading, error }] = useCreateXeroIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>(CreateXeroIntegrationDocument, options);
      }
export type CreateXeroIntegrationMutationHookResult = ReturnType<typeof useCreateXeroIntegrationMutation>;
export type CreateXeroIntegrationMutationResult = Apollo.MutationResult<CreateXeroIntegrationMutation>;
export type CreateXeroIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>;
export const UpdateXeroIntegrationDocument = gql`
    mutation updateXeroIntegration($input: UpdateXeroIntegrationInput!) {
  updateXeroIntegration(input: $input) {
    ...XeroForCreateDialogDialog
  }
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export type UpdateXeroIntegrationMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>;

/**
 * __useUpdateXeroIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationMutation, { data, loading, error }] = useUpdateXeroIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>(UpdateXeroIntegrationDocument, options);
      }
export type UpdateXeroIntegrationMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationMutation>;
export type UpdateXeroIntegrationMutationResult = Apollo.MutationResult<UpdateXeroIntegrationMutation>;
export type UpdateXeroIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>;
export const GetAnrokIntegrationCollectionMappingsDocument = gql`
    query getAnrokIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...AnrokIntegrationItemsListDefault
    }
  }
}
    ${AnrokIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetAnrokIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAnrokIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables> & ({ variables: GetAnrokIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
      }
export function useGetAnrokIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
        }
export function useGetAnrokIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
        }
export type GetAnrokIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsQuery>;
export type GetAnrokIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsLazyQuery>;
export type GetAnrokIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsSuspenseQuery>;
export type GetAnrokIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForAnrokItemsListDocument = gql`
    query getAddOnsForAnrokItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AnrokIntegrationItemsListAddons
    }
  }
}
    ${AnrokIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForAnrokItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForAnrokItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForAnrokItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForAnrokItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForAnrokItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables> & ({ variables: GetAddOnsForAnrokItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
      }
export function useGetAddOnsForAnrokItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
        }
export function useGetAddOnsForAnrokItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
        }
export type GetAddOnsForAnrokItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListQuery>;
export type GetAddOnsForAnrokItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListLazyQuery>;
export type GetAddOnsForAnrokItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListSuspenseQuery>;
export type GetAddOnsForAnrokItemsListQueryResult = Apollo.QueryResult<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>;
export const GetBillableMetricsForAnrokItemsListDocument = gql`
    query getBillableMetricsForAnrokItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AnrokIntegrationItemsListBillableMetrics
    }
  }
}
    ${AnrokIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForAnrokItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForAnrokItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForAnrokItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForAnrokItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForAnrokItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables> & ({ variables: GetBillableMetricsForAnrokItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
      }
export function useGetBillableMetricsForAnrokItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
        }
export function useGetBillableMetricsForAnrokItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
        }
export type GetBillableMetricsForAnrokItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListQuery>;
export type GetBillableMetricsForAnrokItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListLazyQuery>;
export type GetBillableMetricsForAnrokItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListSuspenseQuery>;
export type GetBillableMetricsForAnrokItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>;
export const CreateAnrokIntegrationCollectionMappingDocument = gql`
    mutation createAnrokIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...AnrokIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${AnrokIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>(CreateAnrokIntegrationCollectionMappingDocument, options);
      }
export type CreateAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationCollectionMappingMutation>;
export type CreateAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateAnrokIntegrationCollectionMappingMutation>;
export type CreateAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>;
export const CreateAnrokIntegrationMappingDocument = gql`
    mutation createAnrokIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...AnrokIntegrationMapItemDialogCollectionItem
  }
}
    ${AnrokIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>;

/**
 * __useCreateAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationMappingMutation, { data, loading, error }] = useCreateAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>(CreateAnrokIntegrationMappingDocument, options);
      }
export type CreateAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationMappingMutation>;
export type CreateAnrokIntegrationMappingMutationResult = Apollo.MutationResult<CreateAnrokIntegrationMappingMutation>;
export type CreateAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>;
export const UpdateAnrokIntegrationCollectionMappingDocument = gql`
    mutation updateAnrokIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>(UpdateAnrokIntegrationCollectionMappingDocument, options);
      }
export type UpdateAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationCollectionMappingMutation>;
export type UpdateAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationCollectionMappingMutation>;
export type UpdateAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>;
export const UpdateAnrokIntegrationMappingDocument = gql`
    mutation updateAnrokIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>;

/**
 * __useUpdateAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationMappingMutation, { data, loading, error }] = useUpdateAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>(UpdateAnrokIntegrationMappingDocument, options);
      }
export type UpdateAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationMappingMutation>;
export type UpdateAnrokIntegrationMappingMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationMappingMutation>;
export type UpdateAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>;
export const DeleteAnrokIntegrationCollectionMappingDocument = gql`
    mutation deleteAnrokIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>(DeleteAnrokIntegrationCollectionMappingDocument, options);
      }
export type DeleteAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteAnrokIntegrationCollectionMappingMutation>;
export type DeleteAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteAnrokIntegrationCollectionMappingMutation>;
export type DeleteAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>;
export const DeleteAnrokIntegrationMappingDocument = gql`
    mutation deleteAnrokIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>;

/**
 * __useDeleteAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnrokIntegrationMappingMutation, { data, loading, error }] = useDeleteAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>(DeleteAnrokIntegrationMappingDocument, options);
      }
export type DeleteAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteAnrokIntegrationMappingMutation>;
export type DeleteAnrokIntegrationMappingMutationResult = Apollo.MutationResult<DeleteAnrokIntegrationMappingMutation>;
export type DeleteAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>;
export const GetAnrokIntegrationsSettingsDocument = gql`
    query getAnrokIntegrationsSettings($id: ID!, $limit: Int) {
  integration(id: $id) {
    ... on AnrokIntegration {
      id
      ...AnrokIntegrationSettings
      ...DeleteAnrokIntegrationDialog
      ...AddAnrokIntegrationDialog
    }
  }
  integrations(limit: $limit) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    ${AnrokIntegrationSettingsFragmentDoc}
${DeleteAnrokIntegrationDialogFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAnrokIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables> & ({ variables: GetAnrokIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
      }
export function useGetAnrokIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
        }
export function useGetAnrokIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
        }
export type GetAnrokIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsQuery>;
export type GetAnrokIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsLazyQuery>;
export type GetAnrokIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsSuspenseQuery>;
export type GetAnrokIntegrationsSettingsQueryResult = Apollo.QueryResult<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>;
export const RetryAllInvoicesDocument = gql`
    mutation retryAllInvoices($input: RetryAllInvoicesInput!) {
  retryAllInvoices(input: $input) {
    metadata {
      totalCount
    }
  }
}
    `;
export type RetryAllInvoicesMutationFn = Apollo.MutationFunction<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>;

/**
 * __useRetryAllInvoicesMutation__
 *
 * To run a mutation, you first call `useRetryAllInvoicesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllInvoicesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllInvoicesMutation, { data, loading, error }] = useRetryAllInvoicesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllInvoicesMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>(RetryAllInvoicesDocument, options);
      }
export type RetryAllInvoicesMutationHookResult = ReturnType<typeof useRetryAllInvoicesMutation>;
export type RetryAllInvoicesMutationResult = Apollo.MutationResult<RetryAllInvoicesMutation>;
export type RetryAllInvoicesMutationOptions = Apollo.BaseMutationOptions<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>;
export const GetAvalaraIntegrationCollectionMappingsDocument = gql`
    query getAvalaraIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...AvalaraIntegrationItemsListDefault
    }
  }
}
    ${AvalaraIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetAvalaraIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetAvalaraIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvalaraIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvalaraIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAvalaraIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables> & ({ variables: GetAvalaraIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>(GetAvalaraIntegrationCollectionMappingsDocument, options);
      }
export function useGetAvalaraIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>(GetAvalaraIntegrationCollectionMappingsDocument, options);
        }
export function useGetAvalaraIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>(GetAvalaraIntegrationCollectionMappingsDocument, options);
        }
export type GetAvalaraIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationCollectionMappingsQuery>;
export type GetAvalaraIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationCollectionMappingsLazyQuery>;
export type GetAvalaraIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationCollectionMappingsSuspenseQuery>;
export type GetAvalaraIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetAvalaraIntegrationCollectionMappingsQuery, GetAvalaraIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForAvalaraItemsListDocument = gql`
    query getAddOnsForAvalaraItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AvalaraIntegrationItemsListAddons
    }
  }
}
    ${AvalaraIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForAvalaraItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForAvalaraItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForAvalaraItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForAvalaraItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForAvalaraItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables> & ({ variables: GetAddOnsForAvalaraItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>(GetAddOnsForAvalaraItemsListDocument, options);
      }
export function useGetAddOnsForAvalaraItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>(GetAddOnsForAvalaraItemsListDocument, options);
        }
export function useGetAddOnsForAvalaraItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>(GetAddOnsForAvalaraItemsListDocument, options);
        }
export type GetAddOnsForAvalaraItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForAvalaraItemsListQuery>;
export type GetAddOnsForAvalaraItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForAvalaraItemsListLazyQuery>;
export type GetAddOnsForAvalaraItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForAvalaraItemsListSuspenseQuery>;
export type GetAddOnsForAvalaraItemsListQueryResult = Apollo.QueryResult<GetAddOnsForAvalaraItemsListQuery, GetAddOnsForAvalaraItemsListQueryVariables>;
export const GetBillableMetricsForAvalaraItemsListDocument = gql`
    query getBillableMetricsForAvalaraItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AvalaraIntegrationItemsListBillableMetrics
    }
  }
}
    ${AvalaraIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForAvalaraItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForAvalaraItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForAvalaraItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForAvalaraItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForAvalaraItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables> & ({ variables: GetBillableMetricsForAvalaraItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>(GetBillableMetricsForAvalaraItemsListDocument, options);
      }
export function useGetBillableMetricsForAvalaraItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>(GetBillableMetricsForAvalaraItemsListDocument, options);
        }
export function useGetBillableMetricsForAvalaraItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>(GetBillableMetricsForAvalaraItemsListDocument, options);
        }
export type GetBillableMetricsForAvalaraItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForAvalaraItemsListQuery>;
export type GetBillableMetricsForAvalaraItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForAvalaraItemsListLazyQuery>;
export type GetBillableMetricsForAvalaraItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForAvalaraItemsListSuspenseQuery>;
export type GetBillableMetricsForAvalaraItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForAvalaraItemsListQuery, GetBillableMetricsForAvalaraItemsListQueryVariables>;
export const CreateAvalaraIntegrationCollectionMappingDocument = gql`
    mutation createAvalaraIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...AvalaraIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${AvalaraIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateAvalaraIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateAvalaraIntegrationCollectionMappingMutation, CreateAvalaraIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateAvalaraIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateAvalaraIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAvalaraIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAvalaraIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateAvalaraIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAvalaraIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAvalaraIntegrationCollectionMappingMutation, CreateAvalaraIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAvalaraIntegrationCollectionMappingMutation, CreateAvalaraIntegrationCollectionMappingMutationVariables>(CreateAvalaraIntegrationCollectionMappingDocument, options);
      }
export type CreateAvalaraIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateAvalaraIntegrationCollectionMappingMutation>;
export type CreateAvalaraIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateAvalaraIntegrationCollectionMappingMutation>;
export type CreateAvalaraIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateAvalaraIntegrationCollectionMappingMutation, CreateAvalaraIntegrationCollectionMappingMutationVariables>;
export const CreateAvalaraIntegrationMappingDocument = gql`
    mutation createAvalaraIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...AvalaraIntegrationMapItemDialogCollectionItem
  }
}
    ${AvalaraIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateAvalaraIntegrationMappingMutationFn = Apollo.MutationFunction<CreateAvalaraIntegrationMappingMutation, CreateAvalaraIntegrationMappingMutationVariables>;

/**
 * __useCreateAvalaraIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateAvalaraIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAvalaraIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAvalaraIntegrationMappingMutation, { data, loading, error }] = useCreateAvalaraIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAvalaraIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAvalaraIntegrationMappingMutation, CreateAvalaraIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAvalaraIntegrationMappingMutation, CreateAvalaraIntegrationMappingMutationVariables>(CreateAvalaraIntegrationMappingDocument, options);
      }
export type CreateAvalaraIntegrationMappingMutationHookResult = ReturnType<typeof useCreateAvalaraIntegrationMappingMutation>;
export type CreateAvalaraIntegrationMappingMutationResult = Apollo.MutationResult<CreateAvalaraIntegrationMappingMutation>;
export type CreateAvalaraIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateAvalaraIntegrationMappingMutation, CreateAvalaraIntegrationMappingMutationVariables>;
export const UpdateAvalaraIntegrationCollectionMappingDocument = gql`
    mutation updateAvalaraIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAvalaraIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateAvalaraIntegrationCollectionMappingMutation, UpdateAvalaraIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateAvalaraIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAvalaraIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvalaraIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvalaraIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateAvalaraIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAvalaraIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvalaraIntegrationCollectionMappingMutation, UpdateAvalaraIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvalaraIntegrationCollectionMappingMutation, UpdateAvalaraIntegrationCollectionMappingMutationVariables>(UpdateAvalaraIntegrationCollectionMappingDocument, options);
      }
export type UpdateAvalaraIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateAvalaraIntegrationCollectionMappingMutation>;
export type UpdateAvalaraIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateAvalaraIntegrationCollectionMappingMutation>;
export type UpdateAvalaraIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAvalaraIntegrationCollectionMappingMutation, UpdateAvalaraIntegrationCollectionMappingMutationVariables>;
export const UpdateAvalaraIntegrationMappingDocument = gql`
    mutation updateAvalaraIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAvalaraIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateAvalaraIntegrationMappingMutation, UpdateAvalaraIntegrationMappingMutationVariables>;

/**
 * __useUpdateAvalaraIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAvalaraIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvalaraIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvalaraIntegrationMappingMutation, { data, loading, error }] = useUpdateAvalaraIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAvalaraIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvalaraIntegrationMappingMutation, UpdateAvalaraIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvalaraIntegrationMappingMutation, UpdateAvalaraIntegrationMappingMutationVariables>(UpdateAvalaraIntegrationMappingDocument, options);
      }
export type UpdateAvalaraIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateAvalaraIntegrationMappingMutation>;
export type UpdateAvalaraIntegrationMappingMutationResult = Apollo.MutationResult<UpdateAvalaraIntegrationMappingMutation>;
export type UpdateAvalaraIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAvalaraIntegrationMappingMutation, UpdateAvalaraIntegrationMappingMutationVariables>;
export const DeleteAvalaraIntegrationCollectionMappingDocument = gql`
    mutation deleteAvalaraIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAvalaraIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteAvalaraIntegrationCollectionMappingMutation, DeleteAvalaraIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteAvalaraIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAvalaraIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAvalaraIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAvalaraIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteAvalaraIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAvalaraIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAvalaraIntegrationCollectionMappingMutation, DeleteAvalaraIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAvalaraIntegrationCollectionMappingMutation, DeleteAvalaraIntegrationCollectionMappingMutationVariables>(DeleteAvalaraIntegrationCollectionMappingDocument, options);
      }
export type DeleteAvalaraIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteAvalaraIntegrationCollectionMappingMutation>;
export type DeleteAvalaraIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteAvalaraIntegrationCollectionMappingMutation>;
export type DeleteAvalaraIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAvalaraIntegrationCollectionMappingMutation, DeleteAvalaraIntegrationCollectionMappingMutationVariables>;
export const DeleteAvalaraIntegrationMappingDocument = gql`
    mutation deleteAvalaraIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAvalaraIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteAvalaraIntegrationMappingMutation, DeleteAvalaraIntegrationMappingMutationVariables>;

/**
 * __useDeleteAvalaraIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAvalaraIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAvalaraIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAvalaraIntegrationMappingMutation, { data, loading, error }] = useDeleteAvalaraIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAvalaraIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAvalaraIntegrationMappingMutation, DeleteAvalaraIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAvalaraIntegrationMappingMutation, DeleteAvalaraIntegrationMappingMutationVariables>(DeleteAvalaraIntegrationMappingDocument, options);
      }
export type DeleteAvalaraIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteAvalaraIntegrationMappingMutation>;
export type DeleteAvalaraIntegrationMappingMutationResult = Apollo.MutationResult<DeleteAvalaraIntegrationMappingMutation>;
export type DeleteAvalaraIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAvalaraIntegrationMappingMutation, DeleteAvalaraIntegrationMappingMutationVariables>;
export const GetAvalaraIntegrationSettingsDocument = gql`
    query getAvalaraIntegrationSettings($id: ID!, $limit: Int) {
  integration(id: $id) {
    ... on AvalaraIntegration {
      id
      ...AvalaraIntegrationSettings
      ...DeleteAvalaraIntegrationDialog
      ...AddAvalaraIntegrationDialog
    }
  }
  integrations(limit: $limit) {
    collection {
      ... on AvalaraIntegration {
        id
      }
    }
  }
}
    ${AvalaraIntegrationSettingsFragmentDoc}
${DeleteAvalaraIntegrationDialogFragmentDoc}
${AddAvalaraIntegrationDialogFragmentDoc}`;

/**
 * __useGetAvalaraIntegrationSettingsQuery__
 *
 * To run a query within a React component, call `useGetAvalaraIntegrationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvalaraIntegrationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvalaraIntegrationSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAvalaraIntegrationSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables> & ({ variables: GetAvalaraIntegrationSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>(GetAvalaraIntegrationSettingsDocument, options);
      }
export function useGetAvalaraIntegrationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>(GetAvalaraIntegrationSettingsDocument, options);
        }
export function useGetAvalaraIntegrationSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>(GetAvalaraIntegrationSettingsDocument, options);
        }
export type GetAvalaraIntegrationSettingsQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationSettingsQuery>;
export type GetAvalaraIntegrationSettingsLazyQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationSettingsLazyQuery>;
export type GetAvalaraIntegrationSettingsSuspenseQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationSettingsSuspenseQuery>;
export type GetAvalaraIntegrationSettingsQueryResult = Apollo.QueryResult<GetAvalaraIntegrationSettingsQuery, GetAvalaraIntegrationSettingsQueryVariables>;
export const RetryAllAvalaraInvoicesDocument = gql`
    mutation retryAllAvalaraInvoices($input: RetryAllInvoicesInput!) {
  retryAllInvoices(input: $input) {
    metadata {
      totalCount
    }
  }
}
    `;
export type RetryAllAvalaraInvoicesMutationFn = Apollo.MutationFunction<RetryAllAvalaraInvoicesMutation, RetryAllAvalaraInvoicesMutationVariables>;

/**
 * __useRetryAllAvalaraInvoicesMutation__
 *
 * To run a mutation, you first call `useRetryAllAvalaraInvoicesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllAvalaraInvoicesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllAvalaraInvoicesMutation, { data, loading, error }] = useRetryAllAvalaraInvoicesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllAvalaraInvoicesMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllAvalaraInvoicesMutation, RetryAllAvalaraInvoicesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllAvalaraInvoicesMutation, RetryAllAvalaraInvoicesMutationVariables>(RetryAllAvalaraInvoicesDocument, options);
      }
export type RetryAllAvalaraInvoicesMutationHookResult = ReturnType<typeof useRetryAllAvalaraInvoicesMutation>;
export type RetryAllAvalaraInvoicesMutationResult = Apollo.MutationResult<RetryAllAvalaraInvoicesMutation>;
export type RetryAllAvalaraInvoicesMutationOptions = Apollo.BaseMutationOptions<RetryAllAvalaraInvoicesMutation, RetryAllAvalaraInvoicesMutationVariables>;
export const DeleteAdyenIntegrationDocument = gql`
    mutation deleteAdyenIntegration($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteAdyenIntegrationMutationFn = Apollo.MutationFunction<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;

/**
 * __useDeleteAdyenIntegrationMutation__
 *
 * To run a mutation, you first call `useDeleteAdyenIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAdyenIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAdyenIntegrationMutation, { data, loading, error }] = useDeleteAdyenIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAdyenIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>(DeleteAdyenIntegrationDocument, options);
      }
export type DeleteAdyenIntegrationMutationHookResult = ReturnType<typeof useDeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationResult = Apollo.MutationResult<DeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationOptions = Apollo.BaseMutationOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;
export const DestroyNangoIntegrationDocument = gql`
    mutation destroyNangoIntegration($input: DestroyIntegrationInput!) {
  destroyIntegration(input: $input) {
    id
  }
}
    `;
export type DestroyNangoIntegrationMutationFn = Apollo.MutationFunction<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>;

/**
 * __useDestroyNangoIntegrationMutation__
 *
 * To run a mutation, you first call `useDestroyNangoIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyNangoIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyNangoIntegrationMutation, { data, loading, error }] = useDestroyNangoIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyNangoIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>(DestroyNangoIntegrationDocument, options);
      }
export type DestroyNangoIntegrationMutationHookResult = ReturnType<typeof useDestroyNangoIntegrationMutation>;
export type DestroyNangoIntegrationMutationResult = Apollo.MutationResult<DestroyNangoIntegrationMutation>;
export type DestroyNangoIntegrationMutationOptions = Apollo.BaseMutationOptions<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>;
export const DestroyAvalaraIntegrationDocument = gql`
    mutation destroyAvalaraIntegration($input: DestroyIntegrationInput!) {
  destroyIntegration(input: $input) {
    id
  }
}
    `;
export type DestroyAvalaraIntegrationMutationFn = Apollo.MutationFunction<DestroyAvalaraIntegrationMutation, DestroyAvalaraIntegrationMutationVariables>;

/**
 * __useDestroyAvalaraIntegrationMutation__
 *
 * To run a mutation, you first call `useDestroyAvalaraIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyAvalaraIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyAvalaraIntegrationMutation, { data, loading, error }] = useDestroyAvalaraIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyAvalaraIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DestroyAvalaraIntegrationMutation, DestroyAvalaraIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyAvalaraIntegrationMutation, DestroyAvalaraIntegrationMutationVariables>(DestroyAvalaraIntegrationDocument, options);
      }
export type DestroyAvalaraIntegrationMutationHookResult = ReturnType<typeof useDestroyAvalaraIntegrationMutation>;
export type DestroyAvalaraIntegrationMutationResult = Apollo.MutationResult<DestroyAvalaraIntegrationMutation>;
export type DestroyAvalaraIntegrationMutationOptions = Apollo.BaseMutationOptions<DestroyAvalaraIntegrationMutation, DestroyAvalaraIntegrationMutationVariables>;
export const DeleteCashfreeDocument = gql`
    mutation deleteCashfree($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteCashfreeMutationFn = Apollo.MutationFunction<DeleteCashfreeMutation, DeleteCashfreeMutationVariables>;

/**
 * __useDeleteCashfreeMutation__
 *
 * To run a mutation, you first call `useDeleteCashfreeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCashfreeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCashfreeMutation, { data, loading, error }] = useDeleteCashfreeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCashfreeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCashfreeMutation, DeleteCashfreeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCashfreeMutation, DeleteCashfreeMutationVariables>(DeleteCashfreeDocument, options);
      }
export type DeleteCashfreeMutationHookResult = ReturnType<typeof useDeleteCashfreeMutation>;
export type DeleteCashfreeMutationResult = Apollo.MutationResult<DeleteCashfreeMutation>;
export type DeleteCashfreeMutationOptions = Apollo.BaseMutationOptions<DeleteCashfreeMutation, DeleteCashfreeMutationVariables>;
export const DeleteFlutterwaveIntegrationDocument = gql`
    mutation deleteFlutterwaveIntegration($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteFlutterwaveIntegrationMutationFn = Apollo.MutationFunction<DeleteFlutterwaveIntegrationMutation, DeleteFlutterwaveIntegrationMutationVariables>;

/**
 * __useDeleteFlutterwaveIntegrationMutation__
 *
 * To run a mutation, you first call `useDeleteFlutterwaveIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteFlutterwaveIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteFlutterwaveIntegrationMutation, { data, loading, error }] = useDeleteFlutterwaveIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteFlutterwaveIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteFlutterwaveIntegrationMutation, DeleteFlutterwaveIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteFlutterwaveIntegrationMutation, DeleteFlutterwaveIntegrationMutationVariables>(DeleteFlutterwaveIntegrationDocument, options);
      }
export type DeleteFlutterwaveIntegrationMutationHookResult = ReturnType<typeof useDeleteFlutterwaveIntegrationMutation>;
export type DeleteFlutterwaveIntegrationMutationResult = Apollo.MutationResult<DeleteFlutterwaveIntegrationMutation>;
export type DeleteFlutterwaveIntegrationMutationOptions = Apollo.BaseMutationOptions<DeleteFlutterwaveIntegrationMutation, DeleteFlutterwaveIntegrationMutationVariables>;
export const DeleteGocardlessDocument = gql`
    mutation deleteGocardless($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteGocardlessMutationFn = Apollo.MutationFunction<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;

/**
 * __useDeleteGocardlessMutation__
 *
 * To run a mutation, you first call `useDeleteGocardlessMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGocardlessMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGocardlessMutation, { data, loading, error }] = useDeleteGocardlessMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteGocardlessMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>(DeleteGocardlessDocument, options);
      }
export type DeleteGocardlessMutationHookResult = ReturnType<typeof useDeleteGocardlessMutation>;
export type DeleteGocardlessMutationResult = Apollo.MutationResult<DeleteGocardlessMutation>;
export type DeleteGocardlessMutationOptions = Apollo.BaseMutationOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;
export const DeleteMoneyhashIntegrationDocument = gql`
    mutation deleteMoneyhashIntegration($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteMoneyhashIntegrationMutationFn = Apollo.MutationFunction<DeleteMoneyhashIntegrationMutation, DeleteMoneyhashIntegrationMutationVariables>;

/**
 * __useDeleteMoneyhashIntegrationMutation__
 *
 * To run a mutation, you first call `useDeleteMoneyhashIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMoneyhashIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMoneyhashIntegrationMutation, { data, loading, error }] = useDeleteMoneyhashIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteMoneyhashIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMoneyhashIntegrationMutation, DeleteMoneyhashIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteMoneyhashIntegrationMutation, DeleteMoneyhashIntegrationMutationVariables>(DeleteMoneyhashIntegrationDocument, options);
      }
export type DeleteMoneyhashIntegrationMutationHookResult = ReturnType<typeof useDeleteMoneyhashIntegrationMutation>;
export type DeleteMoneyhashIntegrationMutationResult = Apollo.MutationResult<DeleteMoneyhashIntegrationMutation>;
export type DeleteMoneyhashIntegrationMutationOptions = Apollo.BaseMutationOptions<DeleteMoneyhashIntegrationMutation, DeleteMoneyhashIntegrationMutationVariables>;
export const DeleteStripeDocument = gql`
    mutation deleteStripe($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteStripeMutationFn = Apollo.MutationFunction<DeleteStripeMutation, DeleteStripeMutationVariables>;

/**
 * __useDeleteStripeMutation__
 *
 * To run a mutation, you first call `useDeleteStripeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStripeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStripeMutation, { data, loading, error }] = useDeleteStripeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteStripeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStripeMutation, DeleteStripeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStripeMutation, DeleteStripeMutationVariables>(DeleteStripeDocument, options);
      }
export type DeleteStripeMutationHookResult = ReturnType<typeof useDeleteStripeMutation>;
export type DeleteStripeMutationResult = Apollo.MutationResult<DeleteStripeMutation>;
export type DeleteStripeMutationOptions = Apollo.BaseMutationOptions<DeleteStripeMutation, DeleteStripeMutationVariables>;
export const GetNetsuiteIntegrationCollectionMappingsDocument = gql`
    query getNetsuiteIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...NetsuiteIntegrationItemsListDefault
    }
  }
}
    ${NetsuiteIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables> & ({ variables: GetNetsuiteIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
      }
export function useGetNetsuiteIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
        }
export function useGetNetsuiteIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
        }
export type GetNetsuiteIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsQuery>;
export type GetNetsuiteIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsLazyQuery>;
export type GetNetsuiteIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsSuspenseQuery>;
export type GetNetsuiteIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForNetsuiteItemsListDocument = gql`
    query getAddOnsForNetsuiteItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...NetsuiteIntegrationItemsListAddons
    }
  }
}
    ${NetsuiteIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForNetsuiteItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForNetsuiteItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForNetsuiteItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForNetsuiteItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForNetsuiteItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables> & ({ variables: GetAddOnsForNetsuiteItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
      }
export function useGetAddOnsForNetsuiteItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
        }
export function useGetAddOnsForNetsuiteItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
        }
export type GetAddOnsForNetsuiteItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListQuery>;
export type GetAddOnsForNetsuiteItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListLazyQuery>;
export type GetAddOnsForNetsuiteItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListSuspenseQuery>;
export type GetAddOnsForNetsuiteItemsListQueryResult = Apollo.QueryResult<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>;
export const GetBillableMetricsForNetsuiteItemsListDocument = gql`
    query getBillableMetricsForNetsuiteItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...NetsuiteIntegrationItemsListBillableMetrics
    }
  }
}
    ${NetsuiteIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForNetsuiteItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForNetsuiteItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForNetsuiteItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForNetsuiteItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForNetsuiteItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables> & ({ variables: GetBillableMetricsForNetsuiteItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
      }
export function useGetBillableMetricsForNetsuiteItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
        }
export function useGetBillableMetricsForNetsuiteItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
        }
export type GetBillableMetricsForNetsuiteItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListQuery>;
export type GetBillableMetricsForNetsuiteItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListLazyQuery>;
export type GetBillableMetricsForNetsuiteItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListSuspenseQuery>;
export type GetBillableMetricsForNetsuiteItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>;
export const CreateNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation createNetsuiteIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...NetsuiteIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${NetsuiteIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>(CreateNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type CreateNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationCollectionMappingMutation>;
export type CreateNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationCollectionMappingMutation>;
export type CreateNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>;
export const CreateNetsuiteIntegrationMappingDocument = gql`
    mutation createNetsuiteIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...NetsuiteIntegrationMapItemDialogCollectionItem
  }
}
    ${NetsuiteIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationMappingMutation, { data, loading, error }] = useCreateNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>(CreateNetsuiteIntegrationMappingDocument, options);
      }
export type CreateNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationMappingMutation>;
export type CreateNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationMappingMutation>;
export type CreateNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>;
export const UpdateNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation updateNetsuiteIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>(UpdateNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type UpdateNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationCollectionMappingMutation>;
export type UpdateNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationCollectionMappingMutation>;
export type UpdateNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>;
export const UpdateNetsuiteIntegrationMappingDocument = gql`
    mutation updateNetsuiteIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationMappingMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>(UpdateNetsuiteIntegrationMappingDocument, options);
      }
export type UpdateNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationMappingMutation>;
export type UpdateNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationMappingMutation>;
export type UpdateNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>;
export const DeleteNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation deleteNetsuiteIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>(DeleteNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type DeleteNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteNetsuiteIntegrationCollectionMappingMutation>;
export type DeleteNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteNetsuiteIntegrationCollectionMappingMutation>;
export type DeleteNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>;
export const DeleteNetsuiteIntegrationMappingDocument = gql`
    mutation deleteNetsuiteIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useDeleteNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNetsuiteIntegrationMappingMutation, { data, loading, error }] = useDeleteNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>(DeleteNetsuiteIntegrationMappingDocument, options);
      }
export type DeleteNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteNetsuiteIntegrationMappingMutation>;
export type DeleteNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<DeleteNetsuiteIntegrationMappingMutation>;
export type DeleteNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>;
export const GetNetsuiteIntegrationsSettingsDocument = gql`
    query getNetsuiteIntegrationsSettings($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on NetsuiteIntegration {
      id
      ...NetsuiteIntegrationSettings
      ...DeleteNetsuiteIntegrationDialog
      ...NetsuiteForCreateDialogDialog
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on NetsuiteIntegration {
        id
      }
    }
  }
}
    ${NetsuiteIntegrationSettingsFragmentDoc}
${DeleteNetsuiteIntegrationDialogFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables> & ({ variables: GetNetsuiteIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
      }
export function useGetNetsuiteIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
        }
export function useGetNetsuiteIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
        }
export type GetNetsuiteIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsQuery>;
export type GetNetsuiteIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsLazyQuery>;
export type GetNetsuiteIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsSuspenseQuery>;
export type GetNetsuiteIntegrationsSettingsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>;
export const GetXeroIntegrationCollectionMappingsDocument = gql`
    query getXeroIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...XeroIntegrationItemsListDefault
    }
  }
}
    ${XeroIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetXeroIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetXeroIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables> & ({ variables: GetXeroIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
      }
export function useGetXeroIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
        }
export function useGetXeroIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
        }
export type GetXeroIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsQuery>;
export type GetXeroIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsLazyQuery>;
export type GetXeroIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsSuspenseQuery>;
export type GetXeroIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForXeroItemsListDocument = gql`
    query getAddOnsForXeroItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...XeroIntegrationItemsListAddons
    }
  }
}
    ${XeroIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForXeroItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForXeroItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForXeroItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForXeroItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForXeroItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables> & ({ variables: GetAddOnsForXeroItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
      }
export function useGetAddOnsForXeroItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
        }
export function useGetAddOnsForXeroItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
        }
export type GetAddOnsForXeroItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListQuery>;
export type GetAddOnsForXeroItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListLazyQuery>;
export type GetAddOnsForXeroItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListSuspenseQuery>;
export type GetAddOnsForXeroItemsListQueryResult = Apollo.QueryResult<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>;
export const GetBillableMetricsForXeroItemsListDocument = gql`
    query getBillableMetricsForXeroItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...XeroIntegrationItemsListBillableMetrics
    }
  }
}
    ${XeroIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForXeroItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForXeroItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForXeroItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForXeroItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForXeroItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables> & ({ variables: GetBillableMetricsForXeroItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
      }
export function useGetBillableMetricsForXeroItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
        }
export function useGetBillableMetricsForXeroItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
        }
export type GetBillableMetricsForXeroItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListQuery>;
export type GetBillableMetricsForXeroItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListLazyQuery>;
export type GetBillableMetricsForXeroItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListSuspenseQuery>;
export type GetBillableMetricsForXeroItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>;
export const GetXeroIntegrationItemsDocument = gql`
    query getXeroIntegrationItems($integrationId: ID!, $itemType: IntegrationItemTypeEnum, $page: Int, $limit: Int, $searchTerm: String) {
  integrationItems(
    integrationId: $integrationId
    itemType: $itemType
    page: $page
    limit: $limit
    searchTerm: $searchTerm
  ) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
    metadata {
      currentPage
      totalPages
      totalCount
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationItemsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationItemsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *      itemType: // value for 'itemType'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetXeroIntegrationItemsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables> & ({ variables: GetXeroIntegrationItemsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
      }
export function useGetXeroIntegrationItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
        }
export function useGetXeroIntegrationItemsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
        }
export type GetXeroIntegrationItemsQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsQuery>;
export type GetXeroIntegrationItemsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsLazyQuery>;
export type GetXeroIntegrationItemsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsSuspenseQuery>;
export type GetXeroIntegrationItemsQueryResult = Apollo.QueryResult<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>;
export const TriggerXeroIntegrationAccountsRefetchDocument = gql`
    mutation triggerXeroIntegrationAccountsRefetch($input: FetchIntegrationAccountsInput!) {
  fetchIntegrationAccounts(input: $input) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;
export type TriggerXeroIntegrationAccountsRefetchMutationFn = Apollo.MutationFunction<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>;

/**
 * __useTriggerXeroIntegrationAccountsRefetchMutation__
 *
 * To run a mutation, you first call `useTriggerXeroIntegrationAccountsRefetchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerXeroIntegrationAccountsRefetchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerXeroIntegrationAccountsRefetchMutation, { data, loading, error }] = useTriggerXeroIntegrationAccountsRefetchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTriggerXeroIntegrationAccountsRefetchMutation(baseOptions?: Apollo.MutationHookOptions<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>(TriggerXeroIntegrationAccountsRefetchDocument, options);
      }
export type TriggerXeroIntegrationAccountsRefetchMutationHookResult = ReturnType<typeof useTriggerXeroIntegrationAccountsRefetchMutation>;
export type TriggerXeroIntegrationAccountsRefetchMutationResult = Apollo.MutationResult<TriggerXeroIntegrationAccountsRefetchMutation>;
export type TriggerXeroIntegrationAccountsRefetchMutationOptions = Apollo.BaseMutationOptions<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>;
export const TriggerXeroIntegrationItemsRefetchDocument = gql`
    mutation triggerXeroIntegrationItemsRefetch($input: FetchIntegrationItemsInput!) {
  fetchIntegrationItems(input: $input) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;
export type TriggerXeroIntegrationItemsRefetchMutationFn = Apollo.MutationFunction<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>;

/**
 * __useTriggerXeroIntegrationItemsRefetchMutation__
 *
 * To run a mutation, you first call `useTriggerXeroIntegrationItemsRefetchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerXeroIntegrationItemsRefetchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerXeroIntegrationItemsRefetchMutation, { data, loading, error }] = useTriggerXeroIntegrationItemsRefetchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTriggerXeroIntegrationItemsRefetchMutation(baseOptions?: Apollo.MutationHookOptions<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>(TriggerXeroIntegrationItemsRefetchDocument, options);
      }
export type TriggerXeroIntegrationItemsRefetchMutationHookResult = ReturnType<typeof useTriggerXeroIntegrationItemsRefetchMutation>;
export type TriggerXeroIntegrationItemsRefetchMutationResult = Apollo.MutationResult<TriggerXeroIntegrationItemsRefetchMutation>;
export type TriggerXeroIntegrationItemsRefetchMutationOptions = Apollo.BaseMutationOptions<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>;
export const CreateXeroIntegrationCollectionMappingDocument = gql`
    mutation createXeroIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...XeroIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${XeroIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>(CreateXeroIntegrationCollectionMappingDocument, options);
      }
export type CreateXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateXeroIntegrationCollectionMappingMutation>;
export type CreateXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateXeroIntegrationCollectionMappingMutation>;
export type CreateXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>;
export const CreateXeroIntegrationMappingDocument = gql`
    mutation createXeroIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...XeroIntegrationMapItemDialogCollectionItem
  }
}
    ${XeroIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateXeroIntegrationMappingMutationFn = Apollo.MutationFunction<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>;

/**
 * __useCreateXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationMappingMutation, { data, loading, error }] = useCreateXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>(CreateXeroIntegrationMappingDocument, options);
      }
export type CreateXeroIntegrationMappingMutationHookResult = ReturnType<typeof useCreateXeroIntegrationMappingMutation>;
export type CreateXeroIntegrationMappingMutationResult = Apollo.MutationResult<CreateXeroIntegrationMappingMutation>;
export type CreateXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>;
export const UpdateXeroIntegrationCollectionMappingDocument = gql`
    mutation updateXeroIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>(UpdateXeroIntegrationCollectionMappingDocument, options);
      }
export type UpdateXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationCollectionMappingMutation>;
export type UpdateXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateXeroIntegrationCollectionMappingMutation>;
export type UpdateXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>;
export const UpdateXeroIntegrationMappingDocument = gql`
    mutation updateXeroIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateXeroIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>;

/**
 * __useUpdateXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationMappingMutation, { data, loading, error }] = useUpdateXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>(UpdateXeroIntegrationMappingDocument, options);
      }
export type UpdateXeroIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationMappingMutation>;
export type UpdateXeroIntegrationMappingMutationResult = Apollo.MutationResult<UpdateXeroIntegrationMappingMutation>;
export type UpdateXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>;
export const DeleteXeroIntegrationCollectionMappingDocument = gql`
    mutation deleteXeroIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>(DeleteXeroIntegrationCollectionMappingDocument, options);
      }
export type DeleteXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteXeroIntegrationCollectionMappingMutation>;
export type DeleteXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteXeroIntegrationCollectionMappingMutation>;
export type DeleteXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>;
export const DeleteXeroIntegrationMappingDocument = gql`
    mutation deleteXeroIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteXeroIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>;

/**
 * __useDeleteXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteXeroIntegrationMappingMutation, { data, loading, error }] = useDeleteXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>(DeleteXeroIntegrationMappingDocument, options);
      }
export type DeleteXeroIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteXeroIntegrationMappingMutation>;
export type DeleteXeroIntegrationMappingMutationResult = Apollo.MutationResult<DeleteXeroIntegrationMappingMutation>;
export type DeleteXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>;
export const GetXeroIntegrationsSettingsDocument = gql`
    query getXeroIntegrationsSettings($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on XeroIntegration {
      id
      ...XeroIntegrationSettings
      ...DeleteXeroIntegrationDialog
      ...XeroForCreateDialogDialog
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on XeroIntegration {
        id
      }
    }
  }
}
    ${XeroIntegrationSettingsFragmentDoc}
${DeleteXeroIntegrationDialogFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetXeroIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables> & ({ variables: GetXeroIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
      }
export function useGetXeroIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
        }
export function useGetXeroIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
        }
export type GetXeroIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsQuery>;
export type GetXeroIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsLazyQuery>;
export type GetXeroIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsSuspenseQuery>;
export type GetXeroIntegrationsSettingsQueryResult = Apollo.QueryResult<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>;
export const DeleteCustomSectionDocument = gql`
    mutation deleteCustomSection($input: DestroyInvoiceCustomSectionInput!) {
  destroyInvoiceCustomSection(input: $input) {
    id
  }
}
    `;
export type DeleteCustomSectionMutationFn = Apollo.MutationFunction<DeleteCustomSectionMutation, DeleteCustomSectionMutationVariables>;

/**
 * __useDeleteCustomSectionMutation__
 *
 * To run a mutation, you first call `useDeleteCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomSectionMutation, { data, loading, error }] = useDeleteCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomSectionMutation, DeleteCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomSectionMutation, DeleteCustomSectionMutationVariables>(DeleteCustomSectionDocument, options);
      }
export type DeleteCustomSectionMutationHookResult = ReturnType<typeof useDeleteCustomSectionMutation>;
export type DeleteCustomSectionMutationResult = Apollo.MutationResult<DeleteCustomSectionMutation>;
export type DeleteCustomSectionMutationOptions = Apollo.BaseMutationOptions<DeleteCustomSectionMutation, DeleteCustomSectionMutationVariables>;
export const UpdateDocumentLocaleBillingEntityDocument = gql`
    mutation updateDocumentLocaleBillingEntity($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateDocumentLocaleBillingEntityMutationFn = Apollo.MutationFunction<UpdateDocumentLocaleBillingEntityMutation, UpdateDocumentLocaleBillingEntityMutationVariables>;

/**
 * __useUpdateDocumentLocaleBillingEntityMutation__
 *
 * To run a mutation, you first call `useUpdateDocumentLocaleBillingEntityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDocumentLocaleBillingEntityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDocumentLocaleBillingEntityMutation, { data, loading, error }] = useUpdateDocumentLocaleBillingEntityMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDocumentLocaleBillingEntityMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDocumentLocaleBillingEntityMutation, UpdateDocumentLocaleBillingEntityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDocumentLocaleBillingEntityMutation, UpdateDocumentLocaleBillingEntityMutationVariables>(UpdateDocumentLocaleBillingEntityDocument, options);
      }
export type UpdateDocumentLocaleBillingEntityMutationHookResult = ReturnType<typeof useUpdateDocumentLocaleBillingEntityMutation>;
export type UpdateDocumentLocaleBillingEntityMutationResult = Apollo.MutationResult<UpdateDocumentLocaleBillingEntityMutation>;
export type UpdateDocumentLocaleBillingEntityMutationOptions = Apollo.BaseMutationOptions<UpdateDocumentLocaleBillingEntityMutation, UpdateDocumentLocaleBillingEntityMutationVariables>;
export const UpdateBillingEntityGracePeriodDocument = gql`
    mutation updateBillingEntityGracePeriod($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    billingConfiguration {
      id
      invoiceGracePeriod
    }
  }
}
    `;
export type UpdateBillingEntityGracePeriodMutationFn = Apollo.MutationFunction<UpdateBillingEntityGracePeriodMutation, UpdateBillingEntityGracePeriodMutationVariables>;

/**
 * __useUpdateBillingEntityGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityGracePeriodMutation, { data, loading, error }] = useUpdateBillingEntityGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityGracePeriodMutation, UpdateBillingEntityGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityGracePeriodMutation, UpdateBillingEntityGracePeriodMutationVariables>(UpdateBillingEntityGracePeriodDocument, options);
      }
export type UpdateBillingEntityGracePeriodMutationHookResult = ReturnType<typeof useUpdateBillingEntityGracePeriodMutation>;
export type UpdateBillingEntityGracePeriodMutationResult = Apollo.MutationResult<UpdateBillingEntityGracePeriodMutation>;
export type UpdateBillingEntityGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityGracePeriodMutation, UpdateBillingEntityGracePeriodMutationVariables>;
export const UpdateBillingEntityInvoiceNumberingDocument = gql`
    mutation updateBillingEntityInvoiceNumbering($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    ...EditBillingEntityInvoiceNumberingDialog
  }
}
    ${EditBillingEntityInvoiceNumberingDialogFragmentDoc}`;
export type UpdateBillingEntityInvoiceNumberingMutationFn = Apollo.MutationFunction<UpdateBillingEntityInvoiceNumberingMutation, UpdateBillingEntityInvoiceNumberingMutationVariables>;

/**
 * __useUpdateBillingEntityInvoiceNumberingMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityInvoiceNumberingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityInvoiceNumberingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityInvoiceNumberingMutation, { data, loading, error }] = useUpdateBillingEntityInvoiceNumberingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityInvoiceNumberingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityInvoiceNumberingMutation, UpdateBillingEntityInvoiceNumberingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityInvoiceNumberingMutation, UpdateBillingEntityInvoiceNumberingMutationVariables>(UpdateBillingEntityInvoiceNumberingDocument, options);
      }
export type UpdateBillingEntityInvoiceNumberingMutationHookResult = ReturnType<typeof useUpdateBillingEntityInvoiceNumberingMutation>;
export type UpdateBillingEntityInvoiceNumberingMutationResult = Apollo.MutationResult<UpdateBillingEntityInvoiceNumberingMutation>;
export type UpdateBillingEntityInvoiceNumberingMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityInvoiceNumberingMutation, UpdateBillingEntityInvoiceNumberingMutationVariables>;
export const UpdateBillingEntityInvoiceTemplateDocument = gql`
    mutation updateBillingEntityInvoiceTemplate($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    ...EditBillingEntityInvoiceTemplateDialog
  }
}
    ${EditBillingEntityInvoiceTemplateDialogFragmentDoc}`;
export type UpdateBillingEntityInvoiceTemplateMutationFn = Apollo.MutationFunction<UpdateBillingEntityInvoiceTemplateMutation, UpdateBillingEntityInvoiceTemplateMutationVariables>;

/**
 * __useUpdateBillingEntityInvoiceTemplateMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityInvoiceTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityInvoiceTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityInvoiceTemplateMutation, { data, loading, error }] = useUpdateBillingEntityInvoiceTemplateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityInvoiceTemplateMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityInvoiceTemplateMutation, UpdateBillingEntityInvoiceTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityInvoiceTemplateMutation, UpdateBillingEntityInvoiceTemplateMutationVariables>(UpdateBillingEntityInvoiceTemplateDocument, options);
      }
export type UpdateBillingEntityInvoiceTemplateMutationHookResult = ReturnType<typeof useUpdateBillingEntityInvoiceTemplateMutation>;
export type UpdateBillingEntityInvoiceTemplateMutationResult = Apollo.MutationResult<UpdateBillingEntityInvoiceTemplateMutation>;
export type UpdateBillingEntityInvoiceTemplateMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityInvoiceTemplateMutation, UpdateBillingEntityInvoiceTemplateMutationVariables>;
export const UpdateBillingEntityDefaultCurrencyDocument = gql`
    mutation updateBillingEntityDefaultCurrency($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    ...EditBillingEntityDefaultCurrencyForDialog
  }
}
    ${EditBillingEntityDefaultCurrencyForDialogFragmentDoc}`;
export type UpdateBillingEntityDefaultCurrencyMutationFn = Apollo.MutationFunction<UpdateBillingEntityDefaultCurrencyMutation, UpdateBillingEntityDefaultCurrencyMutationVariables>;

/**
 * __useUpdateBillingEntityDefaultCurrencyMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityDefaultCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityDefaultCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityDefaultCurrencyMutation, { data, loading, error }] = useUpdateBillingEntityDefaultCurrencyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityDefaultCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityDefaultCurrencyMutation, UpdateBillingEntityDefaultCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityDefaultCurrencyMutation, UpdateBillingEntityDefaultCurrencyMutationVariables>(UpdateBillingEntityDefaultCurrencyDocument, options);
      }
export type UpdateBillingEntityDefaultCurrencyMutationHookResult = ReturnType<typeof useUpdateBillingEntityDefaultCurrencyMutation>;
export type UpdateBillingEntityDefaultCurrencyMutationResult = Apollo.MutationResult<UpdateBillingEntityDefaultCurrencyMutation>;
export type UpdateBillingEntityDefaultCurrencyMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityDefaultCurrencyMutation, UpdateBillingEntityDefaultCurrencyMutationVariables>;
export const UpdateCustomerFinalizeZeroAmountInvoiceDocument = gql`
    mutation updateCustomerFinalizeZeroAmountInvoice($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...EditCustomerFinalizeZeroAmountInvoiceForDialog
  }
}
    ${EditCustomerFinalizeZeroAmountInvoiceForDialogFragmentDoc}`;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useUpdateCustomerFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useUpdateCustomerFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>(UpdateCustomerFinalizeZeroAmountInvoiceDocument, options);
      }
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useUpdateCustomerFinalizeZeroAmountInvoiceMutation>;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<UpdateCustomerFinalizeZeroAmountInvoiceMutation>;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>;
export const UpdateBillingEntityFinalizeZeroAmountInvoiceDocument = gql`
    mutation updateBillingEntityFinalizeZeroAmountInvoice($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    ...EditBillingEntityFinalizeZeroAmountInvoiceForDialog
  }
}
    ${EditBillingEntityFinalizeZeroAmountInvoiceForDialogFragmentDoc}`;
export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<UpdateBillingEntityFinalizeZeroAmountInvoiceMutation, UpdateBillingEntityFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityFinalizeZeroAmountInvoiceMutation, UpdateBillingEntityFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityFinalizeZeroAmountInvoiceMutation, UpdateBillingEntityFinalizeZeroAmountInvoiceMutationVariables>(UpdateBillingEntityFinalizeZeroAmountInvoiceDocument, options);
      }
export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useUpdateBillingEntityFinalizeZeroAmountInvoiceMutation>;
export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<UpdateBillingEntityFinalizeZeroAmountInvoiceMutation>;
export type UpdateBillingEntityFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityFinalizeZeroAmountInvoiceMutation, UpdateBillingEntityFinalizeZeroAmountInvoiceMutationVariables>;
export const UpdateCustomerNetPaymentTermDocument = gql`
    mutation updateCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...EditCustomerNetPaymentTermForDialog
  }
}
    ${EditCustomerNetPaymentTermForDialogFragmentDoc}`;
export type UpdateCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;

/**
 * __useUpdateCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerNetPaymentTermMutation, { data, loading, error }] = useUpdateCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>(UpdateCustomerNetPaymentTermDocument, options);
      }
export type UpdateCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationResult = Apollo.MutationResult<UpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;
export const UpdateBillingEntityNetPaymentTermDocument = gql`
    mutation updateBillingEntityNetPaymentTerm($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    ...EditBillingEntityNetPaymentTermForDialog
  }
}
    ${EditBillingEntityNetPaymentTermForDialogFragmentDoc}`;
export type UpdateBillingEntityNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateBillingEntityNetPaymentTermMutation, UpdateBillingEntityNetPaymentTermMutationVariables>;

/**
 * __useUpdateBillingEntityNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityNetPaymentTermMutation, { data, loading, error }] = useUpdateBillingEntityNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityNetPaymentTermMutation, UpdateBillingEntityNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityNetPaymentTermMutation, UpdateBillingEntityNetPaymentTermMutationVariables>(UpdateBillingEntityNetPaymentTermDocument, options);
      }
export type UpdateBillingEntityNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateBillingEntityNetPaymentTermMutation>;
export type UpdateBillingEntityNetPaymentTermMutationResult = Apollo.MutationResult<UpdateBillingEntityNetPaymentTermMutation>;
export type UpdateBillingEntityNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityNetPaymentTermMutation, UpdateBillingEntityNetPaymentTermMutationVariables>;
export const GetOrganizationCustomFooterForInvoiceDocument = gql`
    query GetOrganizationCustomFooterForInvoice {
  organization {
    billingConfiguration {
      invoiceFooter
    }
  }
}
    `;

/**
 * __useGetOrganizationCustomFooterForInvoiceQuery__
 *
 * To run a query within a React component, call `useGetOrganizationCustomFooterForInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationCustomFooterForInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationCustomFooterForInvoiceQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationCustomFooterForInvoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>(GetOrganizationCustomFooterForInvoiceDocument, options);
      }
export function useGetOrganizationCustomFooterForInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>(GetOrganizationCustomFooterForInvoiceDocument, options);
        }
export function useGetOrganizationCustomFooterForInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>(GetOrganizationCustomFooterForInvoiceDocument, options);
        }
export type GetOrganizationCustomFooterForInvoiceQueryHookResult = ReturnType<typeof useGetOrganizationCustomFooterForInvoiceQuery>;
export type GetOrganizationCustomFooterForInvoiceLazyQueryHookResult = ReturnType<typeof useGetOrganizationCustomFooterForInvoiceLazyQuery>;
export type GetOrganizationCustomFooterForInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationCustomFooterForInvoiceSuspenseQuery>;
export type GetOrganizationCustomFooterForInvoiceQueryResult = Apollo.QueryResult<GetOrganizationCustomFooterForInvoiceQuery, GetOrganizationCustomFooterForInvoiceQueryVariables>;
export const CreateInviteDocument = gql`
    mutation createInvite($input: CreateInviteInput!) {
  createInvite(input: $input) {
    id
    token
    ...InviteItemForMembersSettings
  }
}
    ${InviteItemForMembersSettingsFragmentDoc}`;
export type CreateInviteMutationFn = Apollo.MutationFunction<CreateInviteMutation, CreateInviteMutationVariables>;

/**
 * __useCreateInviteMutation__
 *
 * To run a mutation, you first call `useCreateInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInviteMutation, { data, loading, error }] = useCreateInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInviteMutation(baseOptions?: Apollo.MutationHookOptions<CreateInviteMutation, CreateInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInviteMutation, CreateInviteMutationVariables>(CreateInviteDocument, options);
      }
export type CreateInviteMutationHookResult = ReturnType<typeof useCreateInviteMutation>;
export type CreateInviteMutationResult = Apollo.MutationResult<CreateInviteMutation>;
export type CreateInviteMutationOptions = Apollo.BaseMutationOptions<CreateInviteMutation, CreateInviteMutationVariables>;
export const UpdateInviteRoleDocument = gql`
    mutation updateInviteRole($input: UpdateInviteInput!) {
  updateInvite(input: $input) {
    id
    ...InviteForEditRoleForDialog
  }
}
    ${InviteForEditRoleForDialogFragmentDoc}`;
export type UpdateInviteRoleMutationFn = Apollo.MutationFunction<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>;

/**
 * __useUpdateInviteRoleMutation__
 *
 * To run a mutation, you first call `useUpdateInviteRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInviteRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInviteRoleMutation, { data, loading, error }] = useUpdateInviteRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInviteRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>(UpdateInviteRoleDocument, options);
      }
export type UpdateInviteRoleMutationHookResult = ReturnType<typeof useUpdateInviteRoleMutation>;
export type UpdateInviteRoleMutationResult = Apollo.MutationResult<UpdateInviteRoleMutation>;
export type UpdateInviteRoleMutationOptions = Apollo.BaseMutationOptions<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>;
export const UpdateMembershipRoleDocument = gql`
    mutation updateMembershipRole($input: UpdateMembershipInput!) {
  updateMembership(input: $input) {
    id
    ...MemberForEditRoleForDialog
  }
}
    ${MemberForEditRoleForDialogFragmentDoc}`;
export type UpdateMembershipRoleMutationFn = Apollo.MutationFunction<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>;

/**
 * __useUpdateMembershipRoleMutation__
 *
 * To run a mutation, you first call `useUpdateMembershipRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMembershipRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMembershipRoleMutation, { data, loading, error }] = useUpdateMembershipRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMembershipRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>(UpdateMembershipRoleDocument, options);
      }
export type UpdateMembershipRoleMutationHookResult = ReturnType<typeof useUpdateMembershipRoleMutation>;
export type UpdateMembershipRoleMutationResult = Apollo.MutationResult<UpdateMembershipRoleMutation>;
export type UpdateMembershipRoleMutationOptions = Apollo.BaseMutationOptions<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>;
export const RevokeInviteDocument = gql`
    mutation revokeInvite($input: RevokeInviteInput!) {
  revokeInvite(input: $input) {
    id
  }
}
    `;
export type RevokeInviteMutationFn = Apollo.MutationFunction<RevokeInviteMutation, RevokeInviteMutationVariables>;

/**
 * __useRevokeInviteMutation__
 *
 * To run a mutation, you first call `useRevokeInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeInviteMutation, { data, loading, error }] = useRevokeInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeInviteMutation(baseOptions?: Apollo.MutationHookOptions<RevokeInviteMutation, RevokeInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeInviteMutation, RevokeInviteMutationVariables>(RevokeInviteDocument, options);
      }
export type RevokeInviteMutationHookResult = ReturnType<typeof useRevokeInviteMutation>;
export type RevokeInviteMutationResult = Apollo.MutationResult<RevokeInviteMutation>;
export type RevokeInviteMutationOptions = Apollo.BaseMutationOptions<RevokeInviteMutation, RevokeInviteMutationVariables>;
export const RevokeMembershipDocument = gql`
    mutation revokeMembership($input: RevokeMembershipInput!) {
  revokeMembership(input: $input) {
    id
  }
}
    `;
export type RevokeMembershipMutationFn = Apollo.MutationFunction<RevokeMembershipMutation, RevokeMembershipMutationVariables>;

/**
 * __useRevokeMembershipMutation__
 *
 * To run a mutation, you first call `useRevokeMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeMembershipMutation, { data, loading, error }] = useRevokeMembershipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeMembershipMutation(baseOptions?: Apollo.MutationHookOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeMembershipMutation, RevokeMembershipMutationVariables>(RevokeMembershipDocument, options);
      }
export type RevokeMembershipMutationHookResult = ReturnType<typeof useRevokeMembershipMutation>;
export type RevokeMembershipMutationResult = Apollo.MutationResult<RevokeMembershipMutation>;
export type RevokeMembershipMutationOptions = Apollo.BaseMutationOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>;
export const RemoveSubscriptionEntitlementDocument = gql`
    mutation removeSubscriptionEntitlement($input: RemoveSubscriptionEntitlementInput!) {
  removeSubscriptionEntitlement(input: $input) {
    featureCode
  }
}
    `;
export type RemoveSubscriptionEntitlementMutationFn = Apollo.MutationFunction<RemoveSubscriptionEntitlementMutation, RemoveSubscriptionEntitlementMutationVariables>;

/**
 * __useRemoveSubscriptionEntitlementMutation__
 *
 * To run a mutation, you first call `useRemoveSubscriptionEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveSubscriptionEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeSubscriptionEntitlementMutation, { data, loading, error }] = useRemoveSubscriptionEntitlementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveSubscriptionEntitlementMutation(baseOptions?: Apollo.MutationHookOptions<RemoveSubscriptionEntitlementMutation, RemoveSubscriptionEntitlementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveSubscriptionEntitlementMutation, RemoveSubscriptionEntitlementMutationVariables>(RemoveSubscriptionEntitlementDocument, options);
      }
export type RemoveSubscriptionEntitlementMutationHookResult = ReturnType<typeof useRemoveSubscriptionEntitlementMutation>;
export type RemoveSubscriptionEntitlementMutationResult = Apollo.MutationResult<RemoveSubscriptionEntitlementMutation>;
export type RemoveSubscriptionEntitlementMutationOptions = Apollo.BaseMutationOptions<RemoveSubscriptionEntitlementMutation, RemoveSubscriptionEntitlementMutationVariables>;
export const SubscriptionActivityLogsDocument = gql`
    query SubscriptionActivityLogs($page: Int, $limit: Int, $externalSubscriptionId: String) {
  activityLogs(
    page: $page
    limit: $limit
    externalSubscriptionId: $externalSubscriptionId
  ) {
    collection {
      ...ActivityLogsTableData
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${ActivityLogsTableDataFragmentDoc}`;

/**
 * __useSubscriptionActivityLogsQuery__
 *
 * To run a query within a React component, call `useSubscriptionActivityLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionActivityLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionActivityLogsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *   },
 * });
 */
export function useSubscriptionActivityLogsQuery(baseOptions?: Apollo.QueryHookOptions<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>(SubscriptionActivityLogsDocument, options);
      }
export function useSubscriptionActivityLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>(SubscriptionActivityLogsDocument, options);
        }
export function useSubscriptionActivityLogsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>(SubscriptionActivityLogsDocument, options);
        }
export type SubscriptionActivityLogsQueryHookResult = ReturnType<typeof useSubscriptionActivityLogsQuery>;
export type SubscriptionActivityLogsLazyQueryHookResult = ReturnType<typeof useSubscriptionActivityLogsLazyQuery>;
export type SubscriptionActivityLogsSuspenseQueryHookResult = ReturnType<typeof useSubscriptionActivityLogsSuspenseQuery>;
export type SubscriptionActivityLogsQueryResult = Apollo.QueryResult<SubscriptionActivityLogsQuery, SubscriptionActivityLogsQueryVariables>;
export const GetAlertsOfSubscriptionDocument = gql`
    query getAlertsOfSubscription($subscriptionExternalId: String!, $limit: Int, $page: Int) {
  alerts(
    subscriptionExternalId: $subscriptionExternalId
    limit: $limit
    page: $page
  ) {
    collection {
      id
      code
      createdAt
      name
    }
  }
}
    `;

/**
 * __useGetAlertsOfSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetAlertsOfSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAlertsOfSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAlertsOfSubscriptionQuery({
 *   variables: {
 *      subscriptionExternalId: // value for 'subscriptionExternalId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetAlertsOfSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables> & ({ variables: GetAlertsOfSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>(GetAlertsOfSubscriptionDocument, options);
      }
export function useGetAlertsOfSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>(GetAlertsOfSubscriptionDocument, options);
        }
export function useGetAlertsOfSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>(GetAlertsOfSubscriptionDocument, options);
        }
export type GetAlertsOfSubscriptionQueryHookResult = ReturnType<typeof useGetAlertsOfSubscriptionQuery>;
export type GetAlertsOfSubscriptionLazyQueryHookResult = ReturnType<typeof useGetAlertsOfSubscriptionLazyQuery>;
export type GetAlertsOfSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetAlertsOfSubscriptionSuspenseQuery>;
export type GetAlertsOfSubscriptionQueryResult = Apollo.QueryResult<GetAlertsOfSubscriptionQuery, GetAlertsOfSubscriptionQueryVariables>;
export const CustomerForSubscriptionUsageDocument = gql`
    query customerForSubscriptionUsage($customerId: ID!) {
  customer(id: $customerId) {
    id
    applicableTimezone
  }
}
    `;

/**
 * __useCustomerForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useCustomerForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerForSubscriptionUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *   },
 * });
 */
export function useCustomerForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables> & ({ variables: CustomerForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
      }
export function useCustomerForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
        }
export function useCustomerForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
        }
export type CustomerForSubscriptionUsageQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageQuery>;
export type CustomerForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageLazyQuery>;
export type CustomerForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageSuspenseQuery>;
export type CustomerForSubscriptionUsageQueryResult = Apollo.QueryResult<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>;
export const SubscrptionForSubscriptionUsageDocument = gql`
    query subscrptionForSubscriptionUsage($subscription: ID!) {
  subscription(id: $subscription) {
    id
    name
    status
    plan {
      id
      name
      code
    }
    customer {
      id
      applicableTimezone
    }
  }
}
    `;

/**
 * __useSubscrptionForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useSubscrptionForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscrptionForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscrptionForSubscriptionUsageQuery({
 *   variables: {
 *      subscription: // value for 'subscription'
 *   },
 * });
 */
export function useSubscrptionForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables> & ({ variables: SubscrptionForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
      }
export function useSubscrptionForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
        }
export function useSubscrptionForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
        }
export type SubscrptionForSubscriptionUsageQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageQuery>;
export type SubscrptionForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageLazyQuery>;
export type SubscrptionForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageSuspenseQuery>;
export type SubscrptionForSubscriptionUsageQueryResult = Apollo.QueryResult<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>;
export const UsageForSubscriptionUsageDocument = gql`
    query usageForSubscriptionUsage($customerId: ID!, $subscriptionId: ID!) {
  customerUsage(customerId: $customerId, subscriptionId: $subscriptionId) {
    amountCents
    ...SubscriptionCurrentUsageTableComponentCustomerUsage
    ...CustomerUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc}
${CustomerUsageForUsageDetailsFragmentDoc}`;

/**
 * __useUsageForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useUsageForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsageForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsageForSubscriptionUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useUsageForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables> & ({ variables: UsageForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
      }
export function useUsageForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
        }
export function useUsageForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
        }
export type UsageForSubscriptionUsageQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageQuery>;
export type UsageForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageLazyQuery>;
export type UsageForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageSuspenseQuery>;
export type UsageForSubscriptionUsageQueryResult = Apollo.QueryResult<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>;
export const ProjectedUsageForSubscriptionUsageDocument = gql`
    query projectedUsageForSubscriptionUsage($customerId: ID!, $subscriptionId: ID!) {
  customerProjectedUsage(customerId: $customerId, subscriptionId: $subscriptionId) {
    amountCents
    projectedAmountCents
    ...SubscriptionCurrentUsageTableComponentCustomerProjectedUsage
    ...CustomerProjectedUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerProjectedUsageFragmentDoc}
${CustomerProjectedUsageForUsageDetailsFragmentDoc}`;

/**
 * __useProjectedUsageForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useProjectedUsageForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectedUsageForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectedUsageForSubscriptionUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useProjectedUsageForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables> & ({ variables: ProjectedUsageForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>(ProjectedUsageForSubscriptionUsageDocument, options);
      }
export function useProjectedUsageForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>(ProjectedUsageForSubscriptionUsageDocument, options);
        }
export function useProjectedUsageForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>(ProjectedUsageForSubscriptionUsageDocument, options);
        }
export type ProjectedUsageForSubscriptionUsageQueryHookResult = ReturnType<typeof useProjectedUsageForSubscriptionUsageQuery>;
export type ProjectedUsageForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useProjectedUsageForSubscriptionUsageLazyQuery>;
export type ProjectedUsageForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useProjectedUsageForSubscriptionUsageSuspenseQuery>;
export type ProjectedUsageForSubscriptionUsageQueryResult = Apollo.QueryResult<ProjectedUsageForSubscriptionUsageQuery, ProjectedUsageForSubscriptionUsageQueryVariables>;
export const GetSubscriptionForDetailsOverviewDocument = gql`
    query getSubscriptionForDetailsOverview($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    plan {
      id
    }
    ...SubscriptionForSubscriptionInformations
  }
}
    ${SubscriptionForSubscriptionInformationsFragmentDoc}`;

/**
 * __useGetSubscriptionForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsOverviewQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables> & ({ variables: GetSubscriptionForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
      }
export function useGetSubscriptionForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export function useGetSubscriptionForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export type GetSubscriptionForDetailsOverviewQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewQuery>;
export type GetSubscriptionForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewLazyQuery>;
export type GetSubscriptionForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewSuspenseQuery>;
export type GetSubscriptionForDetailsOverviewQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>;
export const GetEntitlementsForSubscriptionDetailsDocument = gql`
    query getEntitlementsForSubscriptionDetails($subscriptionId: ID!) {
  subscriptionEntitlements(subscriptionId: $subscriptionId) {
    collection {
      code
      name
      privileges {
        code
        name
        value
        valueType
        config {
          selectOptions
        }
      }
    }
  }
}
    `;

/**
 * __useGetEntitlementsForSubscriptionDetailsQuery__
 *
 * To run a query within a React component, call `useGetEntitlementsForSubscriptionDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEntitlementsForSubscriptionDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEntitlementsForSubscriptionDetailsQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetEntitlementsForSubscriptionDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables> & ({ variables: GetEntitlementsForSubscriptionDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>(GetEntitlementsForSubscriptionDetailsDocument, options);
      }
export function useGetEntitlementsForSubscriptionDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>(GetEntitlementsForSubscriptionDetailsDocument, options);
        }
export function useGetEntitlementsForSubscriptionDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>(GetEntitlementsForSubscriptionDetailsDocument, options);
        }
export type GetEntitlementsForSubscriptionDetailsQueryHookResult = ReturnType<typeof useGetEntitlementsForSubscriptionDetailsQuery>;
export type GetEntitlementsForSubscriptionDetailsLazyQueryHookResult = ReturnType<typeof useGetEntitlementsForSubscriptionDetailsLazyQuery>;
export type GetEntitlementsForSubscriptionDetailsSuspenseQueryHookResult = ReturnType<typeof useGetEntitlementsForSubscriptionDetailsSuspenseQuery>;
export type GetEntitlementsForSubscriptionDetailsQueryResult = Apollo.QueryResult<GetEntitlementsForSubscriptionDetailsQuery, GetEntitlementsForSubscriptionDetailsQueryVariables>;
export const GetSubscriptionForSubscriptionUsageLifetimeGraphDocument = gql`
    query getSubscriptionForSubscriptionUsageLifetimeGraph($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    ...SubscriptionUsageLifetimeGraphForLifetimeGraph
  }
}
    ${SubscriptionUsageLifetimeGraphForLifetimeGraphFragmentDoc}`;

/**
 * __useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables> & ({ variables: GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
      }
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
        }
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
        }
export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphLazyQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryResult = Apollo.QueryResult<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>;
export const GetCustomerFromSubscriptionDocument = gql`
    query getCustomerFromSubscription($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    customer {
      id
    }
  }
}
    `;

/**
 * __useGetCustomerFromSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetCustomerFromSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerFromSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerFromSubscriptionQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetCustomerFromSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables> & ({ variables: GetCustomerFromSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>(GetCustomerFromSubscriptionDocument, options);
      }
export function useGetCustomerFromSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>(GetCustomerFromSubscriptionDocument, options);
        }
export function useGetCustomerFromSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>(GetCustomerFromSubscriptionDocument, options);
        }
export type GetCustomerFromSubscriptionQueryHookResult = ReturnType<typeof useGetCustomerFromSubscriptionQuery>;
export type GetCustomerFromSubscriptionLazyQueryHookResult = ReturnType<typeof useGetCustomerFromSubscriptionLazyQuery>;
export type GetCustomerFromSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerFromSubscriptionSuspenseQuery>;
export type GetCustomerFromSubscriptionQueryResult = Apollo.QueryResult<GetCustomerFromSubscriptionQuery, GetCustomerFromSubscriptionQueryVariables>;
export const DestroySubscriptionAlertDocument = gql`
    mutation destroySubscriptionAlert($input: DestroySubscriptionAlertInput!) {
  destroySubscriptionAlert(input: $input) {
    id
  }
}
    `;
export type DestroySubscriptionAlertMutationFn = Apollo.MutationFunction<DestroySubscriptionAlertMutation, DestroySubscriptionAlertMutationVariables>;

/**
 * __useDestroySubscriptionAlertMutation__
 *
 * To run a mutation, you first call `useDestroySubscriptionAlertMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroySubscriptionAlertMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroySubscriptionAlertMutation, { data, loading, error }] = useDestroySubscriptionAlertMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroySubscriptionAlertMutation(baseOptions?: Apollo.MutationHookOptions<DestroySubscriptionAlertMutation, DestroySubscriptionAlertMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroySubscriptionAlertMutation, DestroySubscriptionAlertMutationVariables>(DestroySubscriptionAlertDocument, options);
      }
export type DestroySubscriptionAlertMutationHookResult = ReturnType<typeof useDestroySubscriptionAlertMutation>;
export type DestroySubscriptionAlertMutationResult = Apollo.MutationResult<DestroySubscriptionAlertMutation>;
export type DestroySubscriptionAlertMutationOptions = Apollo.BaseMutationOptions<DestroySubscriptionAlertMutation, DestroySubscriptionAlertMutationVariables>;
export const DeleteTaxDocument = gql`
    mutation deleteTax($input: DestroyTaxInput!) {
  destroyTax(input: $input) {
    id
  }
}
    `;
export type DeleteTaxMutationFn = Apollo.MutationFunction<DeleteTaxMutation, DeleteTaxMutationVariables>;

/**
 * __useDeleteTaxMutation__
 *
 * To run a mutation, you first call `useDeleteTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTaxMutation, { data, loading, error }] = useDeleteTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTaxMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTaxMutation, DeleteTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTaxMutation, DeleteTaxMutationVariables>(DeleteTaxDocument, options);
      }
export type DeleteTaxMutationHookResult = ReturnType<typeof useDeleteTaxMutation>;
export type DeleteTaxMutationResult = Apollo.MutationResult<DeleteTaxMutation>;
export type DeleteTaxMutationOptions = Apollo.BaseMutationOptions<DeleteTaxMutation, DeleteTaxMutationVariables>;
export const GetTaxesForTaxesSelectorSectionDocument = gql`
    query getTaxesForTaxesSelectorSection($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForTaxesSelectorSection
    }
  }
}
    ${TaxForTaxesSelectorSectionFragmentDoc}`;

/**
 * __useGetTaxesForTaxesSelectorSectionQuery__
 *
 * To run a query within a React component, call `useGetTaxesForTaxesSelectorSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForTaxesSelectorSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForTaxesSelectorSectionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxesForTaxesSelectorSectionQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>(GetTaxesForTaxesSelectorSectionDocument, options);
      }
export function useGetTaxesForTaxesSelectorSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>(GetTaxesForTaxesSelectorSectionDocument, options);
        }
export function useGetTaxesForTaxesSelectorSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>(GetTaxesForTaxesSelectorSectionDocument, options);
        }
export type GetTaxesForTaxesSelectorSectionQueryHookResult = ReturnType<typeof useGetTaxesForTaxesSelectorSectionQuery>;
export type GetTaxesForTaxesSelectorSectionLazyQueryHookResult = ReturnType<typeof useGetTaxesForTaxesSelectorSectionLazyQuery>;
export type GetTaxesForTaxesSelectorSectionSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForTaxesSelectorSectionSuspenseQuery>;
export type GetTaxesForTaxesSelectorSectionQueryResult = Apollo.QueryResult<GetTaxesForTaxesSelectorSectionQuery, GetTaxesForTaxesSelectorSectionQueryVariables>;
export const GetCustomerWalletListDocument = gql`
    query getCustomerWalletList($customerId: ID!, $page: Int, $limit: Int) {
  wallets(customerId: $customerId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      customerActiveWalletsCount
    }
    collection {
      ...CustomerWallet
    }
  }
}
    ${CustomerWalletFragmentDoc}`;

/**
 * __useGetCustomerWalletListQuery__
 *
 * To run a query within a React component, call `useGetCustomerWalletListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerWalletListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerWalletListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetCustomerWalletListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables> & ({ variables: GetCustomerWalletListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
      }
export function useGetCustomerWalletListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export function useGetCustomerWalletListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export type GetCustomerWalletListQueryHookResult = ReturnType<typeof useGetCustomerWalletListQuery>;
export type GetCustomerWalletListLazyQueryHookResult = ReturnType<typeof useGetCustomerWalletListLazyQuery>;
export type GetCustomerWalletListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerWalletListSuspenseQuery>;
export type GetCustomerWalletListQueryResult = Apollo.QueryResult<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>;
export const TerminateCustomerWalletDocument = gql`
    mutation terminateCustomerWallet($input: TerminateCustomerWalletInput!) {
  terminateCustomerWallet(input: $input) {
    id
    status
    ...WalletAccordion
    customer {
      id
      hasActiveWallet
    }
  }
}
    ${WalletAccordionFragmentDoc}`;
export type TerminateCustomerWalletMutationFn = Apollo.MutationFunction<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;

/**
 * __useTerminateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerWalletMutation, { data, loading, error }] = useTerminateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>(TerminateCustomerWalletDocument, options);
      }
export type TerminateCustomerWalletMutationHookResult = ReturnType<typeof useTerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationResult = Apollo.MutationResult<TerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;
export const CreateCustomerWalletTransactionDocument = gql`
    mutation createCustomerWalletTransaction($input: CreateCustomerWalletTransactionInput!) {
  createCustomerWalletTransaction(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type CreateCustomerWalletTransactionMutationFn = Apollo.MutationFunction<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;

/**
 * __useCreateCustomerWalletTransactionMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletTransactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletTransactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletTransactionMutation, { data, loading, error }] = useCreateCustomerWalletTransactionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletTransactionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>(CreateCustomerWalletTransactionDocument, options);
      }
export type CreateCustomerWalletTransactionMutationHookResult = ReturnType<typeof useCreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationResult = Apollo.MutationResult<CreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;
export const GetWalletTransactionDetailsDocument = gql`
    query GetWalletTransactionDetails($transactionId: ID!) {
  walletTransaction(id: $transactionId) {
    id
    ...WalletTransactionDetails
  }
}
    ${WalletTransactionDetailsFragmentDoc}`;

/**
 * __useGetWalletTransactionDetailsQuery__
 *
 * To run a query within a React component, call `useGetWalletTransactionDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletTransactionDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletTransactionDetailsQuery({
 *   variables: {
 *      transactionId: // value for 'transactionId'
 *   },
 * });
 */
export function useGetWalletTransactionDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables> & ({ variables: GetWalletTransactionDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>(GetWalletTransactionDetailsDocument, options);
      }
export function useGetWalletTransactionDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>(GetWalletTransactionDetailsDocument, options);
        }
export function useGetWalletTransactionDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>(GetWalletTransactionDetailsDocument, options);
        }
export type GetWalletTransactionDetailsQueryHookResult = ReturnType<typeof useGetWalletTransactionDetailsQuery>;
export type GetWalletTransactionDetailsLazyQueryHookResult = ReturnType<typeof useGetWalletTransactionDetailsLazyQuery>;
export type GetWalletTransactionDetailsSuspenseQueryHookResult = ReturnType<typeof useGetWalletTransactionDetailsSuspenseQuery>;
export type GetWalletTransactionDetailsQueryResult = Apollo.QueryResult<GetWalletTransactionDetailsQuery, GetWalletTransactionDetailsQueryVariables>;
export const GetWalletTransactionsDocument = gql`
    query getWalletTransactions($walletId: ID!, $page: Int, $limit: Int) {
  walletTransactions(walletId: $walletId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...WalletTransactionForTransactionListItem
    }
  }
}
    ${WalletTransactionForTransactionListItemFragmentDoc}`;

/**
 * __useGetWalletTransactionsQuery__
 *
 * To run a query within a React component, call `useGetWalletTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletTransactionsQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWalletTransactionsQuery(baseOptions: Apollo.QueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables> & ({ variables: GetWalletTransactionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
      }
export function useGetWalletTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export function useGetWalletTransactionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export type GetWalletTransactionsQueryHookResult = ReturnType<typeof useGetWalletTransactionsQuery>;
export type GetWalletTransactionsLazyQueryHookResult = ReturnType<typeof useGetWalletTransactionsLazyQuery>;
export type GetWalletTransactionsSuspenseQueryHookResult = ReturnType<typeof useGetWalletTransactionsSuspenseQuery>;
export type GetWalletTransactionsQueryResult = Apollo.QueryResult<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>;
export const GetCurrentUserInfosForLoginDocument = gql`
    query getCurrentUserInfosForLogin {
  currentUser {
    id
    ...CurrentUser
  }
}
    ${CurrentUserFragmentDoc}`;

/**
 * __useGetCurrentUserInfosForLoginQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserInfosForLoginQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserInfosForLoginQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserInfosForLoginQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserInfosForLoginQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>(GetCurrentUserInfosForLoginDocument, options);
      }
export function useGetCurrentUserInfosForLoginLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>(GetCurrentUserInfosForLoginDocument, options);
        }
export function useGetCurrentUserInfosForLoginSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>(GetCurrentUserInfosForLoginDocument, options);
        }
export type GetCurrentUserInfosForLoginQueryHookResult = ReturnType<typeof useGetCurrentUserInfosForLoginQuery>;
export type GetCurrentUserInfosForLoginLazyQueryHookResult = ReturnType<typeof useGetCurrentUserInfosForLoginLazyQuery>;
export type GetCurrentUserInfosForLoginSuspenseQueryHookResult = ReturnType<typeof useGetCurrentUserInfosForLoginSuspenseQuery>;
export type GetCurrentUserInfosForLoginQueryResult = Apollo.QueryResult<GetCurrentUserInfosForLoginQuery, GetCurrentUserInfosForLoginQueryVariables>;
export const CreateSubscriptionDocument = gql`
    mutation createSubscription($input: CreateSubscriptionInput!) {
  createSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type CreateSubscriptionMutationFn = Apollo.MutationFunction<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;

/**
 * __useCreateSubscriptionMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionMutation, { data, loading, error }] = useCreateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>(CreateSubscriptionDocument, options);
      }
export type CreateSubscriptionMutationHookResult = ReturnType<typeof useCreateSubscriptionMutation>;
export type CreateSubscriptionMutationResult = Apollo.MutationResult<CreateSubscriptionMutation>;
export type CreateSubscriptionMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;
export const UpdateSubscriptionDocument = gql`
    mutation updateSubscription($input: UpdateSubscriptionInput!) {
  updateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
    plan {
      id
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type UpdateSubscriptionMutationFn = Apollo.MutationFunction<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;

/**
 * __useUpdateSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionMutation, { data, loading, error }] = useUpdateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>(UpdateSubscriptionDocument, options);
      }
export type UpdateSubscriptionMutationHookResult = ReturnType<typeof useUpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationResult = Apollo.MutationResult<UpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;
export const DownloadPaymentReceiptDocument = gql`
    mutation downloadPaymentReceipt($input: DownloadPaymentReceiptInput!) {
  downloadPaymentReceipt(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadPaymentReceiptMutationFn = Apollo.MutationFunction<DownloadPaymentReceiptMutation, DownloadPaymentReceiptMutationVariables>;

/**
 * __useDownloadPaymentReceiptMutation__
 *
 * To run a mutation, you first call `useDownloadPaymentReceiptMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadPaymentReceiptMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadPaymentReceiptMutation, { data, loading, error }] = useDownloadPaymentReceiptMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadPaymentReceiptMutation(baseOptions?: Apollo.MutationHookOptions<DownloadPaymentReceiptMutation, DownloadPaymentReceiptMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadPaymentReceiptMutation, DownloadPaymentReceiptMutationVariables>(DownloadPaymentReceiptDocument, options);
      }
export type DownloadPaymentReceiptMutationHookResult = ReturnType<typeof useDownloadPaymentReceiptMutation>;
export type DownloadPaymentReceiptMutationResult = Apollo.MutationResult<DownloadPaymentReceiptMutation>;
export type DownloadPaymentReceiptMutationOptions = Apollo.BaseMutationOptions<DownloadPaymentReceiptMutation, DownloadPaymentReceiptMutationVariables>;
export const GetCustomPricingUnitsDocument = gql`
    query getCustomPricingUnits($limit: Int, $page: Int) {
  pricingUnits(limit: $limit, page: $page) {
    collection {
      id
      name
      code
      shortName
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetCustomPricingUnitsQuery__
 *
 * To run a query within a React component, call `useGetCustomPricingUnitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomPricingUnitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomPricingUnitsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetCustomPricingUnitsQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>(GetCustomPricingUnitsDocument, options);
      }
export function useGetCustomPricingUnitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>(GetCustomPricingUnitsDocument, options);
        }
export function useGetCustomPricingUnitsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>(GetCustomPricingUnitsDocument, options);
        }
export type GetCustomPricingUnitsQueryHookResult = ReturnType<typeof useGetCustomPricingUnitsQuery>;
export type GetCustomPricingUnitsLazyQueryHookResult = ReturnType<typeof useGetCustomPricingUnitsLazyQuery>;
export type GetCustomPricingUnitsSuspenseQueryHookResult = ReturnType<typeof useGetCustomPricingUnitsSuspenseQuery>;
export type GetCustomPricingUnitsQueryResult = Apollo.QueryResult<GetCustomPricingUnitsQuery, GetCustomPricingUnitsQueryVariables>;
export const GetSinglePlanDocument = gql`
    query getSinglePlan($id: ID!) {
  plan(id: $id) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetSinglePlanQuery__
 *
 * To run a query within a React component, call `useGetSinglePlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSinglePlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSinglePlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSinglePlanQuery(baseOptions: Apollo.QueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables> & ({ variables: GetSinglePlanQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
      }
export function useGetSinglePlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export function useGetSinglePlanSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export type GetSinglePlanQueryHookResult = ReturnType<typeof useGetSinglePlanQuery>;
export type GetSinglePlanLazyQueryHookResult = ReturnType<typeof useGetSinglePlanLazyQuery>;
export type GetSinglePlanSuspenseQueryHookResult = ReturnType<typeof useGetSinglePlanSuspenseQuery>;
export type GetSinglePlanQueryResult = Apollo.QueryResult<GetSinglePlanQuery, GetSinglePlanQueryVariables>;
export const CreatePlanDocument = gql`
    mutation createPlan($input: CreatePlanInput!) {
  createPlan(input: $input) {
    id
  }
}
    `;
export type CreatePlanMutationFn = Apollo.MutationFunction<CreatePlanMutation, CreatePlanMutationVariables>;

/**
 * __useCreatePlanMutation__
 *
 * To run a mutation, you first call `useCreatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlanMutation, { data, loading, error }] = useCreatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlanMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlanMutation, CreatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlanMutation, CreatePlanMutationVariables>(CreatePlanDocument, options);
      }
export type CreatePlanMutationHookResult = ReturnType<typeof useCreatePlanMutation>;
export type CreatePlanMutationResult = Apollo.MutationResult<CreatePlanMutation>;
export type CreatePlanMutationOptions = Apollo.BaseMutationOptions<CreatePlanMutation, CreatePlanMutationVariables>;
export const UpdatePlanDocument = gql`
    mutation updatePlan($input: UpdatePlanInput!) {
  updatePlan(input: $input) {
    ...PlanItem
    ...DeletePlanDialog
    ...EditPlan
  }
}
    ${PlanItemFragmentDoc}
${DeletePlanDialogFragmentDoc}
${EditPlanFragmentDoc}`;
export type UpdatePlanMutationFn = Apollo.MutationFunction<UpdatePlanMutation, UpdatePlanMutationVariables>;

/**
 * __useUpdatePlanMutation__
 *
 * To run a mutation, you first call `useUpdatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePlanMutation, { data, loading, error }] = useUpdatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePlanMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePlanMutation, UpdatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePlanMutation, UpdatePlanMutationVariables>(UpdatePlanDocument, options);
      }
export type UpdatePlanMutationHookResult = ReturnType<typeof useUpdatePlanMutation>;
export type UpdatePlanMutationResult = Apollo.MutationResult<UpdatePlanMutation>;
export type UpdatePlanMutationOptions = Apollo.BaseMutationOptions<UpdatePlanMutation, UpdatePlanMutationVariables>;
export const GetInvoiceCreateCreditNoteDocument = gql`
    query getInvoiceCreateCreditNote($id: ID!) {
  invoice(id: $id) {
    ...InvoiceCreateCreditNote
  }
}
    ${InvoiceCreateCreditNoteFragmentDoc}`;

/**
 * __useGetInvoiceCreateCreditNoteQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreateCreditNoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreateCreditNoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreateCreditNoteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceCreateCreditNoteQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables> & ({ variables: GetInvoiceCreateCreditNoteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
      }
export function useGetInvoiceCreateCreditNoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export function useGetInvoiceCreateCreditNoteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export type GetInvoiceCreateCreditNoteQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteQuery>;
export type GetInvoiceCreateCreditNoteLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteLazyQuery>;
export type GetInvoiceCreateCreditNoteSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteSuspenseQuery>;
export type GetInvoiceCreateCreditNoteQueryResult = Apollo.QueryResult<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>;
export const CreateCreditNoteDocument = gql`
    mutation createCreditNote($input: CreateCreditNoteInput!) {
  createCreditNote(input: $input) {
    id
  }
}
    `;
export type CreateCreditNoteMutationFn = Apollo.MutationFunction<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;

/**
 * __useCreateCreditNoteMutation__
 *
 * To run a mutation, you first call `useCreateCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreditNoteMutation, { data, loading, error }] = useCreateCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>(CreateCreditNoteDocument, options);
      }
export type CreateCreditNoteMutationHookResult = ReturnType<typeof useCreateCreditNoteMutation>;
export type CreateCreditNoteMutationResult = Apollo.MutationResult<CreateCreditNoteMutation>;
export type CreateCreditNoteMutationOptions = Apollo.BaseMutationOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;
export const GetSingleAddOnDocument = gql`
    query getSingleAddOn($id: ID!) {
  addOn(id: $id) {
    ...EditAddOn
  }
}
    ${EditAddOnFragmentDoc}`;

/**
 * __useGetSingleAddOnQuery__
 *
 * To run a query within a React component, call `useGetSingleAddOnQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleAddOnQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleAddOnQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleAddOnQuery(baseOptions: Apollo.QueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables> & ({ variables: GetSingleAddOnQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
      }
export function useGetSingleAddOnLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export function useGetSingleAddOnSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export type GetSingleAddOnQueryHookResult = ReturnType<typeof useGetSingleAddOnQuery>;
export type GetSingleAddOnLazyQueryHookResult = ReturnType<typeof useGetSingleAddOnLazyQuery>;
export type GetSingleAddOnSuspenseQueryHookResult = ReturnType<typeof useGetSingleAddOnSuspenseQuery>;
export type GetSingleAddOnQueryResult = Apollo.QueryResult<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>;
export const CreateAddOnDocument = gql`
    mutation createAddOn($input: CreateAddOnInput!) {
  createAddOn(input: $input) {
    id
  }
}
    `;
export type CreateAddOnMutationFn = Apollo.MutationFunction<CreateAddOnMutation, CreateAddOnMutationVariables>;

/**
 * __useCreateAddOnMutation__
 *
 * To run a mutation, you first call `useCreateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAddOnMutation, { data, loading, error }] = useCreateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<CreateAddOnMutation, CreateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAddOnMutation, CreateAddOnMutationVariables>(CreateAddOnDocument, options);
      }
export type CreateAddOnMutationHookResult = ReturnType<typeof useCreateAddOnMutation>;
export type CreateAddOnMutationResult = Apollo.MutationResult<CreateAddOnMutation>;
export type CreateAddOnMutationOptions = Apollo.BaseMutationOptions<CreateAddOnMutation, CreateAddOnMutationVariables>;
export const UpdateAddOnDocument = gql`
    mutation updateAddOn($input: UpdateAddOnInput!) {
  updateAddOn(input: $input) {
    ...AddOnItem
  }
}
    ${AddOnItemFragmentDoc}`;
export type UpdateAddOnMutationFn = Apollo.MutationFunction<UpdateAddOnMutation, UpdateAddOnMutationVariables>;

/**
 * __useUpdateAddOnMutation__
 *
 * To run a mutation, you first call `useUpdateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAddOnMutation, { data, loading, error }] = useUpdateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAddOnMutation, UpdateAddOnMutationVariables>(UpdateAddOnDocument, options);
      }
export type UpdateAddOnMutationHookResult = ReturnType<typeof useUpdateAddOnMutation>;
export type UpdateAddOnMutationResult = Apollo.MutationResult<UpdateAddOnMutation>;
export type UpdateAddOnMutationOptions = Apollo.BaseMutationOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>;
export const GetSingleBillableMetricDocument = gql`
    query getSingleBillableMetric($id: ID!) {
  billableMetric(id: $id) {
    ...EditBillableMetric
  }
}
    ${EditBillableMetricFragmentDoc}`;

/**
 * __useGetSingleBillableMetricQuery__
 *
 * To run a query within a React component, call `useGetSingleBillableMetricQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleBillableMetricQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleBillableMetricQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleBillableMetricQuery(baseOptions: Apollo.QueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables> & ({ variables: GetSingleBillableMetricQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
      }
export function useGetSingleBillableMetricLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export function useGetSingleBillableMetricSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export type GetSingleBillableMetricQueryHookResult = ReturnType<typeof useGetSingleBillableMetricQuery>;
export type GetSingleBillableMetricLazyQueryHookResult = ReturnType<typeof useGetSingleBillableMetricLazyQuery>;
export type GetSingleBillableMetricSuspenseQueryHookResult = ReturnType<typeof useGetSingleBillableMetricSuspenseQuery>;
export type GetSingleBillableMetricQueryResult = Apollo.QueryResult<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>;
export const CreateBillableMetricDocument = gql`
    mutation createBillableMetric($input: CreateBillableMetricInput!) {
  createBillableMetric(input: $input) {
    id
  }
}
    `;
export type CreateBillableMetricMutationFn = Apollo.MutationFunction<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;

/**
 * __useCreateBillableMetricMutation__
 *
 * To run a mutation, you first call `useCreateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillableMetricMutation, { data, loading, error }] = useCreateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>(CreateBillableMetricDocument, options);
      }
export type CreateBillableMetricMutationHookResult = ReturnType<typeof useCreateBillableMetricMutation>;
export type CreateBillableMetricMutationResult = Apollo.MutationResult<CreateBillableMetricMutation>;
export type CreateBillableMetricMutationOptions = Apollo.BaseMutationOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;
export const UpdateBillableMetricDocument = gql`
    mutation updateBillableMetric($input: UpdateBillableMetricInput!) {
  updateBillableMetric(input: $input) {
    ...BillableMetricItem
  }
}
    ${BillableMetricItemFragmentDoc}`;
export type UpdateBillableMetricMutationFn = Apollo.MutationFunction<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;

/**
 * __useUpdateBillableMetricMutation__
 *
 * To run a mutation, you first call `useUpdateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillableMetricMutation, { data, loading, error }] = useUpdateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>(UpdateBillableMetricDocument, options);
      }
export type UpdateBillableMetricMutationHookResult = ReturnType<typeof useUpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationResult = Apollo.MutationResult<UpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationOptions = Apollo.BaseMutationOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;
export const GetBillingEntitiesDocument = gql`
    query getBillingEntities {
  billingEntities {
    collection {
      ...BillingEntityItem
    }
  }
}
    ${BillingEntityItemFragmentDoc}`;

/**
 * __useGetBillingEntitiesQuery__
 *
 * To run a query within a React component, call `useGetBillingEntitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillingEntitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillingEntitiesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetBillingEntitiesQuery(baseOptions?: Apollo.QueryHookOptions<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>(GetBillingEntitiesDocument, options);
      }
export function useGetBillingEntitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>(GetBillingEntitiesDocument, options);
        }
export function useGetBillingEntitiesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>(GetBillingEntitiesDocument, options);
        }
export type GetBillingEntitiesQueryHookResult = ReturnType<typeof useGetBillingEntitiesQuery>;
export type GetBillingEntitiesLazyQueryHookResult = ReturnType<typeof useGetBillingEntitiesLazyQuery>;
export type GetBillingEntitiesSuspenseQueryHookResult = ReturnType<typeof useGetBillingEntitiesSuspenseQuery>;
export type GetBillingEntitiesQueryResult = Apollo.QueryResult<GetBillingEntitiesQuery, GetBillingEntitiesQueryVariables>;
export const GetBillingEntityDocument = gql`
    query getBillingEntity($code: String!) {
  billingEntity(code: $code) {
    ...BillingEntityItem
  }
}
    ${BillingEntityItemFragmentDoc}`;

/**
 * __useGetBillingEntityQuery__
 *
 * To run a query within a React component, call `useGetBillingEntityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillingEntityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillingEntityQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetBillingEntityQuery(baseOptions: Apollo.QueryHookOptions<GetBillingEntityQuery, GetBillingEntityQueryVariables> & ({ variables: GetBillingEntityQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillingEntityQuery, GetBillingEntityQueryVariables>(GetBillingEntityDocument, options);
      }
export function useGetBillingEntityLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillingEntityQuery, GetBillingEntityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillingEntityQuery, GetBillingEntityQueryVariables>(GetBillingEntityDocument, options);
        }
export function useGetBillingEntitySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillingEntityQuery, GetBillingEntityQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillingEntityQuery, GetBillingEntityQueryVariables>(GetBillingEntityDocument, options);
        }
export type GetBillingEntityQueryHookResult = ReturnType<typeof useGetBillingEntityQuery>;
export type GetBillingEntityLazyQueryHookResult = ReturnType<typeof useGetBillingEntityLazyQuery>;
export type GetBillingEntitySuspenseQueryHookResult = ReturnType<typeof useGetBillingEntitySuspenseQuery>;
export type GetBillingEntityQueryResult = Apollo.QueryResult<GetBillingEntityQuery, GetBillingEntityQueryVariables>;
export const CreateBillingEntityDocument = gql`
    mutation createBillingEntity($input: CreateBillingEntityInput!) {
  createBillingEntity(input: $input) {
    ...BillingEntityItem
  }
}
    ${BillingEntityItemFragmentDoc}`;
export type CreateBillingEntityMutationFn = Apollo.MutationFunction<CreateBillingEntityMutation, CreateBillingEntityMutationVariables>;

/**
 * __useCreateBillingEntityMutation__
 *
 * To run a mutation, you first call `useCreateBillingEntityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillingEntityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillingEntityMutation, { data, loading, error }] = useCreateBillingEntityMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillingEntityMutation(baseOptions?: Apollo.MutationHookOptions<CreateBillingEntityMutation, CreateBillingEntityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBillingEntityMutation, CreateBillingEntityMutationVariables>(CreateBillingEntityDocument, options);
      }
export type CreateBillingEntityMutationHookResult = ReturnType<typeof useCreateBillingEntityMutation>;
export type CreateBillingEntityMutationResult = Apollo.MutationResult<CreateBillingEntityMutation>;
export type CreateBillingEntityMutationOptions = Apollo.BaseMutationOptions<CreateBillingEntityMutation, CreateBillingEntityMutationVariables>;
export const UpdateBillingEntityDocument = gql`
    mutation updateBillingEntity($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    ...BillingEntityItem
  }
}
    ${BillingEntityItemFragmentDoc}`;
export type UpdateBillingEntityMutationFn = Apollo.MutationFunction<UpdateBillingEntityMutation, UpdateBillingEntityMutationVariables>;

/**
 * __useUpdateBillingEntityMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityMutation, { data, loading, error }] = useUpdateBillingEntityMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityMutation, UpdateBillingEntityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityMutation, UpdateBillingEntityMutationVariables>(UpdateBillingEntityDocument, options);
      }
export type UpdateBillingEntityMutationHookResult = ReturnType<typeof useUpdateBillingEntityMutation>;
export type UpdateBillingEntityMutationResult = Apollo.MutationResult<UpdateBillingEntityMutation>;
export type UpdateBillingEntityMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityMutation, UpdateBillingEntityMutationVariables>;
export const GetSingleCouponDocument = gql`
    query getSingleCoupon($id: ID!) {
  coupon(id: $id) {
    ...EditCoupon
  }
}
    ${EditCouponFragmentDoc}`;

/**
 * __useGetSingleCouponQuery__
 *
 * To run a query within a React component, call `useGetSingleCouponQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleCouponQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleCouponQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleCouponQuery(baseOptions: Apollo.QueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables> & ({ variables: GetSingleCouponQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
      }
export function useGetSingleCouponLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export function useGetSingleCouponSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export type GetSingleCouponQueryHookResult = ReturnType<typeof useGetSingleCouponQuery>;
export type GetSingleCouponLazyQueryHookResult = ReturnType<typeof useGetSingleCouponLazyQuery>;
export type GetSingleCouponSuspenseQueryHookResult = ReturnType<typeof useGetSingleCouponSuspenseQuery>;
export type GetSingleCouponQueryResult = Apollo.QueryResult<GetSingleCouponQuery, GetSingleCouponQueryVariables>;
export const CreateCouponDocument = gql`
    mutation createCoupon($input: CreateCouponInput!) {
  createCoupon(input: $input) {
    id
  }
}
    `;
export type CreateCouponMutationFn = Apollo.MutationFunction<CreateCouponMutation, CreateCouponMutationVariables>;

/**
 * __useCreateCouponMutation__
 *
 * To run a mutation, you first call `useCreateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCouponMutation, { data, loading, error }] = useCreateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCouponMutation(baseOptions?: Apollo.MutationHookOptions<CreateCouponMutation, CreateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCouponMutation, CreateCouponMutationVariables>(CreateCouponDocument, options);
      }
export type CreateCouponMutationHookResult = ReturnType<typeof useCreateCouponMutation>;
export type CreateCouponMutationResult = Apollo.MutationResult<CreateCouponMutation>;
export type CreateCouponMutationOptions = Apollo.BaseMutationOptions<CreateCouponMutation, CreateCouponMutationVariables>;
export const UpdateCouponDocument = gql`
    mutation updateCoupon($input: UpdateCouponInput!) {
  updateCoupon(input: $input) {
    ...CouponItem
  }
}
    ${CouponItemFragmentDoc}`;
export type UpdateCouponMutationFn = Apollo.MutationFunction<UpdateCouponMutation, UpdateCouponMutationVariables>;

/**
 * __useUpdateCouponMutation__
 *
 * To run a mutation, you first call `useUpdateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCouponMutation, { data, loading, error }] = useUpdateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCouponMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCouponMutation, UpdateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCouponMutation, UpdateCouponMutationVariables>(UpdateCouponDocument, options);
      }
export type UpdateCouponMutationHookResult = ReturnType<typeof useUpdateCouponMutation>;
export type UpdateCouponMutationResult = Apollo.MutationResult<UpdateCouponMutation>;
export type UpdateCouponMutationOptions = Apollo.BaseMutationOptions<UpdateCouponMutation, UpdateCouponMutationVariables>;
export const CreateCustomerDocument = gql`
    mutation createCustomer($input: CreateCustomerInput!) {
  createCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type CreateCustomerMutationFn = Apollo.MutationFunction<CreateCustomerMutation, CreateCustomerMutationVariables>;

/**
 * __useCreateCustomerMutation__
 *
 * To run a mutation, you first call `useCreateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerMutation, { data, loading, error }] = useCreateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerMutation, CreateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerMutation, CreateCustomerMutationVariables>(CreateCustomerDocument, options);
      }
export type CreateCustomerMutationHookResult = ReturnType<typeof useCreateCustomerMutation>;
export type CreateCustomerMutationResult = Apollo.MutationResult<CreateCustomerMutation>;
export type CreateCustomerMutationOptions = Apollo.BaseMutationOptions<CreateCustomerMutation, CreateCustomerMutationVariables>;
export const UpdateCustomerDocument = gql`
    mutation updateCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type UpdateCustomerMutationFn = Apollo.MutationFunction<UpdateCustomerMutation, UpdateCustomerMutationVariables>;

/**
 * __useUpdateCustomerMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerMutation, { data, loading, error }] = useUpdateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerMutation, UpdateCustomerMutationVariables>(UpdateCustomerDocument, options);
      }
export type UpdateCustomerMutationHookResult = ReturnType<typeof useUpdateCustomerMutation>;
export type UpdateCustomerMutationResult = Apollo.MutationResult<UpdateCustomerMutation>;
export type UpdateCustomerMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>;
export const GetSingleCustomerDocument = gql`
    query GetSingleCustomer($id: ID!) {
  customer(id: $id) {
    id
    ...AddCustomerDrawer
  }
}
    ${AddCustomerDrawerFragmentDoc}`;

/**
 * __useGetSingleCustomerQuery__
 *
 * To run a query within a React component, call `useGetSingleCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleCustomerQuery(baseOptions: Apollo.QueryHookOptions<GetSingleCustomerQuery, GetSingleCustomerQueryVariables> & ({ variables: GetSingleCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>(GetSingleCustomerDocument, options);
      }
export function useGetSingleCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>(GetSingleCustomerDocument, options);
        }
export function useGetSingleCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>(GetSingleCustomerDocument, options);
        }
export type GetSingleCustomerQueryHookResult = ReturnType<typeof useGetSingleCustomerQuery>;
export type GetSingleCustomerLazyQueryHookResult = ReturnType<typeof useGetSingleCustomerLazyQuery>;
export type GetSingleCustomerSuspenseQueryHookResult = ReturnType<typeof useGetSingleCustomerSuspenseQuery>;
export type GetSingleCustomerQueryResult = Apollo.QueryResult<GetSingleCustomerQuery, GetSingleCustomerQueryVariables>;
export const GetSingleCampaignDocument = gql`
    query GetSingleCampaign($id: ID!) {
  dunningCampaign(id: $id) {
    id
    ...DunningCampaignForm
  }
}
    ${DunningCampaignFormFragmentDoc}`;

/**
 * __useGetSingleCampaignQuery__
 *
 * To run a query within a React component, call `useGetSingleCampaignQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleCampaignQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleCampaignQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleCampaignQuery(baseOptions: Apollo.QueryHookOptions<GetSingleCampaignQuery, GetSingleCampaignQueryVariables> & ({ variables: GetSingleCampaignQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>(GetSingleCampaignDocument, options);
      }
export function useGetSingleCampaignLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>(GetSingleCampaignDocument, options);
        }
export function useGetSingleCampaignSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>(GetSingleCampaignDocument, options);
        }
export type GetSingleCampaignQueryHookResult = ReturnType<typeof useGetSingleCampaignQuery>;
export type GetSingleCampaignLazyQueryHookResult = ReturnType<typeof useGetSingleCampaignLazyQuery>;
export type GetSingleCampaignSuspenseQueryHookResult = ReturnType<typeof useGetSingleCampaignSuspenseQuery>;
export type GetSingleCampaignQueryResult = Apollo.QueryResult<GetSingleCampaignQuery, GetSingleCampaignQueryVariables>;
export const CreateDunningCampaignPaymentProviderDocument = gql`
    query CreateDunningCampaignPaymentProvider {
  paymentProviders {
    collection {
      __typename
    }
  }
}
    `;

/**
 * __useCreateDunningCampaignPaymentProviderQuery__
 *
 * To run a query within a React component, call `useCreateDunningCampaignPaymentProviderQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateDunningCampaignPaymentProviderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateDunningCampaignPaymentProviderQuery({
 *   variables: {
 *   },
 * });
 */
export function useCreateDunningCampaignPaymentProviderQuery(baseOptions?: Apollo.QueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
      }
export function useCreateDunningCampaignPaymentProviderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
        }
export function useCreateDunningCampaignPaymentProviderSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
        }
export type CreateDunningCampaignPaymentProviderQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderQuery>;
export type CreateDunningCampaignPaymentProviderLazyQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderLazyQuery>;
export type CreateDunningCampaignPaymentProviderSuspenseQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderSuspenseQuery>;
export type CreateDunningCampaignPaymentProviderQueryResult = Apollo.QueryResult<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>;
export const CreateDunningCampaignDocument = gql`
    mutation CreateDunningCampaign($input: CreateDunningCampaignInput!) {
  createDunningCampaign(input: $input) {
    id
    ...DunningCampaignForm
  }
}
    ${DunningCampaignFormFragmentDoc}`;
export type CreateDunningCampaignMutationFn = Apollo.MutationFunction<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>;

/**
 * __useCreateDunningCampaignMutation__
 *
 * To run a mutation, you first call `useCreateDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDunningCampaignMutation, { data, loading, error }] = useCreateDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>(CreateDunningCampaignDocument, options);
      }
export type CreateDunningCampaignMutationHookResult = ReturnType<typeof useCreateDunningCampaignMutation>;
export type CreateDunningCampaignMutationResult = Apollo.MutationResult<CreateDunningCampaignMutation>;
export type CreateDunningCampaignMutationOptions = Apollo.BaseMutationOptions<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>;
export const UpdateDunningCampaignDocument = gql`
    mutation UpdateDunningCampaign($input: UpdateDunningCampaignInput!) {
  updateDunningCampaign(input: $input) {
    id
    ...DunningCampaignForm
  }
}
    ${DunningCampaignFormFragmentDoc}`;
export type UpdateDunningCampaignMutationFn = Apollo.MutationFunction<UpdateDunningCampaignMutation, UpdateDunningCampaignMutationVariables>;

/**
 * __useUpdateDunningCampaignMutation__
 *
 * To run a mutation, you first call `useUpdateDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDunningCampaignMutation, { data, loading, error }] = useUpdateDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDunningCampaignMutation, UpdateDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDunningCampaignMutation, UpdateDunningCampaignMutationVariables>(UpdateDunningCampaignDocument, options);
      }
export type UpdateDunningCampaignMutationHookResult = ReturnType<typeof useUpdateDunningCampaignMutation>;
export type UpdateDunningCampaignMutationResult = Apollo.MutationResult<UpdateDunningCampaignMutation>;
export type UpdateDunningCampaignMutationOptions = Apollo.BaseMutationOptions<UpdateDunningCampaignMutation, UpdateDunningCampaignMutationVariables>;
export const GetSingleInvoiceCustomSectionDocument = gql`
    query getSingleInvoiceCustomSection($id: ID!) {
  invoiceCustomSection(id: $id) {
    id
    ...InvoiceCustomSectionForm
  }
}
    ${InvoiceCustomSectionFormFragmentDoc}`;

/**
 * __useGetSingleInvoiceCustomSectionQuery__
 *
 * To run a query within a React component, call `useGetSingleInvoiceCustomSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleInvoiceCustomSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleInvoiceCustomSectionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleInvoiceCustomSectionQuery(baseOptions: Apollo.QueryHookOptions<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables> & ({ variables: GetSingleInvoiceCustomSectionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>(GetSingleInvoiceCustomSectionDocument, options);
      }
export function useGetSingleInvoiceCustomSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>(GetSingleInvoiceCustomSectionDocument, options);
        }
export function useGetSingleInvoiceCustomSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>(GetSingleInvoiceCustomSectionDocument, options);
        }
export type GetSingleInvoiceCustomSectionQueryHookResult = ReturnType<typeof useGetSingleInvoiceCustomSectionQuery>;
export type GetSingleInvoiceCustomSectionLazyQueryHookResult = ReturnType<typeof useGetSingleInvoiceCustomSectionLazyQuery>;
export type GetSingleInvoiceCustomSectionSuspenseQueryHookResult = ReturnType<typeof useGetSingleInvoiceCustomSectionSuspenseQuery>;
export type GetSingleInvoiceCustomSectionQueryResult = Apollo.QueryResult<GetSingleInvoiceCustomSectionQuery, GetSingleInvoiceCustomSectionQueryVariables>;
export const CreateInvoiceCustomSectionDocument = gql`
    mutation createInvoiceCustomSection($input: CreateInvoiceCustomSectionInput!) {
  createInvoiceCustomSection(input: $input) {
    id
    ...InvoiceCustomSectionForm
  }
}
    ${InvoiceCustomSectionFormFragmentDoc}`;
export type CreateInvoiceCustomSectionMutationFn = Apollo.MutationFunction<CreateInvoiceCustomSectionMutation, CreateInvoiceCustomSectionMutationVariables>;

/**
 * __useCreateInvoiceCustomSectionMutation__
 *
 * To run a mutation, you first call `useCreateInvoiceCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoiceCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoiceCustomSectionMutation, { data, loading, error }] = useCreateInvoiceCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoiceCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoiceCustomSectionMutation, CreateInvoiceCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoiceCustomSectionMutation, CreateInvoiceCustomSectionMutationVariables>(CreateInvoiceCustomSectionDocument, options);
      }
export type CreateInvoiceCustomSectionMutationHookResult = ReturnType<typeof useCreateInvoiceCustomSectionMutation>;
export type CreateInvoiceCustomSectionMutationResult = Apollo.MutationResult<CreateInvoiceCustomSectionMutation>;
export type CreateInvoiceCustomSectionMutationOptions = Apollo.BaseMutationOptions<CreateInvoiceCustomSectionMutation, CreateInvoiceCustomSectionMutationVariables>;
export const UpdateInvoiceCustomSectionDocument = gql`
    mutation updateInvoiceCustomSection($input: UpdateInvoiceCustomSectionInput!) {
  updateInvoiceCustomSection(input: $input) {
    id
    ...InvoiceCustomSectionForm
  }
}
    ${InvoiceCustomSectionFormFragmentDoc}`;
export type UpdateInvoiceCustomSectionMutationFn = Apollo.MutationFunction<UpdateInvoiceCustomSectionMutation, UpdateInvoiceCustomSectionMutationVariables>;

/**
 * __useUpdateInvoiceCustomSectionMutation__
 *
 * To run a mutation, you first call `useUpdateInvoiceCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoiceCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoiceCustomSectionMutation, { data, loading, error }] = useUpdateInvoiceCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoiceCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoiceCustomSectionMutation, UpdateInvoiceCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoiceCustomSectionMutation, UpdateInvoiceCustomSectionMutationVariables>(UpdateInvoiceCustomSectionDocument, options);
      }
export type UpdateInvoiceCustomSectionMutationHookResult = ReturnType<typeof useUpdateInvoiceCustomSectionMutation>;
export type UpdateInvoiceCustomSectionMutationResult = Apollo.MutationResult<UpdateInvoiceCustomSectionMutation>;
export type UpdateInvoiceCustomSectionMutationOptions = Apollo.BaseMutationOptions<UpdateInvoiceCustomSectionMutation, UpdateInvoiceCustomSectionMutationVariables>;
export const GetSingleTaxDocument = gql`
    query getSingleTax($id: ID!) {
  tax(id: $id) {
    id
    autoGenerated
    ...TaxFormQueryShape
  }
}
    ${TaxFormQueryShapeFragmentDoc}`;

/**
 * __useGetSingleTaxQuery__
 *
 * To run a query within a React component, call `useGetSingleTaxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleTaxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleTaxQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleTaxQuery(baseOptions: Apollo.QueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables> & ({ variables: GetSingleTaxQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
      }
export function useGetSingleTaxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export function useGetSingleTaxSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export type GetSingleTaxQueryHookResult = ReturnType<typeof useGetSingleTaxQuery>;
export type GetSingleTaxLazyQueryHookResult = ReturnType<typeof useGetSingleTaxLazyQuery>;
export type GetSingleTaxSuspenseQueryHookResult = ReturnType<typeof useGetSingleTaxSuspenseQuery>;
export type GetSingleTaxQueryResult = Apollo.QueryResult<GetSingleTaxQuery, GetSingleTaxQueryVariables>;
export const CreateTaxDocument = gql`
    mutation createTax($input: TaxCreateInput!) {
  createTax(input: $input) {
    id
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type CreateTaxMutationFn = Apollo.MutationFunction<CreateTaxMutation, CreateTaxMutationVariables>;

/**
 * __useCreateTaxMutation__
 *
 * To run a mutation, you first call `useCreateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTaxMutation, { data, loading, error }] = useCreateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateTaxMutation, CreateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTaxMutation, CreateTaxMutationVariables>(CreateTaxDocument, options);
      }
export type CreateTaxMutationHookResult = ReturnType<typeof useCreateTaxMutation>;
export type CreateTaxMutationResult = Apollo.MutationResult<CreateTaxMutation>;
export type CreateTaxMutationOptions = Apollo.BaseMutationOptions<CreateTaxMutation, CreateTaxMutationVariables>;
export const UpdateTaxDocument = gql`
    mutation updateTax($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type UpdateTaxMutationFn = Apollo.MutationFunction<UpdateTaxMutation, UpdateTaxMutationVariables>;

/**
 * __useUpdateTaxMutation__
 *
 * To run a mutation, you first call `useUpdateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTaxMutation, { data, loading, error }] = useUpdateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTaxMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTaxMutation, UpdateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTaxMutation, UpdateTaxMutationVariables>(UpdateTaxDocument, options);
      }
export type UpdateTaxMutationHookResult = ReturnType<typeof useUpdateTaxMutation>;
export type UpdateTaxMutationResult = Apollo.MutationResult<UpdateTaxMutation>;
export type UpdateTaxMutationOptions = Apollo.BaseMutationOptions<UpdateTaxMutation, UpdateTaxMutationVariables>;
export const GetCurrentUserInfosDocument = gql`
    query getCurrentUserInfos {
  currentUser {
    ...CurrentUserInfos
  }
}
    ${CurrentUserInfosFragmentDoc}`;

/**
 * __useGetCurrentUserInfosQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
      }
export function useGetCurrentUserInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export function useGetCurrentUserInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export type GetCurrentUserInfosQueryHookResult = ReturnType<typeof useGetCurrentUserInfosQuery>;
export type GetCurrentUserInfosLazyQueryHookResult = ReturnType<typeof useGetCurrentUserInfosLazyQuery>;
export type GetCurrentUserInfosSuspenseQueryHookResult = ReturnType<typeof useGetCurrentUserInfosSuspenseQuery>;
export type GetCurrentUserInfosQueryResult = Apollo.QueryResult<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>;
export const UpdateBillingEntityEmailSettingDocument = gql`
    mutation updateBillingEntityEmailSetting($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    emailSettings
  }
}
    `;
export type UpdateBillingEntityEmailSettingMutationFn = Apollo.MutationFunction<UpdateBillingEntityEmailSettingMutation, UpdateBillingEntityEmailSettingMutationVariables>;

/**
 * __useUpdateBillingEntityEmailSettingMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityEmailSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityEmailSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityEmailSettingMutation, { data, loading, error }] = useUpdateBillingEntityEmailSettingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityEmailSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityEmailSettingMutation, UpdateBillingEntityEmailSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityEmailSettingMutation, UpdateBillingEntityEmailSettingMutationVariables>(UpdateBillingEntityEmailSettingDocument, options);
      }
export type UpdateBillingEntityEmailSettingMutationHookResult = ReturnType<typeof useUpdateBillingEntityEmailSettingMutation>;
export type UpdateBillingEntityEmailSettingMutationResult = Apollo.MutationResult<UpdateBillingEntityEmailSettingMutation>;
export type UpdateBillingEntityEmailSettingMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityEmailSettingMutation, UpdateBillingEntityEmailSettingMutationVariables>;
export const GetTaxProviderPresenceDocument = gql`
    query getTaxProviderPresence($limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    `;

/**
 * __useGetTaxProviderPresenceQuery__
 *
 * To run a query within a React component, call `useGetTaxProviderPresenceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxProviderPresenceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxProviderPresenceQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetTaxProviderPresenceQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
      }
export function useGetTaxProviderPresenceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
        }
export function useGetTaxProviderPresenceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
        }
export type GetTaxProviderPresenceQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceQuery>;
export type GetTaxProviderPresenceLazyQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceLazyQuery>;
export type GetTaxProviderPresenceSuspenseQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceSuspenseQuery>;
export type GetTaxProviderPresenceQueryResult = Apollo.QueryResult<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>;
export const GetOrganizationInfosDocument = gql`
    query getOrganizationInfos {
  organization {
    ...MainOrganizationInfos
  }
}
    ${MainOrganizationInfosFragmentDoc}`;

/**
 * __useGetOrganizationInfosQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
      }
export function useGetOrganizationInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export function useGetOrganizationInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export type GetOrganizationInfosQueryHookResult = ReturnType<typeof useGetOrganizationInfosQuery>;
export type GetOrganizationInfosLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfosLazyQuery>;
export type GetOrganizationInfosSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfosSuspenseQuery>;
export type GetOrganizationInfosQueryResult = Apollo.QueryResult<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>;
export const SideNavInfosDocument = gql`
    query SideNavInfos {
  currentVersion {
    githubUrl
    number
  }
}
    `;

/**
 * __useSideNavInfosQuery__
 *
 * To run a query within a React component, call `useSideNavInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useSideNavInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSideNavInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useSideNavInfosQuery(baseOptions?: Apollo.QueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
      }
export function useSideNavInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export function useSideNavInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export type SideNavInfosQueryHookResult = ReturnType<typeof useSideNavInfosQuery>;
export type SideNavInfosLazyQueryHookResult = ReturnType<typeof useSideNavInfosLazyQuery>;
export type SideNavInfosSuspenseQueryHookResult = ReturnType<typeof useSideNavInfosSuspenseQuery>;
export type SideNavInfosQueryResult = Apollo.QueryResult<SideNavInfosQuery, SideNavInfosQueryVariables>;
export const GetAddOnForDetailsDocument = gql`
    query getAddOnForDetails($addOn: ID!) {
  addOn(id: $addOn) {
    id
    name
    amountCents
    amountCurrency
    code
    taxes {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetAddOnForDetailsQuery__
 *
 * To run a query within a React component, call `useGetAddOnForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnForDetailsQuery({
 *   variables: {
 *      addOn: // value for 'addOn'
 *   },
 * });
 */
export function useGetAddOnForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables> & ({ variables: GetAddOnForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
      }
export function useGetAddOnForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export function useGetAddOnForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export type GetAddOnForDetailsQueryHookResult = ReturnType<typeof useGetAddOnForDetailsQuery>;
export type GetAddOnForDetailsLazyQueryHookResult = ReturnType<typeof useGetAddOnForDetailsLazyQuery>;
export type GetAddOnForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAddOnForDetailsSuspenseQuery>;
export type GetAddOnForDetailsQueryResult = Apollo.QueryResult<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>;
export const AddOnsDocument = gql`
    query addOns($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AddOnItem
    }
  }
}
    ${AddOnItemFragmentDoc}`;

/**
 * __useAddOnsQuery__
 *
 * To run a query within a React component, call `useAddOnsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddOnsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddOnsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useAddOnsQuery(baseOptions?: Apollo.QueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
      }
export function useAddOnsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export function useAddOnsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export type AddOnsQueryHookResult = ReturnType<typeof useAddOnsQuery>;
export type AddOnsLazyQueryHookResult = ReturnType<typeof useAddOnsLazyQuery>;
export type AddOnsSuspenseQueryHookResult = ReturnType<typeof useAddOnsSuspenseQuery>;
export type AddOnsQueryResult = Apollo.QueryResult<AddOnsQuery, AddOnsQueryVariables>;
export const GetSubscriptionInfosDocument = gql`
    query getSubscriptionInfos($id: ID!) {
  subscription(id: $id) {
    id
    externalId
    plan {
      id
      amountCurrency
    }
  }
}
    `;

/**
 * __useGetSubscriptionInfosQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionInfosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSubscriptionInfosQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables> & ({ variables: GetSubscriptionInfosQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>(GetSubscriptionInfosDocument, options);
      }
export function useGetSubscriptionInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>(GetSubscriptionInfosDocument, options);
        }
export function useGetSubscriptionInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>(GetSubscriptionInfosDocument, options);
        }
export type GetSubscriptionInfosQueryHookResult = ReturnType<typeof useGetSubscriptionInfosQuery>;
export type GetSubscriptionInfosLazyQueryHookResult = ReturnType<typeof useGetSubscriptionInfosLazyQuery>;
export type GetSubscriptionInfosSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionInfosSuspenseQuery>;
export type GetSubscriptionInfosQueryResult = Apollo.QueryResult<GetSubscriptionInfosQuery, GetSubscriptionInfosQueryVariables>;
export const GetSubscriptionAlertToEditDocument = gql`
    query getSubscriptionAlertToEdit($id: ID!) {
  alert(id: $id) {
    id
    alertType
    billableMetric {
      id
      code
      name
    }
    code
    name
    thresholds {
      code
      recurring
      value
    }
  }
}
    `;

/**
 * __useGetSubscriptionAlertToEditQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionAlertToEditQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionAlertToEditQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionAlertToEditQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSubscriptionAlertToEditQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables> & ({ variables: GetSubscriptionAlertToEditQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>(GetSubscriptionAlertToEditDocument, options);
      }
export function useGetSubscriptionAlertToEditLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>(GetSubscriptionAlertToEditDocument, options);
        }
export function useGetSubscriptionAlertToEditSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>(GetSubscriptionAlertToEditDocument, options);
        }
export type GetSubscriptionAlertToEditQueryHookResult = ReturnType<typeof useGetSubscriptionAlertToEditQuery>;
export type GetSubscriptionAlertToEditLazyQueryHookResult = ReturnType<typeof useGetSubscriptionAlertToEditLazyQuery>;
export type GetSubscriptionAlertToEditSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionAlertToEditSuspenseQuery>;
export type GetSubscriptionAlertToEditQueryResult = Apollo.QueryResult<GetSubscriptionAlertToEditQuery, GetSubscriptionAlertToEditQueryVariables>;
export const GetExistingAlertsOfSubscriptionDocument = gql`
    query getExistingAlertsOfSubscription($subscriptionExternalId: String!, $limit: Int) {
  alerts(subscriptionExternalId: $subscriptionExternalId, limit: $limit) {
    collection {
      id
      alertType
      billableMetricId
    }
  }
}
    `;

/**
 * __useGetExistingAlertsOfSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetExistingAlertsOfSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExistingAlertsOfSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExistingAlertsOfSubscriptionQuery({
 *   variables: {
 *      subscriptionExternalId: // value for 'subscriptionExternalId'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetExistingAlertsOfSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables> & ({ variables: GetExistingAlertsOfSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>(GetExistingAlertsOfSubscriptionDocument, options);
      }
export function useGetExistingAlertsOfSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>(GetExistingAlertsOfSubscriptionDocument, options);
        }
export function useGetExistingAlertsOfSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>(GetExistingAlertsOfSubscriptionDocument, options);
        }
export type GetExistingAlertsOfSubscriptionQueryHookResult = ReturnType<typeof useGetExistingAlertsOfSubscriptionQuery>;
export type GetExistingAlertsOfSubscriptionLazyQueryHookResult = ReturnType<typeof useGetExistingAlertsOfSubscriptionLazyQuery>;
export type GetExistingAlertsOfSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetExistingAlertsOfSubscriptionSuspenseQuery>;
export type GetExistingAlertsOfSubscriptionQueryResult = Apollo.QueryResult<GetExistingAlertsOfSubscriptionQuery, GetExistingAlertsOfSubscriptionQueryVariables>;
export const GetSubscriptionBillableMetricsDocument = gql`
    query getSubscriptionBillableMetrics($page: Int, $limit: Int, $searchTerm: String, $planId: ID) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    planId: $planId
  ) {
    collection {
      id
      code
      name
    }
  }
}
    `;

/**
 * __useGetSubscriptionBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      planId: // value for 'planId'
 *   },
 * });
 */
export function useGetSubscriptionBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>(GetSubscriptionBillableMetricsDocument, options);
      }
export function useGetSubscriptionBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>(GetSubscriptionBillableMetricsDocument, options);
        }
export function useGetSubscriptionBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>(GetSubscriptionBillableMetricsDocument, options);
        }
export type GetSubscriptionBillableMetricsQueryHookResult = ReturnType<typeof useGetSubscriptionBillableMetricsQuery>;
export type GetSubscriptionBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetSubscriptionBillableMetricsLazyQuery>;
export type GetSubscriptionBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionBillableMetricsSuspenseQuery>;
export type GetSubscriptionBillableMetricsQueryResult = Apollo.QueryResult<GetSubscriptionBillableMetricsQuery, GetSubscriptionBillableMetricsQueryVariables>;
export const CreateSubscriptionAlertDocument = gql`
    mutation createSubscriptionAlert($input: CreateSubscriptionAlertInput!) {
  createSubscriptionAlert(input: $input) {
    id
  }
}
    `;
export type CreateSubscriptionAlertMutationFn = Apollo.MutationFunction<CreateSubscriptionAlertMutation, CreateSubscriptionAlertMutationVariables>;

/**
 * __useCreateSubscriptionAlertMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionAlertMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionAlertMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionAlertMutation, { data, loading, error }] = useCreateSubscriptionAlertMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSubscriptionAlertMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionAlertMutation, CreateSubscriptionAlertMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionAlertMutation, CreateSubscriptionAlertMutationVariables>(CreateSubscriptionAlertDocument, options);
      }
export type CreateSubscriptionAlertMutationHookResult = ReturnType<typeof useCreateSubscriptionAlertMutation>;
export type CreateSubscriptionAlertMutationResult = Apollo.MutationResult<CreateSubscriptionAlertMutation>;
export type CreateSubscriptionAlertMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionAlertMutation, CreateSubscriptionAlertMutationVariables>;
export const UpdateSubscriptionAlertDocument = gql`
    mutation updateSubscriptionAlert($input: UpdateSubscriptionAlertInput!) {
  updateSubscriptionAlert(input: $input) {
    id
  }
}
    `;
export type UpdateSubscriptionAlertMutationFn = Apollo.MutationFunction<UpdateSubscriptionAlertMutation, UpdateSubscriptionAlertMutationVariables>;

/**
 * __useUpdateSubscriptionAlertMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionAlertMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionAlertMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionAlertMutation, { data, loading, error }] = useUpdateSubscriptionAlertMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSubscriptionAlertMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionAlertMutation, UpdateSubscriptionAlertMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionAlertMutation, UpdateSubscriptionAlertMutationVariables>(UpdateSubscriptionAlertDocument, options);
      }
export type UpdateSubscriptionAlertMutationHookResult = ReturnType<typeof useUpdateSubscriptionAlertMutation>;
export type UpdateSubscriptionAlertMutationResult = Apollo.MutationResult<UpdateSubscriptionAlertMutation>;
export type UpdateSubscriptionAlertMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionAlertMutation, UpdateSubscriptionAlertMutationVariables>;
export const GetBillableMetricForHeaderDetailsDocument = gql`
    query getBillableMetricForHeaderDetails($id: ID!) {
  billableMetric(id: $id) {
    id
    name
    code
  }
}
    `;

/**
 * __useGetBillableMetricForHeaderDetailsQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricForHeaderDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricForHeaderDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricForHeaderDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBillableMetricForHeaderDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables> & ({ variables: GetBillableMetricForHeaderDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>(GetBillableMetricForHeaderDetailsDocument, options);
      }
export function useGetBillableMetricForHeaderDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>(GetBillableMetricForHeaderDetailsDocument, options);
        }
export function useGetBillableMetricForHeaderDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>(GetBillableMetricForHeaderDetailsDocument, options);
        }
export type GetBillableMetricForHeaderDetailsQueryHookResult = ReturnType<typeof useGetBillableMetricForHeaderDetailsQuery>;
export type GetBillableMetricForHeaderDetailsLazyQueryHookResult = ReturnType<typeof useGetBillableMetricForHeaderDetailsLazyQuery>;
export type GetBillableMetricForHeaderDetailsSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricForHeaderDetailsSuspenseQuery>;
export type GetBillableMetricForHeaderDetailsQueryResult = Apollo.QueryResult<GetBillableMetricForHeaderDetailsQuery, GetBillableMetricForHeaderDetailsQueryVariables>;
export const BillableMetricsDocument = gql`
    query billableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...BillableMetricItem
    }
  }
}
    ${BillableMetricItemFragmentDoc}`;

/**
 * __useBillableMetricsQuery__
 *
 * To run a query within a React component, call `useBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
      }
export function useBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export function useBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export type BillableMetricsQueryHookResult = ReturnType<typeof useBillableMetricsQuery>;
export type BillableMetricsLazyQueryHookResult = ReturnType<typeof useBillableMetricsLazyQuery>;
export type BillableMetricsSuspenseQueryHookResult = ReturnType<typeof useBillableMetricsSuspenseQuery>;
export type BillableMetricsQueryResult = Apollo.QueryResult<BillableMetricsQuery, BillableMetricsQueryVariables>;
export const GetCouponForDetailsDocument = gql`
    query getCouponForDetails($id: ID!) {
  coupon(id: $id) {
    id
    ...CouponDetailsForHeader
    ...DeleteCoupon
    ...TerminateCoupon
  }
}
    ${CouponDetailsForHeaderFragmentDoc}
${DeleteCouponFragmentDoc}
${TerminateCouponFragmentDoc}`;

/**
 * __useGetCouponForDetailsQuery__
 *
 * To run a query within a React component, call `useGetCouponForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCouponForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables> & ({ variables: GetCouponForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
      }
export function useGetCouponForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
        }
export function useGetCouponForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
        }
export type GetCouponForDetailsQueryHookResult = ReturnType<typeof useGetCouponForDetailsQuery>;
export type GetCouponForDetailsLazyQueryHookResult = ReturnType<typeof useGetCouponForDetailsLazyQuery>;
export type GetCouponForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetCouponForDetailsSuspenseQuery>;
export type GetCouponForDetailsQueryResult = Apollo.QueryResult<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>;
export const CouponsDocument = gql`
    query coupons($page: Int, $limit: Int, $searchTerm: String) {
  coupons(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CouponItem
      ...CouponCaption
      ...DeleteCoupon
    }
  }
}
    ${CouponItemFragmentDoc}
${CouponCaptionFragmentDoc}
${DeleteCouponFragmentDoc}`;

/**
 * __useCouponsQuery__
 *
 * To run a query within a React component, call `useCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCouponsQuery(baseOptions?: Apollo.QueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
      }
export function useCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export function useCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export type CouponsQueryHookResult = ReturnType<typeof useCouponsQuery>;
export type CouponsLazyQueryHookResult = ReturnType<typeof useCouponsLazyQuery>;
export type CouponsSuspenseQueryHookResult = ReturnType<typeof useCouponsSuspenseQuery>;
export type CouponsQueryResult = Apollo.QueryResult<CouponsQuery, CouponsQueryVariables>;
export const GetInvoiceFeesForCreateInvoiceDocument = gql`
    query getInvoiceFeesForCreateInvoice($id: ID!) {
  invoice(id: $id) {
    id
    status
    fees {
      id
      amountCents
      invoiceName
      invoiceDisplayName
      itemName
      description
      groupedBy
      units
      preciseUnitAmount
      appliedTaxes {
        id
        taxCode
        tax {
          id
          name
          rate
          code
        }
      }
      addOn {
        id
        taxes {
          id
          name
          rate
          code
        }
      }
      charge {
        id
        payInAdvance
        minAmountCents
        billableMetric {
          id
          name
        }
      }
      chargeFilter {
        invoiceDisplayName
        values
      }
      subscription {
        id
        plan {
          id
          interval
          name
        }
      }
      ...FeeForInvoiceFeesToFeeInput
    }
  }
}
    ${FeeForInvoiceFeesToFeeInputFragmentDoc}`;

/**
 * __useGetInvoiceFeesForCreateInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInvoiceFeesForCreateInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceFeesForCreateInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceFeesForCreateInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceFeesForCreateInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables> & ({ variables: GetInvoiceFeesForCreateInvoiceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>(GetInvoiceFeesForCreateInvoiceDocument, options);
      }
export function useGetInvoiceFeesForCreateInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>(GetInvoiceFeesForCreateInvoiceDocument, options);
        }
export function useGetInvoiceFeesForCreateInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>(GetInvoiceFeesForCreateInvoiceDocument, options);
        }
export type GetInvoiceFeesForCreateInvoiceQueryHookResult = ReturnType<typeof useGetInvoiceFeesForCreateInvoiceQuery>;
export type GetInvoiceFeesForCreateInvoiceLazyQueryHookResult = ReturnType<typeof useGetInvoiceFeesForCreateInvoiceLazyQuery>;
export type GetInvoiceFeesForCreateInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceFeesForCreateInvoiceSuspenseQuery>;
export type GetInvoiceFeesForCreateInvoiceQueryResult = Apollo.QueryResult<GetInvoiceFeesForCreateInvoiceQuery, GetInvoiceFeesForCreateInvoiceQueryVariables>;
export const GetInfosForCreateInvoiceDocument = gql`
    query getInfosForCreateInvoice($id: ID!) {
  customer(id: $id) {
    id
    addressLine1
    addressLine2
    city
    country
    currency
    email
    name
    displayName
    legalName
    legalNumber
    taxIdentificationNumber
    state
    zipcode
    accountType
    billingEntity {
      code
    }
    taxes {
      id
      ...TaxInfosForCreateInvoice
    }
    anrokCustomer {
      id
    }
    avalaraCustomer {
      id
    }
  }
  taxes(page: 1, limit: 1000, appliedToOrganization: true) {
    collection {
      id
      ...TaxInfosForCreateInvoice
    }
  }
}
    ${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetInfosForCreateInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInfosForCreateInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInfosForCreateInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInfosForCreateInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInfosForCreateInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables> & ({ variables: GetInfosForCreateInvoiceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
      }
export function useGetInfosForCreateInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export function useGetInfosForCreateInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export type GetInfosForCreateInvoiceQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceQuery>;
export type GetInfosForCreateInvoiceLazyQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceLazyQuery>;
export type GetInfosForCreateInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceSuspenseQuery>;
export type GetInfosForCreateInvoiceQueryResult = Apollo.QueryResult<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>;
export const GetAddonListForInfoiceDocument = gql`
    query getAddonListForInfoice($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      description
      amountCents
      amountCurrency
      invoiceDisplayName
      ...AddOnForInvoiceEditTaxDialog
      taxes {
        id
        ...TaxInfosForCreateInvoice
      }
    }
  }
}
    ${AddOnForInvoiceEditTaxDialogFragmentDoc}
${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetAddonListForInfoiceQuery__
 *
 * To run a query within a React component, call `useGetAddonListForInfoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddonListForInfoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddonListForInfoiceQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetAddonListForInfoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
      }
export function useGetAddonListForInfoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export function useGetAddonListForInfoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export type GetAddonListForInfoiceQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceQuery>;
export type GetAddonListForInfoiceLazyQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceLazyQuery>;
export type GetAddonListForInfoiceSuspenseQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceSuspenseQuery>;
export type GetAddonListForInfoiceQueryResult = Apollo.QueryResult<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>;
export const FetchDraftInvoiceTaxesDocument = gql`
    mutation fetchDraftInvoiceTaxes($input: FetchDraftInvoiceTaxesInput!) {
  fetchDraftInvoiceTaxes(input: $input) {
    collection {
      amountCents
      itemId
      taxAmountCents
      taxBreakdown {
        name
        rate
        taxAmount
        enumedTaxCode
      }
    }
  }
}
    `;
export type FetchDraftInvoiceTaxesMutationFn = Apollo.MutationFunction<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>;

/**
 * __useFetchDraftInvoiceTaxesMutation__
 *
 * To run a mutation, you first call `useFetchDraftInvoiceTaxesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFetchDraftInvoiceTaxesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fetchDraftInvoiceTaxesMutation, { data, loading, error }] = useFetchDraftInvoiceTaxesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFetchDraftInvoiceTaxesMutation(baseOptions?: Apollo.MutationHookOptions<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>(FetchDraftInvoiceTaxesDocument, options);
      }
export type FetchDraftInvoiceTaxesMutationHookResult = ReturnType<typeof useFetchDraftInvoiceTaxesMutation>;
export type FetchDraftInvoiceTaxesMutationResult = Apollo.MutationResult<FetchDraftInvoiceTaxesMutation>;
export type FetchDraftInvoiceTaxesMutationOptions = Apollo.BaseMutationOptions<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>;
export const CreateInvoiceDocument = gql`
    mutation createInvoice($input: CreateInvoiceInput!) {
  createInvoice(input: $input) {
    id
  }
}
    `;
export type CreateInvoiceMutationFn = Apollo.MutationFunction<CreateInvoiceMutation, CreateInvoiceMutationVariables>;

/**
 * __useCreateInvoiceMutation__
 *
 * To run a mutation, you first call `useCreateInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoiceMutation, { data, loading, error }] = useCreateInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoiceMutation, CreateInvoiceMutationVariables>(CreateInvoiceDocument, options);
      }
export type CreateInvoiceMutationHookResult = ReturnType<typeof useCreateInvoiceMutation>;
export type CreateInvoiceMutationResult = Apollo.MutationResult<CreateInvoiceMutation>;
export type CreateInvoiceMutationOptions = Apollo.BaseMutationOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>;
export const GetPayableInvoicesDocument = gql`
    query GetPayableInvoices($customerExternalId: String, $status: [InvoiceStatusTypeEnum!]) {
  invoices(
    positiveDueAmount: true
    customerExternalId: $customerExternalId
    status: $status
  ) {
    collection {
      id
      number
      currency
    }
  }
}
    `;

/**
 * __useGetPayableInvoicesQuery__
 *
 * To run a query within a React component, call `useGetPayableInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPayableInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPayableInvoicesQuery({
 *   variables: {
 *      customerExternalId: // value for 'customerExternalId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetPayableInvoicesQuery(baseOptions?: Apollo.QueryHookOptions<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>(GetPayableInvoicesDocument, options);
      }
export function useGetPayableInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>(GetPayableInvoicesDocument, options);
        }
export function useGetPayableInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>(GetPayableInvoicesDocument, options);
        }
export type GetPayableInvoicesQueryHookResult = ReturnType<typeof useGetPayableInvoicesQuery>;
export type GetPayableInvoicesLazyQueryHookResult = ReturnType<typeof useGetPayableInvoicesLazyQuery>;
export type GetPayableInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetPayableInvoicesSuspenseQuery>;
export type GetPayableInvoicesQueryResult = Apollo.QueryResult<GetPayableInvoicesQuery, GetPayableInvoicesQueryVariables>;
export const GetPayableInvoiceDocument = gql`
    query GetPayableInvoice($id: ID!) {
  invoice(id: $id) {
    id
    number
    paymentStatus
    status
    totalDueAmountCents
    issuingDate
    currency
    invoiceType
  }
}
    `;

/**
 * __useGetPayableInvoiceQuery__
 *
 * To run a query within a React component, call `useGetPayableInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPayableInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPayableInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPayableInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables> & ({ variables: GetPayableInvoiceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>(GetPayableInvoiceDocument, options);
      }
export function useGetPayableInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>(GetPayableInvoiceDocument, options);
        }
export function useGetPayableInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>(GetPayableInvoiceDocument, options);
        }
export type GetPayableInvoiceQueryHookResult = ReturnType<typeof useGetPayableInvoiceQuery>;
export type GetPayableInvoiceLazyQueryHookResult = ReturnType<typeof useGetPayableInvoiceLazyQuery>;
export type GetPayableInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetPayableInvoiceSuspenseQuery>;
export type GetPayableInvoiceQueryResult = Apollo.QueryResult<GetPayableInvoiceQuery, GetPayableInvoiceQueryVariables>;
export const CreatePaymentDocument = gql`
    mutation CreatePayment($input: CreatePaymentInput!) {
  createPayment(input: $input) {
    id
  }
}
    `;
export type CreatePaymentMutationFn = Apollo.MutationFunction<CreatePaymentMutation, CreatePaymentMutationVariables>;

/**
 * __useCreatePaymentMutation__
 *
 * To run a mutation, you first call `useCreatePaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPaymentMutation, { data, loading, error }] = useCreatePaymentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePaymentMutation(baseOptions?: Apollo.MutationHookOptions<CreatePaymentMutation, CreatePaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePaymentMutation, CreatePaymentMutationVariables>(CreatePaymentDocument, options);
      }
export type CreatePaymentMutationHookResult = ReturnType<typeof useCreatePaymentMutation>;
export type CreatePaymentMutationResult = Apollo.MutationResult<CreatePaymentMutation>;
export type CreatePaymentMutationOptions = Apollo.BaseMutationOptions<CreatePaymentMutation, CreatePaymentMutationVariables>;
export const GetCreditNoteForDetailsDocument = gql`
    query getCreditNoteForDetails($id: ID!) {
  creditNote(id: $id) {
    id
    number
    canBeVoided
    totalAmountCents
    currency
    integrationSyncable
    taxProviderSyncable
    externalIntegrationId
    taxProviderId
    customer {
      ...CustomerForCreditNoteDetailsExternalSync
    }
  }
}
    ${CustomerForCreditNoteDetailsExternalSyncFragmentDoc}`;

/**
 * __useGetCreditNoteForDetailsQuery__
 *
 * To run a query within a React component, call `useGetCreditNoteForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNoteForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNoteForDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCreditNoteForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables> & ({ variables: GetCreditNoteForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>(GetCreditNoteForDetailsDocument, options);
      }
export function useGetCreditNoteForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>(GetCreditNoteForDetailsDocument, options);
        }
export function useGetCreditNoteForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>(GetCreditNoteForDetailsDocument, options);
        }
export type GetCreditNoteForDetailsQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsQuery>;
export type GetCreditNoteForDetailsLazyQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsLazyQuery>;
export type GetCreditNoteForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetCreditNoteForDetailsSuspenseQuery>;
export type GetCreditNoteForDetailsQueryResult = Apollo.QueryResult<GetCreditNoteForDetailsQuery, GetCreditNoteForDetailsQueryVariables>;
export const SyncIntegrationCreditNoteDocument = gql`
    mutation syncIntegrationCreditNote($input: SyncIntegrationCreditNoteInput!) {
  syncIntegrationCreditNote(input: $input) {
    creditNoteId
  }
}
    `;
export type SyncIntegrationCreditNoteMutationFn = Apollo.MutationFunction<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>;

/**
 * __useSyncIntegrationCreditNoteMutation__
 *
 * To run a mutation, you first call `useSyncIntegrationCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncIntegrationCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncIntegrationCreditNoteMutation, { data, loading, error }] = useSyncIntegrationCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncIntegrationCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>(SyncIntegrationCreditNoteDocument, options);
      }
export type SyncIntegrationCreditNoteMutationHookResult = ReturnType<typeof useSyncIntegrationCreditNoteMutation>;
export type SyncIntegrationCreditNoteMutationResult = Apollo.MutationResult<SyncIntegrationCreditNoteMutation>;
export type SyncIntegrationCreditNoteMutationOptions = Apollo.BaseMutationOptions<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>;
export const RetryTaxReportingDocument = gql`
    mutation retryTaxReporting($input: RetryTaxReportingInput!) {
  retryTaxReporting(input: $input) {
    id
  }
}
    `;
export type RetryTaxReportingMutationFn = Apollo.MutationFunction<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>;

/**
 * __useRetryTaxReportingMutation__
 *
 * To run a mutation, you first call `useRetryTaxReportingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryTaxReportingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryTaxReportingMutation, { data, loading, error }] = useRetryTaxReportingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryTaxReportingMutation(baseOptions?: Apollo.MutationHookOptions<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>(RetryTaxReportingDocument, options);
      }
export type RetryTaxReportingMutationHookResult = ReturnType<typeof useRetryTaxReportingMutation>;
export type RetryTaxReportingMutationResult = Apollo.MutationResult<RetryTaxReportingMutation>;
export type RetryTaxReportingMutationOptions = Apollo.BaseMutationOptions<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>;
export const GetCreditNotesListDocument = gql`
    query getCreditNotesList($amountFrom: Int, $amountTo: Int, $creditStatus: [CreditNoteCreditStatusEnum!], $currency: CurrencyEnum, $customerExternalId: String, $invoiceNumber: String, $issuingDateFrom: ISO8601Date, $issuingDateTo: ISO8601Date, $reason: [CreditNoteReasonEnum!], $refundStatus: [CreditNoteRefundStatusEnum!], $limit: Int, $page: Int, $searchTerm: String, $selfBilled: Boolean, $billingEntityIds: [ID!]) {
  creditNotes(
    amountFrom: $amountFrom
    amountTo: $amountTo
    creditStatus: $creditStatus
    currency: $currency
    customerExternalId: $customerExternalId
    invoiceNumber: $invoiceNumber
    issuingDateFrom: $issuingDateFrom
    issuingDateTo: $issuingDateTo
    reason: $reason
    refundStatus: $refundStatus
    limit: $limit
    page: $page
    searchTerm: $searchTerm
    selfBilled: $selfBilled
    billingEntityIds: $billingEntityIds
  ) {
    ...CreditNotesForTable
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetCreditNotesListQuery__
 *
 * To run a query within a React component, call `useGetCreditNotesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNotesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNotesListQuery({
 *   variables: {
 *      amountFrom: // value for 'amountFrom'
 *      amountTo: // value for 'amountTo'
 *      creditStatus: // value for 'creditStatus'
 *      currency: // value for 'currency'
 *      customerExternalId: // value for 'customerExternalId'
 *      invoiceNumber: // value for 'invoiceNumber'
 *      issuingDateFrom: // value for 'issuingDateFrom'
 *      issuingDateTo: // value for 'issuingDateTo'
 *      reason: // value for 'reason'
 *      refundStatus: // value for 'refundStatus'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *      selfBilled: // value for 'selfBilled'
 *      billingEntityIds: // value for 'billingEntityIds'
 *   },
 * });
 */
export function useGetCreditNotesListQuery(baseOptions?: Apollo.QueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
      }
export function useGetCreditNotesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
        }
export function useGetCreditNotesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
        }
export type GetCreditNotesListQueryHookResult = ReturnType<typeof useGetCreditNotesListQuery>;
export type GetCreditNotesListLazyQueryHookResult = ReturnType<typeof useGetCreditNotesListLazyQuery>;
export type GetCreditNotesListSuspenseQueryHookResult = ReturnType<typeof useGetCreditNotesListSuspenseQuery>;
export type GetCreditNotesListQueryResult = Apollo.QueryResult<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>;
export const CreateCreditNotesDataExportDocument = gql`
    mutation createCreditNotesDataExport($input: CreateDataExportsCreditNotesInput!) {
  createCreditNotesDataExport(input: $input) {
    id
  }
}
    `;
export type CreateCreditNotesDataExportMutationFn = Apollo.MutationFunction<CreateCreditNotesDataExportMutation, CreateCreditNotesDataExportMutationVariables>;

/**
 * __useCreateCreditNotesDataExportMutation__
 *
 * To run a mutation, you first call `useCreateCreditNotesDataExportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreditNotesDataExportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreditNotesDataExportMutation, { data, loading, error }] = useCreateCreditNotesDataExportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCreditNotesDataExportMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreditNotesDataExportMutation, CreateCreditNotesDataExportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreditNotesDataExportMutation, CreateCreditNotesDataExportMutationVariables>(CreateCreditNotesDataExportDocument, options);
      }
export type CreateCreditNotesDataExportMutationHookResult = ReturnType<typeof useCreateCreditNotesDataExportMutation>;
export type CreateCreditNotesDataExportMutationResult = Apollo.MutationResult<CreateCreditNotesDataExportMutation>;
export type CreateCreditNotesDataExportMutationOptions = Apollo.BaseMutationOptions<CreateCreditNotesDataExportMutation, CreateCreditNotesDataExportMutationVariables>;
export const GetCustomerDocument = gql`
    query getCustomer($id: ID!) {
  customer(id: $id) {
    ...CustomerDetails
  }
}
    ${CustomerDetailsFragmentDoc}`;

/**
 * __useGetCustomerQuery__
 *
 * To run a query within a React component, call `useGetCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables> & ({ variables: GetCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
      }
export function useGetCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export function useGetCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export type GetCustomerQueryHookResult = ReturnType<typeof useGetCustomerQuery>;
export type GetCustomerLazyQueryHookResult = ReturnType<typeof useGetCustomerLazyQuery>;
export type GetCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSuspenseQuery>;
export type GetCustomerQueryResult = Apollo.QueryResult<GetCustomerQuery, GetCustomerQueryVariables>;
export const GenerateCustomerPortalUrlDocument = gql`
    mutation generateCustomerPortalUrl($input: GenerateCustomerPortalUrlInput!) {
  generateCustomerPortalUrl(input: $input) {
    url
  }
}
    `;
export type GenerateCustomerPortalUrlMutationFn = Apollo.MutationFunction<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;

/**
 * __useGenerateCustomerPortalUrlMutation__
 *
 * To run a mutation, you first call `useGenerateCustomerPortalUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateCustomerPortalUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateCustomerPortalUrlMutation, { data, loading, error }] = useGenerateCustomerPortalUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGenerateCustomerPortalUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>(GenerateCustomerPortalUrlDocument, options);
      }
export type GenerateCustomerPortalUrlMutationHookResult = ReturnType<typeof useGenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationResult = Apollo.MutationResult<GenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationOptions = Apollo.BaseMutationOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;
export const GetCustomerDraftInvoicesDocument = gql`
    query getCustomerDraftInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerDraftInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerDraftInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerDraftInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerDraftInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerDraftInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables> & ({ variables: GetCustomerDraftInvoicesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
      }
export function useGetCustomerDraftInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export function useGetCustomerDraftInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export type GetCustomerDraftInvoicesQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesQuery>;
export type GetCustomerDraftInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesLazyQuery>;
export type GetCustomerDraftInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesSuspenseQuery>;
export type GetCustomerDraftInvoicesQueryResult = Apollo.QueryResult<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>;
export const GetCustomerInfosForDraftInvoicesListDocument = gql`
    query getCustomerInfosForDraftInvoicesList($customerId: ID!, $status: [InvoiceStatusTypeEnum!]) {
  customer(id: $customerId) {
    id
    name
    displayName
    applicableTimezone
  }
  customerInvoices(customerId: $customerId, status: $status) {
    metadata {
      totalCount
    }
  }
}
    `;

/**
 * __useGetCustomerInfosForDraftInvoicesListQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForDraftInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForDraftInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForDraftInvoicesListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetCustomerInfosForDraftInvoicesListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables> & ({ variables: GetCustomerInfosForDraftInvoicesListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
      }
export function useGetCustomerInfosForDraftInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export function useGetCustomerInfosForDraftInvoicesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export type GetCustomerInfosForDraftInvoicesListQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListQuery>;
export type GetCustomerInfosForDraftInvoicesListLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListLazyQuery>;
export type GetCustomerInfosForDraftInvoicesListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListSuspenseQuery>;
export type GetCustomerInfosForDraftInvoicesListQueryResult = Apollo.QueryResult<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>;
export const GetInvoiceDetailsDocument = gql`
    query getInvoiceDetails($id: ID!) {
  invoice(id: $id) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;

/**
 * __useGetInvoiceDetailsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables> & ({ variables: GetInvoiceDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
      }
export function useGetInvoiceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export function useGetInvoiceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export type GetInvoiceDetailsQueryHookResult = ReturnType<typeof useGetInvoiceDetailsQuery>;
export type GetInvoiceDetailsLazyQueryHookResult = ReturnType<typeof useGetInvoiceDetailsLazyQuery>;
export type GetInvoiceDetailsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceDetailsSuspenseQuery>;
export type GetInvoiceDetailsQueryResult = Apollo.QueryResult<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>;
export const GetInvoiceFeesDocument = gql`
    query getInvoiceFees($id: ID!) {
  invoice(id: $id) {
    id
    fees {
      ...FeeForInvoiceDetailsTable
    }
  }
}
    ${FeeForInvoiceDetailsTableFragmentDoc}`;

/**
 * __useGetInvoiceFeesQuery__
 *
 * To run a query within a React component, call `useGetInvoiceFeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceFeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceFeesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceFeesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables> & ({ variables: GetInvoiceFeesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>(GetInvoiceFeesDocument, options);
      }
export function useGetInvoiceFeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>(GetInvoiceFeesDocument, options);
        }
export function useGetInvoiceFeesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>(GetInvoiceFeesDocument, options);
        }
export type GetInvoiceFeesQueryHookResult = ReturnType<typeof useGetInvoiceFeesQuery>;
export type GetInvoiceFeesLazyQueryHookResult = ReturnType<typeof useGetInvoiceFeesLazyQuery>;
export type GetInvoiceFeesSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceFeesSuspenseQuery>;
export type GetInvoiceFeesQueryResult = Apollo.QueryResult<GetInvoiceFeesQuery, GetInvoiceFeesQueryVariables>;
export const GetInvoiceSubscriptionsDocument = gql`
    query getInvoiceSubscriptions($id: ID!) {
  invoice(id: $id) {
    id
    invoiceSubscriptions {
      ...InvoiceSubscriptionForInvoiceDetailsTable
    }
  }
}
    ${InvoiceSubscriptionForInvoiceDetailsTableFragmentDoc}`;

/**
 * __useGetInvoiceSubscriptionsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceSubscriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceSubscriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceSubscriptionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceSubscriptionsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables> & ({ variables: GetInvoiceSubscriptionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>(GetInvoiceSubscriptionsDocument, options);
      }
export function useGetInvoiceSubscriptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>(GetInvoiceSubscriptionsDocument, options);
        }
export function useGetInvoiceSubscriptionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>(GetInvoiceSubscriptionsDocument, options);
        }
export type GetInvoiceSubscriptionsQueryHookResult = ReturnType<typeof useGetInvoiceSubscriptionsQuery>;
export type GetInvoiceSubscriptionsLazyQueryHookResult = ReturnType<typeof useGetInvoiceSubscriptionsLazyQuery>;
export type GetInvoiceSubscriptionsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceSubscriptionsSuspenseQuery>;
export type GetInvoiceSubscriptionsQueryResult = Apollo.QueryResult<GetInvoiceSubscriptionsQuery, GetInvoiceSubscriptionsQueryVariables>;
export const GetInvoiceCustomerDocument = gql`
    query getInvoiceCustomer($id: ID!) {
  customer(id: $id) {
    id
    ...CustomerForInvoiceDetails
    ...CustomerForInvoiceOverview
  }
}
    ${CustomerForInvoiceDetailsFragmentDoc}
${CustomerForInvoiceOverviewFragmentDoc}`;

/**
 * __useGetInvoiceCustomerQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceCustomerQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables> & ({ variables: GetInvoiceCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>(GetInvoiceCustomerDocument, options);
      }
export function useGetInvoiceCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>(GetInvoiceCustomerDocument, options);
        }
export function useGetInvoiceCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>(GetInvoiceCustomerDocument, options);
        }
export type GetInvoiceCustomerQueryHookResult = ReturnType<typeof useGetInvoiceCustomerQuery>;
export type GetInvoiceCustomerLazyQueryHookResult = ReturnType<typeof useGetInvoiceCustomerLazyQuery>;
export type GetInvoiceCustomerSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCustomerSuspenseQuery>;
export type GetInvoiceCustomerQueryResult = Apollo.QueryResult<GetInvoiceCustomerQuery, GetInvoiceCustomerQueryVariables>;
export const GetInvoiceNumberDocument = gql`
    query getInvoiceNumber($id: ID!) {
  invoice(id: $id) {
    id
    number
  }
}
    `;

/**
 * __useGetInvoiceNumberQuery__
 *
 * To run a query within a React component, call `useGetInvoiceNumberQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceNumberQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceNumberQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceNumberQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables> & ({ variables: GetInvoiceNumberQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>(GetInvoiceNumberDocument, options);
      }
export function useGetInvoiceNumberLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>(GetInvoiceNumberDocument, options);
        }
export function useGetInvoiceNumberSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>(GetInvoiceNumberDocument, options);
        }
export type GetInvoiceNumberQueryHookResult = ReturnType<typeof useGetInvoiceNumberQuery>;
export type GetInvoiceNumberLazyQueryHookResult = ReturnType<typeof useGetInvoiceNumberLazyQuery>;
export type GetInvoiceNumberSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceNumberSuspenseQuery>;
export type GetInvoiceNumberQueryResult = Apollo.QueryResult<GetInvoiceNumberQuery, GetInvoiceNumberQueryVariables>;
export const GetInvoiceStatusDocument = gql`
    query getInvoiceStatus($id: ID!) {
  invoice(id: $id) {
    id
    status
  }
}
    `;

/**
 * __useGetInvoiceStatusQuery__
 *
 * To run a query within a React component, call `useGetInvoiceStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceStatusQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceStatusQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables> & ({ variables: GetInvoiceStatusQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>(GetInvoiceStatusDocument, options);
      }
export function useGetInvoiceStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>(GetInvoiceStatusDocument, options);
        }
export function useGetInvoiceStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>(GetInvoiceStatusDocument, options);
        }
export type GetInvoiceStatusQueryHookResult = ReturnType<typeof useGetInvoiceStatusQuery>;
export type GetInvoiceStatusLazyQueryHookResult = ReturnType<typeof useGetInvoiceStatusLazyQuery>;
export type GetInvoiceStatusSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceStatusSuspenseQuery>;
export type GetInvoiceStatusQueryResult = Apollo.QueryResult<GetInvoiceStatusQuery, GetInvoiceStatusQueryVariables>;
export const IntegrationsListForCustomerInvoiceDetailsDocument = gql`
    query integrationsListForCustomerInvoiceDetails($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        ...NetsuiteIntegrationInfosForInvoiceOverview
      }
      ... on HubspotIntegration {
        __typename
        id
        ...HubspotIntegrationInfosForInvoiceOverview
      }
      ... on SalesforceIntegration {
        __typename
        id
        ...SalesforceIntegrationInfosForInvoiceOverview
      }
      ... on AvalaraIntegration {
        __typename
        id
        ...AvalaraIntegrationInfosForInvoiceOverview
      }
    }
  }
}
    ${NetsuiteIntegrationInfosForInvoiceOverviewFragmentDoc}
${HubspotIntegrationInfosForInvoiceOverviewFragmentDoc}
${SalesforceIntegrationInfosForInvoiceOverviewFragmentDoc}
${AvalaraIntegrationInfosForInvoiceOverviewFragmentDoc}`;

/**
 * __useIntegrationsListForCustomerInvoiceDetailsQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerInvoiceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerInvoiceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerInvoiceDetailsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerInvoiceDetailsQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
      }
export function useIntegrationsListForCustomerInvoiceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
        }
export function useIntegrationsListForCustomerInvoiceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
        }
export type IntegrationsListForCustomerInvoiceDetailsQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsQuery>;
export type IntegrationsListForCustomerInvoiceDetailsLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsLazyQuery>;
export type IntegrationsListForCustomerInvoiceDetailsSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsSuspenseQuery>;
export type IntegrationsListForCustomerInvoiceDetailsQueryResult = Apollo.QueryResult<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>;
export const DownloadInvoiceDocument = gql`
    mutation downloadInvoice($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceMutationFn = Apollo.MutationFunction<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;

/**
 * __useDownloadInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceMutation, { data, loading, error }] = useDownloadInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>(DownloadInvoiceDocument, options);
      }
export type DownloadInvoiceMutationHookResult = ReturnType<typeof useDownloadInvoiceMutation>;
export type DownloadInvoiceMutationResult = Apollo.MutationResult<DownloadInvoiceMutation>;
export type DownloadInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;
export const RefreshInvoiceDocument = gql`
    mutation refreshInvoice($input: RefreshInvoiceInput!) {
  refreshInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type RefreshInvoiceMutationFn = Apollo.MutationFunction<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;

/**
 * __useRefreshInvoiceMutation__
 *
 * To run a mutation, you first call `useRefreshInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshInvoiceMutation, { data, loading, error }] = useRefreshInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRefreshInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>(RefreshInvoiceDocument, options);
      }
export type RefreshInvoiceMutationHookResult = ReturnType<typeof useRefreshInvoiceMutation>;
export type RefreshInvoiceMutationResult = Apollo.MutationResult<RefreshInvoiceMutation>;
export type RefreshInvoiceMutationOptions = Apollo.BaseMutationOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;
export const SyncIntegrationInvoiceDocument = gql`
    mutation syncIntegrationInvoice($input: SyncIntegrationInvoiceInput!) {
  syncIntegrationInvoice(input: $input) {
    invoiceId
  }
}
    `;
export type SyncIntegrationInvoiceMutationFn = Apollo.MutationFunction<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>;

/**
 * __useSyncIntegrationInvoiceMutation__
 *
 * To run a mutation, you first call `useSyncIntegrationInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncIntegrationInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncIntegrationInvoiceMutation, { data, loading, error }] = useSyncIntegrationInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncIntegrationInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>(SyncIntegrationInvoiceDocument, options);
      }
export type SyncIntegrationInvoiceMutationHookResult = ReturnType<typeof useSyncIntegrationInvoiceMutation>;
export type SyncIntegrationInvoiceMutationResult = Apollo.MutationResult<SyncIntegrationInvoiceMutation>;
export type SyncIntegrationInvoiceMutationOptions = Apollo.BaseMutationOptions<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>;
export const SyncHubspotIntegrationInvoiceDocument = gql`
    mutation syncHubspotIntegrationInvoice($input: SyncHubspotIntegrationInvoiceInput!) {
  syncHubspotIntegrationInvoice(input: $input) {
    invoiceId
  }
}
    `;
export type SyncHubspotIntegrationInvoiceMutationFn = Apollo.MutationFunction<SyncHubspotIntegrationInvoiceMutation, SyncHubspotIntegrationInvoiceMutationVariables>;

/**
 * __useSyncHubspotIntegrationInvoiceMutation__
 *
 * To run a mutation, you first call `useSyncHubspotIntegrationInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncHubspotIntegrationInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncHubspotIntegrationInvoiceMutation, { data, loading, error }] = useSyncHubspotIntegrationInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncHubspotIntegrationInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncHubspotIntegrationInvoiceMutation, SyncHubspotIntegrationInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncHubspotIntegrationInvoiceMutation, SyncHubspotIntegrationInvoiceMutationVariables>(SyncHubspotIntegrationInvoiceDocument, options);
      }
export type SyncHubspotIntegrationInvoiceMutationHookResult = ReturnType<typeof useSyncHubspotIntegrationInvoiceMutation>;
export type SyncHubspotIntegrationInvoiceMutationResult = Apollo.MutationResult<SyncHubspotIntegrationInvoiceMutation>;
export type SyncHubspotIntegrationInvoiceMutationOptions = Apollo.BaseMutationOptions<SyncHubspotIntegrationInvoiceMutation, SyncHubspotIntegrationInvoiceMutationVariables>;
export const SyncSalesforceInvoiceDocument = gql`
    mutation syncSalesforceInvoice($input: SyncSalesforceInvoiceInput!) {
  syncSalesforceInvoice(input: $input) {
    invoiceId
  }
}
    `;
export type SyncSalesforceInvoiceMutationFn = Apollo.MutationFunction<SyncSalesforceInvoiceMutation, SyncSalesforceInvoiceMutationVariables>;

/**
 * __useSyncSalesforceInvoiceMutation__
 *
 * To run a mutation, you first call `useSyncSalesforceInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncSalesforceInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncSalesforceInvoiceMutation, { data, loading, error }] = useSyncSalesforceInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncSalesforceInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncSalesforceInvoiceMutation, SyncSalesforceInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncSalesforceInvoiceMutation, SyncSalesforceInvoiceMutationVariables>(SyncSalesforceInvoiceDocument, options);
      }
export type SyncSalesforceInvoiceMutationHookResult = ReturnType<typeof useSyncSalesforceInvoiceMutation>;
export type SyncSalesforceInvoiceMutationResult = Apollo.MutationResult<SyncSalesforceInvoiceMutation>;
export type SyncSalesforceInvoiceMutationOptions = Apollo.BaseMutationOptions<SyncSalesforceInvoiceMutation, SyncSalesforceInvoiceMutationVariables>;
export const RetryInvoiceDocument = gql`
    mutation retryInvoice($input: RetryInvoiceInput!) {
  retryInvoice(input: $input) {
    id
  }
}
    `;
export type RetryInvoiceMutationFn = Apollo.MutationFunction<RetryInvoiceMutation, RetryInvoiceMutationVariables>;

/**
 * __useRetryInvoiceMutation__
 *
 * To run a mutation, you first call `useRetryInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryInvoiceMutation, { data, loading, error }] = useRetryInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RetryInvoiceMutation, RetryInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryInvoiceMutation, RetryInvoiceMutationVariables>(RetryInvoiceDocument, options);
      }
export type RetryInvoiceMutationHookResult = ReturnType<typeof useRetryInvoiceMutation>;
export type RetryInvoiceMutationResult = Apollo.MutationResult<RetryInvoiceMutation>;
export type RetryInvoiceMutationOptions = Apollo.BaseMutationOptions<RetryInvoiceMutation, RetryInvoiceMutationVariables>;
export const RetryTaxProviderVoidingDocument = gql`
    mutation retryTaxProviderVoiding($input: RetryTaxProviderVoidingInput!) {
  retryTaxProviderVoiding(input: $input) {
    id
  }
}
    `;
export type RetryTaxProviderVoidingMutationFn = Apollo.MutationFunction<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>;

/**
 * __useRetryTaxProviderVoidingMutation__
 *
 * To run a mutation, you first call `useRetryTaxProviderVoidingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryTaxProviderVoidingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryTaxProviderVoidingMutation, { data, loading, error }] = useRetryTaxProviderVoidingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryTaxProviderVoidingMutation(baseOptions?: Apollo.MutationHookOptions<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>(RetryTaxProviderVoidingDocument, options);
      }
export type RetryTaxProviderVoidingMutationHookResult = ReturnType<typeof useRetryTaxProviderVoidingMutation>;
export type RetryTaxProviderVoidingMutationResult = Apollo.MutationResult<RetryTaxProviderVoidingMutation>;
export type RetryTaxProviderVoidingMutationOptions = Apollo.BaseMutationOptions<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>;
export const RegenerateInvoiceDocument = gql`
    mutation regenerateInvoice($input: RegenerateInvoiceInput!) {
  regenerateFromVoided(input: $input) {
    id
  }
}
    `;
export type RegenerateInvoiceMutationFn = Apollo.MutationFunction<RegenerateInvoiceMutation, RegenerateInvoiceMutationVariables>;

/**
 * __useRegenerateInvoiceMutation__
 *
 * To run a mutation, you first call `useRegenerateInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegenerateInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [regenerateInvoiceMutation, { data, loading, error }] = useRegenerateInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRegenerateInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RegenerateInvoiceMutation, RegenerateInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RegenerateInvoiceMutation, RegenerateInvoiceMutationVariables>(RegenerateInvoiceDocument, options);
      }
export type RegenerateInvoiceMutationHookResult = ReturnType<typeof useRegenerateInvoiceMutation>;
export type RegenerateInvoiceMutationResult = Apollo.MutationResult<RegenerateInvoiceMutation>;
export type RegenerateInvoiceMutationOptions = Apollo.BaseMutationOptions<RegenerateInvoiceMutation, RegenerateInvoiceMutationVariables>;
export const PreviewAdjustedFeeDocument = gql`
    mutation previewAdjustedFee($input: PreviewAdjustedFeeInput!) {
  previewAdjustedFee(input: $input) {
    id
    feeType
    amountCents
    invoiceName
    invoiceDisplayName
    units
    groupedBy
    preciseUnitAmount
    addOn {
      id
    }
    appliedTaxes {
      id
      amountCents
      taxRate
      taxName
    }
    amountDetails {
      freeUnits
      paidUnits
      perPackageSize
      perPackageUnitAmount
      graduatedRanges {
        flatUnitAmount
        fromValue
        perUnitAmount
        toValue
        units
        perUnitTotalAmount
      }
      graduatedPercentageRanges {
        flatUnitAmount
        fromValue
        rate
        toValue
        units
        perUnitTotalAmount
      }
    }
    charge {
      id
      payInAdvance
      minAmountCents
      chargeModel
      billableMetric {
        id
        name
      }
    }
    chargeFilter {
      id
      invoiceDisplayName
      values
    }
    subscription {
      id
      plan {
        id
        interval
        name
      }
    }
  }
}
    `;
export type PreviewAdjustedFeeMutationFn = Apollo.MutationFunction<PreviewAdjustedFeeMutation, PreviewAdjustedFeeMutationVariables>;

/**
 * __usePreviewAdjustedFeeMutation__
 *
 * To run a mutation, you first call `usePreviewAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewAdjustedFeeMutation, { data, loading, error }] = usePreviewAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePreviewAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<PreviewAdjustedFeeMutation, PreviewAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewAdjustedFeeMutation, PreviewAdjustedFeeMutationVariables>(PreviewAdjustedFeeDocument, options);
      }
export type PreviewAdjustedFeeMutationHookResult = ReturnType<typeof usePreviewAdjustedFeeMutation>;
export type PreviewAdjustedFeeMutationResult = Apollo.MutationResult<PreviewAdjustedFeeMutation>;
export type PreviewAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<PreviewAdjustedFeeMutation, PreviewAdjustedFeeMutationVariables>;
export const GetRequestOverduePaymentInfosDocument = gql`
    query getRequestOverduePaymentInfos($id: ID!) {
  organization {
    defaultCurrency
    ...OrganizationForDunningEmail
  }
  customer(id: $id) {
    externalId
    currency
    ...CustomerForRequestOverduePaymentForm
    ...CustomerForDunningEmail
  }
  paymentRequests {
    collection {
      ...LastPaymentRequest
    }
  }
  invoices(paymentOverdue: true, customerId: $id) {
    collection {
      ...InvoicesForDunningEmail
      ...InvoicesForRequestOverduePaymentForm
    }
  }
}
    ${OrganizationForDunningEmailFragmentDoc}
${CustomerForRequestOverduePaymentFormFragmentDoc}
${CustomerForDunningEmailFragmentDoc}
${LastPaymentRequestFragmentDoc}
${InvoicesForDunningEmailFragmentDoc}
${InvoicesForRequestOverduePaymentFormFragmentDoc}`;

/**
 * __useGetRequestOverduePaymentInfosQuery__
 *
 * To run a query within a React component, call `useGetRequestOverduePaymentInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRequestOverduePaymentInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRequestOverduePaymentInfosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetRequestOverduePaymentInfosQuery(baseOptions: Apollo.QueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables> & ({ variables: GetRequestOverduePaymentInfosQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
      }
export function useGetRequestOverduePaymentInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
        }
export function useGetRequestOverduePaymentInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
        }
export type GetRequestOverduePaymentInfosQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosQuery>;
export type GetRequestOverduePaymentInfosLazyQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosLazyQuery>;
export type GetRequestOverduePaymentInfosSuspenseQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosSuspenseQuery>;
export type GetRequestOverduePaymentInfosQueryResult = Apollo.QueryResult<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>;
export const CreatePaymentRequestDocument = gql`
    mutation createPaymentRequest($input: PaymentRequestCreateInput!) {
  createPaymentRequest(input: $input) {
    id
  }
}
    `;
export type CreatePaymentRequestMutationFn = Apollo.MutationFunction<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>;

/**
 * __useCreatePaymentRequestMutation__
 *
 * To run a mutation, you first call `useCreatePaymentRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePaymentRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPaymentRequestMutation, { data, loading, error }] = useCreatePaymentRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePaymentRequestMutation(baseOptions?: Apollo.MutationHookOptions<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>(CreatePaymentRequestDocument, options);
      }
export type CreatePaymentRequestMutationHookResult = ReturnType<typeof useCreatePaymentRequestMutation>;
export type CreatePaymentRequestMutationResult = Apollo.MutationResult<CreatePaymentRequestMutation>;
export type CreatePaymentRequestMutationOptions = Apollo.BaseMutationOptions<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>;
export const CustomersDocument = gql`
    query customers($page: Int, $limit: Int, $searchTerm: String, $accountType: [CustomerAccountTypeEnum!], $billingEntityIds: [ID!], $activeSubscriptionsCountFrom: Int, $activeSubscriptionsCountTo: Int, $countries: [CountryCode!], $zipcodes: [String!], $states: [String!], $currencies: [CurrencyEnum!], $customerType: CustomerTypeEnum, $hasTaxIdentificationNumber: Boolean, $hasCustomerType: Boolean, $metadata: [CustomerMetadataFilter!]) {
  customers(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    accountType: $accountType
    billingEntityIds: $billingEntityIds
    activeSubscriptionsCountFrom: $activeSubscriptionsCountFrom
    activeSubscriptionsCountTo: $activeSubscriptionsCountTo
    countries: $countries
    zipcodes: $zipcodes
    states: $states
    currencies: $currencies
    customerType: $customerType
    hasTaxIdentificationNumber: $hasTaxIdentificationNumber
    hasCustomerType: $hasCustomerType
    metadata: $metadata
  ) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CustomerItem
    }
  }
}
    ${CustomerItemFragmentDoc}`;

/**
 * __useCustomersQuery__
 *
 * To run a query within a React component, call `useCustomersQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      accountType: // value for 'accountType'
 *      billingEntityIds: // value for 'billingEntityIds'
 *      activeSubscriptionsCountFrom: // value for 'activeSubscriptionsCountFrom'
 *      activeSubscriptionsCountTo: // value for 'activeSubscriptionsCountTo'
 *      countries: // value for 'countries'
 *      zipcodes: // value for 'zipcodes'
 *      states: // value for 'states'
 *      currencies: // value for 'currencies'
 *      customerType: // value for 'customerType'
 *      hasTaxIdentificationNumber: // value for 'hasTaxIdentificationNumber'
 *      hasCustomerType: // value for 'hasCustomerType'
 *      metadata: // value for 'metadata'
 *   },
 * });
 */
export function useCustomersQuery(baseOptions?: Apollo.QueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
      }
export function useCustomersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export function useCustomersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export type CustomersQueryHookResult = ReturnType<typeof useCustomersQuery>;
export type CustomersLazyQueryHookResult = ReturnType<typeof useCustomersLazyQuery>;
export type CustomersSuspenseQueryHookResult = ReturnType<typeof useCustomersSuspenseQuery>;
export type CustomersQueryResult = Apollo.QueryResult<CustomersQuery, CustomersQueryVariables>;
export const GetinviteDocument = gql`
    query getinvite($token: String!) {
  invite(token: $token) {
    id
    email
    organization {
      id
      name
    }
  }
}
    `;

/**
 * __useGetinviteQuery__
 *
 * To run a query within a React component, call `useGetinviteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetinviteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetinviteQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetinviteQuery(baseOptions: Apollo.QueryHookOptions<GetinviteQuery, GetinviteQueryVariables> & ({ variables: GetinviteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
      }
export function useGetinviteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export function useGetinviteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export type GetinviteQueryHookResult = ReturnType<typeof useGetinviteQuery>;
export type GetinviteLazyQueryHookResult = ReturnType<typeof useGetinviteLazyQuery>;
export type GetinviteSuspenseQueryHookResult = ReturnType<typeof useGetinviteSuspenseQuery>;
export type GetinviteQueryResult = Apollo.QueryResult<GetinviteQuery, GetinviteQueryVariables>;
export const AcceptInviteDocument = gql`
    mutation acceptInvite($input: AcceptInviteInput!) {
  acceptInvite(input: $input) {
    token
  }
}
    `;
export type AcceptInviteMutationFn = Apollo.MutationFunction<AcceptInviteMutation, AcceptInviteMutationVariables>;

/**
 * __useAcceptInviteMutation__
 *
 * To run a mutation, you first call `useAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptInviteMutation, { data, loading, error }] = useAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<AcceptInviteMutation, AcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AcceptInviteMutation, AcceptInviteMutationVariables>(AcceptInviteDocument, options);
      }
export type AcceptInviteMutationHookResult = ReturnType<typeof useAcceptInviteMutation>;
export type AcceptInviteMutationResult = Apollo.MutationResult<AcceptInviteMutation>;
export type AcceptInviteMutationOptions = Apollo.BaseMutationOptions<AcceptInviteMutation, AcceptInviteMutationVariables>;
export const GoogleAcceptInviteDocument = gql`
    mutation googleAcceptInvite($input: GoogleAcceptInviteInput!) {
  googleAcceptInvite(input: $input) {
    token
  }
}
    `;
export type GoogleAcceptInviteMutationFn = Apollo.MutationFunction<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;

/**
 * __useGoogleAcceptInviteMutation__
 *
 * To run a mutation, you first call `useGoogleAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleAcceptInviteMutation, { data, loading, error }] = useGoogleAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>(GoogleAcceptInviteDocument, options);
      }
export type GoogleAcceptInviteMutationHookResult = ReturnType<typeof useGoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationResult = Apollo.MutationResult<GoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationOptions = Apollo.BaseMutationOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;
export const FetchOktaAuthorizeUrlDocument = gql`
    mutation fetchOktaAuthorizeUrl($input: OktaAuthorizeInput!) {
  oktaAuthorize(input: $input) {
    url
  }
}
    `;
export type FetchOktaAuthorizeUrlMutationFn = Apollo.MutationFunction<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>;

/**
 * __useFetchOktaAuthorizeUrlMutation__
 *
 * To run a mutation, you first call `useFetchOktaAuthorizeUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFetchOktaAuthorizeUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fetchOktaAuthorizeUrlMutation, { data, loading, error }] = useFetchOktaAuthorizeUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFetchOktaAuthorizeUrlMutation(baseOptions?: Apollo.MutationHookOptions<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>(FetchOktaAuthorizeUrlDocument, options);
      }
export type FetchOktaAuthorizeUrlMutationHookResult = ReturnType<typeof useFetchOktaAuthorizeUrlMutation>;
export type FetchOktaAuthorizeUrlMutationResult = Apollo.MutationResult<FetchOktaAuthorizeUrlMutation>;
export type FetchOktaAuthorizeUrlMutationOptions = Apollo.BaseMutationOptions<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>;
export const OktaAcceptInviteDocument = gql`
    mutation oktaAcceptInvite($input: OktaAcceptInviteInput!) {
  oktaAcceptInvite(input: $input) {
    token
  }
}
    `;
export type OktaAcceptInviteMutationFn = Apollo.MutationFunction<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>;

/**
 * __useOktaAcceptInviteMutation__
 *
 * To run a mutation, you first call `useOktaAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOktaAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [oktaAcceptInviteMutation, { data, loading, error }] = useOktaAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOktaAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>(OktaAcceptInviteDocument, options);
      }
export type OktaAcceptInviteMutationHookResult = ReturnType<typeof useOktaAcceptInviteMutation>;
export type OktaAcceptInviteMutationResult = Apollo.MutationResult<OktaAcceptInviteMutation>;
export type OktaAcceptInviteMutationOptions = Apollo.BaseMutationOptions<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>;
export const GetInvoicesListDocument = gql`
    query getInvoicesList($currency: CurrencyEnum, $customerExternalId: String, $invoiceType: [InvoiceTypeEnum!], $issuingDateFrom: ISO8601Date, $issuingDateTo: ISO8601Date, $limit: Int, $page: Int, $partiallyPaid: Boolean, $paymentDisputeLost: Boolean, $paymentOverdue: Boolean, $paymentStatus: [InvoicePaymentStatusTypeEnum!], $searchTerm: String, $status: [InvoiceStatusTypeEnum!], $amountFrom: Int, $amountTo: Int, $selfBilled: Boolean, $billingEntityIds: [ID!]) {
  invoices(
    currency: $currency
    customerExternalId: $customerExternalId
    invoiceType: $invoiceType
    issuingDateFrom: $issuingDateFrom
    issuingDateTo: $issuingDateTo
    limit: $limit
    page: $page
    partiallyPaid: $partiallyPaid
    paymentDisputeLost: $paymentDisputeLost
    paymentOverdue: $paymentOverdue
    paymentStatus: $paymentStatus
    searchTerm: $searchTerm
    status: $status
    amountFrom: $amountFrom
    amountTo: $amountTo
    selfBilled: $selfBilled
    billingEntityIds: $billingEntityIds
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...InvoiceListItem
    }
  }
}
    ${InvoiceListItemFragmentDoc}`;

/**
 * __useGetInvoicesListQuery__
 *
 * To run a query within a React component, call `useGetInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicesListQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      customerExternalId: // value for 'customerExternalId'
 *      invoiceType: // value for 'invoiceType'
 *      issuingDateFrom: // value for 'issuingDateFrom'
 *      issuingDateTo: // value for 'issuingDateTo'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      partiallyPaid: // value for 'partiallyPaid'
 *      paymentDisputeLost: // value for 'paymentDisputeLost'
 *      paymentOverdue: // value for 'paymentOverdue'
 *      paymentStatus: // value for 'paymentStatus'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *      amountFrom: // value for 'amountFrom'
 *      amountTo: // value for 'amountTo'
 *      selfBilled: // value for 'selfBilled'
 *      billingEntityIds: // value for 'billingEntityIds'
 *   },
 * });
 */
export function useGetInvoicesListQuery(baseOptions?: Apollo.QueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
      }
export function useGetInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
        }
export function useGetInvoicesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
        }
export type GetInvoicesListQueryHookResult = ReturnType<typeof useGetInvoicesListQuery>;
export type GetInvoicesListLazyQueryHookResult = ReturnType<typeof useGetInvoicesListLazyQuery>;
export type GetInvoicesListSuspenseQueryHookResult = ReturnType<typeof useGetInvoicesListSuspenseQuery>;
export type GetInvoicesListQueryResult = Apollo.QueryResult<GetInvoicesListQuery, GetInvoicesListQueryVariables>;
export const RetryAllInvoicePaymentsDocument = gql`
    mutation retryAllInvoicePayments($input: RetryAllInvoicePaymentsInput!) {
  retryAllInvoicePayments(input: $input) {
    metadata {
      totalCount
    }
  }
}
    `;
export type RetryAllInvoicePaymentsMutationFn = Apollo.MutationFunction<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;

/**
 * __useRetryAllInvoicePaymentsMutation__
 *
 * To run a mutation, you first call `useRetryAllInvoicePaymentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllInvoicePaymentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllInvoicePaymentsMutation, { data, loading, error }] = useRetryAllInvoicePaymentsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllInvoicePaymentsMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>(RetryAllInvoicePaymentsDocument, options);
      }
export type RetryAllInvoicePaymentsMutationHookResult = ReturnType<typeof useRetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationResult = Apollo.MutationResult<RetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationOptions = Apollo.BaseMutationOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;
export const CreateInvoicesDataExportDocument = gql`
    mutation createInvoicesDataExport($input: CreateDataExportsInvoicesInput!) {
  createInvoicesDataExport(input: $input) {
    id
  }
}
    `;
export type CreateInvoicesDataExportMutationFn = Apollo.MutationFunction<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>;

/**
 * __useCreateInvoicesDataExportMutation__
 *
 * To run a mutation, you first call `useCreateInvoicesDataExportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoicesDataExportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoicesDataExportMutation, { data, loading, error }] = useCreateInvoicesDataExportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoicesDataExportMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>(CreateInvoicesDataExportDocument, options);
      }
export type CreateInvoicesDataExportMutationHookResult = ReturnType<typeof useCreateInvoicesDataExportMutation>;
export type CreateInvoicesDataExportMutationResult = Apollo.MutationResult<CreateInvoicesDataExportMutation>;
export type CreateInvoicesDataExportMutationOptions = Apollo.BaseMutationOptions<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>;
export const GetPaymentDetailsDocument = gql`
    query GetPaymentDetails($id: ID!) {
  payment(id: $id) {
    id
    amountCents
    amountCurrency
    createdAt
    updatedAt
    reference
    paymentType
    paymentProviderType
    payablePaymentStatus
    providerPaymentId
    customer {
      deletedAt
      id
      name
      displayName
      applicableTimezone
    }
    payable {
      ... on Invoice {
        id
        payableType
        ...InvoiceForPaymentDetails
      }
      ... on PaymentRequest {
        id
        payableType
        invoices {
          ...InvoiceForPaymentDetails
        }
      }
    }
    paymentReceipt {
      id
    }
  }
}
    ${InvoiceForPaymentDetailsFragmentDoc}`;

/**
 * __useGetPaymentDetailsQuery__
 *
 * To run a query within a React component, call `useGetPaymentDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPaymentDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPaymentDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPaymentDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables> & ({ variables: GetPaymentDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>(GetPaymentDetailsDocument, options);
      }
export function useGetPaymentDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>(GetPaymentDetailsDocument, options);
        }
export function useGetPaymentDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>(GetPaymentDetailsDocument, options);
        }
export type GetPaymentDetailsQueryHookResult = ReturnType<typeof useGetPaymentDetailsQuery>;
export type GetPaymentDetailsLazyQueryHookResult = ReturnType<typeof useGetPaymentDetailsLazyQuery>;
export type GetPaymentDetailsSuspenseQueryHookResult = ReturnType<typeof useGetPaymentDetailsSuspenseQuery>;
export type GetPaymentDetailsQueryResult = Apollo.QueryResult<GetPaymentDetailsQuery, GetPaymentDetailsQueryVariables>;
export const GetPaymentsListDocument = gql`
    query getPaymentsList($invoiceId: ID, $externalCustomerId: ID, $limit: Int, $page: Int, $searchTerm: String) {
  payments(
    invoiceId: $invoiceId
    externalCustomerId: $externalCustomerId
    limit: $limit
    page: $page
    searchTerm: $searchTerm
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      ...PaymentForPaymentsList
    }
  }
}
    ${PaymentForPaymentsListFragmentDoc}`;

/**
 * __useGetPaymentsListQuery__
 *
 * To run a query within a React component, call `useGetPaymentsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPaymentsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPaymentsListQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPaymentsListQuery(baseOptions?: Apollo.QueryHookOptions<GetPaymentsListQuery, GetPaymentsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPaymentsListQuery, GetPaymentsListQueryVariables>(GetPaymentsListDocument, options);
      }
export function useGetPaymentsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPaymentsListQuery, GetPaymentsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPaymentsListQuery, GetPaymentsListQueryVariables>(GetPaymentsListDocument, options);
        }
export function useGetPaymentsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPaymentsListQuery, GetPaymentsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPaymentsListQuery, GetPaymentsListQueryVariables>(GetPaymentsListDocument, options);
        }
export type GetPaymentsListQueryHookResult = ReturnType<typeof useGetPaymentsListQuery>;
export type GetPaymentsListLazyQueryHookResult = ReturnType<typeof useGetPaymentsListLazyQuery>;
export type GetPaymentsListSuspenseQueryHookResult = ReturnType<typeof useGetPaymentsListSuspenseQuery>;
export type GetPaymentsListQueryResult = Apollo.QueryResult<GetPaymentsListQuery, GetPaymentsListQueryVariables>;
export const GetPlanForDetailsDocument = gql`
    query getPlanForDetails($planId: ID!) {
  plan(id: $planId) {
    id
    name
    code
    parent {
      id
    }
    ...DeletePlanDialog
  }
}
    ${DeletePlanDialogFragmentDoc}`;

/**
 * __useGetPlanForDetailsQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsQuery({
 *   variables: {
 *      planId: // value for 'planId'
 *   },
 * });
 */
export function useGetPlanForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables> & ({ variables: GetPlanForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
      }
export function useGetPlanForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export function useGetPlanForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export type GetPlanForDetailsQueryHookResult = ReturnType<typeof useGetPlanForDetailsQuery>;
export type GetPlanForDetailsLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsLazyQuery>;
export type GetPlanForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsSuspenseQuery>;
export type GetPlanForDetailsQueryResult = Apollo.QueryResult<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>;
export const PlansDocument = gql`
    query plans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...PlanItem
    }
  }
}
    ${PlanItemFragmentDoc}`;

/**
 * __usePlansQuery__
 *
 * To run a query within a React component, call `usePlansQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function usePlansQuery(baseOptions?: Apollo.QueryHookOptions<PlansQuery, PlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
      }
export function usePlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export function usePlansSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export type PlansQueryHookResult = ReturnType<typeof usePlansQuery>;
export type PlansLazyQueryHookResult = ReturnType<typeof usePlansLazyQuery>;
export type PlansSuspenseQueryHookResult = ReturnType<typeof usePlansSuspenseQuery>;
export type PlansQueryResult = Apollo.QueryResult<PlansQuery, PlansQueryVariables>;
export const GetSubscriptionsListDocument = gql`
    query getSubscriptionsList($limit: Int, $page: Int, $searchTerm: String, $status: [StatusTypeEnum!], $externalCustomerId: String, $overriden: Boolean, $planCode: String) {
  subscriptions(
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
    externalCustomerId: $externalCustomerId
    overriden: $overriden
    planCode: $planCode
  ) {
    collection {
      ...SubscriptionForSubscriptionsList
    }
    metadata {
      currentPage
      totalPages
      totalCount
    }
  }
}
    ${SubscriptionForSubscriptionsListFragmentDoc}`;

/**
 * __useGetSubscriptionsListQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      overriden: // value for 'overriden'
 *      planCode: // value for 'planCode'
 *   },
 * });
 */
export function useGetSubscriptionsListQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>(GetSubscriptionsListDocument, options);
      }
export function useGetSubscriptionsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>(GetSubscriptionsListDocument, options);
        }
export function useGetSubscriptionsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>(GetSubscriptionsListDocument, options);
        }
export type GetSubscriptionsListQueryHookResult = ReturnType<typeof useGetSubscriptionsListQuery>;
export type GetSubscriptionsListLazyQueryHookResult = ReturnType<typeof useGetSubscriptionsListLazyQuery>;
export type GetSubscriptionsListSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionsListSuspenseQuery>;
export type GetSubscriptionsListQueryResult = Apollo.QueryResult<GetSubscriptionsListQuery, GetSubscriptionsListQueryVariables>;
export const GetInvoiceCollectionsForAnalyticsDocument = gql`
    query getInvoiceCollectionsForAnalytics($currency: CurrencyEnum!, $billingEntityCode: String, $isCustomerTinEmpty: Boolean) {
  invoiceCollections(
    currency: $currency
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
  ) {
    collection {
      paymentStatus
      invoicesCount
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetInvoiceCollectionsForAnalyticsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCollectionsForAnalyticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCollectionsForAnalyticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCollectionsForAnalyticsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *   },
 * });
 */
export function useGetInvoiceCollectionsForAnalyticsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables> & ({ variables: GetInvoiceCollectionsForAnalyticsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>(GetInvoiceCollectionsForAnalyticsDocument, options);
      }
export function useGetInvoiceCollectionsForAnalyticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>(GetInvoiceCollectionsForAnalyticsDocument, options);
        }
export function useGetInvoiceCollectionsForAnalyticsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>(GetInvoiceCollectionsForAnalyticsDocument, options);
        }
export type GetInvoiceCollectionsForAnalyticsQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsForAnalyticsQuery>;
export type GetInvoiceCollectionsForAnalyticsLazyQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsForAnalyticsLazyQuery>;
export type GetInvoiceCollectionsForAnalyticsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsForAnalyticsSuspenseQuery>;
export type GetInvoiceCollectionsForAnalyticsQueryResult = Apollo.QueryResult<GetInvoiceCollectionsForAnalyticsQuery, GetInvoiceCollectionsForAnalyticsQueryVariables>;
export const GetOverdueForAnalyticsDocument = gql`
    query getOverdueForAnalytics($currency: CurrencyEnum!, $externalCustomerId: String, $months: Int!, $billingEntityCode: String, $isCustomerTinEmpty: Boolean) {
  overdueBalances(
    currency: $currency
    externalCustomerId: $externalCustomerId
    months: $months
    billingEntityCode: $billingEntityCode
    isCustomerTinEmpty: $isCustomerTinEmpty
  ) {
    collection {
      amountCents
      currency
      month
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetOverdueForAnalyticsQuery__
 *
 * To run a query within a React component, call `useGetOverdueForAnalyticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOverdueForAnalyticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOverdueForAnalyticsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      months: // value for 'months'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *   },
 * });
 */
export function useGetOverdueForAnalyticsQuery(baseOptions: Apollo.QueryHookOptions<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables> & ({ variables: GetOverdueForAnalyticsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>(GetOverdueForAnalyticsDocument, options);
      }
export function useGetOverdueForAnalyticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>(GetOverdueForAnalyticsDocument, options);
        }
export function useGetOverdueForAnalyticsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>(GetOverdueForAnalyticsDocument, options);
        }
export type GetOverdueForAnalyticsQueryHookResult = ReturnType<typeof useGetOverdueForAnalyticsQuery>;
export type GetOverdueForAnalyticsLazyQueryHookResult = ReturnType<typeof useGetOverdueForAnalyticsLazyQuery>;
export type GetOverdueForAnalyticsSuspenseQueryHookResult = ReturnType<typeof useGetOverdueForAnalyticsSuspenseQuery>;
export type GetOverdueForAnalyticsQueryResult = Apollo.QueryResult<GetOverdueForAnalyticsQuery, GetOverdueForAnalyticsQueryVariables>;
export const CreatePasswordResetDocument = gql`
    mutation createPasswordReset($input: CreatePasswordResetInput!) {
  createPasswordReset(input: $input) {
    id
  }
}
    `;
export type CreatePasswordResetMutationFn = Apollo.MutationFunction<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;

/**
 * __useCreatePasswordResetMutation__
 *
 * To run a mutation, you first call `useCreatePasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPasswordResetMutation, { data, loading, error }] = useCreatePasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePasswordResetMutation(baseOptions?: Apollo.MutationHookOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>(CreatePasswordResetDocument, options);
      }
export type CreatePasswordResetMutationHookResult = ReturnType<typeof useCreatePasswordResetMutation>;
export type CreatePasswordResetMutationResult = Apollo.MutationResult<CreatePasswordResetMutation>;
export type CreatePasswordResetMutationOptions = Apollo.BaseMutationOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;
export const GoogleLoginUserDocument = gql`
    mutation googleLoginUser($input: GoogleLoginUserInput!) {
  googleLoginUser(input: $input) {
    token
  }
}
    `;
export type GoogleLoginUserMutationFn = Apollo.MutationFunction<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;

/**
 * __useGoogleLoginUserMutation__
 *
 * To run a mutation, you first call `useGoogleLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleLoginUserMutation, { data, loading, error }] = useGoogleLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>(GoogleLoginUserDocument, options);
      }
export type GoogleLoginUserMutationHookResult = ReturnType<typeof useGoogleLoginUserMutation>;
export type GoogleLoginUserMutationResult = Apollo.MutationResult<GoogleLoginUserMutation>;
export type GoogleLoginUserMutationOptions = Apollo.BaseMutationOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;
export const LoginUserDocument = gql`
    mutation loginUser($input: LoginUserInput!) {
  loginUser(input: $input) {
    token
  }
}
    `;
export type LoginUserMutationFn = Apollo.MutationFunction<LoginUserMutation, LoginUserMutationVariables>;

/**
 * __useLoginUserMutation__
 *
 * To run a mutation, you first call `useLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginUserMutation, { data, loading, error }] = useLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<LoginUserMutation, LoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginUserMutation, LoginUserMutationVariables>(LoginUserDocument, options);
      }
export type LoginUserMutationHookResult = ReturnType<typeof useLoginUserMutation>;
export type LoginUserMutationResult = Apollo.MutationResult<LoginUserMutation>;
export type LoginUserMutationOptions = Apollo.BaseMutationOptions<LoginUserMutation, LoginUserMutationVariables>;
export const OktaLoginUserDocument = gql`
    mutation oktaLoginUser($input: OktaLoginInput!) {
  oktaLogin(input: $input) {
    token
  }
}
    `;
export type OktaLoginUserMutationFn = Apollo.MutationFunction<OktaLoginUserMutation, OktaLoginUserMutationVariables>;

/**
 * __useOktaLoginUserMutation__
 *
 * To run a mutation, you first call `useOktaLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOktaLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [oktaLoginUserMutation, { data, loading, error }] = useOktaLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOktaLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<OktaLoginUserMutation, OktaLoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OktaLoginUserMutation, OktaLoginUserMutationVariables>(OktaLoginUserDocument, options);
      }
export type OktaLoginUserMutationHookResult = ReturnType<typeof useOktaLoginUserMutation>;
export type OktaLoginUserMutationResult = Apollo.MutationResult<OktaLoginUserMutation>;
export type OktaLoginUserMutationOptions = Apollo.BaseMutationOptions<OktaLoginUserMutation, OktaLoginUserMutationVariables>;
export const GetPasswordResetDocument = gql`
    query getPasswordReset($token: String!) {
  passwordReset(token: $token) {
    id
    user {
      id
      email
    }
  }
}
    `;

/**
 * __useGetPasswordResetQuery__
 *
 * To run a query within a React component, call `useGetPasswordResetQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPasswordResetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPasswordResetQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetPasswordResetQuery(baseOptions: Apollo.QueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables> & ({ variables: GetPasswordResetQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
      }
export function useGetPasswordResetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export function useGetPasswordResetSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export type GetPasswordResetQueryHookResult = ReturnType<typeof useGetPasswordResetQuery>;
export type GetPasswordResetLazyQueryHookResult = ReturnType<typeof useGetPasswordResetLazyQuery>;
export type GetPasswordResetSuspenseQueryHookResult = ReturnType<typeof useGetPasswordResetSuspenseQuery>;
export type GetPasswordResetQueryResult = Apollo.QueryResult<GetPasswordResetQuery, GetPasswordResetQueryVariables>;
export const ResetPasswordDocument = gql`
    mutation resetPassword($input: ResetPasswordInput!) {
  resetPassword(input: $input) {
    token
  }
}
    `;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, options);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const SignupDocument = gql`
    mutation signup($input: RegisterUserInput!) {
  registerUser(input: $input) {
    token
  }
}
    `;
export type SignupMutationFn = Apollo.MutationFunction<SignupMutation, SignupMutationVariables>;

/**
 * __useSignupMutation__
 *
 * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupMutation, { data, loading, error }] = useSignupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignupMutation(baseOptions?: Apollo.MutationHookOptions<SignupMutation, SignupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, options);
      }
export type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;
export type SignupMutationResult = Apollo.MutationResult<SignupMutation>;
export type SignupMutationOptions = Apollo.BaseMutationOptions<SignupMutation, SignupMutationVariables>;
export const GoogleRegisterDocument = gql`
    mutation googleRegister($input: GoogleRegisterUserInput!) {
  googleRegisterUser(input: $input) {
    token
  }
}
    `;
export type GoogleRegisterMutationFn = Apollo.MutationFunction<GoogleRegisterMutation, GoogleRegisterMutationVariables>;

/**
 * __useGoogleRegisterMutation__
 *
 * To run a mutation, you first call `useGoogleRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleRegisterMutation, { data, loading, error }] = useGoogleRegisterMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleRegisterMutation(baseOptions?: Apollo.MutationHookOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleRegisterMutation, GoogleRegisterMutationVariables>(GoogleRegisterDocument, options);
      }
export type GoogleRegisterMutationHookResult = ReturnType<typeof useGoogleRegisterMutation>;
export type GoogleRegisterMutationResult = Apollo.MutationResult<GoogleRegisterMutation>;
export type GoogleRegisterMutationOptions = Apollo.BaseMutationOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>;
export const GetPortalOrgaInfosDocument = gql`
    query getPortalOrgaInfos {
  customerPortalOrganization {
    id
    name
    logoUrl
    premiumIntegrations
  }
}
    `;

/**
 * __useGetPortalOrgaInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalOrgaInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalOrgaInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalOrgaInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalOrgaInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
      }
export function useGetPortalOrgaInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export function useGetPortalOrgaInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export type GetPortalOrgaInfosQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosQuery>;
export type GetPortalOrgaInfosLazyQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosLazyQuery>;
export type GetPortalOrgaInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosSuspenseQuery>;
export type GetPortalOrgaInfosQueryResult = Apollo.QueryResult<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>;
export const GetApiKeyToEditDocument = gql`
    query getApiKeyToEdit($apiKeyId: ID!) {
  apiKey(id: $apiKeyId) {
    id
    name
    lastUsedAt
    permissions
  }
}
    `;

/**
 * __useGetApiKeyToEditQuery__
 *
 * To run a query within a React component, call `useGetApiKeyToEditQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApiKeyToEditQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApiKeyToEditQuery({
 *   variables: {
 *      apiKeyId: // value for 'apiKeyId'
 *   },
 * });
 */
export function useGetApiKeyToEditQuery(baseOptions: Apollo.QueryHookOptions<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables> & ({ variables: GetApiKeyToEditQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>(GetApiKeyToEditDocument, options);
      }
export function useGetApiKeyToEditLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>(GetApiKeyToEditDocument, options);
        }
export function useGetApiKeyToEditSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>(GetApiKeyToEditDocument, options);
        }
export type GetApiKeyToEditQueryHookResult = ReturnType<typeof useGetApiKeyToEditQuery>;
export type GetApiKeyToEditLazyQueryHookResult = ReturnType<typeof useGetApiKeyToEditLazyQuery>;
export type GetApiKeyToEditSuspenseQueryHookResult = ReturnType<typeof useGetApiKeyToEditSuspenseQuery>;
export type GetApiKeyToEditQueryResult = Apollo.QueryResult<GetApiKeyToEditQuery, GetApiKeyToEditQueryVariables>;
export const CreateApiKeyDocument = gql`
    mutation createApiKey($input: CreateApiKeyInput!) {
  createApiKey(input: $input) {
    id
  }
}
    `;
export type CreateApiKeyMutationFn = Apollo.MutationFunction<CreateApiKeyMutation, CreateApiKeyMutationVariables>;

/**
 * __useCreateApiKeyMutation__
 *
 * To run a mutation, you first call `useCreateApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createApiKeyMutation, { data, loading, error }] = useCreateApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<CreateApiKeyMutation, CreateApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateApiKeyMutation, CreateApiKeyMutationVariables>(CreateApiKeyDocument, options);
      }
export type CreateApiKeyMutationHookResult = ReturnType<typeof useCreateApiKeyMutation>;
export type CreateApiKeyMutationResult = Apollo.MutationResult<CreateApiKeyMutation>;
export type CreateApiKeyMutationOptions = Apollo.BaseMutationOptions<CreateApiKeyMutation, CreateApiKeyMutationVariables>;
export const UpdateApiKeyDocument = gql`
    mutation updateApiKey($input: UpdateApiKeyInput!) {
  updateApiKey(input: $input) {
    id
  }
}
    `;
export type UpdateApiKeyMutationFn = Apollo.MutationFunction<UpdateApiKeyMutation, UpdateApiKeyMutationVariables>;

/**
 * __useUpdateApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateApiKeyMutation, { data, loading, error }] = useUpdateApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateApiKeyMutation, UpdateApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateApiKeyMutation, UpdateApiKeyMutationVariables>(UpdateApiKeyDocument, options);
      }
export type UpdateApiKeyMutationHookResult = ReturnType<typeof useUpdateApiKeyMutation>;
export type UpdateApiKeyMutationResult = Apollo.MutationResult<UpdateApiKeyMutation>;
export type UpdateApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateApiKeyMutation, UpdateApiKeyMutationVariables>;
export const GetFeatureForDetailsDocument = gql`
    query getFeatureForDetails($feature: ID!) {
  feature(id: $feature) {
    id
    name
    code
    ...FeatureForDeleteFeatureDialog
  }
}
    ${FeatureForDeleteFeatureDialogFragmentDoc}`;

/**
 * __useGetFeatureForDetailsQuery__
 *
 * To run a query within a React component, call `useGetFeatureForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeatureForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeatureForDetailsQuery({
 *   variables: {
 *      feature: // value for 'feature'
 *   },
 * });
 */
export function useGetFeatureForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables> & ({ variables: GetFeatureForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>(GetFeatureForDetailsDocument, options);
      }
export function useGetFeatureForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>(GetFeatureForDetailsDocument, options);
        }
export function useGetFeatureForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>(GetFeatureForDetailsDocument, options);
        }
export type GetFeatureForDetailsQueryHookResult = ReturnType<typeof useGetFeatureForDetailsQuery>;
export type GetFeatureForDetailsLazyQueryHookResult = ReturnType<typeof useGetFeatureForDetailsLazyQuery>;
export type GetFeatureForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetFeatureForDetailsSuspenseQuery>;
export type GetFeatureForDetailsQueryResult = Apollo.QueryResult<GetFeatureForDetailsQuery, GetFeatureForDetailsQueryVariables>;
export const GetFeatureDocument = gql`
    query getFeature($id: ID!) {
  feature(id: $id) {
    ...FeatureForFeatureForm
  }
}
    ${FeatureForFeatureFormFragmentDoc}`;

/**
 * __useGetFeatureQuery__
 *
 * To run a query within a React component, call `useGetFeatureQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeatureQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeatureQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetFeatureQuery(baseOptions: Apollo.QueryHookOptions<GetFeatureQuery, GetFeatureQueryVariables> & ({ variables: GetFeatureQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeatureQuery, GetFeatureQueryVariables>(GetFeatureDocument, options);
      }
export function useGetFeatureLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeatureQuery, GetFeatureQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeatureQuery, GetFeatureQueryVariables>(GetFeatureDocument, options);
        }
export function useGetFeatureSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeatureQuery, GetFeatureQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeatureQuery, GetFeatureQueryVariables>(GetFeatureDocument, options);
        }
export type GetFeatureQueryHookResult = ReturnType<typeof useGetFeatureQuery>;
export type GetFeatureLazyQueryHookResult = ReturnType<typeof useGetFeatureLazyQuery>;
export type GetFeatureSuspenseQueryHookResult = ReturnType<typeof useGetFeatureSuspenseQuery>;
export type GetFeatureQueryResult = Apollo.QueryResult<GetFeatureQuery, GetFeatureQueryVariables>;
export const CreateFeatureDocument = gql`
    mutation createFeature($input: CreateFeatureInput!) {
  createFeature(input: $input) {
    id
  }
}
    `;
export type CreateFeatureMutationFn = Apollo.MutationFunction<CreateFeatureMutation, CreateFeatureMutationVariables>;

/**
 * __useCreateFeatureMutation__
 *
 * To run a mutation, you first call `useCreateFeatureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFeatureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFeatureMutation, { data, loading, error }] = useCreateFeatureMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFeatureMutation(baseOptions?: Apollo.MutationHookOptions<CreateFeatureMutation, CreateFeatureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFeatureMutation, CreateFeatureMutationVariables>(CreateFeatureDocument, options);
      }
export type CreateFeatureMutationHookResult = ReturnType<typeof useCreateFeatureMutation>;
export type CreateFeatureMutationResult = Apollo.MutationResult<CreateFeatureMutation>;
export type CreateFeatureMutationOptions = Apollo.BaseMutationOptions<CreateFeatureMutation, CreateFeatureMutationVariables>;
export const UpdateFeatureDocument = gql`
    mutation updateFeature($input: UpdateFeatureInput!) {
  updateFeature(input: $input) {
    id
  }
}
    `;
export type UpdateFeatureMutationFn = Apollo.MutationFunction<UpdateFeatureMutation, UpdateFeatureMutationVariables>;

/**
 * __useUpdateFeatureMutation__
 *
 * To run a mutation, you first call `useUpdateFeatureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFeatureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFeatureMutation, { data, loading, error }] = useUpdateFeatureMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFeatureMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFeatureMutation, UpdateFeatureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFeatureMutation, UpdateFeatureMutationVariables>(UpdateFeatureDocument, options);
      }
export type UpdateFeatureMutationHookResult = ReturnType<typeof useUpdateFeatureMutation>;
export type UpdateFeatureMutationResult = Apollo.MutationResult<UpdateFeatureMutation>;
export type UpdateFeatureMutationOptions = Apollo.BaseMutationOptions<UpdateFeatureMutation, UpdateFeatureMutationVariables>;
export const GetFeaturesListDocument = gql`
    query getFeaturesList($limit: Int, $page: Int, $searchTerm: String) {
  features(limit: $limit, page: $page, searchTerm: $searchTerm) {
    collection {
      ...FeatureForFeaturesList
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${FeatureForFeaturesListFragmentDoc}`;

/**
 * __useGetFeaturesListQuery__
 *
 * To run a query within a React component, call `useGetFeaturesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeaturesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeaturesListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetFeaturesListQuery(baseOptions?: Apollo.QueryHookOptions<GetFeaturesListQuery, GetFeaturesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeaturesListQuery, GetFeaturesListQueryVariables>(GetFeaturesListDocument, options);
      }
export function useGetFeaturesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeaturesListQuery, GetFeaturesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeaturesListQuery, GetFeaturesListQueryVariables>(GetFeaturesListDocument, options);
        }
export function useGetFeaturesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeaturesListQuery, GetFeaturesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeaturesListQuery, GetFeaturesListQueryVariables>(GetFeaturesListDocument, options);
        }
export type GetFeaturesListQueryHookResult = ReturnType<typeof useGetFeaturesListQuery>;
export type GetFeaturesListLazyQueryHookResult = ReturnType<typeof useGetFeaturesListLazyQuery>;
export type GetFeaturesListSuspenseQueryHookResult = ReturnType<typeof useGetFeaturesListSuspenseQuery>;
export type GetFeaturesListQueryResult = Apollo.QueryResult<GetFeaturesListQuery, GetFeaturesListQueryVariables>;
export const GetForecastsDocument = gql`
    query getForecasts($billableMetricCode: String, $billingEntityCode: String, $currency: CurrencyEnum, $customerCountry: CountryCode, $customerType: CustomerTypeEnum, $externalCustomerId: String, $isCustomerTinEmpty: Boolean, $externalSubscriptionId: String, $planCode: String, $fromDate: ISO8601Date, $toDate: ISO8601Date, $timeGranularity: TimeGranularityEnum) {
  dataApiUsagesForecasted(
    billableMetricCode: $billableMetricCode
    billingEntityCode: $billingEntityCode
    currency: $currency
    customerCountry: $customerCountry
    customerType: $customerType
    externalCustomerId: $externalCustomerId
    isCustomerTinEmpty: $isCustomerTinEmpty
    externalSubscriptionId: $externalSubscriptionId
    planCode: $planCode
    fromDate: $fromDate
    toDate: $toDate
    timeGranularity: $timeGranularity
  ) {
    collection {
      amountCents
      units
      amountCentsForecastConservative
      amountCentsForecastRealistic
      amountCentsForecastOptimistic
      unitsForecastConservative
      unitsForecastRealistic
      unitsForecastOptimistic
      amountCurrency
      endOfPeriodDt
      startOfPeriodDt
    }
  }
}
    `;

/**
 * __useGetForecastsQuery__
 *
 * To run a query within a React component, call `useGetForecastsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetForecastsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetForecastsQuery({
 *   variables: {
 *      billableMetricCode: // value for 'billableMetricCode'
 *      billingEntityCode: // value for 'billingEntityCode'
 *      currency: // value for 'currency'
 *      customerCountry: // value for 'customerCountry'
 *      customerType: // value for 'customerType'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      isCustomerTinEmpty: // value for 'isCustomerTinEmpty'
 *      externalSubscriptionId: // value for 'externalSubscriptionId'
 *      planCode: // value for 'planCode'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      timeGranularity: // value for 'timeGranularity'
 *   },
 * });
 */
export function useGetForecastsQuery(baseOptions?: Apollo.QueryHookOptions<GetForecastsQuery, GetForecastsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetForecastsQuery, GetForecastsQueryVariables>(GetForecastsDocument, options);
      }
export function useGetForecastsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetForecastsQuery, GetForecastsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetForecastsQuery, GetForecastsQueryVariables>(GetForecastsDocument, options);
        }
export function useGetForecastsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetForecastsQuery, GetForecastsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetForecastsQuery, GetForecastsQueryVariables>(GetForecastsDocument, options);
        }
export type GetForecastsQueryHookResult = ReturnType<typeof useGetForecastsQuery>;
export type GetForecastsLazyQueryHookResult = ReturnType<typeof useGetForecastsLazyQuery>;
export type GetForecastsSuspenseQueryHookResult = ReturnType<typeof useGetForecastsSuspenseQuery>;
export type GetForecastsQueryResult = Apollo.QueryResult<GetForecastsQuery, GetForecastsQueryVariables>;
export const GetAdyenIntegrationsDetailsDocument = gql`
    query getAdyenIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on AdyenProvider {
      id
      ...AdyenIntegrationDetails
      ...DeleteAdyenIntegrationDialog
      ...AddAdyenProviderDialog
      ...AdyenForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
      }
    }
  }
}
    ${AdyenIntegrationDetailsFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables> & ({ variables: GetAdyenIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
      }
export function useGetAdyenIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export function useGetAdyenIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export type GetAdyenIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsQuery>;
export type GetAdyenIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsLazyQuery>;
export type GetAdyenIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsSuspenseQuery>;
export type GetAdyenIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>;
export const GetAdyenIntegrationsListDocument = gql`
    query getAdyenIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
        ...AdyenIntegrations
        ...AddAdyenProviderDialog
        ...DeleteAdyenIntegrationDialog
      }
    }
  }
}
    ${AdyenIntegrationsFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
      }
export function useGetAdyenIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export function useGetAdyenIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export type GetAdyenIntegrationsListQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListQuery>;
export type GetAdyenIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListLazyQuery>;
export type GetAdyenIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListSuspenseQuery>;
export type GetAdyenIntegrationsListQueryResult = Apollo.QueryResult<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>;
export const GetAnrokIntegrationsDetailsDocument = gql`
    query getAnrokIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on AnrokIntegration {
      id
      ...AnrokIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    ${AnrokIntegrationDetailsFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetAnrokIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables> & ({ variables: GetAnrokIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
      }
export function useGetAnrokIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
        }
export function useGetAnrokIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
        }
export type GetAnrokIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsQuery>;
export type GetAnrokIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsLazyQuery>;
export type GetAnrokIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsSuspenseQuery>;
export type GetAnrokIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>;
export const GetAnrokIntegrationsListDocument = gql`
    query getAnrokIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on AnrokIntegration {
        id
        ...AnrokIntegrations
        ...AddAnrokIntegrationDialog
        ...DeleteAnrokIntegrationDialog
      }
    }
  }
}
    ${AnrokIntegrationsFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}
${DeleteAnrokIntegrationDialogFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetAnrokIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
      }
export function useGetAnrokIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
        }
export function useGetAnrokIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
        }
export type GetAnrokIntegrationsListQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListQuery>;
export type GetAnrokIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListLazyQuery>;
export type GetAnrokIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListSuspenseQuery>;
export type GetAnrokIntegrationsListQueryResult = Apollo.QueryResult<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>;
export const GetAuthIntegrationsDocument = gql`
    query GetAuthIntegrations($limit: Int!) {
  integrations(limit: $limit) {
    collection {
      ... on OktaIntegration {
        id
        ...AddOktaIntegrationDialog
        ...DeleteOktaIntegrationDialog
      }
    }
  }
}
    ${AddOktaIntegrationDialogFragmentDoc}
${DeleteOktaIntegrationDialogFragmentDoc}`;

/**
 * __useGetAuthIntegrationsQuery__
 *
 * To run a query within a React component, call `useGetAuthIntegrationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthIntegrationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthIntegrationsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAuthIntegrationsQuery(baseOptions: Apollo.QueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables> & ({ variables: GetAuthIntegrationsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
      }
export function useGetAuthIntegrationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
        }
export function useGetAuthIntegrationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
        }
export type GetAuthIntegrationsQueryHookResult = ReturnType<typeof useGetAuthIntegrationsQuery>;
export type GetAuthIntegrationsLazyQueryHookResult = ReturnType<typeof useGetAuthIntegrationsLazyQuery>;
export type GetAuthIntegrationsSuspenseQueryHookResult = ReturnType<typeof useGetAuthIntegrationsSuspenseQuery>;
export type GetAuthIntegrationsQueryResult = Apollo.QueryResult<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>;
export const GetOktaIntegrationDocument = gql`
    query GetOktaIntegration($id: ID) {
  integration(id: $id) {
    ... on OktaIntegration {
      ...OktaIntegrationDetails
      ...AddOktaIntegrationDialog
      ...DeleteOktaIntegrationDialog
    }
  }
}
    ${OktaIntegrationDetailsFragmentDoc}
${AddOktaIntegrationDialogFragmentDoc}
${DeleteOktaIntegrationDialogFragmentDoc}`;

/**
 * __useGetOktaIntegrationQuery__
 *
 * To run a query within a React component, call `useGetOktaIntegrationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOktaIntegrationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOktaIntegrationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetOktaIntegrationQuery(baseOptions?: Apollo.QueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
      }
export function useGetOktaIntegrationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
        }
export function useGetOktaIntegrationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
        }
export type GetOktaIntegrationQueryHookResult = ReturnType<typeof useGetOktaIntegrationQuery>;
export type GetOktaIntegrationLazyQueryHookResult = ReturnType<typeof useGetOktaIntegrationLazyQuery>;
export type GetOktaIntegrationSuspenseQueryHookResult = ReturnType<typeof useGetOktaIntegrationSuspenseQuery>;
export type GetOktaIntegrationQueryResult = Apollo.QueryResult<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>;
export const UpdateOrganizationAuthenticationMethodsDocument = gql`
    mutation updateOrganizationAuthenticationMethods($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    authenticationMethods
  }
}
    `;
export type UpdateOrganizationAuthenticationMethodsMutationFn = Apollo.MutationFunction<UpdateOrganizationAuthenticationMethodsMutation, UpdateOrganizationAuthenticationMethodsMutationVariables>;

/**
 * __useUpdateOrganizationAuthenticationMethodsMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationAuthenticationMethodsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationAuthenticationMethodsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationAuthenticationMethodsMutation, { data, loading, error }] = useUpdateOrganizationAuthenticationMethodsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationAuthenticationMethodsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationAuthenticationMethodsMutation, UpdateOrganizationAuthenticationMethodsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationAuthenticationMethodsMutation, UpdateOrganizationAuthenticationMethodsMutationVariables>(UpdateOrganizationAuthenticationMethodsDocument, options);
      }
export type UpdateOrganizationAuthenticationMethodsMutationHookResult = ReturnType<typeof useUpdateOrganizationAuthenticationMethodsMutation>;
export type UpdateOrganizationAuthenticationMethodsMutationResult = Apollo.MutationResult<UpdateOrganizationAuthenticationMethodsMutation>;
export type UpdateOrganizationAuthenticationMethodsMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationAuthenticationMethodsMutation, UpdateOrganizationAuthenticationMethodsMutationVariables>;
export const GetAvalaraIntegrationsDetailsDocument = gql`
    query getAvalaraIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on AvalaraIntegration {
      id
      ...AvalaraIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on AvalaraIntegration {
        id
      }
    }
  }
}
    ${AvalaraIntegrationDetailsFragmentDoc}`;

/**
 * __useGetAvalaraIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAvalaraIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvalaraIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvalaraIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetAvalaraIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables> & ({ variables: GetAvalaraIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>(GetAvalaraIntegrationsDetailsDocument, options);
      }
export function useGetAvalaraIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>(GetAvalaraIntegrationsDetailsDocument, options);
        }
export function useGetAvalaraIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>(GetAvalaraIntegrationsDetailsDocument, options);
        }
export type GetAvalaraIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsDetailsQuery>;
export type GetAvalaraIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsDetailsLazyQuery>;
export type GetAvalaraIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsDetailsSuspenseQuery>;
export type GetAvalaraIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAvalaraIntegrationsDetailsQuery, GetAvalaraIntegrationsDetailsQueryVariables>;
export const GetAvalaraIntegrationsListDocument = gql`
    query getAvalaraIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on AvalaraIntegration {
        id
        ...AvalaraIntegrations
        ...AddAvalaraIntegrationDialog
        ...DeleteAvalaraIntegrationDialog
      }
    }
  }
}
    ${AvalaraIntegrationsFragmentDoc}
${AddAvalaraIntegrationDialogFragmentDoc}
${DeleteAvalaraIntegrationDialogFragmentDoc}`;

/**
 * __useGetAvalaraIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAvalaraIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvalaraIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvalaraIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetAvalaraIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>(GetAvalaraIntegrationsListDocument, options);
      }
export function useGetAvalaraIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>(GetAvalaraIntegrationsListDocument, options);
        }
export function useGetAvalaraIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>(GetAvalaraIntegrationsListDocument, options);
        }
export type GetAvalaraIntegrationsListQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsListQuery>;
export type GetAvalaraIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsListLazyQuery>;
export type GetAvalaraIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAvalaraIntegrationsListSuspenseQuery>;
export type GetAvalaraIntegrationsListQueryResult = Apollo.QueryResult<GetAvalaraIntegrationsListQuery, GetAvalaraIntegrationsListQueryVariables>;
export const GetBillingEntitySettingsDocument = gql`
    query getBillingEntitySettings($code: String!, $appliedToOrganization: Boolean = true) {
  billingEntity(code: $code) {
    id
    code
    name
    netPaymentTerm
    defaultCurrency
    documentNumbering
    documentNumberPrefix
    finalizeZeroAmountInvoice
    billingConfiguration {
      id
      invoiceGracePeriod
      invoiceFooter
      documentLocale
    }
    ...EditBillingEntityInvoiceTemplateDialog
    ...EditBillingEntityNetPaymentTermForDialog
    ...EditBillingEntityDefaultCurrencyForDialog
    ...EditBillingEntityInvoiceNumberingDialog
  }
  taxes(appliedToOrganization: $appliedToOrganization) {
    collection {
      id
      name
      code
      rate
    }
  }
  invoiceCustomSections {
    collection {
      id
      name
      code
      ...DeleteCustomSection
    }
  }
}
    ${EditBillingEntityInvoiceTemplateDialogFragmentDoc}
${EditBillingEntityNetPaymentTermForDialogFragmentDoc}
${EditBillingEntityDefaultCurrencyForDialogFragmentDoc}
${EditBillingEntityInvoiceNumberingDialogFragmentDoc}
${DeleteCustomSectionFragmentDoc}`;

/**
 * __useGetBillingEntitySettingsQuery__
 *
 * To run a query within a React component, call `useGetBillingEntitySettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillingEntitySettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillingEntitySettingsQuery({
 *   variables: {
 *      code: // value for 'code'
 *      appliedToOrganization: // value for 'appliedToOrganization'
 *   },
 * });
 */
export function useGetBillingEntitySettingsQuery(baseOptions: Apollo.QueryHookOptions<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables> & ({ variables: GetBillingEntitySettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>(GetBillingEntitySettingsDocument, options);
      }
export function useGetBillingEntitySettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>(GetBillingEntitySettingsDocument, options);
        }
export function useGetBillingEntitySettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>(GetBillingEntitySettingsDocument, options);
        }
export type GetBillingEntitySettingsQueryHookResult = ReturnType<typeof useGetBillingEntitySettingsQuery>;
export type GetBillingEntitySettingsLazyQueryHookResult = ReturnType<typeof useGetBillingEntitySettingsLazyQuery>;
export type GetBillingEntitySettingsSuspenseQueryHookResult = ReturnType<typeof useGetBillingEntitySettingsSuspenseQuery>;
export type GetBillingEntitySettingsQueryResult = Apollo.QueryResult<GetBillingEntitySettingsQuery, GetBillingEntitySettingsQueryVariables>;
export const ApplyBillingEntityDunningCampaignDocument = gql`
    mutation applyBillingEntityDunningCampaign($input: BillingEntityUpdateAppliedDunningCampaignInput!) {
  billingEntityUpdateAppliedDunningCampaign(input: $input) {
    id
  }
}
    `;
export type ApplyBillingEntityDunningCampaignMutationFn = Apollo.MutationFunction<ApplyBillingEntityDunningCampaignMutation, ApplyBillingEntityDunningCampaignMutationVariables>;

/**
 * __useApplyBillingEntityDunningCampaignMutation__
 *
 * To run a mutation, you first call `useApplyBillingEntityDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyBillingEntityDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyBillingEntityDunningCampaignMutation, { data, loading, error }] = useApplyBillingEntityDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyBillingEntityDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<ApplyBillingEntityDunningCampaignMutation, ApplyBillingEntityDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyBillingEntityDunningCampaignMutation, ApplyBillingEntityDunningCampaignMutationVariables>(ApplyBillingEntityDunningCampaignDocument, options);
      }
export type ApplyBillingEntityDunningCampaignMutationHookResult = ReturnType<typeof useApplyBillingEntityDunningCampaignMutation>;
export type ApplyBillingEntityDunningCampaignMutationResult = Apollo.MutationResult<ApplyBillingEntityDunningCampaignMutation>;
export type ApplyBillingEntityDunningCampaignMutationOptions = Apollo.BaseMutationOptions<ApplyBillingEntityDunningCampaignMutation, ApplyBillingEntityDunningCampaignMutationVariables>;
export const RemoveBillingEntityDunningCampaignDocument = gql`
    mutation removeBillingEntityDunningCampaign($input: BillingEntityUpdateAppliedDunningCampaignInput!) {
  billingEntityUpdateAppliedDunningCampaign(input: $input) {
    id
  }
}
    `;
export type RemoveBillingEntityDunningCampaignMutationFn = Apollo.MutationFunction<RemoveBillingEntityDunningCampaignMutation, RemoveBillingEntityDunningCampaignMutationVariables>;

/**
 * __useRemoveBillingEntityDunningCampaignMutation__
 *
 * To run a mutation, you first call `useRemoveBillingEntityDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveBillingEntityDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeBillingEntityDunningCampaignMutation, { data, loading, error }] = useRemoveBillingEntityDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveBillingEntityDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<RemoveBillingEntityDunningCampaignMutation, RemoveBillingEntityDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveBillingEntityDunningCampaignMutation, RemoveBillingEntityDunningCampaignMutationVariables>(RemoveBillingEntityDunningCampaignDocument, options);
      }
export type RemoveBillingEntityDunningCampaignMutationHookResult = ReturnType<typeof useRemoveBillingEntityDunningCampaignMutation>;
export type RemoveBillingEntityDunningCampaignMutationResult = Apollo.MutationResult<RemoveBillingEntityDunningCampaignMutation>;
export type RemoveBillingEntityDunningCampaignMutationOptions = Apollo.BaseMutationOptions<RemoveBillingEntityDunningCampaignMutation, RemoveBillingEntityDunningCampaignMutationVariables>;
export const UpdateBillingEntityTimezoneDocument = gql`
    mutation updateBillingEntityTimezone($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
    timezone
  }
}
    `;
export type UpdateBillingEntityTimezoneMutationFn = Apollo.MutationFunction<UpdateBillingEntityTimezoneMutation, UpdateBillingEntityTimezoneMutationVariables>;

/**
 * __useUpdateBillingEntityTimezoneMutation__
 *
 * To run a mutation, you first call `useUpdateBillingEntityTimezoneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillingEntityTimezoneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillingEntityTimezoneMutation, { data, loading, error }] = useUpdateBillingEntityTimezoneMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillingEntityTimezoneMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillingEntityTimezoneMutation, UpdateBillingEntityTimezoneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillingEntityTimezoneMutation, UpdateBillingEntityTimezoneMutationVariables>(UpdateBillingEntityTimezoneDocument, options);
      }
export type UpdateBillingEntityTimezoneMutationHookResult = ReturnType<typeof useUpdateBillingEntityTimezoneMutation>;
export type UpdateBillingEntityTimezoneMutationResult = Apollo.MutationResult<UpdateBillingEntityTimezoneMutation>;
export type UpdateBillingEntityTimezoneMutationOptions = Apollo.BaseMutationOptions<UpdateBillingEntityTimezoneMutation, UpdateBillingEntityTimezoneMutationVariables>;
export const ApplyBillingEntityInvoiceCustomSectionDocument = gql`
    mutation applyBillingEntityInvoiceCustomSection($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
  }
}
    `;
export type ApplyBillingEntityInvoiceCustomSectionMutationFn = Apollo.MutationFunction<ApplyBillingEntityInvoiceCustomSectionMutation, ApplyBillingEntityInvoiceCustomSectionMutationVariables>;

/**
 * __useApplyBillingEntityInvoiceCustomSectionMutation__
 *
 * To run a mutation, you first call `useApplyBillingEntityInvoiceCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyBillingEntityInvoiceCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyBillingEntityInvoiceCustomSectionMutation, { data, loading, error }] = useApplyBillingEntityInvoiceCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyBillingEntityInvoiceCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<ApplyBillingEntityInvoiceCustomSectionMutation, ApplyBillingEntityInvoiceCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyBillingEntityInvoiceCustomSectionMutation, ApplyBillingEntityInvoiceCustomSectionMutationVariables>(ApplyBillingEntityInvoiceCustomSectionDocument, options);
      }
export type ApplyBillingEntityInvoiceCustomSectionMutationHookResult = ReturnType<typeof useApplyBillingEntityInvoiceCustomSectionMutation>;
export type ApplyBillingEntityInvoiceCustomSectionMutationResult = Apollo.MutationResult<ApplyBillingEntityInvoiceCustomSectionMutation>;
export type ApplyBillingEntityInvoiceCustomSectionMutationOptions = Apollo.BaseMutationOptions<ApplyBillingEntityInvoiceCustomSectionMutation, ApplyBillingEntityInvoiceCustomSectionMutationVariables>;
export const RemoveBillingEntityInvoiceCustomSectionDocument = gql`
    mutation removeBillingEntityInvoiceCustomSection($input: UpdateBillingEntityInput!) {
  updateBillingEntity(input: $input) {
    id
  }
}
    `;
export type RemoveBillingEntityInvoiceCustomSectionMutationFn = Apollo.MutationFunction<RemoveBillingEntityInvoiceCustomSectionMutation, RemoveBillingEntityInvoiceCustomSectionMutationVariables>;

/**
 * __useRemoveBillingEntityInvoiceCustomSectionMutation__
 *
 * To run a mutation, you first call `useRemoveBillingEntityInvoiceCustomSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveBillingEntityInvoiceCustomSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeBillingEntityInvoiceCustomSectionMutation, { data, loading, error }] = useRemoveBillingEntityInvoiceCustomSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveBillingEntityInvoiceCustomSectionMutation(baseOptions?: Apollo.MutationHookOptions<RemoveBillingEntityInvoiceCustomSectionMutation, RemoveBillingEntityInvoiceCustomSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveBillingEntityInvoiceCustomSectionMutation, RemoveBillingEntityInvoiceCustomSectionMutationVariables>(RemoveBillingEntityInvoiceCustomSectionDocument, options);
      }
export type RemoveBillingEntityInvoiceCustomSectionMutationHookResult = ReturnType<typeof useRemoveBillingEntityInvoiceCustomSectionMutation>;
export type RemoveBillingEntityInvoiceCustomSectionMutationResult = Apollo.MutationResult<RemoveBillingEntityInvoiceCustomSectionMutation>;
export type RemoveBillingEntityInvoiceCustomSectionMutationOptions = Apollo.BaseMutationOptions<RemoveBillingEntityInvoiceCustomSectionMutation, RemoveBillingEntityInvoiceCustomSectionMutationVariables>;
export const GetTaxesForApplyTaxDocument = gql`
    query getTaxesForApplyTax($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, order: "name", searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxItemForApplyTax
    }
  }
}
    ${TaxItemForApplyTaxFragmentDoc}`;

/**
 * __useGetTaxesForApplyTaxQuery__
 *
 * To run a query within a React component, call `useGetTaxesForApplyTaxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForApplyTaxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForApplyTaxQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxesForApplyTaxQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>(GetTaxesForApplyTaxDocument, options);
      }
export function useGetTaxesForApplyTaxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>(GetTaxesForApplyTaxDocument, options);
        }
export function useGetTaxesForApplyTaxSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>(GetTaxesForApplyTaxDocument, options);
        }
export type GetTaxesForApplyTaxQueryHookResult = ReturnType<typeof useGetTaxesForApplyTaxQuery>;
export type GetTaxesForApplyTaxLazyQueryHookResult = ReturnType<typeof useGetTaxesForApplyTaxLazyQuery>;
export type GetTaxesForApplyTaxSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForApplyTaxSuspenseQuery>;
export type GetTaxesForApplyTaxQueryResult = Apollo.QueryResult<GetTaxesForApplyTaxQuery, GetTaxesForApplyTaxQueryVariables>;
export const ApplyBillingEntityTaxesDocument = gql`
    mutation applyBillingEntityTaxes($input: ApplyTaxesInput!) {
  billingEntityApplyTaxes(input: $input) {
    __typename
  }
}
    `;
export type ApplyBillingEntityTaxesMutationFn = Apollo.MutationFunction<ApplyBillingEntityTaxesMutation, ApplyBillingEntityTaxesMutationVariables>;

/**
 * __useApplyBillingEntityTaxesMutation__
 *
 * To run a mutation, you first call `useApplyBillingEntityTaxesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyBillingEntityTaxesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyBillingEntityTaxesMutation, { data, loading, error }] = useApplyBillingEntityTaxesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyBillingEntityTaxesMutation(baseOptions?: Apollo.MutationHookOptions<ApplyBillingEntityTaxesMutation, ApplyBillingEntityTaxesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyBillingEntityTaxesMutation, ApplyBillingEntityTaxesMutationVariables>(ApplyBillingEntityTaxesDocument, options);
      }
export type ApplyBillingEntityTaxesMutationHookResult = ReturnType<typeof useApplyBillingEntityTaxesMutation>;
export type ApplyBillingEntityTaxesMutationResult = Apollo.MutationResult<ApplyBillingEntityTaxesMutation>;
export type ApplyBillingEntityTaxesMutationOptions = Apollo.BaseMutationOptions<ApplyBillingEntityTaxesMutation, ApplyBillingEntityTaxesMutationVariables>;
export const GetBillingEntityTaxesDocument = gql`
    query getBillingEntityTaxes($billingEntityId: ID!) {
  billingEntityTaxes(billingEntityId: $billingEntityId) {
    collection {
      id
      name
      code
      rate
    }
  }
}
    `;

/**
 * __useGetBillingEntityTaxesQuery__
 *
 * To run a query within a React component, call `useGetBillingEntityTaxesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillingEntityTaxesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillingEntityTaxesQuery({
 *   variables: {
 *      billingEntityId: // value for 'billingEntityId'
 *   },
 * });
 */
export function useGetBillingEntityTaxesQuery(baseOptions: Apollo.QueryHookOptions<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables> & ({ variables: GetBillingEntityTaxesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>(GetBillingEntityTaxesDocument, options);
      }
export function useGetBillingEntityTaxesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>(GetBillingEntityTaxesDocument, options);
        }
export function useGetBillingEntityTaxesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>(GetBillingEntityTaxesDocument, options);
        }
export type GetBillingEntityTaxesQueryHookResult = ReturnType<typeof useGetBillingEntityTaxesQuery>;
export type GetBillingEntityTaxesLazyQueryHookResult = ReturnType<typeof useGetBillingEntityTaxesLazyQuery>;
export type GetBillingEntityTaxesSuspenseQueryHookResult = ReturnType<typeof useGetBillingEntityTaxesSuspenseQuery>;
export type GetBillingEntityTaxesQueryResult = Apollo.QueryResult<GetBillingEntityTaxesQuery, GetBillingEntityTaxesQueryVariables>;
export const RemoveBillingEntityTaxesDocument = gql`
    mutation removeBillingEntityTaxes($input: RemoveTaxesInput!) {
  billingEntityRemoveTaxes(input: $input) {
    __typename
  }
}
    `;
export type RemoveBillingEntityTaxesMutationFn = Apollo.MutationFunction<RemoveBillingEntityTaxesMutation, RemoveBillingEntityTaxesMutationVariables>;

/**
 * __useRemoveBillingEntityTaxesMutation__
 *
 * To run a mutation, you first call `useRemoveBillingEntityTaxesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveBillingEntityTaxesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeBillingEntityTaxesMutation, { data, loading, error }] = useRemoveBillingEntityTaxesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveBillingEntityTaxesMutation(baseOptions?: Apollo.MutationHookOptions<RemoveBillingEntityTaxesMutation, RemoveBillingEntityTaxesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveBillingEntityTaxesMutation, RemoveBillingEntityTaxesMutationVariables>(RemoveBillingEntityTaxesDocument, options);
      }
export type RemoveBillingEntityTaxesMutationHookResult = ReturnType<typeof useRemoveBillingEntityTaxesMutation>;
export type RemoveBillingEntityTaxesMutationResult = Apollo.MutationResult<RemoveBillingEntityTaxesMutation>;
export type RemoveBillingEntityTaxesMutationOptions = Apollo.BaseMutationOptions<RemoveBillingEntityTaxesMutation, RemoveBillingEntityTaxesMutationVariables>;
export const GetCashfreeIntegrationsDetailsDocument = gql`
    query getCashfreeIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on CashfreeProvider {
      id
      ...CashfreeIntegrationDetails
      ...DeleteCashfreeIntegrationDialog
      ...AddCashfreeProviderDialog
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on CashfreeProvider {
        id
      }
    }
  }
}
    ${CashfreeIntegrationDetailsFragmentDoc}
${DeleteCashfreeIntegrationDialogFragmentDoc}
${AddCashfreeProviderDialogFragmentDoc}`;

/**
 * __useGetCashfreeIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetCashfreeIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCashfreeIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCashfreeIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCashfreeIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables> & ({ variables: GetCashfreeIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>(GetCashfreeIntegrationsDetailsDocument, options);
      }
export function useGetCashfreeIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>(GetCashfreeIntegrationsDetailsDocument, options);
        }
export function useGetCashfreeIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>(GetCashfreeIntegrationsDetailsDocument, options);
        }
export type GetCashfreeIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsDetailsQuery>;
export type GetCashfreeIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsDetailsLazyQuery>;
export type GetCashfreeIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsDetailsSuspenseQuery>;
export type GetCashfreeIntegrationsDetailsQueryResult = Apollo.QueryResult<GetCashfreeIntegrationsDetailsQuery, GetCashfreeIntegrationsDetailsQueryVariables>;
export const GetCashfreeIntegrationsListDocument = gql`
    query getCashfreeIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on CashfreeProvider {
        id
        ...CashfreeIntegrations
        ...AddCashfreeProviderDialog
        ...DeleteCashfreeIntegrationDialog
      }
    }
  }
}
    ${CashfreeIntegrationsFragmentDoc}
${AddCashfreeProviderDialogFragmentDoc}
${DeleteCashfreeIntegrationDialogFragmentDoc}`;

/**
 * __useGetCashfreeIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetCashfreeIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCashfreeIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCashfreeIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCashfreeIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>(GetCashfreeIntegrationsListDocument, options);
      }
export function useGetCashfreeIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>(GetCashfreeIntegrationsListDocument, options);
        }
export function useGetCashfreeIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>(GetCashfreeIntegrationsListDocument, options);
        }
export type GetCashfreeIntegrationsListQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsListQuery>;
export type GetCashfreeIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsListLazyQuery>;
export type GetCashfreeIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetCashfreeIntegrationsListSuspenseQuery>;
export type GetCashfreeIntegrationsListQueryResult = Apollo.QueryResult<GetCashfreeIntegrationsListQuery, GetCashfreeIntegrationsListQueryVariables>;
export const GetDunningCampaignsDocument = gql`
    query getDunningCampaigns($limit: Int, $page: Int) {
  dunningCampaigns(limit: $limit, page: $page, order: "name") {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...DunningCampaignItem
      ...DeleteCampaign
    }
  }
}
    ${DunningCampaignItemFragmentDoc}
${DeleteCampaignFragmentDoc}`;

/**
 * __useGetDunningCampaignsQuery__
 *
 * To run a query within a React component, call `useGetDunningCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDunningCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDunningCampaignsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetDunningCampaignsQuery(baseOptions?: Apollo.QueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
      }
export function useGetDunningCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
        }
export function useGetDunningCampaignsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
        }
export type GetDunningCampaignsQueryHookResult = ReturnType<typeof useGetDunningCampaignsQuery>;
export type GetDunningCampaignsLazyQueryHookResult = ReturnType<typeof useGetDunningCampaignsLazyQuery>;
export type GetDunningCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetDunningCampaignsSuspenseQuery>;
export type GetDunningCampaignsQueryResult = Apollo.QueryResult<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>;
export const UpdateDunningCampaignStatusDocument = gql`
    mutation updateDunningCampaignStatus($input: UpdateDunningCampaignInput!) {
  updateDunningCampaign(input: $input) {
    id
    appliedToOrganization
  }
}
    `;
export type UpdateDunningCampaignStatusMutationFn = Apollo.MutationFunction<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>;

/**
 * __useUpdateDunningCampaignStatusMutation__
 *
 * To run a mutation, you first call `useUpdateDunningCampaignStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDunningCampaignStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDunningCampaignStatusMutation, { data, loading, error }] = useUpdateDunningCampaignStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDunningCampaignStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>(UpdateDunningCampaignStatusDocument, options);
      }
export type UpdateDunningCampaignStatusMutationHookResult = ReturnType<typeof useUpdateDunningCampaignStatusMutation>;
export type UpdateDunningCampaignStatusMutationResult = Apollo.MutationResult<UpdateDunningCampaignStatusMutation>;
export type UpdateDunningCampaignStatusMutationOptions = Apollo.BaseMutationOptions<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>;
export const FlutterwaveIntegrationDetailsDocument = gql`
    query flutterwaveIntegrationDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on FlutterwaveProvider {
      id
      ...FlutterwaveIntegrationDetails
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on FlutterwaveProvider {
        id
      }
    }
  }
}
    ${FlutterwaveIntegrationDetailsFragmentDoc}`;

/**
 * __useFlutterwaveIntegrationDetailsQuery__
 *
 * To run a query within a React component, call `useFlutterwaveIntegrationDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlutterwaveIntegrationDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlutterwaveIntegrationDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useFlutterwaveIntegrationDetailsQuery(baseOptions: Apollo.QueryHookOptions<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables> & ({ variables: FlutterwaveIntegrationDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>(FlutterwaveIntegrationDetailsDocument, options);
      }
export function useFlutterwaveIntegrationDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>(FlutterwaveIntegrationDetailsDocument, options);
        }
export function useFlutterwaveIntegrationDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>(FlutterwaveIntegrationDetailsDocument, options);
        }
export type FlutterwaveIntegrationDetailsQueryHookResult = ReturnType<typeof useFlutterwaveIntegrationDetailsQuery>;
export type FlutterwaveIntegrationDetailsLazyQueryHookResult = ReturnType<typeof useFlutterwaveIntegrationDetailsLazyQuery>;
export type FlutterwaveIntegrationDetailsSuspenseQueryHookResult = ReturnType<typeof useFlutterwaveIntegrationDetailsSuspenseQuery>;
export type FlutterwaveIntegrationDetailsQueryResult = Apollo.QueryResult<FlutterwaveIntegrationDetailsQuery, FlutterwaveIntegrationDetailsQueryVariables>;
export const GetFlutterwaveIntegrationsListDocument = gql`
    query getFlutterwaveIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on FlutterwaveProvider {
        id
        ...FlutterwaveIntegrations
        ...DeleteFlutterwaveIntegrationDialog
      }
    }
  }
}
    ${FlutterwaveIntegrationsFragmentDoc}
${DeleteFlutterwaveIntegrationDialogFragmentDoc}`;

/**
 * __useGetFlutterwaveIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetFlutterwaveIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFlutterwaveIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFlutterwaveIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetFlutterwaveIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>(GetFlutterwaveIntegrationsListDocument, options);
      }
export function useGetFlutterwaveIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>(GetFlutterwaveIntegrationsListDocument, options);
        }
export function useGetFlutterwaveIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>(GetFlutterwaveIntegrationsListDocument, options);
        }
export type GetFlutterwaveIntegrationsListQueryHookResult = ReturnType<typeof useGetFlutterwaveIntegrationsListQuery>;
export type GetFlutterwaveIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetFlutterwaveIntegrationsListLazyQuery>;
export type GetFlutterwaveIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetFlutterwaveIntegrationsListSuspenseQuery>;
export type GetFlutterwaveIntegrationsListQueryResult = Apollo.QueryResult<GetFlutterwaveIntegrationsListQuery, GetFlutterwaveIntegrationsListQueryVariables>;
export const GetGocardlessIntegrationsDetailsDocument = gql`
    query getGocardlessIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on GocardlessProvider {
      id
      ...GocardlessIntegrationDetails
      ...DeleteGocardlessIntegrationDialog
      ...AddGocardlessProviderDialog
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
      }
    }
  }
}
    ${GocardlessIntegrationDetailsFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables> & ({ variables: GetGocardlessIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
      }
export function useGetGocardlessIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export function useGetGocardlessIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export type GetGocardlessIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsQuery>;
export type GetGocardlessIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsLazyQuery>;
export type GetGocardlessIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsSuspenseQuery>;
export type GetGocardlessIntegrationsDetailsQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>;
export const AddGocardlessApiKeyDocument = gql`
    mutation addGocardlessApiKey($input: AddGocardlessPaymentProviderInput!) {
  addGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationOauthCallback
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationOauthCallbackFragmentDoc}`;
export type AddGocardlessApiKeyMutationFn = Apollo.MutationFunction<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;

/**
 * __useAddGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useAddGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addGocardlessApiKeyMutation, { data, loading, error }] = useAddGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>(AddGocardlessApiKeyDocument, options);
      }
export type AddGocardlessApiKeyMutationHookResult = ReturnType<typeof useAddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationResult = Apollo.MutationResult<AddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;
export const GetGocardlessIntegrationsListDocument = gql`
    query getGocardlessIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
        ...GocardlessIntegrations
        ...AddGocardlessProviderDialog
        ...DeleteGocardlessIntegrationDialog
      }
    }
  }
}
    ${GocardlessIntegrationsFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
      }
export function useGetGocardlessIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export function useGetGocardlessIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export type GetGocardlessIntegrationsListQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListQuery>;
export type GetGocardlessIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListLazyQuery>;
export type GetGocardlessIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListSuspenseQuery>;
export type GetGocardlessIntegrationsListQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>;
export const GetHubspotIntegrationsDetailsDocument = gql`
    query getHubspotIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on HubspotIntegration {
      id
      ...HubspotIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on HubspotIntegration {
        id
      }
    }
  }
}
    ${HubspotIntegrationDetailsFragmentDoc}`;

/**
 * __useGetHubspotIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetHubspotIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHubspotIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHubspotIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetHubspotIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables> & ({ variables: GetHubspotIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
      }
export function useGetHubspotIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
        }
export function useGetHubspotIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
        }
export type GetHubspotIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsQuery>;
export type GetHubspotIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsLazyQuery>;
export type GetHubspotIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsSuspenseQuery>;
export type GetHubspotIntegrationsDetailsQueryResult = Apollo.QueryResult<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>;
export const GetHubspotIntegrationsListDocument = gql`
    query getHubspotIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on HubspotIntegration {
        id
        ...HubspotIntegrations
        ...HubspotForCreateDialog
      }
    }
  }
}
    ${HubspotIntegrationsFragmentDoc}
${HubspotForCreateDialogFragmentDoc}`;

/**
 * __useGetHubspotIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetHubspotIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHubspotIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHubspotIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetHubspotIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
      }
export function useGetHubspotIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
        }
export function useGetHubspotIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
        }
export type GetHubspotIntegrationsListQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListQuery>;
export type GetHubspotIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListLazyQuery>;
export type GetHubspotIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListSuspenseQuery>;
export type GetHubspotIntegrationsListQueryResult = Apollo.QueryResult<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>;
export const IntegrationsSettingDocument = gql`
    query integrationsSetting($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on MoneyhashProvider {
        id
      }
      ... on StripeProvider {
        id
      }
      ... on GocardlessProvider {
        id
      }
      ... on AdyenProvider {
        id
      }
      ... on CashfreeProvider {
        id
      }
      ... on FlutterwaveProvider {
        id
      }
    }
  }
  integrations(limit: $limit) {
    collection {
      ... on AnrokIntegration {
        id
      }
      ... on AvalaraIntegration {
        id
      }
      ... on NetsuiteIntegration {
        id
      }
      ... on XeroIntegration {
        id
      }
      ... on HubspotIntegration {
        id
      }
      ... on SalesforceIntegration {
        id
      }
    }
  }
}
    `;

/**
 * __useIntegrationsSettingQuery__
 *
 * To run a query within a React component, call `useIntegrationsSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsSettingQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsSettingQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
      }
export function useIntegrationsSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export function useIntegrationsSettingSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export type IntegrationsSettingQueryHookResult = ReturnType<typeof useIntegrationsSettingQuery>;
export type IntegrationsSettingLazyQueryHookResult = ReturnType<typeof useIntegrationsSettingLazyQuery>;
export type IntegrationsSettingSuspenseQueryHookResult = ReturnType<typeof useIntegrationsSettingSuspenseQuery>;
export type IntegrationsSettingQueryResult = Apollo.QueryResult<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>;
export const GetSinglePricingUnitDocument = gql`
    query getSinglePricingUnit($id: ID!) {
  pricingUnit(id: $id) {
    id
    ...PricingUnit
  }
}
    ${PricingUnitFragmentDoc}`;

/**
 * __useGetSinglePricingUnitQuery__
 *
 * To run a query within a React component, call `useGetSinglePricingUnitQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSinglePricingUnitQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSinglePricingUnitQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSinglePricingUnitQuery(baseOptions: Apollo.QueryHookOptions<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables> & ({ variables: GetSinglePricingUnitQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>(GetSinglePricingUnitDocument, options);
      }
export function useGetSinglePricingUnitLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>(GetSinglePricingUnitDocument, options);
        }
export function useGetSinglePricingUnitSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>(GetSinglePricingUnitDocument, options);
        }
export type GetSinglePricingUnitQueryHookResult = ReturnType<typeof useGetSinglePricingUnitQuery>;
export type GetSinglePricingUnitLazyQueryHookResult = ReturnType<typeof useGetSinglePricingUnitLazyQuery>;
export type GetSinglePricingUnitSuspenseQueryHookResult = ReturnType<typeof useGetSinglePricingUnitSuspenseQuery>;
export type GetSinglePricingUnitQueryResult = Apollo.QueryResult<GetSinglePricingUnitQuery, GetSinglePricingUnitQueryVariables>;
export const CreatePricingUnitDocument = gql`
    mutation createPricingUnit($input: CreatePricingUnitInput!) {
  createPricingUnit(input: $input) {
    id
    ...PricingUnit
  }
}
    ${PricingUnitFragmentDoc}`;
export type CreatePricingUnitMutationFn = Apollo.MutationFunction<CreatePricingUnitMutation, CreatePricingUnitMutationVariables>;

/**
 * __useCreatePricingUnitMutation__
 *
 * To run a mutation, you first call `useCreatePricingUnitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePricingUnitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPricingUnitMutation, { data, loading, error }] = useCreatePricingUnitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePricingUnitMutation(baseOptions?: Apollo.MutationHookOptions<CreatePricingUnitMutation, CreatePricingUnitMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePricingUnitMutation, CreatePricingUnitMutationVariables>(CreatePricingUnitDocument, options);
      }
export type CreatePricingUnitMutationHookResult = ReturnType<typeof useCreatePricingUnitMutation>;
export type CreatePricingUnitMutationResult = Apollo.MutationResult<CreatePricingUnitMutation>;
export type CreatePricingUnitMutationOptions = Apollo.BaseMutationOptions<CreatePricingUnitMutation, CreatePricingUnitMutationVariables>;
export const UpdatePricingUnitDocument = gql`
    mutation updatePricingUnit($input: UpdatePricingUnitInput!) {
  updatePricingUnit(input: $input) {
    id
    ...PricingUnit
  }
}
    ${PricingUnitFragmentDoc}`;
export type UpdatePricingUnitMutationFn = Apollo.MutationFunction<UpdatePricingUnitMutation, UpdatePricingUnitMutationVariables>;

/**
 * __useUpdatePricingUnitMutation__
 *
 * To run a mutation, you first call `useUpdatePricingUnitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePricingUnitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePricingUnitMutation, { data, loading, error }] = useUpdatePricingUnitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePricingUnitMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePricingUnitMutation, UpdatePricingUnitMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePricingUnitMutation, UpdatePricingUnitMutationVariables>(UpdatePricingUnitDocument, options);
      }
export type UpdatePricingUnitMutationHookResult = ReturnType<typeof useUpdatePricingUnitMutation>;
export type UpdatePricingUnitMutationResult = Apollo.MutationResult<UpdatePricingUnitMutation>;
export type UpdatePricingUnitMutationOptions = Apollo.BaseMutationOptions<UpdatePricingUnitMutation, UpdatePricingUnitMutationVariables>;
export const GetOrganizationSettingsInvoiceSectionsDocument = gql`
    query getOrganizationSettingsInvoiceSections($limit: Int, $page: Int) {
  invoiceCustomSections(limit: $limit, page: $page) {
    collection {
      id
      name
      code
      ...DeleteCustomSection
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${DeleteCustomSectionFragmentDoc}`;

/**
 * __useGetOrganizationSettingsInvoiceSectionsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationSettingsInvoiceSectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationSettingsInvoiceSectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationSettingsInvoiceSectionsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetOrganizationSettingsInvoiceSectionsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>(GetOrganizationSettingsInvoiceSectionsDocument, options);
      }
export function useGetOrganizationSettingsInvoiceSectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>(GetOrganizationSettingsInvoiceSectionsDocument, options);
        }
export function useGetOrganizationSettingsInvoiceSectionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>(GetOrganizationSettingsInvoiceSectionsDocument, options);
        }
export type GetOrganizationSettingsInvoiceSectionsQueryHookResult = ReturnType<typeof useGetOrganizationSettingsInvoiceSectionsQuery>;
export type GetOrganizationSettingsInvoiceSectionsLazyQueryHookResult = ReturnType<typeof useGetOrganizationSettingsInvoiceSectionsLazyQuery>;
export type GetOrganizationSettingsInvoiceSectionsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationSettingsInvoiceSectionsSuspenseQuery>;
export type GetOrganizationSettingsInvoiceSectionsQueryResult = Apollo.QueryResult<GetOrganizationSettingsInvoiceSectionsQuery, GetOrganizationSettingsInvoiceSectionsQueryVariables>;
export const GetOrganizationSettingsPricingUnitsDocument = gql`
    query getOrganizationSettingsPricingUnits($limit: Int, $page: Int) {
  pricingUnits(limit: $limit, page: $page) {
    collection {
      id
      name
      shortName
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    `;

/**
 * __useGetOrganizationSettingsPricingUnitsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationSettingsPricingUnitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationSettingsPricingUnitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationSettingsPricingUnitsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetOrganizationSettingsPricingUnitsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>(GetOrganizationSettingsPricingUnitsDocument, options);
      }
export function useGetOrganizationSettingsPricingUnitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>(GetOrganizationSettingsPricingUnitsDocument, options);
        }
export function useGetOrganizationSettingsPricingUnitsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>(GetOrganizationSettingsPricingUnitsDocument, options);
        }
export type GetOrganizationSettingsPricingUnitsQueryHookResult = ReturnType<typeof useGetOrganizationSettingsPricingUnitsQuery>;
export type GetOrganizationSettingsPricingUnitsLazyQueryHookResult = ReturnType<typeof useGetOrganizationSettingsPricingUnitsLazyQuery>;
export type GetOrganizationSettingsPricingUnitsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationSettingsPricingUnitsSuspenseQuery>;
export type GetOrganizationSettingsPricingUnitsQueryResult = Apollo.QueryResult<GetOrganizationSettingsPricingUnitsQuery, GetOrganizationSettingsPricingUnitsQueryVariables>;
export const GetTaxesForTaxManagementIntegrationDetailsPageDocument = gql`
    query getTaxesForTaxManagementIntegrationDetailsPage {
  taxes(page: 1, limit: 1000, order: "rate", autoGenerated: true) {
    collection {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetTaxesForTaxManagementIntegrationDetailsPageQuery__
 *
 * To run a query within a React component, call `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForTaxManagementIntegrationDetailsPageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTaxesForTaxManagementIntegrationDetailsPageQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
      }
export function useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export function useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageLazyQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryResult = Apollo.QueryResult<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>;
export const GetInvitesDocument = gql`
    query getInvites($page: Int, $limit: Int) {
  invites(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      ...InviteItemForMembersSettings
    }
  }
}
    ${InviteItemForMembersSettingsFragmentDoc}`;

/**
 * __useGetInvitesQuery__
 *
 * To run a query within a React component, call `useGetInvitesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvitesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvitesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvitesQuery(baseOptions?: Apollo.QueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
      }
export function useGetInvitesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export function useGetInvitesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export type GetInvitesQueryHookResult = ReturnType<typeof useGetInvitesQuery>;
export type GetInvitesLazyQueryHookResult = ReturnType<typeof useGetInvitesLazyQuery>;
export type GetInvitesSuspenseQueryHookResult = ReturnType<typeof useGetInvitesSuspenseQuery>;
export type GetInvitesQueryResult = Apollo.QueryResult<GetInvitesQuery, GetInvitesQueryVariables>;
export const GetMembersDocument = gql`
    query getMembers($page: Int, $limit: Int) {
  memberships(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
      adminCount
    }
    collection {
      ...MembershipItemForMembershipSettings
    }
  }
}
    ${MembershipItemForMembershipSettingsFragmentDoc}`;

/**
 * __useGetMembersQuery__
 *
 * To run a query within a React component, call `useGetMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetMembersQuery(baseOptions?: Apollo.QueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
      }
export function useGetMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export function useGetMembersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export type GetMembersQueryHookResult = ReturnType<typeof useGetMembersQuery>;
export type GetMembersLazyQueryHookResult = ReturnType<typeof useGetMembersLazyQuery>;
export type GetMembersSuspenseQueryHookResult = ReturnType<typeof useGetMembersSuspenseQuery>;
export type GetMembersQueryResult = Apollo.QueryResult<GetMembersQuery, GetMembersQueryVariables>;
export const GetMoneyhashIntegrationsDetailsDocument = gql`
    query getMoneyhashIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on MoneyhashProvider {
      id
      ...MoneyhashIntegrationDetails
      ...DeleteMoneyhashIntegrationDialog
      ...AddMoneyhashProviderDialog
      ...MoneyhashForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on MoneyhashProvider {
        id
      }
    }
  }
}
    ${MoneyhashIntegrationDetailsFragmentDoc}
${DeleteMoneyhashIntegrationDialogFragmentDoc}
${AddMoneyhashProviderDialogFragmentDoc}
${MoneyhashForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetMoneyhashIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetMoneyhashIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMoneyhashIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMoneyhashIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetMoneyhashIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables> & ({ variables: GetMoneyhashIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>(GetMoneyhashIntegrationsDetailsDocument, options);
      }
export function useGetMoneyhashIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>(GetMoneyhashIntegrationsDetailsDocument, options);
        }
export function useGetMoneyhashIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>(GetMoneyhashIntegrationsDetailsDocument, options);
        }
export type GetMoneyhashIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsDetailsQuery>;
export type GetMoneyhashIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsDetailsLazyQuery>;
export type GetMoneyhashIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsDetailsSuspenseQuery>;
export type GetMoneyhashIntegrationsDetailsQueryResult = Apollo.QueryResult<GetMoneyhashIntegrationsDetailsQuery, GetMoneyhashIntegrationsDetailsQueryVariables>;
export const GetMoneyhashIntegrationsListDocument = gql`
    query getMoneyhashIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on MoneyhashProvider {
        id
        ...MoneyhashIntegrations
        ...AddMoneyhashProviderDialog
        ...DeleteMoneyhashIntegrationDialog
      }
    }
  }
}
    ${MoneyhashIntegrationsFragmentDoc}
${AddMoneyhashProviderDialogFragmentDoc}
${DeleteMoneyhashIntegrationDialogFragmentDoc}`;

/**
 * __useGetMoneyhashIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetMoneyhashIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMoneyhashIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMoneyhashIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetMoneyhashIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>(GetMoneyhashIntegrationsListDocument, options);
      }
export function useGetMoneyhashIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>(GetMoneyhashIntegrationsListDocument, options);
        }
export function useGetMoneyhashIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>(GetMoneyhashIntegrationsListDocument, options);
        }
export type GetMoneyhashIntegrationsListQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsListQuery>;
export type GetMoneyhashIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsListLazyQuery>;
export type GetMoneyhashIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetMoneyhashIntegrationsListSuspenseQuery>;
export type GetMoneyhashIntegrationsListQueryResult = Apollo.QueryResult<GetMoneyhashIntegrationsListQuery, GetMoneyhashIntegrationsListQueryVariables>;
export const GetNetsuiteIntegrationsDetailsDocument = gql`
    query getNetsuiteIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on NetsuiteIntegration {
      id
      ...NetsuiteIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on NetsuiteIntegration {
        id
      }
    }
  }
}
    ${NetsuiteIntegrationDetailsFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables> & ({ variables: GetNetsuiteIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
      }
export function useGetNetsuiteIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
        }
export function useGetNetsuiteIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
        }
export type GetNetsuiteIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsQuery>;
export type GetNetsuiteIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsLazyQuery>;
export type GetNetsuiteIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsSuspenseQuery>;
export type GetNetsuiteIntegrationsDetailsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>;
export const GetNetsuiteIntegrationsListDocument = gql`
    query getNetsuiteIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on NetsuiteIntegration {
        id
        ...NetsuiteIntegrations
        ...NetsuiteForCreateDialogDialog
        ...DeleteNetsuiteIntegrationDialog
      }
    }
  }
}
    ${NetsuiteIntegrationsFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}
${DeleteNetsuiteIntegrationDialogFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
      }
export function useGetNetsuiteIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
        }
export function useGetNetsuiteIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
        }
export type GetNetsuiteIntegrationsListQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListQuery>;
export type GetNetsuiteIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListLazyQuery>;
export type GetNetsuiteIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListSuspenseQuery>;
export type GetNetsuiteIntegrationsListQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>;
export const GetSalesforceIntegrationsDetailsDocument = gql`
    query getSalesforceIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on SalesforceIntegration {
      id
      ...SalesforceIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on SalesforceIntegration {
        id
      }
    }
  }
}
    ${SalesforceIntegrationDetailsFragmentDoc}`;

/**
 * __useGetSalesforceIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetSalesforceIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSalesforceIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSalesforceIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetSalesforceIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables> & ({ variables: GetSalesforceIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>(GetSalesforceIntegrationsDetailsDocument, options);
      }
export function useGetSalesforceIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>(GetSalesforceIntegrationsDetailsDocument, options);
        }
export function useGetSalesforceIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>(GetSalesforceIntegrationsDetailsDocument, options);
        }
export type GetSalesforceIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsDetailsQuery>;
export type GetSalesforceIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsDetailsLazyQuery>;
export type GetSalesforceIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsDetailsSuspenseQuery>;
export type GetSalesforceIntegrationsDetailsQueryResult = Apollo.QueryResult<GetSalesforceIntegrationsDetailsQuery, GetSalesforceIntegrationsDetailsQueryVariables>;
export const GetSalesforceIntegrationsListDocument = gql`
    query getSalesforceIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on SalesforceIntegration {
        id
        ...SalesforceIntegrations
        ...SalesforceForCreateDialog
      }
    }
  }
}
    ${SalesforceIntegrationsFragmentDoc}
${SalesforceForCreateDialogFragmentDoc}`;

/**
 * __useGetSalesforceIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetSalesforceIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSalesforceIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSalesforceIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetSalesforceIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>(GetSalesforceIntegrationsListDocument, options);
      }
export function useGetSalesforceIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>(GetSalesforceIntegrationsListDocument, options);
        }
export function useGetSalesforceIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>(GetSalesforceIntegrationsListDocument, options);
        }
export type GetSalesforceIntegrationsListQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsListQuery>;
export type GetSalesforceIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsListLazyQuery>;
export type GetSalesforceIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetSalesforceIntegrationsListSuspenseQuery>;
export type GetSalesforceIntegrationsListQueryResult = Apollo.QueryResult<GetSalesforceIntegrationsListQuery, GetSalesforceIntegrationsListQueryVariables>;
export const GetStripeIntegrationsDetailsDocument = gql`
    query getStripeIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on StripeProvider {
      id
      ...StripeIntegrationDetails
      ...DeleteStripeIntegrationDialog
      ...AddStripeProviderDialog
      ...StripeForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
      }
    }
  }
}
    ${StripeIntegrationDetailsFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${StripeForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetStripeIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables> & ({ variables: GetStripeIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
      }
export function useGetStripeIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export function useGetStripeIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export type GetStripeIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsQuery>;
export type GetStripeIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsLazyQuery>;
export type GetStripeIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsSuspenseQuery>;
export type GetStripeIntegrationsDetailsQueryResult = Apollo.QueryResult<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>;
export const GetStripeIntegrationsListDocument = gql`
    query getStripeIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
        ...StripeIntegrations
        ...AddStripeProviderDialog
        ...DeleteStripeIntegrationDialog
      }
    }
  }
}
    ${StripeIntegrationsFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}`;

/**
 * __useGetStripeIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
      }
export function useGetStripeIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export function useGetStripeIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export type GetStripeIntegrationsListQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListQuery>;
export type GetStripeIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListLazyQuery>;
export type GetStripeIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListSuspenseQuery>;
export type GetStripeIntegrationsListQueryResult = Apollo.QueryResult<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>;
export const GetTaxesSettingsInformationsDocument = gql`
    query getTaxesSettingsInformations($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page, order: "name") {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxItemForTaxSettings
    }
  }
}
    ${TaxItemForTaxSettingsFragmentDoc}`;

/**
 * __useGetTaxesSettingsInformationsQuery__
 *
 * To run a query within a React component, call `useGetTaxesSettingsInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesSettingsInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesSettingsInformationsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesSettingsInformationsQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
      }
export function useGetTaxesSettingsInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
        }
export function useGetTaxesSettingsInformationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
        }
export type GetTaxesSettingsInformationsQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsQuery>;
export type GetTaxesSettingsInformationsLazyQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsLazyQuery>;
export type GetTaxesSettingsInformationsSuspenseQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsSuspenseQuery>;
export type GetTaxesSettingsInformationsQueryResult = Apollo.QueryResult<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>;
export const GetXeroIntegrationsDetailsDocument = gql`
    query getXeroIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: [IntegrationTypeEnum!]) {
  integration(id: $id) {
    ... on XeroIntegration {
      id
      ...XeroIntegrationDetails
    }
  }
  integrations(limit: $limit, types: $integrationsType) {
    collection {
      ... on XeroIntegration {
        id
      }
    }
  }
}
    ${XeroIntegrationDetailsFragmentDoc}`;

/**
 * __useGetXeroIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetXeroIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables> & ({ variables: GetXeroIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
      }
export function useGetXeroIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
        }
export function useGetXeroIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
        }
export type GetXeroIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsQuery>;
export type GetXeroIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsLazyQuery>;
export type GetXeroIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsSuspenseQuery>;
export type GetXeroIntegrationsDetailsQueryResult = Apollo.QueryResult<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>;
export const GetXeroIntegrationsListDocument = gql`
    query getXeroIntegrationsList($limit: Int, $types: [IntegrationTypeEnum!]) {
  integrations(limit: $limit, types: $types) {
    collection {
      ... on XeroIntegration {
        id
        ...XeroIntegrations
        ...XeroForCreateDialogDialog
        ...DeleteXeroIntegrationDialog
      }
    }
  }
}
    ${XeroIntegrationsFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}
${DeleteXeroIntegrationDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      types: // value for 'types'
 *   },
 * });
 */
export function useGetXeroIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
      }
export function useGetXeroIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
        }
export function useGetXeroIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
        }
export type GetXeroIntegrationsListQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListQuery>;
export type GetXeroIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListLazyQuery>;
export type GetXeroIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListSuspenseQuery>;
export type GetXeroIntegrationsListQueryResult = Apollo.QueryResult<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>;
export const GetPlansDocument = gql`
    query getPlans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetPlansQuery__
 *
 * To run a query within a React component, call `useGetPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
      }
export function useGetPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export function useGetPlansSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export type GetPlansQueryHookResult = ReturnType<typeof useGetPlansQuery>;
export type GetPlansLazyQueryHookResult = ReturnType<typeof useGetPlansLazyQuery>;
export type GetPlansSuspenseQueryHookResult = ReturnType<typeof useGetPlansSuspenseQuery>;
export type GetPlansQueryResult = Apollo.QueryResult<GetPlansQuery, GetPlansQueryVariables>;
export const GetCustomerForCreateSubscriptionDocument = gql`
    query getCustomerForCreateSubscription($id: ID!) {
  customer(id: $id) {
    id
    applicableTimezone
    name
    displayName
    externalId
  }
}
    `;

/**
 * __useGetCustomerForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetCustomerForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables> & ({ variables: GetCustomerForCreateSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
      }
export function useGetCustomerForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export function useGetCustomerForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export type GetCustomerForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionQuery>;
export type GetCustomerForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionLazyQuery>;
export type GetCustomerForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionSuspenseQuery>;
export type GetCustomerForCreateSubscriptionQueryResult = Apollo.QueryResult<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>;
export const GetSubscriptionForCreateSubscriptionDocument = gql`
    query getSubscriptionForCreateSubscription($id: ID!) {
  subscription(id: $id) {
    id
    name
    externalId
    subscriptionAt
    endingAt
    billingTime
    periodEndDate
    status
    startedAt
    plan {
      id
      parent {
        id
      }
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetSubscriptionForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSubscriptionForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables> & ({ variables: GetSubscriptionForCreateSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
      }
export function useGetSubscriptionForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export function useGetSubscriptionForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export type GetSubscriptionForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionQuery>;
export type GetSubscriptionForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionLazyQuery>;
export type GetSubscriptionForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionSuspenseQuery>;
export type GetSubscriptionForCreateSubscriptionQueryResult = Apollo.QueryResult<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>;
export const GetSubscriptionForDetailsDocument = gql`
    query getSubscriptionForDetails($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    name
    status
    externalId
    plan {
      id
      name
      code
      payInAdvance
      parent {
        id
        name
        code
      }
    }
    customer {
      id
    }
  }
}
    `;

/**
 * __useGetSubscriptionForDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables> & ({ variables: GetSubscriptionForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
      }
export function useGetSubscriptionForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export function useGetSubscriptionForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export type GetSubscriptionForDetailsQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsQuery>;
export type GetSubscriptionForDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsLazyQuery>;
export type GetSubscriptionForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsSuspenseQuery>;
export type GetSubscriptionForDetailsQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>;
export const GetSubscriptionDataForEntitlementFormDocument = gql`
    query getSubscriptionDataForEntitlementForm($subscriptionId: ID!) {
  subscriptionEntitlements(subscriptionId: $subscriptionId) {
    collection {
      code
      name
      privileges {
        code
        name
        value
        valueType
        config {
          selectOptions
        }
      }
    }
  }
  features(limit: 1000) {
    collection {
      code
      name
      privileges {
        code
        name
        valueType
        config {
          selectOptions
        }
      }
    }
  }
}
    `;

/**
 * __useGetSubscriptionDataForEntitlementFormQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionDataForEntitlementFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionDataForEntitlementFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionDataForEntitlementFormQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionDataForEntitlementFormQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables> & ({ variables: GetSubscriptionDataForEntitlementFormQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>(GetSubscriptionDataForEntitlementFormDocument, options);
      }
export function useGetSubscriptionDataForEntitlementFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>(GetSubscriptionDataForEntitlementFormDocument, options);
        }
export function useGetSubscriptionDataForEntitlementFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>(GetSubscriptionDataForEntitlementFormDocument, options);
        }
export type GetSubscriptionDataForEntitlementFormQueryHookResult = ReturnType<typeof useGetSubscriptionDataForEntitlementFormQuery>;
export type GetSubscriptionDataForEntitlementFormLazyQueryHookResult = ReturnType<typeof useGetSubscriptionDataForEntitlementFormLazyQuery>;
export type GetSubscriptionDataForEntitlementFormSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionDataForEntitlementFormSuspenseQuery>;
export type GetSubscriptionDataForEntitlementFormQueryResult = Apollo.QueryResult<GetSubscriptionDataForEntitlementFormQuery, GetSubscriptionDataForEntitlementFormQueryVariables>;
export const GetSubscriptionEntitlementToEditDocument = gql`
    query getSubscriptionEntitlementToEdit($featureCode: String!, $subscriptionId: ID!) {
  subscriptionEntitlement(
    featureCode: $featureCode
    subscriptionId: $subscriptionId
  ) {
    code
    name
    privileges {
      code
      name
      value
      valueType
      config {
        selectOptions
      }
    }
  }
}
    `;

/**
 * __useGetSubscriptionEntitlementToEditQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionEntitlementToEditQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionEntitlementToEditQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionEntitlementToEditQuery({
 *   variables: {
 *      featureCode: // value for 'featureCode'
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionEntitlementToEditQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables> & ({ variables: GetSubscriptionEntitlementToEditQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>(GetSubscriptionEntitlementToEditDocument, options);
      }
export function useGetSubscriptionEntitlementToEditLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>(GetSubscriptionEntitlementToEditDocument, options);
        }
export function useGetSubscriptionEntitlementToEditSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>(GetSubscriptionEntitlementToEditDocument, options);
        }
export type GetSubscriptionEntitlementToEditQueryHookResult = ReturnType<typeof useGetSubscriptionEntitlementToEditQuery>;
export type GetSubscriptionEntitlementToEditLazyQueryHookResult = ReturnType<typeof useGetSubscriptionEntitlementToEditLazyQuery>;
export type GetSubscriptionEntitlementToEditSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionEntitlementToEditSuspenseQuery>;
export type GetSubscriptionEntitlementToEditQueryResult = Apollo.QueryResult<GetSubscriptionEntitlementToEditQuery, GetSubscriptionEntitlementToEditQueryVariables>;
export const CreateOrUpdateSubscriptionEntitlementDocument = gql`
    mutation createOrUpdateSubscriptionEntitlement($input: CreateOrUpdateSubscriptionEntitlementInput!) {
  createOrUpdateSubscriptionEntitlement(input: $input) {
    code
  }
}
    `;
export type CreateOrUpdateSubscriptionEntitlementMutationFn = Apollo.MutationFunction<CreateOrUpdateSubscriptionEntitlementMutation, CreateOrUpdateSubscriptionEntitlementMutationVariables>;

/**
 * __useCreateOrUpdateSubscriptionEntitlementMutation__
 *
 * To run a mutation, you first call `useCreateOrUpdateSubscriptionEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrUpdateSubscriptionEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrUpdateSubscriptionEntitlementMutation, { data, loading, error }] = useCreateOrUpdateSubscriptionEntitlementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOrUpdateSubscriptionEntitlementMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrUpdateSubscriptionEntitlementMutation, CreateOrUpdateSubscriptionEntitlementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOrUpdateSubscriptionEntitlementMutation, CreateOrUpdateSubscriptionEntitlementMutationVariables>(CreateOrUpdateSubscriptionEntitlementDocument, options);
      }
export type CreateOrUpdateSubscriptionEntitlementMutationHookResult = ReturnType<typeof useCreateOrUpdateSubscriptionEntitlementMutation>;
export type CreateOrUpdateSubscriptionEntitlementMutationResult = Apollo.MutationResult<CreateOrUpdateSubscriptionEntitlementMutation>;
export type CreateOrUpdateSubscriptionEntitlementMutationOptions = Apollo.BaseMutationOptions<CreateOrUpdateSubscriptionEntitlementMutation, CreateOrUpdateSubscriptionEntitlementMutationVariables>;
export const GetCustomerInfosForWalletFormDocument = gql`
    query getCustomerInfosForWalletForm($id: ID!) {
  customer(id: $id) {
    id
    currency
    timezone
  }
}
    `;

/**
 * __useGetCustomerInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables> & ({ variables: GetCustomerInfosForWalletFormQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
      }
export function useGetCustomerInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export function useGetCustomerInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export type GetCustomerInfosForWalletFormQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormQuery>;
export type GetCustomerInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormLazyQuery>;
export type GetCustomerInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormSuspenseQuery>;
export type GetCustomerInfosForWalletFormQueryResult = Apollo.QueryResult<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>;
export const GetWalletInfosForWalletFormDocument = gql`
    query getWalletInfosForWalletForm($id: ID!) {
  wallet(id: $id) {
    id
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;

/**
 * __useGetWalletInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetWalletInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWalletInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables> & ({ variables: GetWalletInfosForWalletFormQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
      }
export function useGetWalletInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export function useGetWalletInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export type GetWalletInfosForWalletFormQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormQuery>;
export type GetWalletInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormLazyQuery>;
export type GetWalletInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormSuspenseQuery>;
export type GetWalletInfosForWalletFormQueryResult = Apollo.QueryResult<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>;
export const CreateCustomerWalletDocument = gql`
    mutation createCustomerWallet($input: CreateCustomerWalletInput!) {
  createCustomerWallet(input: $input) {
    id
    customer {
      id
      hasActiveWallet
    }
  }
}
    `;
export type CreateCustomerWalletMutationFn = Apollo.MutationFunction<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;

/**
 * __useCreateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletMutation, { data, loading, error }] = useCreateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>(CreateCustomerWalletDocument, options);
      }
export type CreateCustomerWalletMutationHookResult = ReturnType<typeof useCreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationResult = Apollo.MutationResult<CreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;
export const UpdateCustomerWalletDocument = gql`
    mutation updateCustomerWallet($input: UpdateCustomerWalletInput!) {
  updateCustomerWallet(input: $input) {
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;
export type UpdateCustomerWalletMutationFn = Apollo.MutationFunction<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;

/**
 * __useUpdateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerWalletMutation, { data, loading, error }] = useUpdateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>(UpdateCustomerWalletDocument, options);
      }
export type UpdateCustomerWalletMutationHookResult = ReturnType<typeof useUpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationResult = Apollo.MutationResult<UpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;
export const GetWalletForTopUpDocument = gql`
    query getWalletForTopUp($walletId: ID!) {
  wallet(id: $walletId) {
    id
    ...WalletForTopUp
  }
}
    ${WalletForTopUpFragmentDoc}`;

/**
 * __useGetWalletForTopUpQuery__
 *
 * To run a query within a React component, call `useGetWalletForTopUpQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletForTopUpQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletForTopUpQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *   },
 * });
 */
export function useGetWalletForTopUpQuery(baseOptions: Apollo.QueryHookOptions<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables> & ({ variables: GetWalletForTopUpQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>(GetWalletForTopUpDocument, options);
      }
export function useGetWalletForTopUpLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>(GetWalletForTopUpDocument, options);
        }
export function useGetWalletForTopUpSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>(GetWalletForTopUpDocument, options);
        }
export type GetWalletForTopUpQueryHookResult = ReturnType<typeof useGetWalletForTopUpQuery>;
export type GetWalletForTopUpLazyQueryHookResult = ReturnType<typeof useGetWalletForTopUpLazyQuery>;
export type GetWalletForTopUpSuspenseQueryHookResult = ReturnType<typeof useGetWalletForTopUpSuspenseQuery>;
export type GetWalletForTopUpQueryResult = Apollo.QueryResult<GetWalletForTopUpQuery, GetWalletForTopUpQueryVariables>;
export const GetBillableMetricsForWalletDocument = gql`
    query getBillableMetricsForWallet($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...BillableMetricForWalletScopeSection
    }
    metadata {
      totalCount
    }
  }
}
    ${BillableMetricForWalletScopeSectionFragmentDoc}`;

/**
 * __useGetBillableMetricsForWalletQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForWalletQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetBillableMetricsForWalletQuery(baseOptions?: Apollo.QueryHookOptions<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>(GetBillableMetricsForWalletDocument, options);
      }
export function useGetBillableMetricsForWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>(GetBillableMetricsForWalletDocument, options);
        }
export function useGetBillableMetricsForWalletSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>(GetBillableMetricsForWalletDocument, options);
        }
export type GetBillableMetricsForWalletQueryHookResult = ReturnType<typeof useGetBillableMetricsForWalletQuery>;
export type GetBillableMetricsForWalletLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForWalletLazyQuery>;
export type GetBillableMetricsForWalletSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForWalletSuspenseQuery>;
export type GetBillableMetricsForWalletQueryResult = Apollo.QueryResult<GetBillableMetricsForWalletQuery, GetBillableMetricsForWalletQueryVariables>;