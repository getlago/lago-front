import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: { input: any; output: any; }
  ChargeFilterValues: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: any; output: any; }
  /** Represents untyped JSON */
  JSON: { input: any; output: any; }
};

/** Autogenerated input type of AcceptInvite */
export type AcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  /** Uniq token of the Invite */
  token: Scalars['String']['input'];
};

/** Adyen input arguments */
export type AddAdyenPaymentProviderInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  hmacKey?: InputMaybe<Scalars['String']['input']>;
  livePrefix?: InputMaybe<Scalars['String']['input']>;
  merchantAccount: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Gocardless input arguments */
export type AddGocardlessPaymentProviderInput = {
  accessCode?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export type AddOn = {
  __typename?: 'AddOn';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  appliedAddOnsCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this add-on */
  customersCount: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AddOnCollection = {
  __typename?: 'AddOnCollection';
  collection: Array<AddOn>;
  metadata: CollectionMetadata;
};

/** Stripe input arguments */
export type AddStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  secretKey?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum AdjustedFeeTypeEnum {
  AdjustedAmount = 'adjusted_amount',
  AdjustedUnits = 'adjusted_units'
}

export type AdyenProvider = {
  __typename?: 'AdyenProvider';
  apiKey?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  hmacKey?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  livePrefix?: Maybe<Scalars['String']['output']>;
  merchantAccount: Scalars['String']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export enum AggregationTypeEnum {
  CountAgg = 'count_agg',
  CustomAgg = 'custom_agg',
  LatestAgg = 'latest_agg',
  MaxAgg = 'max_agg',
  SumAgg = 'sum_agg',
  UniqueCountAgg = 'unique_count_agg',
  WeightedSumAgg = 'weighted_sum_agg'
}

export type AppliedAddOn = {
  __typename?: 'AppliedAddOn';
  addOn: AddOn;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
};

export type AppliedCoupon = {
  __typename?: 'AppliedCoupon';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCentsRemaining?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  coupon: Coupon;
  createdAt: Scalars['ISO8601DateTime']['output'];
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  frequencyDurationRemaining?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  percentageRate?: Maybe<Scalars['Float']['output']>;
  terminatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AppliedTax = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  tax: Tax;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AuthUrl = {
  __typename?: 'AuthUrl';
  url: Scalars['String']['output'];
};

export type Authorize = {
  __typename?: 'Authorize';
  url: Scalars['String']['output'];
};

/** Base billable metric */
export type BillableMetric = {
  __typename?: 'BillableMetric';
  activeSubscriptionsCount: Scalars['Int']['output'];
  aggregationType: AggregationTypeEnum;
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  draftInvoicesCount: Scalars['Int']['output'];
  fieldName?: Maybe<Scalars['String']['output']>;
  filters?: Maybe<Array<BillableMetricFilter>>;
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  plansCount: Scalars['Int']['output'];
  recurring: Scalars['Boolean']['output'];
  subscriptionsCount: Scalars['Int']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  weightedInterval?: Maybe<WeightedIntervalEnum>;
};

export type BillableMetricCollection = {
  __typename?: 'BillableMetricCollection';
  collection: Array<BillableMetric>;
  metadata: CollectionMetadata;
};

/** Billable metric filters */
export type BillableMetricFilter = {
  __typename?: 'BillableMetricFilter';
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

/** Billable metric filters input arguments */
export type BillableMetricFiltersInput = {
  key: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export enum BillingTimeEnum {
  Anniversary = 'anniversary',
  Calendar = 'calendar'
}

export type Charge = {
  __typename?: 'Charge';
  billableMetric: BillableMetric;
  chargeModel: ChargeModelEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  filters?: Maybe<Array<ChargeFilter>>;
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceable: Scalars['Boolean']['output'];
  minAmountCents: Scalars['BigInt']['output'];
  payInAdvance: Scalars['Boolean']['output'];
  properties?: Maybe<Properties>;
  prorated: Scalars['Boolean']['output'];
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Charge filters object */
export type ChargeFilter = {
  __typename?: 'ChargeFilter';
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  properties: Properties;
  values: Scalars['ChargeFilterValues']['output'];
};

/** Charge filters input arguments */
export type ChargeFilterInput = {
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  properties: PropertiesInput;
  values: Scalars['ChargeFilterValues']['input'];
};

export type ChargeFilterUsage = {
  __typename?: 'ChargeFilterUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  id?: Maybe<Scalars['ID']['output']>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  units: Scalars['Float']['output'];
  values: Scalars['ChargeFilterValues']['output'];
};

export type ChargeInput = {
  billableMetricId: Scalars['ID']['input'];
  chargeModel: ChargeModelEnum;
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  invoiceable?: InputMaybe<Scalars['Boolean']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  payInAdvance?: InputMaybe<Scalars['Boolean']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  prorated?: InputMaybe<Scalars['Boolean']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum ChargeModelEnum {
  Custom = 'custom',
  Graduated = 'graduated',
  GraduatedPercentage = 'graduated_percentage',
  Package = 'package',
  Percentage = 'percentage',
  Standard = 'standard',
  Volume = 'volume'
}

export type ChargeOverridesInput = {
  billableMetricId: Scalars['ID']['input'];
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ChargeUsage = {
  __typename?: 'ChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  billableMetric: BillableMetric;
  charge: Charge;
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedUsage: Array<GroupedChargeUsage>;
  units: Scalars['Float']['output'];
};

export type CollectionMapping = {
  __typename?: 'CollectionMapping';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappingType: MappingTypeEnum;
};

export type CollectionMappingCollection = {
  __typename?: 'CollectionMappingCollection';
  collection: Array<CollectionMapping>;
  metadata: CollectionMetadata;
};

export type CollectionMetadata = {
  __typename?: 'CollectionMetadata';
  currentPage: Scalars['Int']['output'];
  limitValue: Scalars['Int']['output'];
  totalCount: Scalars['Int']['output'];
  totalPages: Scalars['Int']['output'];
};

export type Commitment = {
  __typename?: 'Commitment';
  amountCents: Scalars['BigInt']['output'];
  commitmentType: CommitmentTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  plan: Plan;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CommitmentInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  commitmentType?: InputMaybe<CommitmentTypeEnum>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum CommitmentTypeEnum {
  MinimumCommitment = 'minimum_commitment'
}

export enum CountryCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland Islands */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia (Plurinational State of) */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands */
  Cc = 'CC',
  /** Congo (Democratic Republic of the) */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Congo */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cuba */
  Cu = 'CU',
  /** Cabo Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czechia */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands (Malvinas) */
  Fk = 'FK',
  /** Micronesia (Federated States of) */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom of Great Britain and Northern Ireland */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and the South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard Island and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran (Islamic Republic of) */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea (Democratic People's Republic of) */
  Kp = 'KP',
  /** Korea (Republic of) */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Lao People's Democratic Republic */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova (Republic of) */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** North Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macao */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine, State of */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Réunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena, Ascension and Tristan da Cunha */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Syrian Arab Republic */
  Sy = 'SY',
  /** Eswatini */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Territories */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Turkey */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan, Province of China */
  Tw = 'TW',
  /** Tanzania, United Republic of */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands */
  Um = 'UM',
  /** United States of America */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Holy See */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela (Bolivarian Republic of) */
  Ve = 'VE',
  /** Virgin Islands (British) */
  Vg = 'VG',
  /** Virgin Islands (U.S.) */
  Vi = 'VI',
  /** Viet Nam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW'
}

export type Coupon = {
  __typename?: 'Coupon';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  appliedCouponsCount: Scalars['Int']['output'];
  billableMetrics?: Maybe<Array<BillableMetric>>;
  code?: Maybe<Scalars['String']['output']>;
  couponType: CouponTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this coupon */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  expiration: CouponExpiration;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  limitedBillableMetrics: Scalars['Boolean']['output'];
  limitedPlans: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  percentageRate?: Maybe<Scalars['Float']['output']>;
  plans?: Maybe<Array<Plan>>;
  reusable: Scalars['Boolean']['output'];
  status: CouponStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CouponCollection = {
  __typename?: 'CouponCollection';
  collection: Array<Coupon>;
  metadata: CollectionMetadata;
};

export enum CouponExpiration {
  NoExpiration = 'no_expiration',
  TimeLimit = 'time_limit'
}

export enum CouponFrequency {
  Forever = 'forever',
  Once = 'once',
  Recurring = 'recurring'
}

export enum CouponStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export enum CouponTypeEnum {
  FixedAmount = 'fixed_amount',
  Percentage = 'percentage'
}

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Create Adjusted Fee Input */
export type CreateAdjustedFeeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  feeId: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of CreateAppliedCoupon */
export type CreateAppliedCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  couponId: Scalars['ID']['input'];
  customerId: Scalars['ID']['input'];
  frequency?: InputMaybe<CouponFrequency>;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
};

/** Create Billable metric input arguments */
export type CreateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  group?: InputMaybe<Scalars['JSON']['input']>;
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Autogenerated input type of CreateCoupon */
export type CreateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateCreditNote */
export type CreateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
  reason: CreditNoteReasonEnum;
  refundAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Create Customer input arguments */
export type CreateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  integrationCustomer?: InputMaybe<IntegrationCustomerInput>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name: Scalars['String']['input'];
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Create Wallet Input */
export type CreateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency: CurrencyEnum;
  customerId: Scalars['ID']['input'];
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  grantedCredits: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  paidCredits: Scalars['String']['input'];
  rateAmount: Scalars['String']['input'];
  recurringTransactionRules?: InputMaybe<Array<CreateRecurringTransactionRuleInput>>;
};

/** Autogenerated input type of CreateCustomerWalletTransaction */
export type CreateCustomerWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  voidedCredits?: InputMaybe<Scalars['String']['input']>;
  walletId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateIntegrationCollectionMapping */
export type CreateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappingType: MappingTypeEnum;
};

/** Autogenerated input type of CreateIntegrationMapping */
export type CreateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode: Scalars['String']['input'];
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappableId: Scalars['ID']['input'];
  mappableType: MappableTypeEnum;
};

/** Autogenerated input type of CreateInvite */
export type CreateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  role: MembershipRole;
};

/** Create Invoice input arguments */
export type CreateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerId: Scalars['ID']['input'];
  fees: Array<FeeInput>;
};

/** Autogenerated input type of CreateNetsuiteIntegration */
export type CreateNetsuiteIntegrationInput = {
  accountId: Scalars['String']['input'];
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  scriptEndpointUrl?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  syncSalesOrders?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateOktaIntegration */
export type CreateOktaIntegrationInput = {
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  domain: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

/** Autogenerated input type of CreatePasswordReset */
export type CreatePasswordResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePasswordReset */
export type CreatePasswordResetPayload = {
  __typename?: 'CreatePasswordResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
};

/** Autogenerated input type of CreatePlan */
export type CreatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
};

export type CreateRecurringTransactionRuleInput = {
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  trigger: RecurringTransactionTriggerEnum;
};

/** Create Subscription input arguments */
export type CreateSubscriptionInput = {
  billingTime: BillingTimeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['ID']['input'];
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  planId: Scalars['ID']['input'];
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
};

/** CreditNote */
export type CreditNote = {
  __typename?: 'CreditNote';
  appliedTaxes?: Maybe<Array<CreditNoteAppliedTax>>;
  balanceAmountCents: Scalars['BigInt']['output'];
  /** Check if credit note can be voided */
  canBeVoided: Scalars['Boolean']['output'];
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmountCents: Scalars['BigInt']['output'];
  creditStatus?: Maybe<CreditNoteCreditStatusEnum>;
  currency: CurrencyEnum;
  customer: Customer;
  description?: Maybe<Scalars['String']['output']>;
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoice?: Maybe<Invoice>;
  issuingDate: Scalars['ISO8601Date']['output'];
  items: Array<CreditNoteItem>;
  number: Scalars['String']['output'];
  reason: CreditNoteReasonEnum;
  refundAmountCents: Scalars['BigInt']['output'];
  refundStatus?: Maybe<CreditNoteRefundStatusEnum>;
  refundedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  sequentialId: Scalars['ID']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  voidedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

export type CreditNoteAppliedTax = AppliedTax & {
  __typename?: 'CreditNoteAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  baseAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNote: CreditNote;
  id: Scalars['ID']['output'];
  tax: Tax;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CreditNoteCollection = {
  __typename?: 'CreditNoteCollection';
  collection: Array<CreditNote>;
  metadata: CollectionMetadata;
};

export enum CreditNoteCreditStatusEnum {
  Available = 'available',
  Consumed = 'consumed',
  Voided = 'voided'
}

/** Estimate amounts for credit note creation */
export type CreditNoteEstimate = {
  __typename?: 'CreditNoteEstimate';
  appliedTaxes: Array<CreditNoteAppliedTax>;
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  items: Array<CreditNoteItemEstimate>;
  maxCreditableAmountCents: Scalars['BigInt']['output'];
  maxRefundableAmountCents: Scalars['BigInt']['output'];
  preciseCouponsAdjustmentAmountCents: Scalars['Float']['output'];
  preciseTaxesAmountCents: Scalars['Float']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
};

export type CreditNoteItem = {
  __typename?: 'CreditNoteItem';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
};

export type CreditNoteItemEstimate = {
  __typename?: 'CreditNoteItemEstimate';
  amountCents: Scalars['BigInt']['output'];
  fee: Fee;
};

export type CreditNoteItemInput = {
  amountCents: Scalars['BigInt']['input'];
  feeId: Scalars['ID']['input'];
};

export enum CreditNoteReasonEnum {
  DuplicatedCharge = 'duplicated_charge',
  FraudulentCharge = 'fraudulent_charge',
  OrderCancellation = 'order_cancellation',
  OrderChange = 'order_change',
  Other = 'other',
  ProductUnsatisfactory = 'product_unsatisfactory'
}

export enum CreditNoteRefundStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum CurrencyEnum {
  /** United Arab Emirates Dirham */
  Aed = 'AED',
  /** Afghan Afghani */
  Afn = 'AFN',
  /** Albanian Lek */
  All = 'ALL',
  /** Armenian Dram */
  Amd = 'AMD',
  /** Netherlands Antillean Gulden */
  Ang = 'ANG',
  /** Angolan Kwanza */
  Aoa = 'AOA',
  /** Argentine Peso */
  Ars = 'ARS',
  /** Australian Dollar */
  Aud = 'AUD',
  /** Aruban Florin */
  Awg = 'AWG',
  /** Azerbaijani Manat */
  Azn = 'AZN',
  /** Bosnia and Herzegovina Convertible Mark */
  Bam = 'BAM',
  /** Barbadian Dollar */
  Bbd = 'BBD',
  /** Bangladeshi Taka */
  Bdt = 'BDT',
  /** Bulgarian Lev */
  Bgn = 'BGN',
  /** Burundian Franc */
  Bif = 'BIF',
  /** Bermudian Dollar */
  Bmd = 'BMD',
  /** Brunei Dollar */
  Bnd = 'BND',
  /** Bolivian Boliviano */
  Bob = 'BOB',
  /** Brazilian Real */
  Brl = 'BRL',
  /** Bahamian Dollar */
  Bsd = 'BSD',
  /** Botswana Pula */
  Bwp = 'BWP',
  /** Belarusian Ruble */
  Byn = 'BYN',
  /** Belize Dollar */
  Bzd = 'BZD',
  /** Canadian Dollar */
  Cad = 'CAD',
  /** Congolese Franc */
  Cdf = 'CDF',
  /** Swiss Franc */
  Chf = 'CHF',
  /** Unidad de Fomento */
  Clf = 'CLF',
  /** Chilean Peso */
  Clp = 'CLP',
  /** Chinese Renminbi Yuan */
  Cny = 'CNY',
  /** Colombian Peso */
  Cop = 'COP',
  /** Costa Rican Colón */
  Crc = 'CRC',
  /** Cape Verdean Escudo */
  Cve = 'CVE',
  /** Czech Koruna */
  Czk = 'CZK',
  /** Djiboutian Franc */
  Djf = 'DJF',
  /** Danish Krone */
  Dkk = 'DKK',
  /** Dominican Peso */
  Dop = 'DOP',
  /** Algerian Dinar */
  Dzd = 'DZD',
  /** Egyptian Pound */
  Egp = 'EGP',
  /** Ethiopian Birr */
  Etb = 'ETB',
  /** Euro */
  Eur = 'EUR',
  /** Fijian Dollar */
  Fjd = 'FJD',
  /** Falkland Pound */
  Fkp = 'FKP',
  /** British Pound */
  Gbp = 'GBP',
  /** Georgian Lari */
  Gel = 'GEL',
  /** Gibraltar Pound */
  Gip = 'GIP',
  /** Gambian Dalasi */
  Gmd = 'GMD',
  /** Guinean Franc */
  Gnf = 'GNF',
  /** Guatemalan Quetzal */
  Gtq = 'GTQ',
  /** Guyanese Dollar */
  Gyd = 'GYD',
  /** Hong Kong Dollar */
  Hkd = 'HKD',
  /** Honduran Lempira */
  Hnl = 'HNL',
  /** Croatian Kuna */
  Hrk = 'HRK',
  /** Haitian Gourde */
  Htg = 'HTG',
  /** Hungarian Forint */
  Huf = 'HUF',
  /** Indonesian Rupiah */
  Idr = 'IDR',
  /** Israeli New Sheqel */
  Ils = 'ILS',
  /** Indian Rupee */
  Inr = 'INR',
  /** Icelandic Króna */
  Isk = 'ISK',
  /** Jamaican Dollar */
  Jmd = 'JMD',
  /** Jordanian Dinar */
  Jod = 'JOD',
  /** Japanese Yen */
  Jpy = 'JPY',
  /** Kenyan Shilling */
  Kes = 'KES',
  /** Kyrgyzstani Som */
  Kgs = 'KGS',
  /** Cambodian Riel */
  Khr = 'KHR',
  /** Comorian Franc */
  Kmf = 'KMF',
  /** South Korean Won */
  Krw = 'KRW',
  /** Kuwaiti Dinar */
  Kwd = 'KWD',
  /** Cayman Islands Dollar */
  Kyd = 'KYD',
  /** Kazakhstani Tenge */
  Kzt = 'KZT',
  /** Lao Kip */
  Lak = 'LAK',
  /** Lebanese Pound */
  Lbp = 'LBP',
  /** Sri Lankan Rupee */
  Lkr = 'LKR',
  /** Liberian Dollar */
  Lrd = 'LRD',
  /** Lesotho Loti */
  Lsl = 'LSL',
  /** Moroccan Dirham */
  Mad = 'MAD',
  /** Moldovan Leu */
  Mdl = 'MDL',
  /** Malagasy Ariary */
  Mga = 'MGA',
  /** Macedonian Denar */
  Mkd = 'MKD',
  /** Myanmar Kyat */
  Mmk = 'MMK',
  /** Mongolian Tögrög */
  Mnt = 'MNT',
  /** Macanese Pataca */
  Mop = 'MOP',
  /** Mauritanian Ouguiya */
  Mro = 'MRO',
  /** Mauritian Rupee */
  Mur = 'MUR',
  /** Maldivian Rufiyaa */
  Mvr = 'MVR',
  /** Malawian Kwacha */
  Mwk = 'MWK',
  /** Mexican Peso */
  Mxn = 'MXN',
  /** Malaysian Ringgit */
  Myr = 'MYR',
  /** Mozambican Metical */
  Mzn = 'MZN',
  /** Namibian Dollar */
  Nad = 'NAD',
  /** Nigerian Naira */
  Ngn = 'NGN',
  /** Nicaraguan Córdoba */
  Nio = 'NIO',
  /** Norwegian Krone */
  Nok = 'NOK',
  /** Nepalese Rupee */
  Npr = 'NPR',
  /** New Zealand Dollar */
  Nzd = 'NZD',
  /** Panamanian Balboa */
  Pab = 'PAB',
  /** Peruvian Sol */
  Pen = 'PEN',
  /** Papua New Guinean Kina */
  Pgk = 'PGK',
  /** Philippine Peso */
  Php = 'PHP',
  /** Pakistani Rupee */
  Pkr = 'PKR',
  /** Polish Złoty */
  Pln = 'PLN',
  /** Paraguayan Guaraní */
  Pyg = 'PYG',
  /** Qatari Riyal */
  Qar = 'QAR',
  /** Romanian Leu */
  Ron = 'RON',
  /** Serbian Dinar */
  Rsd = 'RSD',
  /** Russian Ruble */
  Rub = 'RUB',
  /** Rwandan Franc */
  Rwf = 'RWF',
  /** Saudi Riyal */
  Sar = 'SAR',
  /** Solomon Islands Dollar */
  Sbd = 'SBD',
  /** Seychellois Rupee */
  Scr = 'SCR',
  /** Swedish Krona */
  Sek = 'SEK',
  /** Singapore Dollar */
  Sgd = 'SGD',
  /** Saint Helenian Pound */
  Shp = 'SHP',
  /** Sierra Leonean Leone */
  Sll = 'SLL',
  /** Somali Shilling */
  Sos = 'SOS',
  /** Surinamese Dollar */
  Srd = 'SRD',
  /** São Tomé and Príncipe Dobra */
  Std = 'STD',
  /** Swazi Lilangeni */
  Szl = 'SZL',
  /** Thai Baht */
  Thb = 'THB',
  /** Tajikistani Somoni */
  Tjs = 'TJS',
  /** Tongan Paʻanga */
  Top = 'TOP',
  /** Turkish Lira */
  Try = 'TRY',
  /** Trinidad and Tobago Dollar */
  Ttd = 'TTD',
  /** New Taiwan Dollar */
  Twd = 'TWD',
  /** Tanzanian Shilling */
  Tzs = 'TZS',
  /** Ukrainian Hryvnia */
  Uah = 'UAH',
  /** Ugandan Shilling */
  Ugx = 'UGX',
  /** United States Dollar */
  Usd = 'USD',
  /** Uruguayan Peso */
  Uyu = 'UYU',
  /** Uzbekistan Som */
  Uzs = 'UZS',
  /** Vietnamese Đồng */
  Vnd = 'VND',
  /** Vanuatu Vatu */
  Vuv = 'VUV',
  /** Samoan Tala */
  Wst = 'WST',
  /** Central African Cfa Franc */
  Xaf = 'XAF',
  /** East Caribbean Dollar */
  Xcd = 'XCD',
  /** West African Cfa Franc */
  Xof = 'XOF',
  /** Cfp Franc */
  Xpf = 'XPF',
  /** Yemeni Rial */
  Yer = 'YER',
  /** South African Rand */
  Zar = 'ZAR',
  /** Zambian Kwacha */
  Zmw = 'ZMW'
}

/** Current Organization Type */
export type CurrentOrganization = {
  __typename?: 'CurrentOrganization';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  adyenPaymentProviders?: Maybe<Array<AdyenProvider>>;
  apiKey?: Maybe<Scalars['String']['output']>;
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  defaultCurrency: CurrencyEnum;
  documentNumberPrefix: Scalars['String']['output'];
  documentNumbering: DocumentNumberingEnum;
  email?: Maybe<Scalars['String']['output']>;
  emailSettings?: Maybe<Array<EmailSettingsEnum>>;
  euTaxManagement: Scalars['Boolean']['output'];
  gocardlessPaymentProviders?: Maybe<Array<GocardlessProvider>>;
  id: Scalars['ID']['output'];
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  netPaymentTerm: Scalars['Int']['output'];
  premiumIntegrations: Array<IntegrationTypeEnum>;
  state?: Maybe<Scalars['String']['output']>;
  stripePaymentProviders?: Maybe<Array<StripeProvider>>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  /** Query taxes of an organization */
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


/** Current Organization Type */
export type CurrentOrganizationTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};

export type CurrentVersion = {
  __typename?: 'CurrentVersion';
  githubUrl: Scalars['String']['output'];
  number: Scalars['String']['output'];
};

export type Customer = {
  __typename?: 'Customer';
  /** Number of active subscriptions per customer */
  activeSubscriptionsCount: Scalars['Int']['output'];
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  applicableTimezone: TimezoneEnum;
  appliedAddOns?: Maybe<Array<AppliedAddOn>>;
  appliedCoupons?: Maybe<Array<AppliedCoupon>>;
  billingConfiguration?: Maybe<CustomerBillingConfiguration>;
  /** Check if customer attributes are editable */
  canEditAttributes: Scalars['Boolean']['output'];
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  /** Credit notes credits balance available per customer */
  creditNotesBalanceAmountCents: Scalars['BigInt']['output'];
  /** Number of available credits from credit notes per customer */
  creditNotesCreditsAvailableCount: Scalars['Int']['output'];
  currency?: Maybe<CurrencyEnum>;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalSalesforceId?: Maybe<Scalars['String']['output']>;
  /** Define if a customer has an active wallet */
  hasActiveWallet: Scalars['Boolean']['output'];
  /** Define if a customer has any credit note */
  hasCreditNotes: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  invoiceGracePeriod?: Maybe<Scalars['Int']['output']>;
  invoices?: Maybe<Array<Invoice>>;
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Array<CustomerMetadata>>;
  name?: Maybe<Scalars['String']['output']>;
  netPaymentTerm?: Maybe<Scalars['Int']['output']>;
  netsuiteCustomer?: Maybe<NetsuiteCustomer>;
  paymentProvider?: Maybe<ProviderTypeEnum>;
  paymentProviderCode?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  providerCustomer?: Maybe<ProviderCustomer>;
  sequentialId: Scalars['String']['output'];
  slug: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  /** Query subscriptions of a customer */
  subscriptions: Array<Subscription>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  url?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


export type CustomerSubscriptionsArgs = {
  status?: InputMaybe<Array<StatusTypeEnum>>;
};

export type CustomerBillingConfiguration = {
  __typename?: 'CustomerBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
};

export type CustomerBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerCollection = {
  __typename?: 'CustomerCollection';
  collection: Array<Customer>;
  metadata: CollectionMetadata;
};

export type CustomerMetadata = {
  __typename?: 'CustomerMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayInInvoice: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

export type CustomerMetadataInput = {
  displayInInvoice: Scalars['Boolean']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type CustomerUsage = {
  __typename?: 'CustomerUsage';
  amountCents: Scalars['BigInt']['output'];
  chargesUsage: Array<ChargeUsage>;
  currency: CurrencyEnum;
  fromDatetime: Scalars['ISO8601DateTime']['output'];
  issuingDate: Scalars['ISO8601Date']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  toDatetime: Scalars['ISO8601DateTime']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
};

/** Autogenerated input type of DestroyAddOn */
export type DestroyAddOnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAddOn */
export type DestroyAddOnPayload = {
  __typename?: 'DestroyAddOnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyAdjustedFee */
export type DestroyAdjustedFeeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAdjustedFee */
export type DestroyAdjustedFeePayload = {
  __typename?: 'DestroyAdjustedFeePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyBillableMetric */
export type DestroyBillableMetricInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** Autogenerated return type of DestroyBillableMetric */
export type DestroyBillableMetricPayload = {
  __typename?: 'DestroyBillableMetricPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyCoupon */
export type DestroyCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCoupon */
export type DestroyCouponPayload = {
  __typename?: 'DestroyCouponPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyCustomer */
export type DestroyCustomerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCustomer */
export type DestroyCustomerPayload = {
  __typename?: 'DestroyCustomerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyIntegrationCollectionMapping */
export type DestroyIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationCollectionMapping */
export type DestroyIntegrationCollectionMappingPayload = {
  __typename?: 'DestroyIntegrationCollectionMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyIntegration */
export type DestroyIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyIntegrationMapping */
export type DestroyIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationMapping */
export type DestroyIntegrationMappingPayload = {
  __typename?: 'DestroyIntegrationMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DestroyIntegration */
export type DestroyIntegrationPayload = {
  __typename?: 'DestroyIntegrationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPaymentProvider */
export type DestroyPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPaymentProvider */
export type DestroyPaymentProviderPayload = {
  __typename?: 'DestroyPaymentProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPlan */
export type DestroyPlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPlan */
export type DestroyPlanPayload = {
  __typename?: 'DestroyPlanPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyTax */
export type DestroyTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyTax */
export type DestroyTaxPayload = {
  __typename?: 'DestroyTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyWebhookEndpoint */
export type DestroyWebhookEndpointInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyWebhookEndpoint */
export type DestroyWebhookEndpointPayload = {
  __typename?: 'DestroyWebhookEndpointPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Document numbering type */
export enum DocumentNumberingEnum {
  PerCustomer = 'per_customer',
  PerOrganization = 'per_organization'
}

/** Autogenerated input type of DownloadCreditNote */
export type DownloadCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadCustomerPortalInvoice */
export type DownloadCustomerPortalInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadInvoice */
export type DownloadInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Organization Email Settings Values */
export enum EmailSettingsEnum {
  /** credit_note.created */
  CreditNoteCreated = 'credit_note_created',
  /** invoice.finalized */
  InvoiceFinalized = 'invoice_finalized'
}

export type Event = {
  __typename?: 'Event';
  apiClient?: Maybe<Scalars['String']['output']>;
  billableMetricName?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  customerTimezone: TimezoneEnum;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  externalSubscriptionId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  matchBillableMetric: Scalars['Boolean']['output'];
  matchCustomField: Scalars['Boolean']['output'];
  matchCustomer: Scalars['Boolean']['output'];
  matchSubscription: Scalars['Boolean']['output'];
  payload: Scalars['JSON']['output'];
  receivedAt: Scalars['ISO8601DateTime']['output'];
  timestamp?: Maybe<Scalars['ISO8601DateTime']['output']>;
  transactionId?: Maybe<Scalars['String']['output']>;
};

export type EventCollection = {
  __typename?: 'EventCollection';
  collection: Array<Event>;
  metadata: CollectionMetadata;
};

export type Fee = InvoiceItem & {
  __typename?: 'Fee';
  adjustedFee: Scalars['Boolean']['output'];
  adjustedFeeType?: Maybe<AdjustedFeeTypeEnum>;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  amountDetails?: Maybe<FeeAmountDetails>;
  appliedTaxes?: Maybe<Array<FeeAppliedTax>>;
  charge?: Maybe<Charge>;
  chargeFilter?: Maybe<ChargeFilter>;
  creditableAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  description?: Maybe<Scalars['String']['output']>;
  eventsCount?: Maybe<Scalars['BigInt']['output']>;
  feeType: FeeTypesEnum;
  group?: Maybe<Group>;
  groupedBy: Scalars['JSON']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceName?: Maybe<Scalars['String']['output']>;
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
  preciseUnitAmount: Scalars['Float']['output'];
  subscription?: Maybe<Subscription>;
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate?: Maybe<Scalars['Float']['output']>;
  trueUpFee?: Maybe<Fee>;
  trueUpParentFee?: Maybe<Fee>;
  units: Scalars['Float']['output'];
};

export type FeeAmountDetails = {
  __typename?: 'FeeAmountDetails';
  fixedFeeTotalAmount?: Maybe<Scalars['String']['output']>;
  fixedFeeUnitAmount?: Maybe<Scalars['String']['output']>;
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  freeEvents?: Maybe<Scalars['Int']['output']>;
  freeUnits?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<FeeAmountDetailsGraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<FeeAmountDetailsGraduatedRange>>;
  minMaxAdjustmentTotalAmount?: Maybe<Scalars['String']['output']>;
  paidEvents?: Maybe<Scalars['Int']['output']>;
  paidUnits?: Maybe<Scalars['String']['output']>;
  perPackageSize?: Maybe<Scalars['Int']['output']>;
  perPackageUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedPercentageRange = {
  __typename?: 'FeeAmountDetailsGraduatedPercentageRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedRange = {
  __typename?: 'FeeAmountDetailsGraduatedRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAppliedTax = AppliedTax & {
  __typename?: 'FeeAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
  tax: Tax;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Fee input for creating invoice */
export type FeeInput = {
  addOnId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

export enum FeeTypesEnum {
  AddOn = 'add_on',
  Charge = 'charge',
  Commitment = 'commitment',
  Credit = 'credit',
  Subscription = 'subscription'
}

/** Autogenerated input type of FetchIntegrationItems */
export type FetchIntegrationItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FetchIntegrationTaxItems */
export type FetchIntegrationTaxItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FinalizeInvoice */
export type FinalizeInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type FinalizedInvoiceCollection = {
  __typename?: 'FinalizedInvoiceCollection';
  amountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  invoicesCount: Scalars['BigInt']['output'];
  month: Scalars['ISO8601DateTime']['output'];
  paymentStatus?: Maybe<InvoicePaymentStatusTypeEnum>;
};

export type FinalizedInvoiceCollectionCollection = {
  __typename?: 'FinalizedInvoiceCollectionCollection';
  collection: Array<FinalizedInvoiceCollection>;
  metadata: CollectionMetadata;
};

/** Autogenerated input type of GenerateCustomerPortalUrl */
export type GenerateCustomerPortalUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of GenerateCustomerPortalUrl */
export type GenerateCustomerPortalUrlPayload = {
  __typename?: 'GenerateCustomerPortalUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type GocardlessProvider = {
  __typename?: 'GocardlessProvider';
  code: Scalars['String']['output'];
  hasAccessToken: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
  webhookSecret?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of GoogleAcceptInvite */
export type GoogleAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleLoginUser */
export type GoogleLoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleRegisterUser */
export type GoogleRegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

export type GraduatedPercentageRange = {
  __typename?: 'GraduatedPercentageRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  rate: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedPercentageRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  rate: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GraduatedRange = {
  __typename?: 'GraduatedRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GrossRevenue = {
  __typename?: 'GrossRevenue';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  month: Scalars['ISO8601DateTime']['output'];
};

export type GrossRevenueCollection = {
  __typename?: 'GrossRevenueCollection';
  collection: Array<GrossRevenue>;
  metadata: CollectionMetadata;
};

export type Group = {
  __typename?: 'Group';
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  key?: Maybe<Scalars['String']['output']>;
  value: Scalars['String']['output'];
};

export type GroupedChargeUsage = {
  __typename?: 'GroupedChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedBy?: Maybe<Scalars['JSON']['output']>;
  units: Scalars['Float']['output'];
};

export type Integration = NetsuiteIntegration;

export type IntegrationCollection = {
  __typename?: 'IntegrationCollection';
  collection: Array<Integration>;
  metadata: CollectionMetadata;
};

export type IntegrationCustomerInput = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  integrationCode?: InputMaybe<Scalars['String']['input']>;
  integrationType?: InputMaybe<IntegrationTypeEnum>;
  subsidiaryId?: InputMaybe<Scalars['String']['input']>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
};

export type IntegrationItem = {
  __typename?: 'IntegrationItem';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  itemType: IntegrationItemTypeEnum;
};

export type IntegrationItemCollection = {
  __typename?: 'IntegrationItemCollection';
  collection: Array<IntegrationItem>;
  metadata: CollectionMetadata;
};

export enum IntegrationItemTypeEnum {
  Standard = 'standard',
  Tax = 'tax'
}

export enum IntegrationTypeEnum {
  Netsuite = 'netsuite'
}

export type Invite = {
  __typename?: 'Invite';
  acceptedAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  recipient: Membership;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role: MembershipRole;
  status: InviteStatusTypeEnum;
  token: Scalars['String']['output'];
};

export type InviteCollection = {
  __typename?: 'InviteCollection';
  collection: Array<Invite>;
  metadata: CollectionMetadata;
};

export enum InviteStatusTypeEnum {
  Accepted = 'accepted',
  Pending = 'pending',
  Revoked = 'revoked'
}

/** Invoice */
export type Invoice = {
  __typename?: 'Invoice';
  appliedTaxes?: Maybe<Array<InvoiceAppliedTax>>;
  chargeAmountCents: Scalars['BigInt']['output'];
  couponsAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  creditNotesAmountCents: Scalars['BigInt']['output'];
  creditableAmountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  customer: Customer;
  fees?: Maybe<Array<Fee>>;
  feesAmountCents: Scalars['BigInt']['output'];
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceSubscriptions?: Maybe<Array<InvoiceSubscription>>;
  invoiceType: InvoiceTypeEnum;
  issuingDate: Scalars['ISO8601Date']['output'];
  metadata?: Maybe<Array<InvoiceMetadata>>;
  number: Scalars['String']['output'];
  paymentDisputeLosable: Scalars['Boolean']['output'];
  paymentDisputeLostAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  paymentDueDate: Scalars['ISO8601Date']['output'];
  paymentStatus: InvoicePaymentStatusTypeEnum;
  prepaidCreditAmountCents: Scalars['BigInt']['output'];
  refundableAmountCents: Scalars['BigInt']['output'];
  sequentialId: Scalars['ID']['output'];
  status: InvoiceStatusTypeEnum;
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  subTotalIncludingTaxesAmountCents: Scalars['BigInt']['output'];
  subscriptions?: Maybe<Array<Subscription>>;
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  versionNumber: Scalars['Int']['output'];
  voidable: Scalars['Boolean']['output'];
};

export type InvoiceAppliedTax = AppliedTax & {
  __typename?: 'InvoiceAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  feesAmountCents: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  invoice: Invoice;
  tax: Tax;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type InvoiceCollection = {
  __typename?: 'InvoiceCollection';
  collection: Array<Invoice>;
  metadata: CollectionMetadata;
};

/** Invoice Item */
export type InvoiceItem = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  group?: Maybe<Group>;
  id: Scalars['ID']['output'];
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
};

/** Attributes for invoice metadata object */
export type InvoiceMetadata = {
  __typename?: 'InvoiceMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

/** Attributes for creating or updating invoice metadata object */
export type InvoiceMetadataInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum InvoicePaymentStatusTypeEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum InvoiceStatusTypeEnum {
  Draft = 'draft',
  Finalized = 'finalized',
  Voided = 'voided'
}

export type InvoiceSubscription = {
  __typename?: 'InvoiceSubscription';
  chargeAmountCents: Scalars['BigInt']['output'];
  chargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  chargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  fees?: Maybe<Array<Fee>>;
  fromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  invoice: Invoice;
  subscription: Subscription;
  subscriptionAmountCents: Scalars['BigInt']['output'];
  toDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  totalAmountCents: Scalars['BigInt']['output'];
};

export enum InvoiceTypeEnum {
  AddOn = 'add_on',
  Credit = 'credit',
  OneOff = 'one_off',
  Subscription = 'subscription'
}

export type InvoicedUsage = {
  __typename?: 'InvoicedUsage';
  amountCents: Scalars['BigInt']['output'];
  code?: Maybe<Scalars['String']['output']>;
  currency: CurrencyEnum;
  month: Scalars['ISO8601DateTime']['output'];
};

export type InvoicedUsageCollection = {
  __typename?: 'InvoicedUsageCollection';
  collection: Array<InvoicedUsage>;
  metadata: CollectionMetadata;
};

export enum LagoApiError {
  CouponIsNotReusable = 'coupon_is_not_reusable',
  CurrenciesDoesNotMatch = 'currencies_does_not_match',
  DoesNotMatchItemAmounts = 'does_not_match_item_amounts',
  EmailAlreadyUsed = 'email_already_used',
  ExpiredJwtToken = 'expired_jwt_token',
  Forbidden = 'forbidden',
  GoogleAuthMissingSetup = 'google_auth_missing_setup',
  IncorrectLoginOrPassword = 'incorrect_login_or_password',
  InternalError = 'internal_error',
  InvalidGoogleCode = 'invalid_google_code',
  InvalidGoogleToken = 'invalid_google_token',
  InviteAlreadyExists = 'invite_already_exists',
  InviteEmailMistmatch = 'invite_email_mistmatch',
  InviteNotFound = 'invite_not_found',
  NotFound = 'not_found',
  NotOrganizationMember = 'not_organization_member',
  PaymentProcessorIsCurrentlyHandlingPayment = 'payment_processor_is_currently_handling_payment',
  PlanNotFound = 'plan_not_found',
  PlanOverlapping = 'plan_overlapping',
  TokenEncodingError = 'token_encoding_error',
  Unauthorized = 'unauthorized',
  UnprocessableEntity = 'unprocessable_entity',
  UrlIsInvalid = 'url_is_invalid',
  UserAlreadyExists = 'user_already_exists',
  UserDoesNotExist = 'user_does_not_exist',
  ValueAlreadyExist = 'value_already_exist',
  ValueIsInvalid = 'value_is_invalid',
  ValueIsOutOfRange = 'value_is_out_of_range'
}

export type LimitationInput = {
  billableMetricIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  planIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type LoginUser = {
  __typename?: 'LoginUser';
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of LoginUser */
export type LoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated input type of LoseInvoiceDispute */
export type LoseInvoiceDisputeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum MappableTypeEnum {
  AddOn = 'AddOn',
  BillableMetric = 'BillableMetric'
}

export type Mapping = {
  __typename?: 'Mapping';
  externalAccountCode: Scalars['String']['output'];
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappableId: Scalars['ID']['output'];
  mappableType: MappableTypeEnum;
};

export type MappingCollection = {
  __typename?: 'MappingCollection';
  collection: Array<Mapping>;
  metadata: CollectionMetadata;
};

export enum MappingTypeEnum {
  Coupon = 'coupon',
  CreditNote = 'credit_note',
  FallbackItem = 'fallback_item',
  MinimumCommitment = 'minimum_commitment',
  PrepaidCredit = 'prepaid_credit',
  SubscriptionFee = 'subscription_fee',
  Tax = 'tax'
}

export type Membership = {
  __typename?: 'Membership';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  permissions: Permissions;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role?: Maybe<MembershipRole>;
  status: MembershipStatus;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

export type MembershipCollection = {
  __typename?: 'MembershipCollection';
  collection: Array<Membership>;
  metadata: CollectionMetadata;
};

export enum MembershipRole {
  Admin = 'admin',
  Finance = 'finance',
  Manager = 'manager'
}

export enum MembershipStatus {
  Active = 'active',
  Revoked = 'revoked'
}

export type Mrr = {
  __typename?: 'Mrr';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  month: Scalars['ISO8601DateTime']['output'];
};

export type MrrCollection = {
  __typename?: 'MrrCollection';
  collection: Array<Mrr>;
  metadata: CollectionMetadata;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a new Invite */
  acceptInvite?: Maybe<RegisterUser>;
  /** Add Adyen payment provider */
  addAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Add or update Gocardless payment provider */
  addGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Add Stripe API keys to the organization */
  addStripePaymentProvider?: Maybe<StripeProvider>;
  /** Creates a new add-on */
  createAddOn?: Maybe<AddOn>;
  /** Creates Adjusted Fee */
  createAdjustedFee?: Maybe<Fee>;
  /** Assigns a Coupon to a Customer */
  createAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Creates a new Billable metric */
  createBillableMetric?: Maybe<BillableMetric>;
  /** Creates a new Coupon */
  createCoupon?: Maybe<Coupon>;
  /** Creates a new Credit Note */
  createCreditNote?: Maybe<CreditNote>;
  /** Creates a new customer */
  createCustomer?: Maybe<Customer>;
  /** Creates a new Customer Wallet */
  createCustomerWallet?: Maybe<Wallet>;
  /** Creates a new Customer Wallet Transaction */
  createCustomerWalletTransaction?: Maybe<WalletTransactionCollection>;
  /** Create integration collection mapping */
  createIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Create integration mapping */
  createIntegrationMapping?: Maybe<Mapping>;
  /** Creates a new Invite */
  createInvite?: Maybe<Invite>;
  /** Creates a new Invoice */
  createInvoice?: Maybe<Invoice>;
  /** Create Netsuite integration */
  createNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Create Okta integration */
  createOktaIntegration?: Maybe<OktaIntegration>;
  /** Creates a new password reset */
  createPasswordReset?: Maybe<CreatePasswordResetPayload>;
  /** Creates a new Plan */
  createPlan?: Maybe<Plan>;
  /** Create a new Subscription */
  createSubscription?: Maybe<Subscription>;
  /** Creates a tax */
  createTax?: Maybe<Tax>;
  /** Create a new webhook endpoint */
  createWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Deletes an add-on */
  destroyAddOn?: Maybe<DestroyAddOnPayload>;
  /** Deletes an adjusted fee */
  destroyAdjustedFee?: Maybe<DestroyAdjustedFeePayload>;
  /** Deletes a Billable metric */
  destroyBillableMetric?: Maybe<DestroyBillableMetricPayload>;
  /** Deletes a coupon */
  destroyCoupon?: Maybe<DestroyCouponPayload>;
  /** Delete a Customer */
  destroyCustomer?: Maybe<DestroyCustomerPayload>;
  /** Destroy an integration */
  destroyIntegration?: Maybe<DestroyIntegrationPayload>;
  /** Destroy an integration collection mapping */
  destroyIntegrationCollectionMapping?: Maybe<DestroyIntegrationCollectionMappingPayload>;
  /** Destroy an integration mapping */
  destroyIntegrationMapping?: Maybe<DestroyIntegrationMappingPayload>;
  /** Destroy a payment provider */
  destroyPaymentProvider?: Maybe<DestroyPaymentProviderPayload>;
  /** Deletes a Plan */
  destroyPlan?: Maybe<DestroyPlanPayload>;
  /** Deletes a tax */
  destroyTax?: Maybe<DestroyTaxPayload>;
  /** Deletes a webhook endpoint */
  destroyWebhookEndpoint?: Maybe<DestroyWebhookEndpointPayload>;
  /** Download a Credit Note PDF */
  downloadCreditNote?: Maybe<CreditNote>;
  /** Download customer portal invoice PDF */
  downloadCustomerPortalInvoice?: Maybe<Invoice>;
  /** Download an Invoice PDF */
  downloadInvoice?: Maybe<Invoice>;
  /** Fetch integration items */
  fetchIntegrationItems: IntegrationItemCollection;
  /** Fetch integration tax items */
  fetchIntegrationTaxItems: IntegrationItemCollection;
  /** Finalize a draft invoice */
  finalizeInvoice?: Maybe<Invoice>;
  /** Generate customer portal URL */
  generateCustomerPortalUrl?: Maybe<GenerateCustomerPortalUrlPayload>;
  /** Accepts a membership invite with Google Oauth */
  googleAcceptInvite?: Maybe<RegisterUser>;
  /** Opens a session for an existing user with Google Oauth */
  googleLoginUser?: Maybe<LoginUser>;
  /** Register a new user with Google Oauth */
  googleRegisterUser?: Maybe<RegisterUser>;
  /** Opens a session for an existing user */
  loginUser?: Maybe<LoginUser>;
  /** Mark payment dispute as lost */
  loseInvoiceDispute?: Maybe<Invoice>;
  /** Accepts a membership invite with Okta Oauth */
  oktaAcceptInvite?: Maybe<LoginUser>;
  oktaAuthorize?: Maybe<Authorize>;
  oktaLogin?: Maybe<LoginUser>;
  /** Refresh a draft invoice */
  refreshInvoice?: Maybe<Invoice>;
  /** Registers a new user and creates related organization */
  registerUser?: Maybe<RegisterUser>;
  /** Reset password for user and log in */
  resetPassword?: Maybe<LoginUser>;
  /** Retry all invoice payments */
  retryAllInvoicePayments?: Maybe<InvoiceCollection>;
  /** Retry invoice payment */
  retryInvoicePayment?: Maybe<Invoice>;
  /** Retry a Webhook */
  retryWebhook?: Maybe<Webhook>;
  /** Revokes a invite */
  revokeInvite?: Maybe<Invite>;
  /** Revoke a membership */
  revokeMembership?: Maybe<Membership>;
  /** Unassign a coupon from a customer */
  terminateAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Deletes a coupon */
  terminateCoupon?: Maybe<Coupon>;
  /** Terminates a new Customer Wallet */
  terminateCustomerWallet?: Maybe<Wallet>;
  /** Terminate a Subscription */
  terminateSubscription?: Maybe<Subscription>;
  /** Update an existing add-on */
  updateAddOn?: Maybe<AddOn>;
  /** Update Adyen payment provider */
  updateAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Updates an existing Billable metric */
  updateBillableMetric?: Maybe<BillableMetric>;
  /** Update an existing coupon */
  updateCoupon?: Maybe<Coupon>;
  /** Updates an existing Credit Note */
  updateCreditNote?: Maybe<CreditNote>;
  /** Updates an existing Customer */
  updateCustomer?: Maybe<Customer>;
  /** Assign the invoice grace period to Customers */
  updateCustomerInvoiceGracePeriod?: Maybe<Customer>;
  /** Updates a new Customer Wallet */
  updateCustomerWallet?: Maybe<Wallet>;
  /** Update Gocardless payment provider */
  updateGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Update integration mapping */
  updateIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Update integration mapping */
  updateIntegrationMapping?: Maybe<Mapping>;
  /** Update an existing invoice */
  updateInvoice?: Maybe<Invoice>;
  /** Update Netsuite integration */
  updateNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Update Okta integration */
  updateOktaIntegration?: Maybe<OktaIntegration>;
  /** Updates an Organization */
  updateOrganization?: Maybe<CurrentOrganization>;
  /** Updates an existing Plan */
  updatePlan?: Maybe<Plan>;
  /** Update Stripe payment provider */
  updateStripePaymentProvider?: Maybe<StripeProvider>;
  /** Update a Subscription */
  updateSubscription?: Maybe<Subscription>;
  /** Update an existing tax */
  updateTax?: Maybe<Tax>;
  /** Update a new webhook endpoint */
  updateWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Voids a Credit Note */
  voidCreditNote?: Maybe<CreditNote>;
  /** Void an invoice */
  voidInvoice?: Maybe<Invoice>;
};


export type MutationAcceptInviteArgs = {
  input: AcceptInviteInput;
};


export type MutationAddAdyenPaymentProviderArgs = {
  input: AddAdyenPaymentProviderInput;
};


export type MutationAddGocardlessPaymentProviderArgs = {
  input: AddGocardlessPaymentProviderInput;
};


export type MutationAddStripePaymentProviderArgs = {
  input: AddStripePaymentProviderInput;
};


export type MutationCreateAddOnArgs = {
  input: CreateAddOnInput;
};


export type MutationCreateAdjustedFeeArgs = {
  input: CreateAdjustedFeeInput;
};


export type MutationCreateAppliedCouponArgs = {
  input: CreateAppliedCouponInput;
};


export type MutationCreateBillableMetricArgs = {
  input: CreateBillableMetricInput;
};


export type MutationCreateCouponArgs = {
  input: CreateCouponInput;
};


export type MutationCreateCreditNoteArgs = {
  input: CreateCreditNoteInput;
};


export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


export type MutationCreateCustomerWalletArgs = {
  input: CreateCustomerWalletInput;
};


export type MutationCreateCustomerWalletTransactionArgs = {
  input: CreateCustomerWalletTransactionInput;
};


export type MutationCreateIntegrationCollectionMappingArgs = {
  input: CreateIntegrationCollectionMappingInput;
};


export type MutationCreateIntegrationMappingArgs = {
  input: CreateIntegrationMappingInput;
};


export type MutationCreateInviteArgs = {
  input: CreateInviteInput;
};


export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


export type MutationCreateNetsuiteIntegrationArgs = {
  input: CreateNetsuiteIntegrationInput;
};


export type MutationCreateOktaIntegrationArgs = {
  input: CreateOktaIntegrationInput;
};


export type MutationCreatePasswordResetArgs = {
  input: CreatePasswordResetInput;
};


export type MutationCreatePlanArgs = {
  input: CreatePlanInput;
};


export type MutationCreateSubscriptionArgs = {
  input: CreateSubscriptionInput;
};


export type MutationCreateTaxArgs = {
  input: TaxCreateInput;
};


export type MutationCreateWebhookEndpointArgs = {
  input: WebhookEndpointCreateInput;
};


export type MutationDestroyAddOnArgs = {
  input: DestroyAddOnInput;
};


export type MutationDestroyAdjustedFeeArgs = {
  input: DestroyAdjustedFeeInput;
};


export type MutationDestroyBillableMetricArgs = {
  input: DestroyBillableMetricInput;
};


export type MutationDestroyCouponArgs = {
  input: DestroyCouponInput;
};


export type MutationDestroyCustomerArgs = {
  input: DestroyCustomerInput;
};


export type MutationDestroyIntegrationArgs = {
  input: DestroyIntegrationInput;
};


export type MutationDestroyIntegrationCollectionMappingArgs = {
  input: DestroyIntegrationCollectionMappingInput;
};


export type MutationDestroyIntegrationMappingArgs = {
  input: DestroyIntegrationMappingInput;
};


export type MutationDestroyPaymentProviderArgs = {
  input: DestroyPaymentProviderInput;
};


export type MutationDestroyPlanArgs = {
  input: DestroyPlanInput;
};


export type MutationDestroyTaxArgs = {
  input: DestroyTaxInput;
};


export type MutationDestroyWebhookEndpointArgs = {
  input: DestroyWebhookEndpointInput;
};


export type MutationDownloadCreditNoteArgs = {
  input: DownloadCreditNoteInput;
};


export type MutationDownloadCustomerPortalInvoiceArgs = {
  input: DownloadCustomerPortalInvoiceInput;
};


export type MutationDownloadInvoiceArgs = {
  input: DownloadInvoiceInput;
};


export type MutationFetchIntegrationItemsArgs = {
  input: FetchIntegrationItemsInput;
};


export type MutationFetchIntegrationTaxItemsArgs = {
  input: FetchIntegrationTaxItemsInput;
};


export type MutationFinalizeInvoiceArgs = {
  input: FinalizeInvoiceInput;
};


export type MutationGenerateCustomerPortalUrlArgs = {
  input: GenerateCustomerPortalUrlInput;
};


export type MutationGoogleAcceptInviteArgs = {
  input: GoogleAcceptInviteInput;
};


export type MutationGoogleLoginUserArgs = {
  input: GoogleLoginUserInput;
};


export type MutationGoogleRegisterUserArgs = {
  input: GoogleRegisterUserInput;
};


export type MutationLoginUserArgs = {
  input: LoginUserInput;
};


export type MutationLoseInvoiceDisputeArgs = {
  input: LoseInvoiceDisputeInput;
};


export type MutationOktaAcceptInviteArgs = {
  input: OktaAcceptInviteInput;
};


export type MutationOktaAuthorizeArgs = {
  input: OktaAuthorizeInput;
};


export type MutationOktaLoginArgs = {
  input: OktaLoginInput;
};


export type MutationRefreshInvoiceArgs = {
  input: RefreshInvoiceInput;
};


export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


export type MutationRetryAllInvoicePaymentsArgs = {
  input: RetryAllInvoicePaymentsInput;
};


export type MutationRetryInvoicePaymentArgs = {
  input: RetryInvoicePaymentInput;
};


export type MutationRetryWebhookArgs = {
  input: RetryWebhookInput;
};


export type MutationRevokeInviteArgs = {
  input: RevokeInviteInput;
};


export type MutationRevokeMembershipArgs = {
  input: RevokeMembershipInput;
};


export type MutationTerminateAppliedCouponArgs = {
  input: TerminateAppliedCouponInput;
};


export type MutationTerminateCouponArgs = {
  input: TerminateCouponInput;
};


export type MutationTerminateCustomerWalletArgs = {
  input: TerminateCustomerWalletInput;
};


export type MutationTerminateSubscriptionArgs = {
  input: TerminateSubscriptionInput;
};


export type MutationUpdateAddOnArgs = {
  input: UpdateAddOnInput;
};


export type MutationUpdateAdyenPaymentProviderArgs = {
  input: UpdateAdyenPaymentProviderInput;
};


export type MutationUpdateBillableMetricArgs = {
  input: UpdateBillableMetricInput;
};


export type MutationUpdateCouponArgs = {
  input: UpdateCouponInput;
};


export type MutationUpdateCreditNoteArgs = {
  input: UpdateCreditNoteInput;
};


export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


export type MutationUpdateCustomerInvoiceGracePeriodArgs = {
  input: UpdateCustomerInvoiceGracePeriodInput;
};


export type MutationUpdateCustomerWalletArgs = {
  input: UpdateCustomerWalletInput;
};


export type MutationUpdateGocardlessPaymentProviderArgs = {
  input: UpdateGocardlessPaymentProviderInput;
};


export type MutationUpdateIntegrationCollectionMappingArgs = {
  input: UpdateIntegrationCollectionMappingInput;
};


export type MutationUpdateIntegrationMappingArgs = {
  input: UpdateIntegrationMappingInput;
};


export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


export type MutationUpdateNetsuiteIntegrationArgs = {
  input: UpdateNetsuiteIntegrationInput;
};


export type MutationUpdateOktaIntegrationArgs = {
  input: UpdateOktaIntegrationInput;
};


export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


export type MutationUpdatePlanArgs = {
  input: UpdatePlanInput;
};


export type MutationUpdateStripePaymentProviderArgs = {
  input: UpdateStripePaymentProviderInput;
};


export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


export type MutationUpdateTaxArgs = {
  input: TaxUpdateInput;
};


export type MutationUpdateWebhookEndpointArgs = {
  input: WebhookEndpointUpdateInput;
};


export type MutationVoidCreditNoteArgs = {
  input: VoidCreditNoteInput;
};


export type MutationVoidInvoiceArgs = {
  input: VoidInvoiceInput;
};

export type NetsuiteCustomer = {
  __typename?: 'NetsuiteCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  subsidiaryId?: Maybe<Scalars['String']['output']>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type NetsuiteIntegration = {
  __typename?: 'NetsuiteIntegration';
  accountId?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  scriptEndpointUrl?: Maybe<Scalars['String']['output']>;
  syncCreditNotes?: Maybe<Scalars['Boolean']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncPayments?: Maybe<Scalars['Boolean']['output']>;
  syncSalesOrders?: Maybe<Scalars['Boolean']['output']>;
};

/** Accept Invite with Okta Oauth input arguments */
export type OktaAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

/** Autogenerated input type of OktaAuthorize */
export type OktaAuthorizeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  inviteToken?: InputMaybe<Scalars['String']['input']>;
};

export type OktaIntegration = {
  __typename?: 'OktaIntegration';
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  domain: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organizationName: Scalars['String']['output'];
};

/** Autogenerated input type of OktaLogin */
export type OktaLoginInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

/** Safe Organization Type */
export type Organization = {
  __typename?: 'Organization';
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  defaultCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  timezone?: Maybe<TimezoneEnum>;
};

export type OrganizationBillingConfiguration = {
  __typename?: 'OrganizationBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceFooter?: Maybe<Scalars['String']['output']>;
  invoiceGracePeriod: Scalars['Int']['output'];
  vatRate: Scalars['Float']['output'];
};

export type OrganizationBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  invoiceFooter?: InputMaybe<Scalars['String']['input']>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentProvider = AdyenProvider | GocardlessProvider | StripeProvider;

export type PaymentProviderCollection = {
  __typename?: 'PaymentProviderCollection';
  collection: Array<PaymentProvider>;
  metadata: CollectionMetadata;
};

/** Permissions Type */
export type Permissions = {
  __typename?: 'Permissions';
  addonsCreate: Scalars['Boolean']['output'];
  addonsDelete: Scalars['Boolean']['output'];
  addonsUpdate: Scalars['Boolean']['output'];
  addonsView: Scalars['Boolean']['output'];
  analyticsView: Scalars['Boolean']['output'];
  billableMetricsCreate: Scalars['Boolean']['output'];
  billableMetricsDelete: Scalars['Boolean']['output'];
  billableMetricsUpdate: Scalars['Boolean']['output'];
  billableMetricsView: Scalars['Boolean']['output'];
  couponsAttach: Scalars['Boolean']['output'];
  couponsCreate: Scalars['Boolean']['output'];
  couponsDelete: Scalars['Boolean']['output'];
  couponsDetach: Scalars['Boolean']['output'];
  couponsUpdate: Scalars['Boolean']['output'];
  couponsView: Scalars['Boolean']['output'];
  creditNotesCreate: Scalars['Boolean']['output'];
  creditNotesUpdate: Scalars['Boolean']['output'];
  creditNotesView: Scalars['Boolean']['output'];
  creditNotesVoid: Scalars['Boolean']['output'];
  customerSettingsUpdateGracePeriod: Scalars['Boolean']['output'];
  customerSettingsUpdateLang: Scalars['Boolean']['output'];
  customerSettingsUpdatePaymentTerms: Scalars['Boolean']['output'];
  customerSettingsUpdateTaxRates: Scalars['Boolean']['output'];
  customerSettingsView: Scalars['Boolean']['output'];
  customersCreate: Scalars['Boolean']['output'];
  customersDelete: Scalars['Boolean']['output'];
  customersUpdate: Scalars['Boolean']['output'];
  customersView: Scalars['Boolean']['output'];
  developersKeysManage: Scalars['Boolean']['output'];
  developersManage: Scalars['Boolean']['output'];
  draftInvoicesUpdate: Scalars['Boolean']['output'];
  invoicesCreate: Scalars['Boolean']['output'];
  invoicesSend: Scalars['Boolean']['output'];
  invoicesUpdate: Scalars['Boolean']['output'];
  invoicesView: Scalars['Boolean']['output'];
  invoicesVoid: Scalars['Boolean']['output'];
  organizationEmailsUpdate: Scalars['Boolean']['output'];
  organizationEmailsView: Scalars['Boolean']['output'];
  organizationIntegrationsCreate: Scalars['Boolean']['output'];
  organizationIntegrationsDelete: Scalars['Boolean']['output'];
  organizationIntegrationsUpdate: Scalars['Boolean']['output'];
  organizationIntegrationsView: Scalars['Boolean']['output'];
  organizationInvoicesUpdate: Scalars['Boolean']['output'];
  organizationInvoicesView: Scalars['Boolean']['output'];
  organizationMembersCreate: Scalars['Boolean']['output'];
  organizationMembersDelete: Scalars['Boolean']['output'];
  organizationMembersUpdate: Scalars['Boolean']['output'];
  organizationMembersView: Scalars['Boolean']['output'];
  organizationTaxesUpdate: Scalars['Boolean']['output'];
  organizationTaxesView: Scalars['Boolean']['output'];
  organizationUpdate: Scalars['Boolean']['output'];
  organizationView: Scalars['Boolean']['output'];
  plansCreate: Scalars['Boolean']['output'];
  plansDelete: Scalars['Boolean']['output'];
  plansUpdate: Scalars['Boolean']['output'];
  plansView: Scalars['Boolean']['output'];
  subscriptionsCreate: Scalars['Boolean']['output'];
  subscriptionsDelete: Scalars['Boolean']['output'];
  subscriptionsUpdate: Scalars['Boolean']['output'];
  subscriptionsView: Scalars['Boolean']['output'];
  walletsCreate: Scalars['Boolean']['output'];
  walletsTerminate: Scalars['Boolean']['output'];
  walletsTopUp: Scalars['Boolean']['output'];
  walletsUpdate: Scalars['Boolean']['output'];
};

export type Plan = {
  __typename?: 'Plan';
  activeSubscriptionsCount: Scalars['Int']['output'];
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: Maybe<Scalars['Boolean']['output']>;
  charges?: Maybe<Array<Charge>>;
  /** Number of charges attached to a plan */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers attached to a plan */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  draftInvoicesCount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  interval: PlanInterval;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  minimumCommitment?: Maybe<Commitment>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  parent?: Maybe<Plan>;
  payInAdvance: Scalars['Boolean']['output'];
  subscriptionsCount: Scalars['Int']['output'];
  taxes?: Maybe<Array<Tax>>;
  trialPeriod?: Maybe<Scalars['Float']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type PlanCollection = {
  __typename?: 'PlanCollection';
  collection: Array<Plan>;
  metadata: CollectionMetadata;
};

export enum PlanInterval {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export type PlanOverridesInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  charges?: InputMaybe<Array<ChargeOverridesInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
};

export type Properties = {
  __typename?: 'Properties';
  amount?: Maybe<Scalars['String']['output']>;
  customProperties?: Maybe<Scalars['JSON']['output']>;
  fixedAmount?: Maybe<Scalars['String']['output']>;
  freeUnits?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerEvents?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerTotalAggregation?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<GraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<GraduatedRange>>;
  groupedBy?: Maybe<Array<Scalars['String']['output']>>;
  packageSize?: Maybe<Scalars['BigInt']['output']>;
  perTransactionMaxAmount?: Maybe<Scalars['String']['output']>;
  perTransactionMinAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  volumeRanges?: Maybe<Array<VolumeRange>>;
};

export type PropertiesInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  customProperties?: InputMaybe<Scalars['JSON']['input']>;
  fixedAmount?: InputMaybe<Scalars['String']['input']>;
  freeUnits?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerEvents?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerTotalAggregation?: InputMaybe<Scalars['String']['input']>;
  graduatedPercentageRanges?: InputMaybe<Array<GraduatedPercentageRangeInput>>;
  graduatedRanges?: InputMaybe<Array<GraduatedRangeInput>>;
  groupedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  packageSize?: InputMaybe<Scalars['BigInt']['input']>;
  perTransactionMaxAmount?: InputMaybe<Scalars['String']['input']>;
  perTransactionMinAmount?: InputMaybe<Scalars['String']['input']>;
  rate?: InputMaybe<Scalars['String']['input']>;
  volumeRanges?: InputMaybe<Array<VolumeRangeInput>>;
};

export type ProviderCustomer = {
  __typename?: 'ProviderCustomer';
  id: Scalars['ID']['output'];
  providerCustomerId?: Maybe<Scalars['ID']['output']>;
  providerPaymentMethods?: Maybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type ProviderCustomerInput = {
  providerCustomerId?: InputMaybe<Scalars['ID']['input']>;
  providerPaymentMethods?: InputMaybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ProviderPaymentMethodsEnum {
  BacsDebit = 'bacs_debit',
  Card = 'card',
  SepaDebit = 'sepa_debit',
  UsBankAccount = 'us_bank_account'
}

export enum ProviderTypeEnum {
  Adyen = 'adyen',
  Gocardless = 'gocardless',
  Stripe = 'stripe'
}

export type Query = {
  __typename?: 'Query';
  /** Query a single add-on of an organization */
  addOn?: Maybe<AddOn>;
  /** Query add-ons of an organization */
  addOns: AddOnCollection;
  /** Query a single billable metric of an organization */
  billableMetric?: Maybe<BillableMetric>;
  /** Query billable metrics of an organization */
  billableMetrics: BillableMetricCollection;
  /** Query a single coupon of an organization */
  coupon?: Maybe<Coupon>;
  /** Query coupons of an organization */
  coupons: CouponCollection;
  /** Query a single credit note */
  creditNote?: Maybe<CreditNote>;
  /** Fetch amounts for credit note creation */
  creditNoteEstimate: CreditNoteEstimate;
  /** Retrieves currently connected user */
  currentUser: User;
  /** Retrieve the version of the application */
  currentVersion: CurrentVersion;
  /** Query a single customer of an organization */
  customer?: Maybe<Customer>;
  /** Query customer's credit note */
  customerCreditNotes?: Maybe<CreditNoteCollection>;
  /** Query invoices of a customer */
  customerInvoices: InvoiceCollection;
  /** Query invoices of a customer */
  customerPortalInvoices: InvoiceCollection;
  /** Query customer portal organization */
  customerPortalOrganization?: Maybe<Organization>;
  /** Query a customer portal user */
  customerPortalUser?: Maybe<Customer>;
  /** Query the usage of the customer on the current billing period */
  customerUsage: CustomerUsage;
  /** Query customers of an organization */
  customers: CustomerCollection;
  /** Query events of an organization */
  events?: Maybe<EventCollection>;
  /** Get Google auth url. */
  googleAuthUrl: AuthUrl;
  /** Query gross revenue of an organization */
  grossRevenues: GrossRevenueCollection;
  /** Query a single integration */
  integration?: Maybe<Integration>;
  /** Query a single integration collection mapping */
  integrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Query integration collection mappings */
  integrationCollectionMappings?: Maybe<CollectionMappingCollection>;
  /** Query integration items of an integration */
  integrationItems: IntegrationItemCollection;
  /** Query a single integration mapping */
  integrationMapping?: Maybe<Mapping>;
  /** Query netsuite integration mappings */
  integrationMappings?: Maybe<MappingCollection>;
  /** Query integration subsidiaries */
  integrationSubsidiaries?: Maybe<SubsidiaryCollection>;
  /** Query organization's integrations */
  integrations?: Maybe<IntegrationCollection>;
  /** Query a single Invite */
  invite?: Maybe<Invite>;
  /** Query pending invites of an organization */
  invites: InviteCollection;
  /** Query a single Invoice of an organization */
  invoice?: Maybe<Invoice>;
  /** Query invoice collections of an organization */
  invoiceCollections: FinalizedInvoiceCollectionCollection;
  /** Query invoice's credit note */
  invoiceCreditNotes?: Maybe<CreditNoteCollection>;
  /** Query invoiced usage of an organization */
  invoicedUsages: InvoicedUsageCollection;
  /** Query invoices */
  invoices: InvoiceCollection;
  /** Query memberships of an organization */
  memberships: MembershipCollection;
  /** Query MRR of an organization */
  mrrs: MrrCollection;
  /** Query the current organization */
  organization?: Maybe<CurrentOrganization>;
  /** Query a password reset by token */
  passwordReset: ResetPassword;
  /** Query a single payment provider */
  paymentProvider?: Maybe<PaymentProvider>;
  /** Query organization's payment providers */
  paymentProviders?: Maybe<PaymentProviderCollection>;
  /** Query a single plan of an organization */
  plan?: Maybe<Plan>;
  /** Query plans of an organization */
  plans: PlanCollection;
  /** Query a single subscription of an organization */
  subscription?: Maybe<Subscription>;
  /** Query subscriptions of an organization */
  subscriptions: SubscriptionCollection;
  /** Query a single tax of an organization */
  tax?: Maybe<Tax>;
  /** Query taxes of an organization */
  taxes: TaxCollection;
  /** Query a single wallet of an organization */
  wallet?: Maybe<Wallet>;
  /** Query wallet transactions */
  walletTransactions: WalletTransactionCollection;
  /** Query wallets */
  wallets: WalletCollection;
  /** Query a single webhook endpoint */
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Query webhook endpoints of an organization */
  webhookEndpoints: WebhookEndpointCollection;
  /** Query Webhooks */
  webhooks: WebhookCollection;
};


export type QueryAddOnArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAddOnsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryBillableMetricArgs = {
  id: Scalars['ID']['input'];
};


export type QueryBillableMetricsArgs = {
  aggregationTypes?: InputMaybe<Array<AggregationTypeEnum>>;
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCouponArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCouponsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
};


export type QueryCreditNoteArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCreditNoteEstimateArgs = {
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
};


export type QueryCustomerArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCustomerCreditNotesArgs = {
  customerId: Scalars['ID']['input'];
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomerInvoicesArgs = {
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerPortalInvoicesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerUsageArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomersArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryEventsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGrossRevenuesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryIntegrationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationCollectionMappingArgs = {
  id: Scalars['ID']['input'];
};


export type QueryIntegrationCollectionMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  mappingType?: InputMaybe<MappingTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationItemsArgs = {
  integrationId: Scalars['ID']['input'];
  itemType?: InputMaybe<IntegrationItemTypeEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryIntegrationMappingArgs = {
  id: Scalars['ID']['input'];
};


export type QueryIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  mappableType?: InputMaybe<MappableTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationSubsidiariesArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
};


export type QueryInviteArgs = {
  token: Scalars['String']['input'];
};


export type QueryInvitesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoiceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryInvoiceCollectionsArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryInvoiceCreditNotesArgs = {
  invoiceId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoicedUsagesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryInvoicesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<InvoiceStatusTypeEnum>;
};


export type QueryMembershipsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMrrsArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryPasswordResetArgs = {
  token: Scalars['String']['input'];
};


export type QueryPaymentProviderArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentProvidersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
};


export type QueryPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPlansArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySubscriptionArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySubscriptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum>>;
};


export type QueryTaxArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWalletArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWalletTransactionsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletTransactionStatusEnum>;
  transactionType?: InputMaybe<WalletTransactionTransactionTypeEnum>;
  walletId: Scalars['ID']['input'];
};


export type QueryWalletsArgs = {
  customerId: Scalars['ID']['input'];
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletStatusEnum>;
};


export type QueryWebhookEndpointArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookEndpointsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWebhooksArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<WebhookStatusEnum>;
  webhookEndpointId: Scalars['String']['input'];
};

export enum RecurringTransactionIntervalEnum {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export type RecurringTransactionRule = {
  __typename?: 'RecurringTransactionRule';
  createdAt: Scalars['ISO8601DateTime']['output'];
  grantedCredits: Scalars['String']['output'];
  interval?: Maybe<RecurringTransactionIntervalEnum>;
  lagoId: Scalars['ID']['output'];
  paidCredits: Scalars['String']['output'];
  thresholdCredits?: Maybe<Scalars['String']['output']>;
  trigger: RecurringTransactionTriggerEnum;
};

export enum RecurringTransactionTriggerEnum {
  Interval = 'interval',
  Threshold = 'threshold'
}

/** Autogenerated input type of RefreshInvoice */
export type RefreshInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type RegisterUser = {
  __typename?: 'RegisterUser';
  membership: Membership;
  organization: Organization;
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of RegisterUser */
export type RegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** ResetPassword type */
export type ResetPassword = {
  __typename?: 'ResetPassword';
  expireAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of ResetPassword */
export type ResetPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

/** Autogenerated input type of RetryAllInvoicePayments */
export type RetryAllInvoicePaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RetryInvoicePayment */
export type RetryInvoicePaymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryWebhook */
export type RetryWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeInvite */
export type RevokeInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeMembership */
export type RevokeMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum StatusTypeEnum {
  Active = 'active',
  Canceled = 'canceled',
  Pending = 'pending',
  Terminated = 'terminated'
}

export type StripeProvider = {
  __typename?: 'StripeProvider';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  secretKey?: Maybe<Scalars['String']['output']>;
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  billingTime?: Maybe<BillingTimeEnum>;
  canceledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  customer: Customer;
  endingAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalId: Scalars['String']['output'];
  fees?: Maybe<Array<Fee>>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextName?: Maybe<Scalars['String']['output']>;
  nextPendingStartDate?: Maybe<Scalars['ISO8601Date']['output']>;
  nextPlan?: Maybe<Plan>;
  nextSubscription?: Maybe<Subscription>;
  periodEndDate?: Maybe<Scalars['ISO8601Date']['output']>;
  plan: Plan;
  startedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status?: Maybe<StatusTypeEnum>;
  subscriptionAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type SubscriptionCollection = {
  __typename?: 'SubscriptionCollection';
  collection: Array<Subscription>;
  metadata: CollectionMetadata;
};

export type Subsidiary = {
  __typename?: 'Subsidiary';
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
};

export type SubsidiaryCollection = {
  __typename?: 'SubsidiaryCollection';
  collection: Array<Subsidiary>;
  metadata: CollectionMetadata;
};

export type Tax = {
  __typename?: 'Tax';
  /** Number of add ons using this tax */
  addOnsCount: Scalars['Int']['output'];
  appliedToOrganization: Scalars['Boolean']['output'];
  autoGenerated: Scalars['Boolean']['output'];
  /** Number of charges using this tax */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this tax */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  /** Number of plans using this tax */
  plansCount: Scalars['Int']['output'];
  rate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type TaxCollection = {
  __typename?: 'TaxCollection';
  collection: Array<Tax>;
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateTax */
export type TaxCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  rate: Scalars['Float']['input'];
};

/** Autogenerated input type of UpdateTax */
export type TaxUpdateInput = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  rate?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of TerminateAppliedCoupon */
export type TerminateAppliedCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCoupon */
export type TerminateCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCustomerWallet */
export type TerminateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateSubscription */
export type TerminateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum TimezoneEnum {
  /** Africa/Algiers */
  TzAfricaAlgiers = 'TZ_AFRICA_ALGIERS',
  /** Africa/Cairo */
  TzAfricaCairo = 'TZ_AFRICA_CAIRO',
  /** Africa/Casablanca */
  TzAfricaCasablanca = 'TZ_AFRICA_CASABLANCA',
  /** Africa/Harare */
  TzAfricaHarare = 'TZ_AFRICA_HARARE',
  /** Africa/Johannesburg */
  TzAfricaJohannesburg = 'TZ_AFRICA_JOHANNESBURG',
  /** Africa/Monrovia */
  TzAfricaMonrovia = 'TZ_AFRICA_MONROVIA',
  /** Africa/Nairobi */
  TzAfricaNairobi = 'TZ_AFRICA_NAIROBI',
  /** America/Argentina/Buenos_Aires */
  TzAmericaArgentinaBuenosAires = 'TZ_AMERICA_ARGENTINA_BUENOS_AIRES',
  /** America/Bogota */
  TzAmericaBogota = 'TZ_AMERICA_BOGOTA',
  /** America/Caracas */
  TzAmericaCaracas = 'TZ_AMERICA_CARACAS',
  /** America/Chicago */
  TzAmericaChicago = 'TZ_AMERICA_CHICAGO',
  /** America/Chihuahua */
  TzAmericaChihuahua = 'TZ_AMERICA_CHIHUAHUA',
  /** America/Denver */
  TzAmericaDenver = 'TZ_AMERICA_DENVER',
  /** America/Godthab */
  TzAmericaGodthab = 'TZ_AMERICA_GODTHAB',
  /** America/Guatemala */
  TzAmericaGuatemala = 'TZ_AMERICA_GUATEMALA',
  /** America/Guyana */
  TzAmericaGuyana = 'TZ_AMERICA_GUYANA',
  /** America/Halifax */
  TzAmericaHalifax = 'TZ_AMERICA_HALIFAX',
  /** America/Indiana/Indianapolis */
  TzAmericaIndianaIndianapolis = 'TZ_AMERICA_INDIANA_INDIANAPOLIS',
  /** America/Juneau */
  TzAmericaJuneau = 'TZ_AMERICA_JUNEAU',
  /** America/La_Paz */
  TzAmericaLaPaz = 'TZ_AMERICA_LA_PAZ',
  /** America/Lima */
  TzAmericaLima = 'TZ_AMERICA_LIMA',
  /** America/Los_Angeles */
  TzAmericaLosAngeles = 'TZ_AMERICA_LOS_ANGELES',
  /** America/Mazatlan */
  TzAmericaMazatlan = 'TZ_AMERICA_MAZATLAN',
  /** America/Mexico_City */
  TzAmericaMexicoCity = 'TZ_AMERICA_MEXICO_CITY',
  /** America/Monterrey */
  TzAmericaMonterrey = 'TZ_AMERICA_MONTERREY',
  /** America/Montevideo */
  TzAmericaMontevideo = 'TZ_AMERICA_MONTEVIDEO',
  /** America/New_York */
  TzAmericaNewYork = 'TZ_AMERICA_NEW_YORK',
  /** America/Phoenix */
  TzAmericaPhoenix = 'TZ_AMERICA_PHOENIX',
  /** America/Puerto_Rico */
  TzAmericaPuertoRico = 'TZ_AMERICA_PUERTO_RICO',
  /** America/Regina */
  TzAmericaRegina = 'TZ_AMERICA_REGINA',
  /** America/Santiago */
  TzAmericaSantiago = 'TZ_AMERICA_SANTIAGO',
  /** America/Sao_Paulo */
  TzAmericaSaoPaulo = 'TZ_AMERICA_SAO_PAULO',
  /** America/St_Johns */
  TzAmericaStJohns = 'TZ_AMERICA_ST_JOHNS',
  /** America/Tijuana */
  TzAmericaTijuana = 'TZ_AMERICA_TIJUANA',
  /** Asia/Almaty */
  TzAsiaAlmaty = 'TZ_ASIA_ALMATY',
  /** Asia/Baghdad */
  TzAsiaBaghdad = 'TZ_ASIA_BAGHDAD',
  /** Asia/Baku */
  TzAsiaBaku = 'TZ_ASIA_BAKU',
  /** Asia/Bangkok */
  TzAsiaBangkok = 'TZ_ASIA_BANGKOK',
  /** Asia/Chongqing */
  TzAsiaChongqing = 'TZ_ASIA_CHONGQING',
  /** Asia/Colombo */
  TzAsiaColombo = 'TZ_ASIA_COLOMBO',
  /** Asia/Dhaka */
  TzAsiaDhaka = 'TZ_ASIA_DHAKA',
  /** Asia/Hong_Kong */
  TzAsiaHongKong = 'TZ_ASIA_HONG_KONG',
  /** Asia/Irkutsk */
  TzAsiaIrkutsk = 'TZ_ASIA_IRKUTSK',
  /** Asia/Jakarta */
  TzAsiaJakarta = 'TZ_ASIA_JAKARTA',
  /** Asia/Jerusalem */
  TzAsiaJerusalem = 'TZ_ASIA_JERUSALEM',
  /** Asia/Kabul */
  TzAsiaKabul = 'TZ_ASIA_KABUL',
  /** Asia/Kamchatka */
  TzAsiaKamchatka = 'TZ_ASIA_KAMCHATKA',
  /** Asia/Karachi */
  TzAsiaKarachi = 'TZ_ASIA_KARACHI',
  /** Asia/Kathmandu */
  TzAsiaKathmandu = 'TZ_ASIA_KATHMANDU',
  /** Asia/Kolkata */
  TzAsiaKolkata = 'TZ_ASIA_KOLKATA',
  /** Asia/Krasnoyarsk */
  TzAsiaKrasnoyarsk = 'TZ_ASIA_KRASNOYARSK',
  /** Asia/Kuala_Lumpur */
  TzAsiaKualaLumpur = 'TZ_ASIA_KUALA_LUMPUR',
  /** Asia/Kuwait */
  TzAsiaKuwait = 'TZ_ASIA_KUWAIT',
  /** Asia/Magadan */
  TzAsiaMagadan = 'TZ_ASIA_MAGADAN',
  /** Asia/Muscat */
  TzAsiaMuscat = 'TZ_ASIA_MUSCAT',
  /** Asia/Novosibirsk */
  TzAsiaNovosibirsk = 'TZ_ASIA_NOVOSIBIRSK',
  /** Asia/Rangoon */
  TzAsiaRangoon = 'TZ_ASIA_RANGOON',
  /** Asia/Riyadh */
  TzAsiaRiyadh = 'TZ_ASIA_RIYADH',
  /** Asia/Seoul */
  TzAsiaSeoul = 'TZ_ASIA_SEOUL',
  /** Asia/Shanghai */
  TzAsiaShanghai = 'TZ_ASIA_SHANGHAI',
  /** Asia/Singapore */
  TzAsiaSingapore = 'TZ_ASIA_SINGAPORE',
  /** Asia/Srednekolymsk */
  TzAsiaSrednekolymsk = 'TZ_ASIA_SREDNEKOLYMSK',
  /** Asia/Taipei */
  TzAsiaTaipei = 'TZ_ASIA_TAIPEI',
  /** Asia/Tashkent */
  TzAsiaTashkent = 'TZ_ASIA_TASHKENT',
  /** Asia/Tbilisi */
  TzAsiaTbilisi = 'TZ_ASIA_TBILISI',
  /** Asia/Tehran */
  TzAsiaTehran = 'TZ_ASIA_TEHRAN',
  /** Asia/Tokyo */
  TzAsiaTokyo = 'TZ_ASIA_TOKYO',
  /** Asia/Ulaanbaatar */
  TzAsiaUlaanbaatar = 'TZ_ASIA_ULAANBAATAR',
  /** Asia/Urumqi */
  TzAsiaUrumqi = 'TZ_ASIA_URUMQI',
  /** Asia/Vladivostok */
  TzAsiaVladivostok = 'TZ_ASIA_VLADIVOSTOK',
  /** Asia/Yakutsk */
  TzAsiaYakutsk = 'TZ_ASIA_YAKUTSK',
  /** Asia/Yekaterinburg */
  TzAsiaYekaterinburg = 'TZ_ASIA_YEKATERINBURG',
  /** Asia/Yerevan */
  TzAsiaYerevan = 'TZ_ASIA_YEREVAN',
  /** Atlantic/Azores */
  TzAtlanticAzores = 'TZ_ATLANTIC_AZORES',
  /** Atlantic/Cape_Verde */
  TzAtlanticCapeVerde = 'TZ_ATLANTIC_CAPE_VERDE',
  /** Atlantic/South_Georgia */
  TzAtlanticSouthGeorgia = 'TZ_ATLANTIC_SOUTH_GEORGIA',
  /** Australia/Adelaide */
  TzAustraliaAdelaide = 'TZ_AUSTRALIA_ADELAIDE',
  /** Australia/Brisbane */
  TzAustraliaBrisbane = 'TZ_AUSTRALIA_BRISBANE',
  /** Australia/Darwin */
  TzAustraliaDarwin = 'TZ_AUSTRALIA_DARWIN',
  /** Australia/Hobart */
  TzAustraliaHobart = 'TZ_AUSTRALIA_HOBART',
  /** Australia/Melbourne */
  TzAustraliaMelbourne = 'TZ_AUSTRALIA_MELBOURNE',
  /** Australia/Perth */
  TzAustraliaPerth = 'TZ_AUSTRALIA_PERTH',
  /** Australia/Sydney */
  TzAustraliaSydney = 'TZ_AUSTRALIA_SYDNEY',
  /** Etc/GMT+12 */
  TzEtcGmt_12 = 'TZ_ETC_GMT_12',
  /** Europe/Amsterdam */
  TzEuropeAmsterdam = 'TZ_EUROPE_AMSTERDAM',
  /** Europe/Athens */
  TzEuropeAthens = 'TZ_EUROPE_ATHENS',
  /** Europe/Belgrade */
  TzEuropeBelgrade = 'TZ_EUROPE_BELGRADE',
  /** Europe/Berlin */
  TzEuropeBerlin = 'TZ_EUROPE_BERLIN',
  /** Europe/Bratislava */
  TzEuropeBratislava = 'TZ_EUROPE_BRATISLAVA',
  /** Europe/Brussels */
  TzEuropeBrussels = 'TZ_EUROPE_BRUSSELS',
  /** Europe/Bucharest */
  TzEuropeBucharest = 'TZ_EUROPE_BUCHAREST',
  /** Europe/Budapest */
  TzEuropeBudapest = 'TZ_EUROPE_BUDAPEST',
  /** Europe/Copenhagen */
  TzEuropeCopenhagen = 'TZ_EUROPE_COPENHAGEN',
  /** Europe/Dublin */
  TzEuropeDublin = 'TZ_EUROPE_DUBLIN',
  /** Europe/Helsinki */
  TzEuropeHelsinki = 'TZ_EUROPE_HELSINKI',
  /** Europe/Istanbul */
  TzEuropeIstanbul = 'TZ_EUROPE_ISTANBUL',
  /** Europe/Kaliningrad */
  TzEuropeKaliningrad = 'TZ_EUROPE_KALININGRAD',
  /** Europe/Kiev */
  TzEuropeKiev = 'TZ_EUROPE_KIEV',
  /** Europe/Lisbon */
  TzEuropeLisbon = 'TZ_EUROPE_LISBON',
  /** Europe/Ljubljana */
  TzEuropeLjubljana = 'TZ_EUROPE_LJUBLJANA',
  /** Europe/London */
  TzEuropeLondon = 'TZ_EUROPE_LONDON',
  /** Europe/Madrid */
  TzEuropeMadrid = 'TZ_EUROPE_MADRID',
  /** Europe/Minsk */
  TzEuropeMinsk = 'TZ_EUROPE_MINSK',
  /** Europe/Moscow */
  TzEuropeMoscow = 'TZ_EUROPE_MOSCOW',
  /** Europe/Paris */
  TzEuropeParis = 'TZ_EUROPE_PARIS',
  /** Europe/Prague */
  TzEuropePrague = 'TZ_EUROPE_PRAGUE',
  /** Europe/Riga */
  TzEuropeRiga = 'TZ_EUROPE_RIGA',
  /** Europe/Rome */
  TzEuropeRome = 'TZ_EUROPE_ROME',
  /** Europe/Samara */
  TzEuropeSamara = 'TZ_EUROPE_SAMARA',
  /** Europe/Sarajevo */
  TzEuropeSarajevo = 'TZ_EUROPE_SARAJEVO',
  /** Europe/Skopje */
  TzEuropeSkopje = 'TZ_EUROPE_SKOPJE',
  /** Europe/Sofia */
  TzEuropeSofia = 'TZ_EUROPE_SOFIA',
  /** Europe/Stockholm */
  TzEuropeStockholm = 'TZ_EUROPE_STOCKHOLM',
  /** Europe/Tallinn */
  TzEuropeTallinn = 'TZ_EUROPE_TALLINN',
  /** Europe/Vienna */
  TzEuropeVienna = 'TZ_EUROPE_VIENNA',
  /** Europe/Vilnius */
  TzEuropeVilnius = 'TZ_EUROPE_VILNIUS',
  /** Europe/Volgograd */
  TzEuropeVolgograd = 'TZ_EUROPE_VOLGOGRAD',
  /** Europe/Warsaw */
  TzEuropeWarsaw = 'TZ_EUROPE_WARSAW',
  /** Europe/Zagreb */
  TzEuropeZagreb = 'TZ_EUROPE_ZAGREB',
  /** Europe/Zurich */
  TzEuropeZurich = 'TZ_EUROPE_ZURICH',
  /** Pacific/Apia */
  TzPacificApia = 'TZ_PACIFIC_APIA',
  /** Pacific/Auckland */
  TzPacificAuckland = 'TZ_PACIFIC_AUCKLAND',
  /** Pacific/Chatham */
  TzPacificChatham = 'TZ_PACIFIC_CHATHAM',
  /** Pacific/Fakaofo */
  TzPacificFakaofo = 'TZ_PACIFIC_FAKAOFO',
  /** Pacific/Fiji */
  TzPacificFiji = 'TZ_PACIFIC_FIJI',
  /** Pacific/Guadalcanal */
  TzPacificGuadalcanal = 'TZ_PACIFIC_GUADALCANAL',
  /** Pacific/Guam */
  TzPacificGuam = 'TZ_PACIFIC_GUAM',
  /** Pacific/Honolulu */
  TzPacificHonolulu = 'TZ_PACIFIC_HONOLULU',
  /** Pacific/Majuro */
  TzPacificMajuro = 'TZ_PACIFIC_MAJURO',
  /** Pacific/Midway */
  TzPacificMidway = 'TZ_PACIFIC_MIDWAY',
  /** Pacific/Noumea */
  TzPacificNoumea = 'TZ_PACIFIC_NOUMEA',
  /** Pacific/Pago_Pago */
  TzPacificPagoPago = 'TZ_PACIFIC_PAGO_PAGO',
  /** Pacific/Port_Moresby */
  TzPacificPortMoresby = 'TZ_PACIFIC_PORT_MORESBY',
  /** Pacific/Tongatapu */
  TzPacificTongatapu = 'TZ_PACIFIC_TONGATAPU',
  /** UTC */
  TzUtc = 'TZ_UTC'
}

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Update input arguments */
export type UpdateAdyenPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Update Billable metric input arguments */
export type UpdateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  group?: InputMaybe<Scalars['JSON']['input']>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Autogenerated input type of UpdateCoupon */
export type UpdateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateCreditNote */
export type UpdateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  refundStatus: CreditNoteRefundStatusEnum;
};

/** Update Customer input arguments */
export type UpdateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationCustomer?: InputMaybe<IntegrationCustomerInput>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name: Scalars['String']['input'];
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateCustomerInvoiceGracePeriod */
export type UpdateCustomerInvoiceGracePeriodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

/** Update Wallet Input */
export type UpdateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  recurringTransactionRules?: InputMaybe<Array<UpdateRecurringTransactionRuleInput>>;
};

/** Update input arguments */
export type UpdateGocardlessPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateIntegrationCollectionMapping */
export type UpdateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappingType?: InputMaybe<MappingTypeEnum>;
};

/** Autogenerated input type of UpdateIntegrationMapping */
export type UpdateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappableId?: InputMaybe<Scalars['ID']['input']>;
  mappableType?: InputMaybe<MappableTypeEnum>;
};

/** Update Invoice input arguments */
export type UpdateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<Array<InvoiceMetadataInput>>;
  paymentStatus?: InputMaybe<InvoicePaymentStatusTypeEnum>;
};

/** Autogenerated input type of UpdateNetsuiteIntegration */
export type UpdateNetsuiteIntegrationInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  scriptEndpointUrl?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  syncSalesOrders?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateOktaIntegration */
export type UpdateOktaIntegrationInput = {
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  domain?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  organizationName?: InputMaybe<Scalars['String']['input']>;
};

/** Update Organization input arguments */
export type UpdateOrganizationInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<OrganizationBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  defaultCurrency?: InputMaybe<CurrencyEnum>;
  documentNumberPrefix?: InputMaybe<Scalars['String']['input']>;
  documentNumbering?: InputMaybe<DocumentNumberingEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<Array<EmailSettingsEnum>>;
  euTaxManagement?: InputMaybe<Scalars['Boolean']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  webhookUrl?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdatePlan */
export type UpdatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
};

export type UpdateRecurringTransactionRuleInput = {
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  lagoId?: InputMaybe<Scalars['ID']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  trigger?: InputMaybe<RecurringTransactionTriggerEnum>;
};

/** Update input arguments */
export type UpdateStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Update Subscription input arguments */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  memberships: Array<Membership>;
  organizations: Array<Organization>;
  premium: Scalars['Boolean']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of VoidCreditNote */
export type VoidCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of VoidInvoice */
export type VoidInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type VolumeRange = {
  __typename?: 'VolumeRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type VolumeRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Wallet */
export type Wallet = {
  __typename?: 'Wallet';
  balanceCents: Scalars['BigInt']['output'];
  consumedAmountCents: Scalars['BigInt']['output'];
  consumedCredits: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditsBalance: Scalars['Float']['output'];
  creditsOngoingBalance: Scalars['Float']['output'];
  creditsOngoingUsageBalance: Scalars['Float']['output'];
  currency: CurrencyEnum;
  customer?: Maybe<Customer>;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastConsumedCreditAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ongoingBalanceCents: Scalars['BigInt']['output'];
  ongoingUsageBalanceCents: Scalars['BigInt']['output'];
  rateAmount: Scalars['Float']['output'];
  recurringTransactionRules?: Maybe<Array<RecurringTransactionRule>>;
  status: WalletStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type WalletCollection = {
  __typename?: 'WalletCollection';
  collection: Array<Wallet>;
  metadata: CollectionMetadata;
};

export enum WalletStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  amount: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmount: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status: WalletTransactionStatusEnum;
  transactionStatus: WalletTransactionTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  wallet?: Maybe<Wallet>;
};

export type WalletTransactionCollection = {
  __typename?: 'WalletTransactionCollection';
  collection: Array<WalletTransaction>;
  metadata: CollectionMetadata;
};

export enum WalletTransactionStatusEnum {
  Pending = 'pending',
  Settled = 'settled'
}

export enum WalletTransactionTransactionStatusEnum {
  Granted = 'granted',
  Invoiced = 'invoiced',
  Purchased = 'purchased',
  Voided = 'voided'
}

export enum WalletTransactionTransactionTypeEnum {
  Inbound = 'inbound',
  Outbound = 'outbound'
}

export type Webhook = {
  __typename?: 'Webhook';
  createdAt: Scalars['ISO8601DateTime']['output'];
  endpoint: Scalars['String']['output'];
  httpStatus?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  lastRetriedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  objectType: Scalars['String']['output'];
  payload?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  retries: Scalars['Int']['output'];
  status: WebhookStatusEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  webhookType: Scalars['String']['output'];
};

export type WebhookCollection = {
  __typename?: 'WebhookCollection';
  collection: Array<Webhook>;
  metadata: CollectionMetadata;
};

export type WebhookEndpoint = {
  __typename?: 'WebhookEndpoint';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization?: Maybe<Organization>;
  signatureAlgo?: Maybe<WebhookEndpointSignatureAlgoEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl: Scalars['String']['output'];
};

export type WebhookEndpointCollection = {
  __typename?: 'WebhookEndpointCollection';
  collection: Array<WebhookEndpoint>;
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateWebhookEndpoint */
export type WebhookEndpointCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookEndpointSignatureAlgoEnum {
  Hmac = 'hmac',
  Jwt = 'jwt'
}

/** Autogenerated input type of UpdateWebhookEndpoint */
export type WebhookEndpointUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum WeightedIntervalEnum {
  Seconds = 'seconds'
}

export type UserIdentifierQueryVariables = Exact<{ [key: string]: never; }>;


export type UserIdentifierQuery = { __typename?: 'Query', me: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesUpdate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsDelete: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> }, organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum } | null };

export type AddOnItemFragment = { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any };

export type DeleteAddOnFragment = { __typename?: 'AddOn', id: string, name: string };

export type DeleteAddOnMutationVariables = Exact<{
  input: DestroyAddOnInput;
}>;


export type DeleteAddOnMutation = { __typename?: 'Mutation', destroyAddOn?: { __typename?: 'DestroyAddOnPayload', id?: string | null } | null };

export type GetGoogleAuthUrlQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGoogleAuthUrlQuery = { __typename?: 'Query', googleAuthUrl: { __typename?: 'AuthUrl', url: string } };

export type BillableMetricItemFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type DeleteBillableMetricDialogFragment = { __typename?: 'BillableMetric', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type DeleteBillableMetricMutationVariables = Exact<{
  input: DestroyBillableMetricInput;
}>;


export type DeleteBillableMetricMutation = { __typename?: 'Mutation', destroyBillableMetric?: { __typename?: 'DestroyBillableMetricPayload', id?: string | null } | null };

export type BillableMetricsForCouponsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string };

export type GetBillableMetricsForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetBillableMetricsForCouponsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> } };

export type PlansForCouponsFragment = { __typename?: 'Plan', id: string, name: string, code: string };

export type GetPlansForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansForCouponsQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> } };

export type CouponCaptionFragment = { __typename?: 'Coupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type AppliedCouponCaptionFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null };

export type CouponItemFragment = { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type DeleteCouponFragment = { __typename?: 'Coupon', id: string, name: string };

export type DeleteCouponMutationVariables = Exact<{
  input: DestroyCouponInput;
}>;


export type DeleteCouponMutation = { __typename?: 'Mutation', destroyCoupon?: { __typename?: 'DestroyCouponPayload', id?: string | null } | null };

export type TerminateCouponFragment = { __typename?: 'Coupon', id: string, name: string };

export type TerminateCouponMutationVariables = Exact<{
  input: TerminateCouponInput;
}>;


export type TerminateCouponMutation = { __typename?: 'Mutation', terminateCoupon?: { __typename?: 'Coupon', id: string } | null };

export type InvoiceForCreditNoteFormCalculationFragment = { __typename?: 'Invoice', id: string, couponsAmountCents: any, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, feesAmountCents: any, currency?: CurrencyEnum | null, versionNumber: number, paymentDisputeLostAt?: any | null, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null }> | null };

export type CreditNoteEstimateQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput> | CreditNoteItemInput;
}>;


export type CreditNoteEstimateQuery = { __typename?: 'Query', creditNoteEstimate: { __typename?: 'CreditNoteEstimate', couponsAdjustmentAmountCents: any, currency: CurrencyEnum, maxCreditableAmountCents: any, maxRefundableAmountCents: any, subTotalExcludingTaxesAmountCents: any, taxesAmountCents: any, taxesRate: number, appliedTaxes: Array<{ __typename?: 'CreditNoteAppliedTax', taxCode: string, taxName: string, taxRate: number, amountCents: any, tax: { __typename?: 'Tax', id: string } }>, items: Array<{ __typename?: 'CreditNoteItemEstimate', amountCents: any, fee: { __typename?: 'Fee', id: string } }> } };

export type GetPortalCustomerInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalCustomerInfosQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'Customer', id: string, name?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null } | null };

export type PortalInvoiceListItemFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null };

export type DownloadCustomerPortalInvoiceMutationVariables = Exact<{
  input: DownloadCustomerPortalInvoiceInput;
}>;


export type DownloadCustomerPortalInvoiceMutation = { __typename?: 'Mutation', downloadCustomerPortalInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type CustomerPortalInvoicesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type CustomerPortalInvoicesQuery = { __typename?: 'Query', customerPortalInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null }> } };

export type CouponPlansForCustomerFragment = { __typename?: 'Plan', id: string, name: string };

export type CouponBillableMetricsForCustomerFragment = { __typename?: 'BillableMetric', id: string, name: string };

export type GetCouponForCustomerQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCouponForCustomerQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null }> } };

export type AddCouponMutationVariables = Exact<{
  input: CreateAppliedCouponInput;
}>;


export type AddCouponMutation = { __typename?: 'Mutation', createAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } } | null };

export type CustomerCouponFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } };

export type CustomerAppliedCouponsFragment = { __typename?: 'Customer', id: string, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } }> | null };

export type GetCustomerCouponsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerCouponsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } }> | null } | null };

export type RemoveCouponMutationVariables = Exact<{
  input: TerminateAppliedCouponInput;
}>;


export type RemoveCouponMutation = { __typename?: 'Mutation', terminateAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string } | null };

export type GetCustomerCreditNotesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerCreditNotesQuery = { __typename?: 'Query', customerCreditNotes?: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'CreditNote', id: string, canBeVoided: boolean, createdAt: any, creditStatus?: CreditNoteCreditStatusEnum | null, currency: CurrencyEnum, number: string, totalAmountCents: any }> } | null };

export type InvoiceForInvoiceListFragment = { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } };

export type GetCustomerInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type CustomerItemFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type CustomerMainInfosFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, email?: string | null, currency?: CurrencyEnum | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, url?: string | null, zipcode?: string | null, paymentProvider?: ProviderTypeEnum | null, timezone?: TimezoneEnum | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string }> | null };

export type IntegrationsListForCustomerMainInfosQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerMainInfosQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string, name: string, code: string } | { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | { __typename?: 'StripeProvider', id: string, name: string, code: string }> } | null };

export type CustomerAppliedTaxRatesForSettingsFragment = { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null };

export type GetCustomerSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSettingsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null, netPaymentTerm?: number | null, name?: string | null, externalId: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null } | null, organization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number, documentLocale?: string | null } | null } | null };

export type DeleteCustomerDialogFragment = { __typename?: 'Customer', id: string, name?: string | null };

export type DeleteCustomerMutationVariables = Exact<{
  input: DestroyCustomerInput;
}>;


export type DeleteCustomerMutation = { __typename?: 'Mutation', destroyCustomer?: { __typename?: 'DestroyCustomerPayload', id?: string | null } | null };

export type DeleteCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string };

export type DeleteCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type DeleteCustomerGracePeriodFragment = { __typename?: 'Customer', id: string, name?: string | null };

export type DeleteCustomerGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type DeleteCustomerGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type DeleteCustomerNetPaymentTermFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null };

export type DeleteCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null } | null };

export type CustomerForDeleteVatRateDialogFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type TaxRateForDeleteCustomerVatRateDialogFragment = { __typename?: 'Tax', id: string, name: string };

export type RemoveAppliedTaxRateOnCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type RemoveAppliedTaxRateOnCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string } | null };

export type EditCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null };

export type UpdateCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type EditCustomerInvoiceGracePeriodFragment = { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null };

export type UpdateCustomerInvoiceGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type UpdateCustomerInvoiceGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type EditCustomerVatRateFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type GetTaxRatesForEditCustomerQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxRatesForEditCustomerQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type CreateCustomerAppliedTaxMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type CreateCustomerAppliedTaxMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null } | null };

export type CreditNotesForListFragment = { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'CreditNote', id: string, canBeVoided: boolean, createdAt: any, creditStatus?: CreditNoteCreditStatusEnum | null, currency: CurrencyEnum, number: string, totalAmountCents: any }> };

export type DownloadCreditNoteMutationVariables = Exact<{
  input: DownloadCreditNoteInput;
}>;


export type DownloadCreditNoteMutation = { __typename?: 'Mutation', downloadCreditNote?: { __typename?: 'CreditNote', id: string, fileUrl?: string | null } | null };

export type VoidCreditNoteMutationVariables = Exact<{
  input: VoidCreditNoteInput;
}>;


export type VoidCreditNoteMutation = { __typename?: 'Mutation', voidCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type GetCustomerSubscriptionForListQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, subscriptions: Array<{ __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextPendingStartDate?: any | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, plan: { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum, name: string, code: string }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string } | null, nextSubscription?: { __typename?: 'Subscription', id: string } | null }> } | null };

export type SubscriptionItemFragment = { __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextPendingStartDate?: any | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, plan: { __typename?: 'Plan', id: string, name: string, code: string }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string } | null, nextSubscription?: { __typename?: 'Subscription', id: string } | null };

export type SubscriptionLinePlanFragment = { __typename?: 'Plan', id: string, name: string, code: string };

export type TerminateCustomerSubscriptionMutationVariables = Exact<{
  input: TerminateSubscriptionInput;
}>;


export type TerminateCustomerSubscriptionMutation = { __typename?: 'Mutation', terminateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number } } | null };

export type CustomerSubscriptionForUsageFragment = { __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, plan: { __typename?: 'Plan', id: string, name: string, code: string } };

export type GetCustomerSubscriptionForUsageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForUsageQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, externalId: string, currency?: CurrencyEnum | null, subscriptions: Array<{ __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, plan: { __typename?: 'Plan', id: string, name: string, code: string } }> } | null };

export type CustomerUsageForUsageDetailsFragment = { __typename?: 'CustomerUsage', fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null }> }> };

export type CustomerUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  subscriptionId: Scalars['ID']['input'];
}>;


export type CustomerUsageQuery = { __typename?: 'Query', customerUsage: { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', units: number, amountCents: any, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null }> }> } };

export type WebhookForCreateAndEditFragment = { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null };

export type CreateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointCreateInput;
}>;


export type CreateWebhookEndpointMutation = { __typename?: 'Mutation', createWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type UpdateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointUpdateInput;
}>;


export type UpdateWebhookEndpointMutation = { __typename?: 'Mutation', updateWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type DebuggerEventDetailsFragment = { __typename?: 'Event', id: string, code: string, externalCustomerId?: string | null, transactionId?: string | null, timestamp?: any | null, receivedAt: any, payload: any, billableMetricName?: string | null, matchBillableMetric: boolean, matchCustomField: boolean, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum };

export type DeleteWebhookMutationVariables = Exact<{
  input: DestroyWebhookEndpointInput;
}>;


export type DeleteWebhookMutation = { __typename?: 'Mutation', destroyWebhookEndpoint?: { __typename?: 'DestroyWebhookEndpointPayload', id?: string | null } | null };

export type EventItemFragment = { __typename?: 'Event', id: string, code: string, externalCustomerId?: string | null, timestamp?: any | null, matchBillableMetric: boolean, matchCustomField: boolean };

export type WebhookLogDetailsFragment = { __typename?: 'Webhook', id: string, webhookType: string, status: WebhookStatusEnum, payload?: string | null, response?: string | null, httpStatus?: number | null, endpoint: string, retries: number, updatedAt: any };

export type RetryWebhookMutationVariables = Exact<{
  input: RetryWebhookInput;
}>;


export type RetryWebhookMutation = { __typename?: 'Mutation', retryWebhook?: { __typename?: 'Webhook', id: string } | null };

export type WebhookLogItemFragment = { __typename?: 'Webhook', id: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string };

export type OrganizationForDatePickerFragment = { __typename?: 'CurrentOrganization', id: string, timezone?: TimezoneEnum | null };

export type GetGrossRevenuesQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetGrossRevenuesQuery = { __typename?: 'Query', grossRevenues: { __typename?: 'GrossRevenueCollection', collection: Array<{ __typename?: 'GrossRevenue', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetInvoiceCollectionsQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoiceCollectionsQuery = { __typename?: 'Query', invoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', paymentStatus?: InvoicePaymentStatusTypeEnum | null, invoicesCount: any, amountCents: any, currency?: CurrencyEnum | null, month: any }> } };

export type GetMrrQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetMrrQuery = { __typename?: 'Query', mrrs: { __typename?: 'MrrCollection', collection: Array<{ __typename?: 'Mrr', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetInvoicedUsagesQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoicedUsagesQuery = { __typename?: 'Query', invoicedUsages: { __typename?: 'InvoicedUsageCollection', collection: Array<{ __typename?: 'InvoicedUsage', amountCents: any, month: any, currency: CurrencyEnum, code?: string | null }> } };

export type InvoiceMetadatasForMetadataDrawerFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type UpdateInvoiceMetadataMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoiceMetadataMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null } | null };

export type DisputeInvoiceMutationVariables = Exact<{
  input: LoseInvoiceDisputeInput;
}>;


export type DisputeInvoiceMutation = { __typename?: 'Mutation', loseInvoiceDispute?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, issuingDate: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type TaxForInvoiceEditTaxDialogFragment = { __typename?: 'Tax', id: string, name: string, rate: number, code: string };

export type AddOnForInvoiceEditTaxDialogFragment = { __typename?: 'AddOn', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> | null };

export type GetTaxesForInvoiceEditTaxDialogQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForInvoiceEditTaxDialogQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type InvoiceForUpdateInvoicePaymentStatusFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum };

export type UpdateInvoicePaymentStatusMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoicePaymentStatusMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, invoiceType: InvoiceTypeEnum, refundableAmountCents: any, creditableAmountCents: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type InvoiceForFinalizeInvoiceFragment = { __typename?: 'Invoice', id: string, issuingDate: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } };

export type FinalizeInvoiceMutationVariables = Exact<{
  input: FinalizeInvoiceInput;
}>;


export type FinalizeInvoiceMutation = { __typename?: 'Mutation', finalizeInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, issuingDate: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type InvoiceForCreditNotesTableFragment = { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null };

export type InvoiceForInvoiceInfosFragment = { __typename?: 'Invoice', number: string, issuingDate: any, paymentDueDate: any, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null } };

export type InvoiceListItemFragment = { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum } };

export type DownloadInvoiceItemMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceItemMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RetryInvoicePaymentMutationVariables = Exact<{
  input: RetryInvoicePaymentInput;
}>;


export type RetryInvoicePaymentMutation = { __typename?: 'Mutation', retryInvoicePayment?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum } } | null };

export type CustomerMetadatasForInvoiceOverviewFragment = { __typename?: 'Customer', id: string, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null };

export type InvoiceMetadatasForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type InvoiceForVoidInvoiceDialogFragment = { __typename?: 'Invoice', id: string, number: string };

export type VoidInvoiceMutationVariables = Exact<{
  input: VoidInvoiceInput;
}>;


export type VoidInvoiceMutation = { __typename?: 'Mutation', voidInvoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, invoiceType: InvoiceTypeEnum, refundableAmountCents: any, creditableAmountCents: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type FeeForDeleteAdjustmentFeeDialogFragment = { __typename?: 'Fee', id: string };

export type DestroyAdjustedFeeMutationVariables = Exact<{
  input: DestroyAdjustedFeeInput;
}>;


export type DestroyAdjustedFeeMutation = { __typename?: 'Mutation', destroyAdjustedFee?: { __typename?: 'DestroyAdjustedFeePayload', id?: string | null } | null };

export type FeeForEditfeeDrawerFragment = { __typename?: 'Fee', id: string, currency: CurrencyEnum };

export type CreateAdjustedFeeMutationVariables = Exact<{
  input: CreateAdjustedFeeInput;
}>;


export type CreateAdjustedFeeMutation = { __typename?: 'Mutation', createAdjustedFee?: { __typename?: 'Fee', id: string } | null };

export type FeeForInvoiceDetailsTableFragment = { __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type InvoiceForDetailsTableFragment = { __typename?: 'Invoice', invoiceType: InvoiceTypeEnum, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any, versionNumber: number, couponsAmountCents: any, creditNotesAmountCents: any, status: InvoiceStatusTypeEnum, prepaidCreditAmountCents: any, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null };

export type FeeForInvoiceDetailsTableBodyLineFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLinePackageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null } | null };

export type FeeForInvoiceDetailsTableBodyLinePercentageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', fixedFeeTotalAmount?: string | null, fixedFeeUnitAmount?: string | null, freeEvents?: number | null, freeUnits?: string | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, paidUnits?: string | null, perUnitTotalAmount?: string | null, rate?: string | null, units?: string | null } | null };

export type FeeForInvoiceDetailsTableBodyLineVolumeFragment = { __typename?: 'Fee', id: string, units: number, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null } | null };

export type InvoiceForDetailsTableFooterFragment = { __typename?: 'Invoice', couponsAmountCents: any, creditNotesAmountCents: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum, status: InvoiceStatusTypeEnum, prepaidCreditAmountCents: any, versionNumber: number, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null };

export type FeeForInvoiceFeeAdvanceDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceFeeArrearsDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type TaxForPlanChargeAccordionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type ChargeAccordionFragment = { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean, prorated: boolean, invoiceDisplayName?: string | null, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null }, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetTaxesForChargesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForChargesQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type ChargeForChargeOptionsAccordionFragment = { __typename?: 'Charge', id: string, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean };

export type PercentageChargeFragment = { __typename?: 'Properties', fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null };

export type PlanForChargeAccordionFragment = { __typename?: 'Plan', billChargesMonthly?: boolean | null };

export type BillableMetricForChargeSectionFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type GetMeteredBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetMeteredBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type GetRecurringBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetRecurringBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type GetTaxesForCommitmentsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForCommitmentsQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type CustomChargeFragment = { __typename?: 'Properties', customProperties?: any | null };

export type DeletePlanDialogFragment = { __typename?: 'Plan', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type DeletePlanMutationVariables = Exact<{
  input: DestroyPlanInput;
}>;


export type DeletePlanMutation = { __typename?: 'Mutation', destroyPlan?: { __typename?: 'DestroyPlanPayload', id?: string | null } | null };

export type PlanForFixedFeeSectionFragment = { __typename?: 'Plan', id: string, amountCents: any, payInAdvance: boolean, trialPeriod?: number | null, invoiceDisplayName?: string | null };

export type GraduatedChargeFragment = { __typename?: 'Properties', graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null };

export type GraduatedPercentageChargeFragment = { __typename?: 'Properties', graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null };

export type PackageChargeFragment = { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null };

export type PlanItemFragment = { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number };

export type TaxForPlanSettingsSectionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type PlanForSettingsSectionFragment = { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum, code: string, description?: string | null, interval: PlanInterval, name: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetTaxesForPlanQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForPlanQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type StandardChargeFragment = { __typename?: 'Properties', amount?: string | null, groupedBy?: Array<string> | null };

export type VolumeRangesFragment = { __typename?: 'Properties', volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null };

export type GetPlanForDetailsOverviewSectionQueryVariables = Exact<{
  plan: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsOverviewSectionQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null } | null };

export type GetSubscribtionsForPlanDetailsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum> | StatusTypeEnum>;
}>;


export type GetSubscribtionsForPlanDetailsQuery = { __typename?: 'Query', subscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, endingAt?: any | null, subscriptionAt?: any | null, plan: { __typename?: 'Plan', id: string, parent?: { __typename?: 'Plan', id: string } | null }, customer: { __typename?: 'Customer', id: string, name?: string | null, externalId: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type PlanSubscriptionListItemForSubscriptionListFragment = { __typename?: 'Subscription', id: string, endingAt?: any | null, subscriptionAt?: any | null, plan: { __typename?: 'Plan', id: string, parent?: { __typename?: 'Plan', id: string } | null }, customer: { __typename?: 'Customer', id: string, name?: string | null, externalId: string } };

export type GetTaxRatesForEditOrgaQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxRatesForEditOrgaQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number }> } };

export type AssignTaxRateToOrganizationMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type AssignTaxRateToOrganizationMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string } | null };

export type DeleteOrganizationVatRateFragment = { __typename?: 'Tax', id: string, name: string, appliedToOrganization: boolean };

export type UnassignTaxRateToOrganizationMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type UnassignTaxRateToOrganizationMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string, name: string, appliedToOrganization: boolean } | null };

export type EditOrganizationDefaultCurrencyForDialogFragment = { __typename?: 'CurrentOrganization', id: string, defaultCurrency: CurrencyEnum };

export type UpdateOrganizationDefaultCurrencyMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationDefaultCurrencyMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, defaultCurrency: CurrencyEnum } | null };

export type EditCustomerNetPaymentTermForDialogFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null };

export type EditOrganizationNetPaymentTermForDialogFragment = { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number };

export type UpdateCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null } | null };

export type UpdateOrganizationNetPaymentTermMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationNetPaymentTermMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number } | null };

export type UpdateDocumentLocaleOrganizationMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateDocumentLocaleOrganizationMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type UpdateOrganizationGracePeriodMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationGracePeriodMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number } | null } | null };

export type EditOrganizationInformationsDialogFragment = { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null };

export type UpdateOrganizationInformationsMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInformationsMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null } | null };

export type EditOrganizationInvoiceNumberingDialogFragment = { __typename?: 'CurrentOrganization', id: string, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string };

export type UpdateOrganizationInvoiceNumberingMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInvoiceNumberingMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string } | null };

export type EditOrganizationInvoiceTemplateDialogFragment = { __typename?: 'CurrentOrganization', billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceFooter?: string | null } | null };

export type UpdateOrganizationInvoiceTemplateMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInvoiceTemplateMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceFooter?: string | null } | null } | null };

export type UpdateOrganizationTimezoneMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationTimezoneMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, timezone?: TimezoneEnum | null } | null };

export type UpdateOrganizationLogoMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationLogoMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null } | null };

export type AddAdyenProviderDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string };

export type GetProviderByCodeForAdyenQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForAdyenQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type AddAdyenApiKeyMutationVariables = Exact<{
  input: AddAdyenPaymentProviderInput;
}>;


export type AddAdyenApiKeyMutation = { __typename?: 'Mutation', addAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string, successRedirectUrl?: string | null } | null };

export type UpdateAdyenApiKeyMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenApiKeyMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string, successRedirectUrl?: string | null } | null };

export type AdyenForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null };

export type GocardlessForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null };

export type StripeForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null };

export type UpdateAdyenPaymentProviderMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenPaymentProviderMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateGocardlessPaymentProviderMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessPaymentProviderMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateStripePaymentProviderMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripePaymentProviderMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null } | null };

export type AddGocardlessProviderDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetProviderByCodeForGocardlessQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForGocardlessQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type UpdateGocardlessApiKeyMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessApiKeyMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string, successRedirectUrl?: string | null, webhookSecret?: string | null } | null };

export type UpdateOrgaForLagoTaxManagementMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrgaForLagoTaxManagementMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string } | null };

export type AddStripeProviderDialogFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null };

export type GetProviderByCodeForStripeQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForStripeQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type AddStripeApiKeyMutationVariables = Exact<{
  input: AddStripePaymentProviderInput;
}>;


export type AddStripeApiKeyMutation = { __typename?: 'Mutation', addStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateStripeApiKeyMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripeApiKeyMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null, successRedirectUrl?: string | null } | null };

export type DeleteAdyenIntegrationDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string };

export type DeleteAdyenIntegrationMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteAdyenIntegrationMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteGocardlessIntegrationDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string };

export type DeleteGocardlessMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteGocardlessMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteStripeIntegrationDialogFragment = { __typename?: 'StripeProvider', id: string, name: string };

export type DeleteStripeMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteStripeMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type CreateInviteMutationVariables = Exact<{
  input: CreateInviteInput;
}>;


export type CreateInviteMutation = { __typename?: 'Mutation', createInvite?: { __typename?: 'Invite', id: string, token: string, email: string, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type InviteItemFragment = { __typename?: 'Invite', id: string, email: string, token: string, organization: { __typename?: 'Organization', id: string, name: string } };

export type MembershipItemFragment = { __typename?: 'Membership', id: string, user: { __typename?: 'User', id: string, email?: string | null } };

export type RevokeInviteMutationVariables = Exact<{
  input: RevokeInviteInput;
}>;


export type RevokeInviteMutation = { __typename?: 'Mutation', revokeInvite?: { __typename?: 'Invite', id: string } | null };

export type RevokeMembershipMutationVariables = Exact<{
  input: RevokeMembershipInput;
}>;


export type RevokeMembershipMutation = { __typename?: 'Mutation', revokeMembership?: { __typename?: 'Membership', id: string } | null };

export type GetSubscriptionForDetailsOverviewQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsOverviewQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, nextPendingStartDate?: any | null, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null }, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null } } | null };

export type SubscriptionForSubscriptionInformationsFragment = { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, nextPendingStartDate?: any | null, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null }, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null } };

export type DeleteTaxFragment = { __typename?: 'Tax', id: string, name: string, customersCount: number };

export type DeleteTaxMutationVariables = Exact<{
  input: DestroyTaxInput;
}>;


export type DeleteTaxMutation = { __typename?: 'Mutation', destroyTax?: { __typename?: 'DestroyTaxPayload', id?: string | null } | null };

export type TaxItemFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number };

export type CustomerWalletFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, expirationAt?: any | null, name?: string | null, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, thresholdCredits?: string | null, paidCredits: string, grantedCredits: string }> | null };

export type GetCustomerWalletListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetCustomerWalletListQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, expirationAt?: any | null, name?: string | null, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, thresholdCredits?: string | null, paidCredits: string, grantedCredits: string }> | null }> } };

export type TerminateCustomerWalletMutationVariables = Exact<{
  input: TerminateCustomerWalletInput;
}>;


export type TerminateCustomerWalletMutation = { __typename?: 'Mutation', terminateCustomerWallet?: { __typename?: 'Wallet', id: string, status: WalletStatusEnum, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, name?: string | null, rateAmount: number, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type CreateCustomerWalletTransactionMutationVariables = Exact<{
  input: CreateCustomerWalletTransactionInput;
}>;


export type CreateCustomerWalletTransactionMutation = { __typename?: 'Mutation', createCustomerWalletTransaction?: { __typename?: 'WalletTransactionCollection', collection: Array<{ __typename?: 'WalletTransaction', id: string }> } | null };

export type WalletForTopupFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number };

export type WalletForVoidTransactionFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, creditsBalance: number };

export type WalletAccordionFragment = { __typename?: 'Wallet', id: string, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, name?: string | null, rateAmount: number, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type WalletInfosForTransactionsFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, status: WalletStatusEnum, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type GetWalletTransactionsQueryVariables = Exact<{
  walletId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWalletTransactionsQuery = { __typename?: 'Query', walletTransactions: { __typename?: 'WalletTransactionCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'WalletTransaction', id: string, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, amount: string, creditAmount: string, settledAt?: any | null, createdAt: any, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null }> } };

export type WalletTransactionForTransactionListItemFragment = { __typename?: 'WalletTransaction', id: string, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, amount: string, creditAmount: string, settledAt?: any | null, createdAt: any, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null };

export type CurrentUserFragment = { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> };

export type InvoiceSubscriptionFormatingFragment = { __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval } } | null }> | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } };

export type CreateSubscriptionMutationVariables = Exact<{
  input: CreateSubscriptionInput;
}>;


export type CreateSubscriptionMutation = { __typename?: 'Mutation', createSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, name?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } } | null };

export type UpdateSubscriptionMutationVariables = Exact<{
  input: UpdateSubscriptionInput;
}>;


export type UpdateSubscriptionMutation = { __typename?: 'Mutation', updateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, name?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } } | null };

export type GetSinglePlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSinglePlanQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null } | null };

export type CreatePlanMutationVariables = Exact<{
  input: CreatePlanInput;
}>;


export type CreatePlanMutation = { __typename?: 'Mutation', createPlan?: { __typename?: 'Plan', id: string } | null };

export type UpdatePlanMutationVariables = Exact<{
  input: UpdatePlanInput;
}>;


export type UpdatePlanMutation = { __typename?: 'Mutation', updatePlan?: { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null } | null };

export type InvoiceFeeFragment = { __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null };

export type InvoiceCreateCreditNoteFragment = { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null };

export type GetInvoiceCreateCreditNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceCreateCreditNoteQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null } | null };

export type CreateCreditNoteMutationVariables = Exact<{
  input: CreateCreditNoteInput;
}>;


export type CreateCreditNoteMutation = { __typename?: 'Mutation', createCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type TaxOnAddOnEditCreateFragment = { __typename?: 'Tax', id: string, name: string, code: string, rate: number };

export type EditAddOnFragment = { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null };

export type GetSingleAddOnQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleAddOnQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null } | null };

export type CreateAddOnMutationVariables = Exact<{
  input: CreateAddOnInput;
}>;


export type CreateAddOnMutation = { __typename?: 'Mutation', createAddOn?: { __typename?: 'AddOn', id: string } | null };

export type UpdateAddOnMutationVariables = Exact<{
  input: UpdateAddOnInput;
}>;


export type UpdateAddOnMutation = { __typename?: 'Mutation', updateAddOn?: { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any } | null };

export type GetSingleBillableMetricQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleBillableMetricQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, subscriptionsCount: number, plansCount: number, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null } | null };

export type CreateBillableMetricMutationVariables = Exact<{
  input: CreateBillableMetricInput;
}>;


export type CreateBillableMetricMutation = { __typename?: 'Mutation', createBillableMetric?: { __typename?: 'BillableMetric', id: string } | null };

export type UpdateBillableMetricMutationVariables = Exact<{
  input: UpdateBillableMetricInput;
}>;


export type UpdateBillableMetricMutation = { __typename?: 'Mutation', updateBillableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any, draftInvoicesCount: number, activeSubscriptionsCount: number } | null };

export type EditCouponFragment = { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null };

export type GetSingleCouponQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleCouponQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null } | null };

export type CreateCouponMutationVariables = Exact<{
  input: CreateCouponInput;
}>;


export type CreateCouponMutation = { __typename?: 'Mutation', createCoupon?: { __typename?: 'Coupon', id: string } | null };

export type UpdateCouponMutationVariables = Exact<{
  input: UpdateCouponInput;
}>;


export type UpdateCouponMutation = { __typename?: 'Mutation', updateCoupon?: { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null } | null };

export type AddCustomerDrawerFragment = { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, name?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type CreateCustomerMutationVariables = Exact<{
  input: CreateCustomerInput;
}>;


export type CreateCustomerMutation = { __typename?: 'Mutation', createCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, name?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, createdAt: any, activeSubscriptionsCount: number, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type UpdateCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, name?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, createdAt: any, activeSubscriptionsCount: number, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type IntegrationsListForCustomerCreateEditQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerCreateEditQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename: 'AdyenProvider', id: string, name: string, code: string } | { __typename: 'GocardlessProvider', id: string, name: string, code: string } | { __typename: 'StripeProvider', id: string, name: string, code: string }> } | null };

export type TaxFormFragment = { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type TaxFormQueryShapeFragment = { __typename?: 'Tax', autoGenerated: boolean, id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type GetSingleTaxQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleTaxQuery = { __typename?: 'Query', tax?: { __typename?: 'Tax', id: string, autoGenerated: boolean, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CreateTaxMutationVariables = Exact<{
  input: TaxCreateInput;
}>;


export type CreateTaxMutation = { __typename?: 'Mutation', createTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type UpdateTaxMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type UpdateTaxMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CurrentUserInfosFragment = { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesUpdate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsDelete: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> };

export type GetCurrentUserInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserInfosQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesUpdate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsDelete: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> } };

export type GetEmailSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetEmailSettingsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, emailSettings?: Array<EmailSettingsEnum> | null, logoUrl?: string | null, name: string } | null };

export type UpdateEmailSettingMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateEmailSettingMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, emailSettings?: Array<EmailSettingsEnum> | null } | null };

export type MainOrganizationInfosFragment = { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum };

export type GetOrganizationInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfosQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum } | null };

export type MembershipPermissionsFragment = { __typename?: 'Membership', id: string, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesUpdate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsDelete: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type AllInvoiceDetailsForCustomerInvoiceDetailsFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, issuingDate: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null };

export type GetInvoiceDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceDetailsQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, issuingDate: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type DownloadInvoiceMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RefreshInvoiceMutationVariables = Exact<{
  input: RefreshInvoiceInput;
}>;


export type RefreshInvoiceMutation = { __typename?: 'Mutation', refreshInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, issuingDate: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, name?: string | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxRate: number, taxName: string }> | null } | null };

export type SideNavInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type SideNavInfosQuery = { __typename?: 'Query', currentVersion: { __typename?: 'CurrentVersion', githubUrl: string, number: string } };

export type GetAddOnForDetailsQueryVariables = Exact<{
  addOn: Scalars['ID']['input'];
}>;


export type GetAddOnForDetailsQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, amountCents: any, amountCurrency: CurrencyEnum, code: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null };

export type AddOnsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type AddOnsQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any }> } };

export type BillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type BillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any, draftInvoicesCount: number, activeSubscriptionsCount: number }> } };

export type CouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type CouponsQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null }> } };

export type GetTaxesForAddOnFormQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForAddOnFormQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type EditBillableMetricFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, subscriptionsCount: number, plansCount: number, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null };

export type CreateCreditNoteInvoiceFragment = { __typename?: 'Invoice', id: string, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, subTotalIncludingTaxesAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, name: string, rate: number } }> | null }> | null };

export type TaxInfosForCreateInvoiceFragment = { __typename?: 'Tax', id: string, name: string, code: string, rate: number };

export type CreateInvoiceMutationVariables = Exact<{
  input: CreateInvoiceInput;
}>;


export type CreateInvoiceMutation = { __typename?: 'Mutation', createInvoice?: { __typename?: 'Invoice', id: string } | null };

export type GetInfosForCreateInvoiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInfosForCreateInvoiceQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, name?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, state?: string | null, zipcode?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null } | null, organization?: { __typename?: 'CurrentOrganization', id: string, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, email?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, logoUrl?: string | null, state?: string | null, zipcode?: string | null, defaultCurrency: CurrencyEnum } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> } };

export type GetAddonListForInfoiceQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetAddonListForInfoiceQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null }> } };

export type TaxForPlanAndChargesInPlanFormFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type BillableMetricForPlanFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type EditPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null };

export type AddSubscriptionPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval };

export type GetPlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval }> } };

export type GetCustomerForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerForCreateSubscriptionQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null, externalId: string } | null };

export type GetSubscriptionForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSubscriptionForCreateSubscriptionQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, billingTime?: BillingTimeEnum | null, periodEndDate?: any | null, status?: StatusTypeEnum | null, startedAt?: any | null, plan: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval, parent?: { __typename?: 'Plan', id: string } | null } } | null };

export type GetCreditNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCreditNoteQuery = { __typename?: 'Query', creditNote?: { __typename?: 'CreditNote', id: string, balanceAmountCents: any, canBeVoided: boolean, couponsAdjustmentAmountCents: any, createdAt: any, creditAmountCents: any, creditStatus?: CreditNoteCreditStatusEnum | null, currency: CurrencyEnum, number: string, refundAmountCents: any, refundedAt?: any | null, refundStatus?: CreditNoteRefundStatusEnum | null, subTotalExcludingTaxesAmountCents: any, totalAmountCents: any, customer: { __typename?: 'Customer', id: string, name?: string | null, deletedAt?: any | null, applicableTimezone: TimezoneEnum }, invoice?: { __typename?: 'Invoice', id: string, number: string } | null, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, itemName: string, groupedBy: any, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, tax: { __typename?: 'Tax', id: string, rate: number } }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> } | null };

export type CustomerDetailsFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type GetCustomerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type GenerateCustomerPortalUrlMutationVariables = Exact<{
  input: GenerateCustomerPortalUrlInput;
}>;


export type GenerateCustomerPortalUrlMutation = { __typename?: 'Mutation', generateCustomerPortalUrl?: { __typename?: 'GenerateCustomerPortalUrlPayload', url: string } | null };

export type GetCustomerDraftInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerDraftInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type GetCustomerInfosForDraftInvoicesListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type GetCustomerInfosForDraftInvoicesListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum } | null, customerInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } };

export type CustomersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type CustomersQuery = { __typename?: 'Query', customers: { __typename?: 'CustomerCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Customer', id: string, name?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null }> } };

export type GetinviteQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetinviteQuery = { __typename?: 'Query', invite?: { __typename?: 'Invite', id: string, email: string, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type AcceptInviteMutationVariables = Exact<{
  input: AcceptInviteInput;
}>;


export type AcceptInviteMutation = { __typename?: 'Mutation', acceptInvite?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GoogleAcceptInviteMutationVariables = Exact<{
  input: GoogleAcceptInviteInput;
}>;


export type GoogleAcceptInviteMutation = { __typename?: 'Mutation', googleAcceptInvite?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetInvoiceCreditNotesQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvoiceCreditNotesQuery = { __typename?: 'Query', invoiceCreditNotes?: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'CreditNote', id: string, canBeVoided: boolean, createdAt: any, creditStatus?: CreditNoteCreditStatusEnum | null, currency: CurrencyEnum, number: string, totalAmountCents: any }> } | null, invoice?: { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, status: InvoiceStatusTypeEnum, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } } | null };

export type InvoiceDetailsForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, issuingDate: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } };

export type InvoicesListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<InvoiceStatusTypeEnum>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum> | InvoicePaymentStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type InvoicesListQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, customer: { __typename?: 'Customer', id: string, name?: string | null, applicableTimezone: TimezoneEnum } }> } };

export type RetryAllInvoicePaymentsMutationVariables = Exact<{
  input: RetryAllInvoicePaymentsInput;
}>;


export type RetryAllInvoicePaymentsMutation = { __typename?: 'Mutation', retryAllInvoicePayments?: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string }> } | null };

export type GetPlanForDetailsQueryVariables = Exact<{
  planId: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, draftInvoicesCount: number, activeSubscriptionsCount: number, parent?: { __typename?: 'Plan', id: string } | null } | null };

export type PlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type PlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number }> } };

export type GetSubscriptionForDetailsQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, externalId: string, plan: { __typename?: 'Plan', id: string, name: string, code: string, parent?: { __typename?: 'Plan', id: string, name: string, code: string } | null }, customer: { __typename?: 'Customer', id: string } } | null };

export type WalletForUpdateFragment = { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, thresholdCredits?: string | null, paidCredits: string, grantedCredits: string }> | null };

export type GetCustomerInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerInfosForWalletFormQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, timezone?: TimezoneEnum | null } | null };

export type GetWalletInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWalletInfosForWalletFormQuery = { __typename?: 'Query', wallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, thresholdCredits?: string | null, paidCredits: string, grantedCredits: string }> | null } | null };

export type CreateCustomerWalletMutationVariables = Exact<{
  input: CreateCustomerWalletInput;
}>;


export type CreateCustomerWalletMutation = { __typename?: 'Mutation', createCustomerWallet?: { __typename?: 'Wallet', id: string, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type UpdateCustomerWalletMutationVariables = Exact<{
  input: UpdateCustomerWalletInput;
}>;


export type UpdateCustomerWalletMutation = { __typename?: 'Mutation', updateCustomerWallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, thresholdCredits?: string | null, paidCredits: string, grantedCredits: string }> | null } | null };

export type CreatePasswordResetMutationVariables = Exact<{
  input: CreatePasswordResetInput;
}>;


export type CreatePasswordResetMutation = { __typename?: 'Mutation', createPasswordReset?: { __typename?: 'CreatePasswordResetPayload', id: string } | null };

export type GoogleLoginUserMutationVariables = Exact<{
  input: GoogleLoginUserInput;
}>;


export type GoogleLoginUserMutation = { __typename?: 'Mutation', googleLoginUser?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type LoginUserMutationVariables = Exact<{
  input: LoginUserInput;
}>;


export type LoginUserMutation = { __typename?: 'Mutation', loginUser?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetPortalLocaleQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalLocaleQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'Organization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, documentLocale?: string | null } | null } | null, customerPortalUser?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type GetPasswordResetQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetPasswordResetQuery = { __typename?: 'Query', passwordReset: { __typename?: 'ResetPassword', id: string, user: { __typename?: 'User', id: string, email?: string | null } } };

export type ResetPasswordMutationVariables = Exact<{
  input: ResetPasswordInput;
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type SignupMutationVariables = Exact<{
  input: RegisterUserInput;
}>;


export type SignupMutation = { __typename?: 'Mutation', registerUser?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GoogleRegisterMutationVariables = Exact<{
  input: GoogleRegisterUserInput;
}>;


export type GoogleRegisterMutation = { __typename?: 'Mutation', googleRegisterUser?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetPortalOrgaInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalOrgaInfosQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null } | null };

export type GetOrganizationApiKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationApiKeyQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, apiKey?: string | null } | null };

export type EventListFragment = { __typename?: 'Event', id: string, code: string, externalCustomerId?: string | null, transactionId?: string | null, timestamp?: any | null, receivedAt: any, payload: any, billableMetricName?: string | null, matchBillableMetric: boolean, matchCustomField: boolean, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum };

export type EventsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type EventsQuery = { __typename?: 'Query', events?: { __typename?: 'EventCollection', collection: Array<{ __typename?: 'Event', id: string, code: string, externalCustomerId?: string | null, transactionId?: string | null, timestamp?: any | null, receivedAt: any, payload: any, billableMetricName?: string | null, matchBillableMetric: boolean, matchCustomField: boolean, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetWebhookInformationsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWebhookInformationsQuery = { __typename?: 'Query', webhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string } | null };

export type WebhookLogFragment = { __typename?: 'Webhook', id: string, createdAt: any, endpoint: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string, payload?: string | null, response?: string | null, httpStatus?: number | null, retries: number };

export type GetWebhookLogQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  webhookEndpointId: Scalars['String']['input'];
  status?: InputMaybe<WebhookStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetWebhookLogQuery = { __typename?: 'Query', webhooks: { __typename?: 'WebhookCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Webhook', id: string, createdAt: any, endpoint: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string, payload?: string | null, response?: string | null, httpStatus?: number | null, retries: number }> } };

export type GetWebhookListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWebhookListQuery = { __typename?: 'Query', webhookEndpoints: { __typename?: 'WebhookEndpointCollection', collection: Array<{ __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null }> } };

export type AdyenIntegrationDetailsFragment = { __typename?: 'AdyenProvider', id: string, apiKey?: string | null, code: string, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string, successRedirectUrl?: string | null, name: string };

export type GetAdyenIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string, apiKey?: string | null, code: string, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string, successRedirectUrl?: string | null, name: string } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' }> } | null };

export type AdyenIntegrationsFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string };

export type GetAdyenIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount: string } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' }> } | null };

export type GocardlessIntegrationDetailsFragment = { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null };

export type GetGocardlessIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null } | { __typename?: 'StripeProvider' } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider' }> } | null };

export type GocardlessIntegrationOauthCallbackFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type AddGocardlessApiKeyMutationVariables = Exact<{
  input: AddGocardlessPaymentProviderInput;
}>;


export type AddGocardlessApiKeyMutation = { __typename?: 'Mutation', addGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | null };

export type GocardlessIntegrationsFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetGocardlessIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | { __typename?: 'StripeProvider' }> } | null };

export type IntegrationsSettingQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsSettingQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, euTaxManagement: boolean, country?: CountryCode | null } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string }> } | null };

export type GetOrganizationSettingsQueryVariables = Exact<{
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetOrganizationSettingsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number, defaultCurrency: CurrencyEnum, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number, invoiceFooter?: string | null, documentLocale?: string | null } | null } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, appliedToOrganization: boolean }> } };

export type LagoTaxManagementIntegrationsSettingQueryVariables = Exact<{ [key: string]: never; }>;


export type LagoTaxManagementIntegrationsSettingQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, country?: CountryCode | null, euTaxManagement: boolean } | null };

export type GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTaxesForTaxManagementIntegrationDetailsPageQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type RemoveTaxManagementIntegrationMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type RemoveTaxManagementIntegrationMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, euTaxManagement: boolean } | null };

export type GetInvitesQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvitesQuery = { __typename?: 'Query', invites: { __typename?: 'InviteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invite', id: string, email: string, token: string, organization: { __typename?: 'Organization', id: string, name: string } }> } };

export type GetMembersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetMembersQuery = { __typename?: 'Query', memberships: { __typename?: 'MembershipCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Membership', id: string, user: { __typename?: 'User', id: string, email?: string | null } }> } };

export type OrganizationInformationsFragment = { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null };

export type GetOrganizationInformationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInformationsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null } | null };

export type StripeIntegrationDetailsFragment = { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: string | null, successRedirectUrl?: string | null };

export type GetStripeIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: string | null, successRedirectUrl?: string | null } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string }> } | null };

export type StripeIntegrationsFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string };

export type GetStripeIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null }> } | null };

export type GetTaxesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number }> } };

export const AddOnItemFragmentDoc = gql`
    fragment AddOnItem on AddOn {
  id
  name
  amountCurrency
  amountCents
  customersCount
  createdAt
}
    `;
export const DeleteAddOnFragmentDoc = gql`
    fragment DeleteAddOn on AddOn {
  id
  name
}
    `;
export const DeleteBillableMetricDialogFragmentDoc = gql`
    fragment DeleteBillableMetricDialog on BillableMetric {
  id
  name
  draftInvoicesCount
  activeSubscriptionsCount
}
    `;
export const BillableMetricItemFragmentDoc = gql`
    fragment BillableMetricItem on BillableMetric {
  id
  name
  code
  createdAt
  ...DeleteBillableMetricDialog
}
    ${DeleteBillableMetricDialogFragmentDoc}`;
export const CouponCaptionFragmentDoc = gql`
    fragment CouponCaption on Coupon {
  id
  amountCurrency
  amountCents
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const CouponItemFragmentDoc = gql`
    fragment CouponItem on Coupon {
  id
  name
  customersCount
  status
  amountCurrency
  amountCents
  appliedCouponsCount
  expiration
  expirationAt
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const DeleteCouponFragmentDoc = gql`
    fragment DeleteCoupon on Coupon {
  id
  name
}
    `;
export const TerminateCouponFragmentDoc = gql`
    fragment TerminateCoupon on Coupon {
  id
  name
}
    `;
export const PortalInvoiceListItemFragmentDoc = gql`
    fragment PortalInvoiceListItem on Invoice {
  id
  paymentStatus
  number
  issuingDate
  totalAmountCents
  currency
}
    `;
export const CouponPlansForCustomerFragmentDoc = gql`
    fragment CouponPlansForCustomer on Plan {
  id
  name
}
    `;
export const CouponBillableMetricsForCustomerFragmentDoc = gql`
    fragment CouponBillableMetricsForCustomer on BillableMetric {
  id
  name
}
    `;
export const AppliedCouponCaptionFragmentDoc = gql`
    fragment AppliedCouponCaption on AppliedCoupon {
  id
  amountCurrency
  amountCents
  amountCentsRemaining
  percentageRate
  frequency
  frequencyDuration
  frequencyDurationRemaining
}
    `;
export const CustomerCouponFragmentDoc = gql`
    fragment CustomerCoupon on AppliedCoupon {
  id
  ...AppliedCouponCaption
  coupon {
    id
    name
  }
}
    ${AppliedCouponCaptionFragmentDoc}`;
export const CustomerAppliedCouponsFragmentDoc = gql`
    fragment CustomerAppliedCoupons on Customer {
  id
  appliedCoupons {
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export const InvoiceForFinalizeInvoiceFragmentDoc = gql`
    fragment InvoiceForFinalizeInvoice on Invoice {
  id
  issuingDate
  customer {
    id
    applicableTimezone
  }
}
    `;
export const InvoiceForUpdateInvoicePaymentStatusFragmentDoc = gql`
    fragment InvoiceForUpdateInvoicePaymentStatus on Invoice {
  id
  paymentStatus
}
    `;
export const InvoiceListItemFragmentDoc = gql`
    fragment InvoiceListItem on Invoice {
  id
  status
  paymentStatus
  number
  issuingDate
  totalAmountCents
  currency
  voidable
  paymentDisputeLostAt
  customer {
    id
    name
    applicableTimezone
  }
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
}
    ${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}`;
export const InvoiceForInvoiceListFragmentDoc = gql`
    fragment InvoiceForInvoiceList on InvoiceCollection {
  collection {
    id
    customer {
      id
      applicableTimezone
    }
    ...InvoiceListItem
  }
  metadata {
    currentPage
    totalCount
    totalPages
  }
}
    ${InvoiceListItemFragmentDoc}`;
export const AddCustomerDrawerFragmentDoc = gql`
    fragment AddCustomerDrawer on Customer {
  id
  addressLine1
  addressLine2
  applicableTimezone
  canEditAttributes
  city
  country
  currency
  email
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  name
  paymentProvider
  phone
  state
  timezone
  zipcode
  url
  paymentProviderCode
  providerCustomer {
    id
    providerCustomerId
    syncWithProvider
    providerPaymentMethods
  }
  metadata {
    id
    key
    value
    displayInInvoice
  }
}
    `;
export const CustomerItemFragmentDoc = gql`
    fragment CustomerItem on Customer {
  id
  name
  externalId
  createdAt
  activeSubscriptionsCount
  ...AddCustomerDrawer
}
    ${AddCustomerDrawerFragmentDoc}`;
export const CustomerAppliedTaxRatesForSettingsFragmentDoc = gql`
    fragment CustomerAppliedTaxRatesForSettings on Customer {
  id
  taxes {
    id
    name
    code
    rate
    autoGenerated
  }
}
    `;
export const DeleteCustomerDialogFragmentDoc = gql`
    fragment DeleteCustomerDialog on Customer {
  id
  name
}
    `;
export const DeleteCustomerDocumentLocaleFragmentDoc = gql`
    fragment DeleteCustomerDocumentLocale on Customer {
  id
  name
  externalId
}
    `;
export const DeleteCustomerGracePeriodFragmentDoc = gql`
    fragment DeleteCustomerGracePeriod on Customer {
  id
  name
}
    `;
export const DeleteCustomerNetPaymentTermFragmentDoc = gql`
    fragment DeleteCustomerNetPaymentTerm on Customer {
  id
  externalId
  name
  netPaymentTerm
}
    `;
export const CustomerForDeleteVatRateDialogFragmentDoc = gql`
    fragment CustomerForDeleteVatRateDialog on Customer {
  id
  name
  externalId
  taxes {
    id
    code
  }
}
    `;
export const TaxRateForDeleteCustomerVatRateDialogFragmentDoc = gql`
    fragment TaxRateForDeleteCustomerVatRateDialog on Tax {
  id
  name
}
    `;
export const EditCustomerDocumentLocaleFragmentDoc = gql`
    fragment EditCustomerDocumentLocale on Customer {
  id
  name
  externalId
  billingConfiguration {
    id
    documentLocale
  }
}
    `;
export const EditCustomerInvoiceGracePeriodFragmentDoc = gql`
    fragment EditCustomerInvoiceGracePeriod on Customer {
  id
  invoiceGracePeriod
}
    `;
export const EditCustomerVatRateFragmentDoc = gql`
    fragment EditCustomerVatRate on Customer {
  id
  name
  externalId
  taxes {
    id
    code
  }
}
    `;
export const CreditNotesForListFragmentDoc = gql`
    fragment CreditNotesForList on CreditNoteCollection {
  metadata {
    currentPage
    totalPages
  }
  collection {
    id
    canBeVoided
    createdAt
    creditStatus
    currency
    number
    totalAmountCents
  }
}
    `;
export const SubscriptionLinePlanFragmentDoc = gql`
    fragment SubscriptionLinePlan on Plan {
  id
  name
  code
}
    `;
export const SubscriptionItemFragmentDoc = gql`
    fragment SubscriptionItem on Subscription {
  id
  status
  startedAt
  nextPendingStartDate
  name
  nextName
  externalId
  subscriptionAt
  endingAt
  plan {
    ...SubscriptionLinePlan
  }
  nextPlan {
    ...SubscriptionLinePlan
  }
  nextSubscription {
    id
  }
}
    ${SubscriptionLinePlanFragmentDoc}`;
export const CustomerSubscriptionForUsageFragmentDoc = gql`
    fragment CustomerSubscriptionForUsage on Subscription {
  id
  name
  status
  plan {
    id
    name
    code
  }
}
    `;
export const CustomerUsageForUsageDetailsFragmentDoc = gql`
    fragment CustomerUsageForUsageDetails on CustomerUsage {
  fromDatetime
  toDatetime
  chargesUsage {
    charge {
      id
      invoiceDisplayName
    }
    billableMetric {
      name
    }
    filters {
      id
      amountCents
      units
      values
      invoiceDisplayName
    }
    groupedUsage {
      amountCents
      groupedBy
      eventsCount
      units
      filters {
        id
        amountCents
        units
        values
        invoiceDisplayName
      }
    }
  }
}
    `;
export const WebhookForCreateAndEditFragmentDoc = gql`
    fragment WebhookForCreateAndEdit on WebhookEndpoint {
  id
  webhookUrl
  signatureAlgo
}
    `;
export const TaxForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment TaxForInvoiceEditTaxDialog on Tax {
  id
  name
  rate
  code
}
    `;
export const AddOnForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment AddOnForInvoiceEditTaxDialog on AddOn {
  id
  taxes {
    id
    ...TaxForInvoiceEditTaxDialog
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;
export const InvoiceForVoidInvoiceDialogFragmentDoc = gql`
    fragment InvoiceForVoidInvoiceDialog on Invoice {
  id
  number
}
    `;
export const BillableMetricForChargeSectionFragmentDoc = gql`
    fragment BillableMetricForChargeSection on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const DeletePlanDialogFragmentDoc = gql`
    fragment DeletePlanDialog on Plan {
  id
  name
  draftInvoicesCount
  activeSubscriptionsCount
}
    `;
export const PlanItemFragmentDoc = gql`
    fragment PlanItem on Plan {
  id
  name
  code
  chargesCount
  activeSubscriptionsCount
  createdAt
  ...DeletePlanDialog
}
    ${DeletePlanDialogFragmentDoc}`;
export const PlanSubscriptionListItemForSubscriptionListFragmentDoc = gql`
    fragment PlanSubscriptionListItemForSubscriptionList on Subscription {
  id
  endingAt
  subscriptionAt
  plan {
    id
    parent {
      id
    }
  }
  customer {
    id
    name
    externalId
  }
}
    `;
export const DeleteOrganizationVatRateFragmentDoc = gql`
    fragment DeleteOrganizationVatRate on Tax {
  id
  name
  appliedToOrganization
}
    `;
export const EditOrganizationDefaultCurrencyForDialogFragmentDoc = gql`
    fragment EditOrganizationDefaultCurrencyForDialog on CurrentOrganization {
  id
  defaultCurrency
}
    `;
export const EditCustomerNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditCustomerNetPaymentTermForDialog on Customer {
  id
  externalId
  name
  netPaymentTerm
}
    `;
export const EditOrganizationNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditOrganizationNetPaymentTermForDialog on CurrentOrganization {
  id
  netPaymentTerm
}
    `;
export const EditOrganizationInformationsDialogFragmentDoc = gql`
    fragment EditOrganizationInformationsDialog on CurrentOrganization {
  id
  logoUrl
  name
  legalName
  legalNumber
  taxIdentificationNumber
  email
  addressLine1
  addressLine2
  zipcode
  city
  state
  country
}
    `;
export const EditOrganizationInvoiceNumberingDialogFragmentDoc = gql`
    fragment EditOrganizationInvoiceNumberingDialog on CurrentOrganization {
  id
  documentNumbering
  documentNumberPrefix
}
    `;
export const EditOrganizationInvoiceTemplateDialogFragmentDoc = gql`
    fragment EditOrganizationInvoiceTemplateDialog on CurrentOrganization {
  billingConfiguration {
    id
    invoiceFooter
  }
}
    `;
export const AddAdyenProviderDialogFragmentDoc = gql`
    fragment AddAdyenProviderDialog on AdyenProvider {
  id
  name
  code
  apiKey
  hmacKey
  livePrefix
  merchantAccount
}
    `;
export const AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment AdyenForCreateAndEditSuccessRedirectUrl on AdyenProvider {
  id
  successRedirectUrl
}
    `;
export const GocardlessForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment gocardlessForCreateAndEditSuccessRedirectUrl on GocardlessProvider {
  id
  successRedirectUrl
}
    `;
export const StripeForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment StripeForCreateAndEditSuccessRedirectUrl on StripeProvider {
  id
  successRedirectUrl
}
    `;
export const AddGocardlessProviderDialogFragmentDoc = gql`
    fragment AddGocardlessProviderDialog on GocardlessProvider {
  id
  name
  code
}
    `;
export const AddStripeProviderDialogFragmentDoc = gql`
    fragment AddStripeProviderDialog on StripeProvider {
  id
  name
  code
  secretKey
}
    `;
export const DeleteAdyenIntegrationDialogFragmentDoc = gql`
    fragment DeleteAdyenIntegrationDialog on AdyenProvider {
  id
  name
}
    `;
export const DeleteGocardlessIntegrationDialogFragmentDoc = gql`
    fragment DeleteGocardlessIntegrationDialog on GocardlessProvider {
  id
  name
}
    `;
export const DeleteStripeIntegrationDialogFragmentDoc = gql`
    fragment DeleteStripeIntegrationDialog on StripeProvider {
  id
  name
}
    `;
export const InviteItemFragmentDoc = gql`
    fragment InviteItem on Invite {
  id
  email
  token
  organization {
    id
    name
  }
}
    `;
export const MembershipItemFragmentDoc = gql`
    fragment MembershipItem on Membership {
  id
  user {
    id
    email
  }
}
    `;
export const SubscriptionForSubscriptionInformationsFragmentDoc = gql`
    fragment SubscriptionForSubscriptionInformations on Subscription {
  id
  externalId
  status
  subscriptionAt
  endingAt
  nextPendingStartDate
  nextPlan {
    id
    name
  }
  customer {
    id
    name
  }
  plan {
    id
    name
    parent {
      id
      name
    }
  }
}
    `;
export const DeleteTaxFragmentDoc = gql`
    fragment DeleteTax on Tax {
  id
  name
  customersCount
}
    `;
export const TaxItemFragmentDoc = gql`
    fragment TaxItem on Tax {
  id
  code
  name
  rate
  autoGenerated
  ...DeleteTax
}
    ${DeleteTaxFragmentDoc}`;
export const WalletForTopupFragmentDoc = gql`
    fragment WalletForTopup on Wallet {
  id
  currency
  rateAmount
}
    `;
export const WalletForUpdateFragmentDoc = gql`
    fragment WalletForUpdate on Wallet {
  id
  expirationAt
  name
  rateAmount
  recurringTransactionRules {
    lagoId
    trigger
    interval
    thresholdCredits
    paidCredits
    grantedCredits
  }
}
    `;
export const WalletInfosForTransactionsFragmentDoc = gql`
    fragment WalletInfosForTransactions on Wallet {
  id
  currency
  status
  ongoingUsageBalanceCents
  creditsOngoingUsageBalance
}
    `;
export const WalletAccordionFragmentDoc = gql`
    fragment WalletAccordion on Wallet {
  id
  balanceCents
  consumedAmountCents
  consumedCredits
  createdAt
  creditsBalance
  currency
  expirationAt
  lastBalanceSyncAt
  lastConsumedCreditAt
  name
  rateAmount
  status
  terminatedAt
  ongoingBalanceCents
  creditsOngoingBalance
  ...WalletInfosForTransactions
}
    ${WalletInfosForTransactionsFragmentDoc}`;
export const CustomerWalletFragmentDoc = gql`
    fragment CustomerWallet on Wallet {
  ...WalletForTopup
  ...WalletForUpdate
  ...WalletAccordion
  ...WalletInfosForTransactions
}
    ${WalletForTopupFragmentDoc}
${WalletForUpdateFragmentDoc}
${WalletAccordionFragmentDoc}
${WalletInfosForTransactionsFragmentDoc}`;
export const WalletForVoidTransactionFragmentDoc = gql`
    fragment WalletForVoidTransaction on Wallet {
  id
  currency
  rateAmount
  creditsBalance
}
    `;
export const WalletTransactionForTransactionListItemFragmentDoc = gql`
    fragment WalletTransactionForTransactionListItem on WalletTransaction {
  id
  status
  transactionStatus
  transactionType
  amount
  creditAmount
  settledAt
  createdAt
  wallet {
    id
    currency
  }
}
    `;
export const CurrentUserFragmentDoc = gql`
    fragment CurrentUser on User {
  id
  organizations {
    id
    name
    timezone
  }
}
    `;
export const InvoiceFeeFragmentDoc = gql`
    fragment InvoiceFee on Fee {
  id
  amountCurrency
  feeType
  invoiceName
  invoiceDisplayName
  groupedBy
  appliedTaxes {
    id
    tax {
      id
      name
      rate
    }
  }
  creditableAmountCents
  trueUpFee {
    id
  }
  charge {
    id
    billableMetric {
      id
      name
    }
  }
  chargeFilter {
    id
    invoiceDisplayName
    values
  }
}
    `;
export const InvoiceForCreditNoteFormCalculationFragmentDoc = gql`
    fragment InvoiceForCreditNoteFormCalculation on Invoice {
  id
  couponsAmountCents
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  feesAmountCents
  currency
  versionNumber
  paymentDisputeLostAt
  fees {
    id
    appliedTaxes {
      id
      tax {
        id
        name
        rate
      }
    }
  }
}
    `;
export const CreateCreditNoteInvoiceFragmentDoc = gql`
    fragment CreateCreditNoteInvoice on Invoice {
  id
  currency
  number
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  subTotalIncludingTaxesAmountCents
  paymentDisputeLostAt
  ...InvoiceForCreditNoteFormCalculation
}
    ${InvoiceForCreditNoteFormCalculationFragmentDoc}`;
export const InvoiceCreateCreditNoteFragmentDoc = gql`
    fragment InvoiceCreateCreditNote on Invoice {
  id
  refundableAmountCents
  creditableAmountCents
  invoiceType
  fees {
    id
    amountCurrency
    itemCode
    itemName
    invoiceName
    invoiceDisplayName
    creditableAmountCents
    appliedTaxes {
      id
      tax {
        id
        name
        rate
      }
    }
    trueUpFee {
      id
    }
  }
  invoiceSubscriptions {
    subscription {
      id
      name
      plan {
        id
        name
        invoiceDisplayName
      }
    }
    fees {
      ...InvoiceFee
    }
  }
  ...CreateCreditNoteInvoice
}
    ${InvoiceFeeFragmentDoc}
${CreateCreditNoteInvoiceFragmentDoc}`;
export const TaxOnAddOnEditCreateFragmentDoc = gql`
    fragment TaxOnAddOnEditCreate on Tax {
  id
  name
  code
  rate
}
    `;
export const EditAddOnFragmentDoc = gql`
    fragment EditAddOn on AddOn {
  id
  name
  code
  description
  amountCents
  amountCurrency
  taxes {
    id
    ...TaxOnAddOnEditCreate
  }
}
    ${TaxOnAddOnEditCreateFragmentDoc}`;
export const PlansForCouponsFragmentDoc = gql`
    fragment PlansForCoupons on Plan {
  id
  name
  code
}
    `;
export const BillableMetricsForCouponsFragmentDoc = gql`
    fragment BillableMetricsForCoupons on BillableMetric {
  id
  name
  code
}
    `;
export const EditCouponFragmentDoc = gql`
    fragment EditCoupon on Coupon {
  id
  amountCents
  amountCurrency
  appliedCouponsCount
  code
  couponType
  description
  expiration
  expirationAt
  frequency
  frequencyDuration
  limitedBillableMetrics
  limitedPlans
  name
  percentageRate
  reusable
  plans {
    ...PlansForCoupons
  }
  billableMetrics {
    ...BillableMetricsForCoupons
  }
}
    ${PlansForCouponsFragmentDoc}
${BillableMetricsForCouponsFragmentDoc}`;
export const TaxFormFragmentDoc = gql`
    fragment TaxForm on Tax {
  id
  code
  description
  name
  rate
  customersCount
}
    `;
export const TaxFormQueryShapeFragmentDoc = gql`
    fragment TaxFormQueryShape on Tax {
  ...TaxForm
  autoGenerated
}
    ${TaxFormFragmentDoc}`;
export const MembershipPermissionsFragmentDoc = gql`
    fragment MembershipPermissions on Membership {
  id
  permissions {
    addonsCreate
    addonsDelete
    addonsUpdate
    addonsView
    analyticsView
    billableMetricsCreate
    billableMetricsDelete
    billableMetricsUpdate
    billableMetricsView
    couponsAttach
    couponsCreate
    couponsDelete
    couponsDetach
    couponsUpdate
    couponsView
    creditNotesCreate
    creditNotesUpdate
    creditNotesView
    creditNotesVoid
    customerSettingsUpdateGracePeriod
    customerSettingsUpdateLang
    customerSettingsUpdatePaymentTerms
    customerSettingsUpdateTaxRates
    customerSettingsView
    customersCreate
    customersDelete
    customersUpdate
    customersView
    developersKeysManage
    developersManage
    draftInvoicesUpdate
    invoicesCreate
    invoicesSend
    invoicesUpdate
    invoicesView
    invoicesVoid
    organizationEmailsUpdate
    organizationEmailsView
    organizationIntegrationsCreate
    organizationIntegrationsDelete
    organizationIntegrationsUpdate
    organizationIntegrationsView
    organizationInvoicesUpdate
    organizationInvoicesView
    organizationMembersCreate
    organizationMembersDelete
    organizationMembersUpdate
    organizationMembersView
    organizationTaxesUpdate
    organizationTaxesView
    organizationUpdate
    organizationView
    plansCreate
    plansDelete
    plansUpdate
    plansView
    subscriptionsCreate
    subscriptionsDelete
    subscriptionsUpdate
    subscriptionsView
    walletsCreate
    walletsTerminate
    walletsTopUp
    walletsUpdate
  }
}
    `;
export const CurrentUserInfosFragmentDoc = gql`
    fragment CurrentUserInfos on User {
  id
  email
  premium
  memberships {
    id
    ...MembershipPermissions
    organization {
      id
      name
      logoUrl
    }
  }
}
    ${MembershipPermissionsFragmentDoc}`;
export const OrganizationForDatePickerFragmentDoc = gql`
    fragment OrganizationForDatePicker on CurrentOrganization {
  id
  timezone
}
    `;
export const MainOrganizationInfosFragmentDoc = gql`
    fragment MainOrganizationInfos on CurrentOrganization {
  id
  name
  logoUrl
  timezone
  defaultCurrency
  ...OrganizationForDatePicker
}
    ${OrganizationForDatePickerFragmentDoc}`;
export const CustomerMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment CustomerMetadatasForInvoiceOverview on Customer {
  id
  metadata {
    id
    displayInInvoice
    key
    value
  }
}
    `;
export const InvoiceDetailsForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceDetailsForInvoiceOverview on Invoice {
  id
  status
  issuingDate
  customer {
    id
    applicableTimezone
  }
}
    `;
export const InvoiceForCreditNotesTableFragmentDoc = gql`
    fragment InvoiceForCreditNotesTable on Invoice {
  id
  customer {
    id
  }
  creditNotes {
    id
    couponsAdjustmentAmountCents
    number
    subTotalExcludingTaxesAmountCents
    currency
    totalAmountCents
    appliedTaxes {
      id
      amountCents
      baseAmountCents
      taxRate
      taxName
    }
    items {
      amountCents
      amountCurrency
      fee {
        id
        amountCents
        eventsCount
        units
        feeType
        groupedBy
        itemName
        invoiceName
        appliedTaxes {
          id
          tax {
            id
            rate
          }
        }
        trueUpParentFee {
          id
        }
        charge {
          id
          billableMetric {
            id
            name
            aggregationType
          }
        }
        subscription {
          id
          name
          plan {
            id
            name
            invoiceDisplayName
          }
        }
        chargeFilter {
          invoiceDisplayName
          values
        }
      }
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduated on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedRanges {
      flatUnitAmount
      fromValue
      perUnitAmount
      perUnitTotalAmount
      toValue
      totalWithFlatAmount
      units
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduatedPercentage on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedPercentageRanges {
      flatUnitAmount
      fromValue
      perUnitTotalAmount
      rate
      toValue
      totalWithFlatAmount
      units
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineVolume on Fee {
  id
  units
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    flatUnitAmount
    perUnitAmount
    perUnitTotalAmount
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePackage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    paidUnits
    perPackageSize
    perPackageUnitAmount
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePercentage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    fixedFeeTotalAmount
    fixedFeeUnitAmount
    freeEvents
    freeUnits
    minMaxAdjustmentTotalAmount
    paidEvents
    paidUnits
    perUnitTotalAmount
    rate
    units
  }
}
    `;
export const FeeForEditfeeDrawerFragmentDoc = gql`
    fragment FeeForEditfeeDrawer on Fee {
  id
  currency
}
    `;
export const FeeForDeleteAdjustmentFeeDialogFragmentDoc = gql`
    fragment FeeForDeleteAdjustmentFeeDialog on Fee {
  id
}
    `;
export const FeeForInvoiceDetailsTableBodyLineFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLine on Fee {
  id
  units
  preciseUnitAmount
  amountCents
  eventsCount
  adjustedFee
  adjustedFeeType
  charge {
    id
    chargeModel
    minAmountCents
    payInAdvance
    prorated
    billableMetric {
      id
      recurring
    }
  }
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    fixedFeeUnitAmount
    flatUnitAmount
    graduatedRanges {
      toValue
    }
    graduatedPercentageRanges {
      toValue
    }
  }
  ...FeeForInvoiceDetailsTableBodyLineGraduated
  ...FeeForInvoiceDetailsTableBodyLineGraduatedPercentage
  ...FeeForInvoiceDetailsTableBodyLineVolume
  ...FeeForInvoiceDetailsTableBodyLinePackage
  ...FeeForInvoiceDetailsTableBodyLinePercentage
  ...FeeForEditfeeDrawer
  ...FeeForDeleteAdjustmentFeeDialog
}
    ${FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}`;
export const FeeForInvoiceFeeArrearsDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeArrearsDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeAdvanceDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTable on Fee {
  id
  amountCents
  description
  feeType
  invoiceDisplayName
  invoiceName
  itemName
  units
  preciseUnitAmount
  appliedTaxes {
    id
    taxRate
  }
  trueUpFee {
    id
  }
  trueUpParentFee {
    id
  }
  charge {
    id
    payInAdvance
    invoiceDisplayName
    billableMetric {
      id
      name
      aggregationType
    }
  }
  chargeFilter {
    invoiceDisplayName
    values
  }
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForInvoiceFeeArrearsDetailsTable
  ...FeeForInvoiceFeeAdvanceDetailsTable
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForInvoiceFeeArrearsDetailsTableFragmentDoc}
${FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc}`;
export const InvoiceSubscriptionFormatingFragmentDoc = gql`
    fragment InvoiceSubscriptionFormating on InvoiceSubscription {
  fromDatetime
  toDatetime
  chargesFromDatetime
  chargesToDatetime
  inAdvanceChargesFromDatetime
  inAdvanceChargesToDatetime
  fees {
    id
    amountCents
    invoiceName
    invoiceDisplayName
    units
    groupedBy
    charge {
      id
      payInAdvance
      minAmountCents
      billableMetric {
        id
        name
      }
    }
    chargeFilter {
      invoiceDisplayName
      values
    }
    subscription {
      id
      plan {
        id
        interval
      }
    }
  }
  subscription {
    id
    name
    plan {
      id
      name
      invoiceDisplayName
    }
  }
  invoice {
    id
    status
  }
}
    `;
export const InvoiceForDetailsTableFooterFragmentDoc = gql`
    fragment InvoiceForDetailsTableFooter on Invoice {
  couponsAmountCents
  creditNotesAmountCents
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  currency
  invoiceType
  status
  prepaidCreditAmountCents
  versionNumber
  appliedTaxes {
    id
    amountCents
    feesAmountCents
    taxRate
    taxName
  }
}
    `;
export const InvoiceForDetailsTableFragmentDoc = gql`
    fragment InvoiceForDetailsTable on Invoice {
  invoiceType
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  currency
  issuingDate
  versionNumber
  fees {
    id
    ...FeeForInvoiceDetailsTable
  }
  customer {
    id
    currency
    applicableTimezone
  }
  invoiceSubscriptions {
    fromDatetime
    toDatetime
    chargesFromDatetime
    chargesToDatetime
    inAdvanceChargesFromDatetime
    inAdvanceChargesToDatetime
    subscription {
      id
      name
      plan {
        id
        name
        interval
        amountCents
        amountCurrency
        invoiceDisplayName
      }
    }
    fees {
      id
      subscription {
        id
        name
        plan {
          id
          name
          invoiceDisplayName
        }
      }
      ...FeeForInvoiceDetailsTable
    }
    ...InvoiceSubscriptionFormating
  }
  ...InvoiceForDetailsTableFooter
}
    ${FeeForInvoiceDetailsTableFragmentDoc}
${InvoiceSubscriptionFormatingFragmentDoc}
${InvoiceForDetailsTableFooterFragmentDoc}`;
export const InvoiceForInvoiceInfosFragmentDoc = gql`
    fragment InvoiceForInvoiceInfos on Invoice {
  number
  issuingDate
  paymentDueDate
  status
  paymentStatus
  paymentDisputeLostAt
  customer {
    id
    name
    legalNumber
    legalName
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
    applicableTimezone
    deletedAt
  }
}
    `;
export const InvoiceMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceMetadatasForInvoiceOverview on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const InvoiceMetadatasForMetadataDrawerFragmentDoc = gql`
    fragment InvoiceMetadatasForMetadataDrawer on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc = gql`
    fragment AllInvoiceDetailsForCustomerInvoiceDetails on Invoice {
  id
  invoiceType
  number
  paymentStatus
  status
  totalAmountCents
  currency
  refundableAmountCents
  creditableAmountCents
  voidable
  paymentDisputeLostAt
  customer {
    ...CustomerMetadatasForInvoiceOverview
  }
  ...InvoiceDetailsForInvoiceOverview
  ...InvoiceForCreditNotesTable
  ...InvoiceForDetailsTable
  ...InvoiceForInvoiceInfos
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
  ...InvoiceMetadatasForInvoiceOverview
  ...InvoiceMetadatasForMetadataDrawer
}
    ${CustomerMetadatasForInvoiceOverviewFragmentDoc}
${InvoiceDetailsForInvoiceOverviewFragmentDoc}
${InvoiceForCreditNotesTableFragmentDoc}
${InvoiceForDetailsTableFragmentDoc}
${InvoiceForInvoiceInfosFragmentDoc}
${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}
${InvoiceMetadatasForInvoiceOverviewFragmentDoc}
${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;
export const EditBillableMetricFragmentDoc = gql`
    fragment EditBillableMetric on BillableMetric {
  id
  name
  code
  description
  aggregationType
  fieldName
  subscriptionsCount
  plansCount
  recurring
  filters {
    key
    values
  }
}
    `;
export const TaxInfosForCreateInvoiceFragmentDoc = gql`
    fragment TaxInfosForCreateInvoice on Tax {
  id
  name
  code
  rate
}
    `;
export const TaxForPlanAndChargesInPlanFormFragmentDoc = gql`
    fragment TaxForPlanAndChargesInPlanForm on Tax {
  id
  code
  name
  rate
}
    `;
export const BillableMetricForPlanFragmentDoc = gql`
    fragment BillableMetricForPlan on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const GraduatedChargeFragmentDoc = gql`
    fragment GraduatedCharge on Properties {
  graduatedRanges {
    flatAmount
    fromValue
    perUnitAmount
    toValue
  }
}
    `;
export const GraduatedPercentageChargeFragmentDoc = gql`
    fragment GraduatedPercentageCharge on Properties {
  graduatedPercentageRanges {
    flatAmount
    fromValue
    rate
    toValue
  }
}
    `;
export const VolumeRangesFragmentDoc = gql`
    fragment VolumeRanges on Properties {
  volumeRanges {
    flatAmount
    fromValue
    perUnitAmount
    toValue
  }
}
    `;
export const PackageChargeFragmentDoc = gql`
    fragment PackageCharge on Properties {
  amount
  packageSize
  freeUnits
}
    `;
export const StandardChargeFragmentDoc = gql`
    fragment StandardCharge on Properties {
  amount
  groupedBy
}
    `;
export const PercentageChargeFragmentDoc = gql`
    fragment PercentageCharge on Properties {
  fixedAmount
  freeUnitsPerEvents
  freeUnitsPerTotalAggregation
  rate
  perTransactionMinAmount
  perTransactionMaxAmount
}
    `;
export const CustomChargeFragmentDoc = gql`
    fragment CustomCharge on Properties {
  customProperties
}
    `;
export const TaxForPlanChargeAccordionFragmentDoc = gql`
    fragment TaxForPlanChargeAccordion on Tax {
  id
  code
  name
  rate
}
    `;
export const ChargeForChargeOptionsAccordionFragmentDoc = gql`
    fragment ChargeForChargeOptionsAccordion on Charge {
  id
  invoiceable
  minAmountCents
  payInAdvance
}
    `;
export const ChargeAccordionFragmentDoc = gql`
    fragment ChargeAccordion on Charge {
  id
  chargeModel
  invoiceable
  minAmountCents
  payInAdvance
  prorated
  invoiceDisplayName
  properties {
    ...GraduatedCharge
    ...GraduatedPercentageCharge
    ...VolumeRanges
    ...PackageCharge
    ...StandardCharge
    ...PercentageCharge
    ...CustomCharge
  }
  filters {
    invoiceDisplayName
    values
    properties {
      ...GraduatedCharge
      ...GraduatedPercentageCharge
      ...VolumeRanges
      ...PackageCharge
      ...StandardCharge
      ...PercentageCharge
      ...CustomCharge
    }
  }
  billableMetric {
    id
    name
    aggregationType
    recurring
    filters {
      key
      values
    }
  }
  taxes {
    ...TaxForPlanChargeAccordion
  }
  ...ChargeForChargeOptionsAccordion
}
    ${GraduatedChargeFragmentDoc}
${GraduatedPercentageChargeFragmentDoc}
${VolumeRangesFragmentDoc}
${PackageChargeFragmentDoc}
${StandardChargeFragmentDoc}
${PercentageChargeFragmentDoc}
${CustomChargeFragmentDoc}
${TaxForPlanChargeAccordionFragmentDoc}
${ChargeForChargeOptionsAccordionFragmentDoc}`;
export const PlanForChargeAccordionFragmentDoc = gql`
    fragment PlanForChargeAccordion on Plan {
  billChargesMonthly
}
    `;
export const TaxForPlanSettingsSectionFragmentDoc = gql`
    fragment TaxForPlanSettingsSection on Tax {
  id
  code
  name
  rate
}
    `;
export const PlanForSettingsSectionFragmentDoc = gql`
    fragment PlanForSettingsSection on Plan {
  id
  amountCurrency
  code
  description
  interval
  name
  taxes {
    ...TaxForPlanSettingsSection
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;
export const PlanForFixedFeeSectionFragmentDoc = gql`
    fragment PlanForFixedFeeSection on Plan {
  id
  amountCents
  payInAdvance
  trialPeriod
  invoiceDisplayName
}
    `;
export const EditPlanFragmentDoc = gql`
    fragment EditPlan on Plan {
  id
  name
  code
  description
  interval
  payInAdvance
  invoiceDisplayName
  amountCents
  amountCurrency
  trialPeriod
  subscriptionsCount
  billChargesMonthly
  minimumCommitment {
    amountCents
    commitmentType
    invoiceDisplayName
    taxes {
      id
      ...TaxForPlanAndChargesInPlanForm
    }
  }
  taxes {
    ...TaxForPlanAndChargesInPlanForm
  }
  charges {
    id
    minAmountCents
    payInAdvance
    taxes {
      ...TaxForPlanAndChargesInPlanForm
    }
    billableMetric {
      id
      code
      ...BillableMetricForPlan
    }
    ...ChargeAccordion
    chargeModel
  }
  ...PlanForChargeAccordion
  ...PlanForSettingsSection
  ...PlanForFixedFeeSection
}
    ${TaxForPlanAndChargesInPlanFormFragmentDoc}
${BillableMetricForPlanFragmentDoc}
${ChargeAccordionFragmentDoc}
${PlanForChargeAccordionFragmentDoc}
${PlanForSettingsSectionFragmentDoc}
${PlanForFixedFeeSectionFragmentDoc}`;
export const AddSubscriptionPlanFragmentDoc = gql`
    fragment AddSubscriptionPlan on Plan {
  id
  name
  code
  interval
}
    `;
export const CustomerMainInfosFragmentDoc = gql`
    fragment CustomerMainInfos on Customer {
  id
  name
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  phone
  email
  currency
  addressLine1
  addressLine2
  state
  country
  city
  url
  zipcode
  paymentProvider
  timezone
  paymentProviderCode
  providerCustomer {
    id
    providerCustomerId
    providerPaymentMethods
  }
  metadata {
    id
    key
    value
  }
}
    `;
export const CustomerDetailsFragmentDoc = gql`
    fragment CustomerDetails on Customer {
  id
  name
  externalId
  hasActiveWallet
  currency
  hasCreditNotes
  creditNotesCreditsAvailableCount
  creditNotesBalanceAmountCents
  applicableTimezone
  ...AddCustomerDrawer
  ...CustomerMainInfos
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerMainInfosFragmentDoc}`;
export const EventItemFragmentDoc = gql`
    fragment EventItem on Event {
  id
  code
  externalCustomerId
  timestamp
  matchBillableMetric
  matchCustomField
}
    `;
export const DebuggerEventDetailsFragmentDoc = gql`
    fragment DebuggerEventDetails on Event {
  id
  code
  externalCustomerId
  transactionId
  timestamp
  receivedAt
  payload
  billableMetricName
  matchBillableMetric
  matchCustomField
  apiClient
  ipAddress
  externalSubscriptionId
  customerTimezone
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on Event {
  id
  code
  externalCustomerId
  transactionId
  timestamp
  receivedAt
  payload
  billableMetricName
  matchBillableMetric
  matchCustomField
  apiClient
  ipAddress
  externalSubscriptionId
  customerTimezone
  ...EventItem
  ...DebuggerEventDetails
}
    ${EventItemFragmentDoc}
${DebuggerEventDetailsFragmentDoc}`;
export const WebhookLogItemFragmentDoc = gql`
    fragment WebhookLogItem on Webhook {
  id
  status
  updatedAt
  webhookType
}
    `;
export const WebhookLogDetailsFragmentDoc = gql`
    fragment WebhookLogDetails on Webhook {
  id
  webhookType
  status
  payload
  response
  httpStatus
  endpoint
  retries
  updatedAt
}
    `;
export const WebhookLogFragmentDoc = gql`
    fragment WebhookLog on Webhook {
  id
  createdAt
  endpoint
  ...WebhookLogItem
  ...WebhookLogDetails
}
    ${WebhookLogItemFragmentDoc}
${WebhookLogDetailsFragmentDoc}`;
export const AdyenIntegrationDetailsFragmentDoc = gql`
    fragment AdyenIntegrationDetails on AdyenProvider {
  id
  apiKey
  code
  hmacKey
  livePrefix
  merchantAccount
  successRedirectUrl
  name
}
    `;
export const AdyenIntegrationsFragmentDoc = gql`
    fragment AdyenIntegrations on AdyenProvider {
  id
  name
  code
}
    `;
export const GocardlessIntegrationDetailsFragmentDoc = gql`
    fragment GocardlessIntegrationDetails on GocardlessProvider {
  id
  code
  name
  successRedirectUrl
  webhookSecret
}
    `;
export const GocardlessIntegrationOauthCallbackFragmentDoc = gql`
    fragment GocardlessIntegrationOauthCallback on GocardlessProvider {
  id
  name
  code
}
    `;
export const GocardlessIntegrationsFragmentDoc = gql`
    fragment GocardlessIntegrations on GocardlessProvider {
  id
  name
  code
}
    `;
export const OrganizationInformationsFragmentDoc = gql`
    fragment OrganizationInformations on CurrentOrganization {
  id
  logoUrl
  name
  legalName
  legalNumber
  taxIdentificationNumber
  email
  addressLine1
  addressLine2
  zipcode
  city
  state
  country
  timezone
}
    `;
export const StripeIntegrationDetailsFragmentDoc = gql`
    fragment StripeIntegrationDetails on StripeProvider {
  id
  code
  name
  secretKey
  successRedirectUrl
}
    `;
export const StripeIntegrationsFragmentDoc = gql`
    fragment StripeIntegrations on StripeProvider {
  id
  name
  code
}
    `;
export const UserIdentifierDocument = gql`
    query UserIdentifier {
  me: currentUser {
    id
    email
    ...CurrentUserInfos
  }
  organization {
    ...MainOrganizationInfos
  }
}
    ${CurrentUserInfosFragmentDoc}
${MainOrganizationInfosFragmentDoc}`;

/**
 * __useUserIdentifierQuery__
 *
 * To run a query within a React component, call `useUserIdentifierQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserIdentifierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserIdentifierQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserIdentifierQuery(baseOptions?: Apollo.QueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
      }
export function useUserIdentifierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export function useUserIdentifierSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export type UserIdentifierQueryHookResult = ReturnType<typeof useUserIdentifierQuery>;
export type UserIdentifierLazyQueryHookResult = ReturnType<typeof useUserIdentifierLazyQuery>;
export type UserIdentifierSuspenseQueryHookResult = ReturnType<typeof useUserIdentifierSuspenseQuery>;
export type UserIdentifierQueryResult = Apollo.QueryResult<UserIdentifierQuery, UserIdentifierQueryVariables>;
export const DeleteAddOnDocument = gql`
    mutation deleteAddOn($input: DestroyAddOnInput!) {
  destroyAddOn(input: $input) {
    id
  }
}
    `;
export type DeleteAddOnMutationFn = Apollo.MutationFunction<DeleteAddOnMutation, DeleteAddOnMutationVariables>;

/**
 * __useDeleteAddOnMutation__
 *
 * To run a mutation, you first call `useDeleteAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAddOnMutation, { data, loading, error }] = useDeleteAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAddOnMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAddOnMutation, DeleteAddOnMutationVariables>(DeleteAddOnDocument, options);
      }
export type DeleteAddOnMutationHookResult = ReturnType<typeof useDeleteAddOnMutation>;
export type DeleteAddOnMutationResult = Apollo.MutationResult<DeleteAddOnMutation>;
export type DeleteAddOnMutationOptions = Apollo.BaseMutationOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>;
export const GetGoogleAuthUrlDocument = gql`
    query getGoogleAuthUrl {
  googleAuthUrl {
    url
  }
}
    `;

/**
 * __useGetGoogleAuthUrlQuery__
 *
 * To run a query within a React component, call `useGetGoogleAuthUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGoogleAuthUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGoogleAuthUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetGoogleAuthUrlQuery(baseOptions?: Apollo.QueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
      }
export function useGetGoogleAuthUrlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export function useGetGoogleAuthUrlSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export type GetGoogleAuthUrlQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlQuery>;
export type GetGoogleAuthUrlLazyQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlLazyQuery>;
export type GetGoogleAuthUrlSuspenseQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlSuspenseQuery>;
export type GetGoogleAuthUrlQueryResult = Apollo.QueryResult<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>;
export const DeleteBillableMetricDocument = gql`
    mutation deleteBillableMetric($input: DestroyBillableMetricInput!) {
  destroyBillableMetric(input: $input) {
    id
  }
}
    `;
export type DeleteBillableMetricMutationFn = Apollo.MutationFunction<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;

/**
 * __useDeleteBillableMetricMutation__
 *
 * To run a mutation, you first call `useDeleteBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBillableMetricMutation, { data, loading, error }] = useDeleteBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>(DeleteBillableMetricDocument, options);
      }
export type DeleteBillableMetricMutationHookResult = ReturnType<typeof useDeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationResult = Apollo.MutationResult<DeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationOptions = Apollo.BaseMutationOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;
export const GetBillableMetricsForCouponsDocument = gql`
    query getBillableMetricsForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...BillableMetricsForCoupons
    }
  }
}
    ${BillableMetricsForCouponsFragmentDoc}`;

/**
 * __useGetBillableMetricsForCouponsQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetBillableMetricsForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
      }
export function useGetBillableMetricsForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export function useGetBillableMetricsForCouponsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export type GetBillableMetricsForCouponsQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsQuery>;
export type GetBillableMetricsForCouponsLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsLazyQuery>;
export type GetBillableMetricsForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsSuspenseQuery>;
export type GetBillableMetricsForCouponsQueryResult = Apollo.QueryResult<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>;
export const GetPlansForCouponsDocument = gql`
    query getPlansForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...PlansForCoupons
    }
  }
}
    ${PlansForCouponsFragmentDoc}`;

/**
 * __useGetPlansForCouponsQuery__
 *
 * To run a query within a React component, call `useGetPlansForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
      }
export function useGetPlansForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export function useGetPlansForCouponsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export type GetPlansForCouponsQueryHookResult = ReturnType<typeof useGetPlansForCouponsQuery>;
export type GetPlansForCouponsLazyQueryHookResult = ReturnType<typeof useGetPlansForCouponsLazyQuery>;
export type GetPlansForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetPlansForCouponsSuspenseQuery>;
export type GetPlansForCouponsQueryResult = Apollo.QueryResult<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>;
export const DeleteCouponDocument = gql`
    mutation deleteCoupon($input: DestroyCouponInput!) {
  destroyCoupon(input: $input) {
    id
  }
}
    `;
export type DeleteCouponMutationFn = Apollo.MutationFunction<DeleteCouponMutation, DeleteCouponMutationVariables>;

/**
 * __useDeleteCouponMutation__
 *
 * To run a mutation, you first call `useDeleteCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCouponMutation, { data, loading, error }] = useDeleteCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCouponMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCouponMutation, DeleteCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCouponMutation, DeleteCouponMutationVariables>(DeleteCouponDocument, options);
      }
export type DeleteCouponMutationHookResult = ReturnType<typeof useDeleteCouponMutation>;
export type DeleteCouponMutationResult = Apollo.MutationResult<DeleteCouponMutation>;
export type DeleteCouponMutationOptions = Apollo.BaseMutationOptions<DeleteCouponMutation, DeleteCouponMutationVariables>;
export const TerminateCouponDocument = gql`
    mutation terminateCoupon($input: TerminateCouponInput!) {
  terminateCoupon(input: $input) {
    id
  }
}
    `;
export type TerminateCouponMutationFn = Apollo.MutationFunction<TerminateCouponMutation, TerminateCouponMutationVariables>;

/**
 * __useTerminateCouponMutation__
 *
 * To run a mutation, you first call `useTerminateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCouponMutation, { data, loading, error }] = useTerminateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCouponMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCouponMutation, TerminateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCouponMutation, TerminateCouponMutationVariables>(TerminateCouponDocument, options);
      }
export type TerminateCouponMutationHookResult = ReturnType<typeof useTerminateCouponMutation>;
export type TerminateCouponMutationResult = Apollo.MutationResult<TerminateCouponMutation>;
export type TerminateCouponMutationOptions = Apollo.BaseMutationOptions<TerminateCouponMutation, TerminateCouponMutationVariables>;
export const CreditNoteEstimateDocument = gql`
    query creditNoteEstimate($invoiceId: ID!, $items: [CreditNoteItemInput!]!) {
  creditNoteEstimate(invoiceId: $invoiceId, items: $items) {
    appliedTaxes {
      taxCode
      taxName
      taxRate
      amountCents
      tax {
        id
      }
    }
    couponsAdjustmentAmountCents
    currency
    items {
      amountCents
      fee {
        id
      }
    }
    maxCreditableAmountCents
    maxRefundableAmountCents
    subTotalExcludingTaxesAmountCents
    taxesAmountCents
    taxesRate
  }
}
    `;

/**
 * __useCreditNoteEstimateQuery__
 *
 * To run a query within a React component, call `useCreditNoteEstimateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreditNoteEstimateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreditNoteEstimateQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      items: // value for 'items'
 *   },
 * });
 */
export function useCreditNoteEstimateQuery(baseOptions: Apollo.QueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
      }
export function useCreditNoteEstimateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export function useCreditNoteEstimateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export type CreditNoteEstimateQueryHookResult = ReturnType<typeof useCreditNoteEstimateQuery>;
export type CreditNoteEstimateLazyQueryHookResult = ReturnType<typeof useCreditNoteEstimateLazyQuery>;
export type CreditNoteEstimateSuspenseQueryHookResult = ReturnType<typeof useCreditNoteEstimateSuspenseQuery>;
export type CreditNoteEstimateQueryResult = Apollo.QueryResult<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>;
export const GetPortalCustomerInfosDocument = gql`
    query getPortalCustomerInfos {
  customerPortalUser {
    id
    name
    legalName
    legalNumber
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
  }
}
    `;

/**
 * __useGetPortalCustomerInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalCustomerInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalCustomerInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalCustomerInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalCustomerInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
      }
export function useGetPortalCustomerInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export function useGetPortalCustomerInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export type GetPortalCustomerInfosQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosQuery>;
export type GetPortalCustomerInfosLazyQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosLazyQuery>;
export type GetPortalCustomerInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosSuspenseQuery>;
export type GetPortalCustomerInfosQueryResult = Apollo.QueryResult<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>;
export const DownloadCustomerPortalInvoiceDocument = gql`
    mutation downloadCustomerPortalInvoice($input: DownloadCustomerPortalInvoiceInput!) {
  downloadCustomerPortalInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCustomerPortalInvoiceMutationFn = Apollo.MutationFunction<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;

/**
 * __useDownloadCustomerPortalInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadCustomerPortalInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCustomerPortalInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCustomerPortalInvoiceMutation, { data, loading, error }] = useDownloadCustomerPortalInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCustomerPortalInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>(DownloadCustomerPortalInvoiceDocument, options);
      }
export type DownloadCustomerPortalInvoiceMutationHookResult = ReturnType<typeof useDownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationResult = Apollo.MutationResult<DownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;
export const CustomerPortalInvoicesDocument = gql`
    query customerPortalInvoices($limit: Int, $page: Int, $searchTerm: String, $status: [InvoiceStatusTypeEnum!]) {
  customerPortalInvoices(
    limit: $limit
    page: $page
    searchTerm: $searchTerm
    status: $status
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...PortalInvoiceListItem
    }
  }
}
    ${PortalInvoiceListItemFragmentDoc}`;

/**
 * __useCustomerPortalInvoicesQuery__
 *
 * To run a query within a React component, call `useCustomerPortalInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerPortalInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerPortalInvoicesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useCustomerPortalInvoicesQuery(baseOptions?: Apollo.QueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
      }
export function useCustomerPortalInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export function useCustomerPortalInvoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export type CustomerPortalInvoicesQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesQuery>;
export type CustomerPortalInvoicesLazyQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesLazyQuery>;
export type CustomerPortalInvoicesSuspenseQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesSuspenseQuery>;
export type CustomerPortalInvoicesQueryResult = Apollo.QueryResult<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>;
export const GetCouponForCustomerDocument = gql`
    query getCouponForCustomer($page: Int, $limit: Int, $status: CouponStatusEnum, $searchTerm: String) {
  coupons(page: $page, limit: $limit, status: $status, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      amountCurrency
      amountCents
      couponType
      percentageRate
      frequency
      frequencyDuration
      plans {
        ...CouponPlansForCustomer
      }
      billableMetrics {
        ...CouponBillableMetricsForCustomer
      }
      ...CouponCaption
    }
  }
}
    ${CouponPlansForCustomerFragmentDoc}
${CouponBillableMetricsForCustomerFragmentDoc}
${CouponCaptionFragmentDoc}`;

/**
 * __useGetCouponForCustomerQuery__
 *
 * To run a query within a React component, call `useGetCouponForCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForCustomerQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCouponForCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
      }
export function useGetCouponForCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export function useGetCouponForCustomerSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export type GetCouponForCustomerQueryHookResult = ReturnType<typeof useGetCouponForCustomerQuery>;
export type GetCouponForCustomerLazyQueryHookResult = ReturnType<typeof useGetCouponForCustomerLazyQuery>;
export type GetCouponForCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCouponForCustomerSuspenseQuery>;
export type GetCouponForCustomerQueryResult = Apollo.QueryResult<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>;
export const AddCouponDocument = gql`
    mutation addCoupon($input: CreateAppliedCouponInput!) {
  createAppliedCoupon(input: $input) {
    id
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export type AddCouponMutationFn = Apollo.MutationFunction<AddCouponMutation, AddCouponMutationVariables>;

/**
 * __useAddCouponMutation__
 *
 * To run a mutation, you first call `useAddCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCouponMutation, { data, loading, error }] = useAddCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddCouponMutation(baseOptions?: Apollo.MutationHookOptions<AddCouponMutation, AddCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCouponMutation, AddCouponMutationVariables>(AddCouponDocument, options);
      }
export type AddCouponMutationHookResult = ReturnType<typeof useAddCouponMutation>;
export type AddCouponMutationResult = Apollo.MutationResult<AddCouponMutation>;
export type AddCouponMutationOptions = Apollo.BaseMutationOptions<AddCouponMutation, AddCouponMutationVariables>;
export const GetCustomerCouponsDocument = gql`
    query getCustomerCoupons($id: ID!) {
  customer(id: $id) {
    id
    name
    ...CustomerAppliedCoupons
  }
}
    ${CustomerAppliedCouponsFragmentDoc}`;

/**
 * __useGetCustomerCouponsQuery__
 *
 * To run a query within a React component, call `useGetCustomerCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCouponsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerCouponsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
      }
export function useGetCustomerCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export function useGetCustomerCouponsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export type GetCustomerCouponsQueryHookResult = ReturnType<typeof useGetCustomerCouponsQuery>;
export type GetCustomerCouponsLazyQueryHookResult = ReturnType<typeof useGetCustomerCouponsLazyQuery>;
export type GetCustomerCouponsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCouponsSuspenseQuery>;
export type GetCustomerCouponsQueryResult = Apollo.QueryResult<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>;
export const RemoveCouponDocument = gql`
    mutation removeCoupon($input: TerminateAppliedCouponInput!) {
  terminateAppliedCoupon(input: $input) {
    id
  }
}
    `;
export type RemoveCouponMutationFn = Apollo.MutationFunction<RemoveCouponMutation, RemoveCouponMutationVariables>;

/**
 * __useRemoveCouponMutation__
 *
 * To run a mutation, you first call `useRemoveCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCouponMutation, { data, loading, error }] = useRemoveCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveCouponMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCouponMutation, RemoveCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCouponMutation, RemoveCouponMutationVariables>(RemoveCouponDocument, options);
      }
export type RemoveCouponMutationHookResult = ReturnType<typeof useRemoveCouponMutation>;
export type RemoveCouponMutationResult = Apollo.MutationResult<RemoveCouponMutation>;
export type RemoveCouponMutationOptions = Apollo.BaseMutationOptions<RemoveCouponMutation, RemoveCouponMutationVariables>;
export const GetCustomerCreditNotesDocument = gql`
    query getCustomerCreditNotes($customerId: ID!, $page: Int, $limit: Int, $searchTerm: String) {
  customerCreditNotes(
    customerId: $customerId
    page: $page
    limit: $limit
    searchTerm: $searchTerm
  ) {
    ...CreditNotesForList
  }
}
    ${CreditNotesForListFragmentDoc}`;

/**
 * __useGetCustomerCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetCustomerCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCreditNotesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
      }
export function useGetCustomerCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export function useGetCustomerCreditNotesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export type GetCustomerCreditNotesQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesQuery>;
export type GetCustomerCreditNotesLazyQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesLazyQuery>;
export type GetCustomerCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesSuspenseQuery>;
export type GetCustomerCreditNotesQueryResult = Apollo.QueryResult<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>;
export const GetCustomerInvoicesDocument = gql`
    query getCustomerInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
      }
export function useGetCustomerInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export function useGetCustomerInvoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export type GetCustomerInvoicesQueryHookResult = ReturnType<typeof useGetCustomerInvoicesQuery>;
export type GetCustomerInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerInvoicesLazyQuery>;
export type GetCustomerInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInvoicesSuspenseQuery>;
export type GetCustomerInvoicesQueryResult = Apollo.QueryResult<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>;
export const IntegrationsListForCustomerMainInfosDocument = gql`
    query integrationsListForCustomerMainInfos($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        id
        name
        code
      }
      ... on GocardlessProvider {
        id
        name
        code
      }
      ... on AdyenProvider {
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __useIntegrationsListForCustomerMainInfosQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerMainInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerMainInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerMainInfosQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerMainInfosQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
      }
export function useIntegrationsListForCustomerMainInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export function useIntegrationsListForCustomerMainInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export type IntegrationsListForCustomerMainInfosQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosQuery>;
export type IntegrationsListForCustomerMainInfosLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosLazyQuery>;
export type IntegrationsListForCustomerMainInfosSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosSuspenseQuery>;
export type IntegrationsListForCustomerMainInfosQueryResult = Apollo.QueryResult<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>;
export const GetCustomerSettingsDocument = gql`
    query getCustomerSettings($id: ID!) {
  customer(id: $id) {
    id
    invoiceGracePeriod
    netPaymentTerm
    billingConfiguration {
      id
      documentLocale
    }
    ...CustomerAppliedTaxRatesForSettings
    ...EditCustomerVatRate
    ...EditCustomerDocumentLocale
    ...EditCustomerInvoiceGracePeriod
    ...DeleteCustomerGracePeriod
    ...DeleteCustomerDocumentLocale
    ...CustomerForDeleteVatRateDialog
    ...DeleteCustomerNetPaymentTerm
  }
  organization {
    id
    netPaymentTerm
    billingConfiguration {
      id
      invoiceGracePeriod
      documentLocale
    }
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}
${EditCustomerVatRateFragmentDoc}
${EditCustomerDocumentLocaleFragmentDoc}
${EditCustomerInvoiceGracePeriodFragmentDoc}
${DeleteCustomerGracePeriodFragmentDoc}
${DeleteCustomerDocumentLocaleFragmentDoc}
${CustomerForDeleteVatRateDialogFragmentDoc}
${DeleteCustomerNetPaymentTermFragmentDoc}`;

/**
 * __useGetCustomerSettingsQuery__
 *
 * To run a query within a React component, call `useGetCustomerSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
      }
export function useGetCustomerSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export function useGetCustomerSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export type GetCustomerSettingsQueryHookResult = ReturnType<typeof useGetCustomerSettingsQuery>;
export type GetCustomerSettingsLazyQueryHookResult = ReturnType<typeof useGetCustomerSettingsLazyQuery>;
export type GetCustomerSettingsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSettingsSuspenseQuery>;
export type GetCustomerSettingsQueryResult = Apollo.QueryResult<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>;
export const DeleteCustomerDocument = gql`
    mutation deleteCustomer($input: DestroyCustomerInput!) {
  destroyCustomer(input: $input) {
    id
  }
}
    `;
export type DeleteCustomerMutationFn = Apollo.MutationFunction<DeleteCustomerMutation, DeleteCustomerMutationVariables>;

/**
 * __useDeleteCustomerMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerMutation, { data, loading, error }] = useDeleteCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerMutation, DeleteCustomerMutationVariables>(DeleteCustomerDocument, options);
      }
export type DeleteCustomerMutationHookResult = ReturnType<typeof useDeleteCustomerMutation>;
export type DeleteCustomerMutationResult = Apollo.MutationResult<DeleteCustomerMutation>;
export type DeleteCustomerMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>;
export const DeleteCustomerDocumentLocaleDocument = gql`
    mutation deleteCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type DeleteCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;

/**
 * __useDeleteCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerDocumentLocaleMutation, { data, loading, error }] = useDeleteCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>(DeleteCustomerDocumentLocaleDocument, options);
      }
export type DeleteCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useDeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationResult = Apollo.MutationResult<DeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;
export const DeleteCustomerGracePeriodDocument = gql`
    mutation deleteCustomerGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    invoiceGracePeriod
  }
}
    `;
export type DeleteCustomerGracePeriodMutationFn = Apollo.MutationFunction<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;

/**
 * __useDeleteCustomerGracePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerGracePeriodMutation, { data, loading, error }] = useDeleteCustomerGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>(DeleteCustomerGracePeriodDocument, options);
      }
export type DeleteCustomerGracePeriodMutationHookResult = ReturnType<typeof useDeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationResult = Apollo.MutationResult<DeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;
export const DeleteCustomerNetPaymentTermDocument = gql`
    mutation deleteCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...DeleteCustomerNetPaymentTerm
  }
}
    ${DeleteCustomerNetPaymentTermFragmentDoc}`;
export type DeleteCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;

/**
 * __useDeleteCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerNetPaymentTermMutation, { data, loading, error }] = useDeleteCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>(DeleteCustomerNetPaymentTermDocument, options);
      }
export type DeleteCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useDeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationResult = Apollo.MutationResult<DeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;
export const RemoveAppliedTaxRateOnCustomerDocument = gql`
    mutation removeAppliedTaxRateOnCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
  }
}
    `;
export type RemoveAppliedTaxRateOnCustomerMutationFn = Apollo.MutationFunction<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;

/**
 * __useRemoveAppliedTaxRateOnCustomerMutation__
 *
 * To run a mutation, you first call `useRemoveAppliedTaxRateOnCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveAppliedTaxRateOnCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeAppliedTaxRateOnCustomerMutation, { data, loading, error }] = useRemoveAppliedTaxRateOnCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveAppliedTaxRateOnCustomerMutation(baseOptions?: Apollo.MutationHookOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>(RemoveAppliedTaxRateOnCustomerDocument, options);
      }
export type RemoveAppliedTaxRateOnCustomerMutationHookResult = ReturnType<typeof useRemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationResult = Apollo.MutationResult<RemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationOptions = Apollo.BaseMutationOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;
export const UpdateCustomerDocumentLocaleDocument = gql`
    mutation updateCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;

/**
 * __useUpdateCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerDocumentLocaleMutation, { data, loading, error }] = useUpdateCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>(UpdateCustomerDocumentLocaleDocument, options);
      }
export type UpdateCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useUpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationResult = Apollo.MutationResult<UpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;
export const UpdateCustomerInvoiceGracePeriodDocument = gql`
    mutation updateCustomerInvoiceGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    ...EditCustomerInvoiceGracePeriod
  }
}
    ${EditCustomerInvoiceGracePeriodFragmentDoc}`;
export type UpdateCustomerInvoiceGracePeriodMutationFn = Apollo.MutationFunction<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;

/**
 * __useUpdateCustomerInvoiceGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerInvoiceGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerInvoiceGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerInvoiceGracePeriodMutation, { data, loading, error }] = useUpdateCustomerInvoiceGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerInvoiceGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>(UpdateCustomerInvoiceGracePeriodDocument, options);
      }
export type UpdateCustomerInvoiceGracePeriodMutationHookResult = ReturnType<typeof useUpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationResult = Apollo.MutationResult<UpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;
export const GetTaxRatesForEditCustomerDocument = gql`
    query getTaxRatesForEditCustomer($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
      code
    }
  }
}
    `;

/**
 * __useGetTaxRatesForEditCustomerQuery__
 *
 * To run a query within a React component, call `useGetTaxRatesForEditCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxRatesForEditCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxRatesForEditCustomerQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxRatesForEditCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
      }
export function useGetTaxRatesForEditCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export function useGetTaxRatesForEditCustomerSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export type GetTaxRatesForEditCustomerQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerQuery>;
export type GetTaxRatesForEditCustomerLazyQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerLazyQuery>;
export type GetTaxRatesForEditCustomerSuspenseQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerSuspenseQuery>;
export type GetTaxRatesForEditCustomerQueryResult = Apollo.QueryResult<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>;
export const CreateCustomerAppliedTaxDocument = gql`
    mutation createCustomerAppliedTax($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...CustomerAppliedTaxRatesForSettings
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}`;
export type CreateCustomerAppliedTaxMutationFn = Apollo.MutationFunction<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;

/**
 * __useCreateCustomerAppliedTaxMutation__
 *
 * To run a mutation, you first call `useCreateCustomerAppliedTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerAppliedTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerAppliedTaxMutation, { data, loading, error }] = useCreateCustomerAppliedTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerAppliedTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>(CreateCustomerAppliedTaxDocument, options);
      }
export type CreateCustomerAppliedTaxMutationHookResult = ReturnType<typeof useCreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationResult = Apollo.MutationResult<CreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationOptions = Apollo.BaseMutationOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;
export const DownloadCreditNoteDocument = gql`
    mutation downloadCreditNote($input: DownloadCreditNoteInput!) {
  downloadCreditNote(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCreditNoteMutationFn = Apollo.MutationFunction<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;

/**
 * __useDownloadCreditNoteMutation__
 *
 * To run a mutation, you first call `useDownloadCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCreditNoteMutation, { data, loading, error }] = useDownloadCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>(DownloadCreditNoteDocument, options);
      }
export type DownloadCreditNoteMutationHookResult = ReturnType<typeof useDownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationResult = Apollo.MutationResult<DownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationOptions = Apollo.BaseMutationOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;
export const VoidCreditNoteDocument = gql`
    mutation voidCreditNote($input: VoidCreditNoteInput!) {
  voidCreditNote(input: $input) {
    id
  }
}
    `;
export type VoidCreditNoteMutationFn = Apollo.MutationFunction<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;

/**
 * __useVoidCreditNoteMutation__
 *
 * To run a mutation, you first call `useVoidCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidCreditNoteMutation, { data, loading, error }] = useVoidCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>(VoidCreditNoteDocument, options);
      }
export type VoidCreditNoteMutationHookResult = ReturnType<typeof useVoidCreditNoteMutation>;
export type VoidCreditNoteMutationResult = Apollo.MutationResult<VoidCreditNoteMutation>;
export type VoidCreditNoteMutationOptions = Apollo.BaseMutationOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;
export const GetCustomerSubscriptionForListDocument = gql`
    query getCustomerSubscriptionForList($id: ID!) {
  customer(id: $id) {
    id
    subscriptions(status: [active, pending]) {
      id
      plan {
        id
        amountCurrency
      }
      ...SubscriptionItem
    }
  }
}
    ${SubscriptionItemFragmentDoc}`;

/**
 * __useGetCustomerSubscriptionForListQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForListQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
      }
export function useGetCustomerSubscriptionForListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export function useGetCustomerSubscriptionForListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export type GetCustomerSubscriptionForListQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListQuery>;
export type GetCustomerSubscriptionForListLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListLazyQuery>;
export type GetCustomerSubscriptionForListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListSuspenseQuery>;
export type GetCustomerSubscriptionForListQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>;
export const TerminateCustomerSubscriptionDocument = gql`
    mutation terminateCustomerSubscription($input: TerminateSubscriptionInput!) {
  terminateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
    }
  }
}
    `;
export type TerminateCustomerSubscriptionMutationFn = Apollo.MutationFunction<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;

/**
 * __useTerminateCustomerSubscriptionMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerSubscriptionMutation, { data, loading, error }] = useTerminateCustomerSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>(TerminateCustomerSubscriptionDocument, options);
      }
export type TerminateCustomerSubscriptionMutationHookResult = ReturnType<typeof useTerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationResult = Apollo.MutationResult<TerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;
export const GetCustomerSubscriptionForUsageDocument = gql`
    query getCustomerSubscriptionForUsage($id: ID!) {
  customer(id: $id) {
    id
    externalId
    currency
    subscriptions(status: [active, pending]) {
      id
      ...CustomerSubscriptionForUsage
    }
  }
}
    ${CustomerSubscriptionForUsageFragmentDoc}`;

/**
 * __useGetCustomerSubscriptionForUsageQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForUsageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForUsageQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
      }
export function useGetCustomerSubscriptionForUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export function useGetCustomerSubscriptionForUsageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export type GetCustomerSubscriptionForUsageQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageQuery>;
export type GetCustomerSubscriptionForUsageLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageLazyQuery>;
export type GetCustomerSubscriptionForUsageSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageSuspenseQuery>;
export type GetCustomerSubscriptionForUsageQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>;
export const CustomerUsageDocument = gql`
    query customerUsage($customerId: ID!, $subscriptionId: ID!) {
  customerUsage(customerId: $customerId, subscriptionId: $subscriptionId) {
    amountCents
    currency
    fromDatetime
    toDatetime
    chargesUsage {
      units
      amountCents
      charge {
        id
        invoiceDisplayName
      }
      billableMetric {
        id
        code
        name
      }
      filters {
        id
      }
      groupedUsage {
        amountCents
        groupedBy
        eventsCount
        units
        filters {
          id
        }
      }
    }
    ...CustomerUsageForUsageDetails
  }
}
    ${CustomerUsageForUsageDetailsFragmentDoc}`;

/**
 * __useCustomerUsageQuery__
 *
 * To run a query within a React component, call `useCustomerUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useCustomerUsageQuery(baseOptions: Apollo.QueryHookOptions<CustomerUsageQuery, CustomerUsageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerUsageQuery, CustomerUsageQueryVariables>(CustomerUsageDocument, options);
      }
export function useCustomerUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerUsageQuery, CustomerUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerUsageQuery, CustomerUsageQueryVariables>(CustomerUsageDocument, options);
        }
export function useCustomerUsageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CustomerUsageQuery, CustomerUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerUsageQuery, CustomerUsageQueryVariables>(CustomerUsageDocument, options);
        }
export type CustomerUsageQueryHookResult = ReturnType<typeof useCustomerUsageQuery>;
export type CustomerUsageLazyQueryHookResult = ReturnType<typeof useCustomerUsageLazyQuery>;
export type CustomerUsageSuspenseQueryHookResult = ReturnType<typeof useCustomerUsageSuspenseQuery>;
export type CustomerUsageQueryResult = Apollo.QueryResult<CustomerUsageQuery, CustomerUsageQueryVariables>;
export const CreateWebhookEndpointDocument = gql`
    mutation createWebhookEndpoint($input: WebhookEndpointCreateInput!) {
  createWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type CreateWebhookEndpointMutationFn = Apollo.MutationFunction<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;

/**
 * __useCreateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useCreateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createWebhookEndpointMutation, { data, loading, error }] = useCreateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>(CreateWebhookEndpointDocument, options);
      }
export type CreateWebhookEndpointMutationHookResult = ReturnType<typeof useCreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationResult = Apollo.MutationResult<CreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;
export const UpdateWebhookEndpointDocument = gql`
    mutation updateWebhookEndpoint($input: WebhookEndpointUpdateInput!) {
  updateWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type UpdateWebhookEndpointMutationFn = Apollo.MutationFunction<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;

/**
 * __useUpdateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useUpdateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWebhookEndpointMutation, { data, loading, error }] = useUpdateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>(UpdateWebhookEndpointDocument, options);
      }
export type UpdateWebhookEndpointMutationHookResult = ReturnType<typeof useUpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationResult = Apollo.MutationResult<UpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;
export const DeleteWebhookDocument = gql`
    mutation deleteWebhook($input: DestroyWebhookEndpointInput!) {
  destroyWebhookEndpoint(input: $input) {
    id
  }
}
    `;
export type DeleteWebhookMutationFn = Apollo.MutationFunction<DeleteWebhookMutation, DeleteWebhookMutationVariables>;

/**
 * __useDeleteWebhookMutation__
 *
 * To run a mutation, you first call `useDeleteWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWebhookMutation, { data, loading, error }] = useDeleteWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteWebhookMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWebhookMutation, DeleteWebhookMutationVariables>(DeleteWebhookDocument, options);
      }
export type DeleteWebhookMutationHookResult = ReturnType<typeof useDeleteWebhookMutation>;
export type DeleteWebhookMutationResult = Apollo.MutationResult<DeleteWebhookMutation>;
export type DeleteWebhookMutationOptions = Apollo.BaseMutationOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>;
export const RetryWebhookDocument = gql`
    mutation retryWebhook($input: RetryWebhookInput!) {
  retryWebhook(input: $input) {
    id
  }
}
    `;
export type RetryWebhookMutationFn = Apollo.MutationFunction<RetryWebhookMutation, RetryWebhookMutationVariables>;

/**
 * __useRetryWebhookMutation__
 *
 * To run a mutation, you first call `useRetryWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryWebhookMutation, { data, loading, error }] = useRetryWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryWebhookMutation(baseOptions?: Apollo.MutationHookOptions<RetryWebhookMutation, RetryWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryWebhookMutation, RetryWebhookMutationVariables>(RetryWebhookDocument, options);
      }
export type RetryWebhookMutationHookResult = ReturnType<typeof useRetryWebhookMutation>;
export type RetryWebhookMutationResult = Apollo.MutationResult<RetryWebhookMutation>;
export type RetryWebhookMutationOptions = Apollo.BaseMutationOptions<RetryWebhookMutation, RetryWebhookMutationVariables>;
export const GetGrossRevenuesDocument = gql`
    query getGrossRevenues($currency: CurrencyEnum!, $externalCustomerId: String) {
  grossRevenues(currency: $currency, externalCustomerId: $externalCustomerId) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetGrossRevenuesQuery__
 *
 * To run a query within a React component, call `useGetGrossRevenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGrossRevenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGrossRevenuesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *   },
 * });
 */
export function useGetGrossRevenuesQuery(baseOptions: Apollo.QueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
      }
export function useGetGrossRevenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export function useGetGrossRevenuesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export type GetGrossRevenuesQueryHookResult = ReturnType<typeof useGetGrossRevenuesQuery>;
export type GetGrossRevenuesLazyQueryHookResult = ReturnType<typeof useGetGrossRevenuesLazyQuery>;
export type GetGrossRevenuesSuspenseQueryHookResult = ReturnType<typeof useGetGrossRevenuesSuspenseQuery>;
export type GetGrossRevenuesQueryResult = Apollo.QueryResult<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>;
export const GetInvoiceCollectionsDocument = gql`
    query getInvoiceCollections($currency: CurrencyEnum!) {
  invoiceCollections(currency: $currency) {
    collection {
      paymentStatus
      invoicesCount
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetInvoiceCollectionsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCollectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCollectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCollectionsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoiceCollectionsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
      }
export function useGetInvoiceCollectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export function useGetInvoiceCollectionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export type GetInvoiceCollectionsQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsQuery>;
export type GetInvoiceCollectionsLazyQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsLazyQuery>;
export type GetInvoiceCollectionsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsSuspenseQuery>;
export type GetInvoiceCollectionsQueryResult = Apollo.QueryResult<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>;
export const GetMrrDocument = gql`
    query getMrr($currency: CurrencyEnum!) {
  mrrs(currency: $currency) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetMrrQuery__
 *
 * To run a query within a React component, call `useGetMrrQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMrrQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMrrQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetMrrQuery(baseOptions: Apollo.QueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
      }
export function useGetMrrLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export function useGetMrrSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export type GetMrrQueryHookResult = ReturnType<typeof useGetMrrQuery>;
export type GetMrrLazyQueryHookResult = ReturnType<typeof useGetMrrLazyQuery>;
export type GetMrrSuspenseQueryHookResult = ReturnType<typeof useGetMrrSuspenseQuery>;
export type GetMrrQueryResult = Apollo.QueryResult<GetMrrQuery, GetMrrQueryVariables>;
export const GetInvoicedUsagesDocument = gql`
    query getInvoicedUsages($currency: CurrencyEnum!) {
  invoicedUsages(currency: $currency) {
    collection {
      amountCents
      month
      currency
      code
    }
  }
}
    `;

/**
 * __useGetInvoicedUsagesQuery__
 *
 * To run a query within a React component, call `useGetInvoicedUsagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicedUsagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicedUsagesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoicedUsagesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
      }
export function useGetInvoicedUsagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export function useGetInvoicedUsagesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export type GetInvoicedUsagesQueryHookResult = ReturnType<typeof useGetInvoicedUsagesQuery>;
export type GetInvoicedUsagesLazyQueryHookResult = ReturnType<typeof useGetInvoicedUsagesLazyQuery>;
export type GetInvoicedUsagesSuspenseQueryHookResult = ReturnType<typeof useGetInvoicedUsagesSuspenseQuery>;
export type GetInvoicedUsagesQueryResult = Apollo.QueryResult<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>;
export const UpdateInvoiceMetadataDocument = gql`
    mutation updateInvoiceMetadata($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceMetadatasForMetadataDrawer
  }
}
    ${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;
export type UpdateInvoiceMetadataMutationFn = Apollo.MutationFunction<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;

/**
 * __useUpdateInvoiceMetadataMutation__
 *
 * To run a mutation, you first call `useUpdateInvoiceMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoiceMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoiceMetadataMutation, { data, loading, error }] = useUpdateInvoiceMetadataMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoiceMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>(UpdateInvoiceMetadataDocument, options);
      }
export type UpdateInvoiceMetadataMutationHookResult = ReturnType<typeof useUpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationResult = Apollo.MutationResult<UpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationOptions = Apollo.BaseMutationOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;
export const DisputeInvoiceDocument = gql`
    mutation disputeInvoice($input: LoseInvoiceDisputeInput!) {
  loseInvoiceDispute(input: $input) {
    id
    status
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type DisputeInvoiceMutationFn = Apollo.MutationFunction<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;

/**
 * __useDisputeInvoiceMutation__
 *
 * To run a mutation, you first call `useDisputeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDisputeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [disputeInvoiceMutation, { data, loading, error }] = useDisputeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDisputeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>(DisputeInvoiceDocument, options);
      }
export type DisputeInvoiceMutationHookResult = ReturnType<typeof useDisputeInvoiceMutation>;
export type DisputeInvoiceMutationResult = Apollo.MutationResult<DisputeInvoiceMutation>;
export type DisputeInvoiceMutationOptions = Apollo.BaseMutationOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;
export const GetTaxesForInvoiceEditTaxDialogDocument = gql`
    query getTaxesForInvoiceEditTaxDialog($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForInvoiceEditTaxDialog
    }
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;

/**
 * __useGetTaxesForInvoiceEditTaxDialogQuery__
 *
 * To run a query within a React component, call `useGetTaxesForInvoiceEditTaxDialogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForInvoiceEditTaxDialogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForInvoiceEditTaxDialogQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForInvoiceEditTaxDialogQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
      }
export function useGetTaxesForInvoiceEditTaxDialogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export function useGetTaxesForInvoiceEditTaxDialogSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export type GetTaxesForInvoiceEditTaxDialogQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogQuery>;
export type GetTaxesForInvoiceEditTaxDialogLazyQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogLazyQuery>;
export type GetTaxesForInvoiceEditTaxDialogSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogSuspenseQuery>;
export type GetTaxesForInvoiceEditTaxDialogQueryResult = Apollo.QueryResult<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>;
export const UpdateInvoicePaymentStatusDocument = gql`
    mutation updateInvoicePaymentStatus($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceForUpdateInvoicePaymentStatus
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}
${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type UpdateInvoicePaymentStatusMutationFn = Apollo.MutationFunction<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;

/**
 * __useUpdateInvoicePaymentStatusMutation__
 *
 * To run a mutation, you first call `useUpdateInvoicePaymentStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoicePaymentStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoicePaymentStatusMutation, { data, loading, error }] = useUpdateInvoicePaymentStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoicePaymentStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>(UpdateInvoicePaymentStatusDocument, options);
      }
export type UpdateInvoicePaymentStatusMutationHookResult = ReturnType<typeof useUpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationResult = Apollo.MutationResult<UpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationOptions = Apollo.BaseMutationOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;
export const FinalizeInvoiceDocument = gql`
    mutation finalizeInvoice($input: FinalizeInvoiceInput!) {
  finalizeInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type FinalizeInvoiceMutationFn = Apollo.MutationFunction<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;

/**
 * __useFinalizeInvoiceMutation__
 *
 * To run a mutation, you first call `useFinalizeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinalizeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finalizeInvoiceMutation, { data, loading, error }] = useFinalizeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFinalizeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>(FinalizeInvoiceDocument, options);
      }
export type FinalizeInvoiceMutationHookResult = ReturnType<typeof useFinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationResult = Apollo.MutationResult<FinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationOptions = Apollo.BaseMutationOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;
export const DownloadInvoiceItemDocument = gql`
    mutation downloadInvoiceItem($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceItemMutationFn = Apollo.MutationFunction<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;

/**
 * __useDownloadInvoiceItemMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceItemMutation, { data, loading, error }] = useDownloadInvoiceItemMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceItemMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>(DownloadInvoiceItemDocument, options);
      }
export type DownloadInvoiceItemMutationHookResult = ReturnType<typeof useDownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationResult = Apollo.MutationResult<DownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;
export const RetryInvoicePaymentDocument = gql`
    mutation retryInvoicePayment($input: RetryInvoicePaymentInput!) {
  retryInvoicePayment(input: $input) {
    id
    ...InvoiceListItem
  }
}
    ${InvoiceListItemFragmentDoc}`;
export type RetryInvoicePaymentMutationFn = Apollo.MutationFunction<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;

/**
 * __useRetryInvoicePaymentMutation__
 *
 * To run a mutation, you first call `useRetryInvoicePaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryInvoicePaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryInvoicePaymentMutation, { data, loading, error }] = useRetryInvoicePaymentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryInvoicePaymentMutation(baseOptions?: Apollo.MutationHookOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>(RetryInvoicePaymentDocument, options);
      }
export type RetryInvoicePaymentMutationHookResult = ReturnType<typeof useRetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationResult = Apollo.MutationResult<RetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationOptions = Apollo.BaseMutationOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;
export const VoidInvoiceDocument = gql`
    mutation voidInvoice($input: VoidInvoiceInput!) {
  voidInvoice(input: $input) {
    id
    status
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type VoidInvoiceMutationFn = Apollo.MutationFunction<VoidInvoiceMutation, VoidInvoiceMutationVariables>;

/**
 * __useVoidInvoiceMutation__
 *
 * To run a mutation, you first call `useVoidInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidInvoiceMutation, { data, loading, error }] = useVoidInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidInvoiceMutation, VoidInvoiceMutationVariables>(VoidInvoiceDocument, options);
      }
export type VoidInvoiceMutationHookResult = ReturnType<typeof useVoidInvoiceMutation>;
export type VoidInvoiceMutationResult = Apollo.MutationResult<VoidInvoiceMutation>;
export type VoidInvoiceMutationOptions = Apollo.BaseMutationOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>;
export const DestroyAdjustedFeeDocument = gql`
    mutation destroyAdjustedFee($input: DestroyAdjustedFeeInput!) {
  destroyAdjustedFee(input: $input) {
    id
  }
}
    `;
export type DestroyAdjustedFeeMutationFn = Apollo.MutationFunction<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;

/**
 * __useDestroyAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useDestroyAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyAdjustedFeeMutation, { data, loading, error }] = useDestroyAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>(DestroyAdjustedFeeDocument, options);
      }
export type DestroyAdjustedFeeMutationHookResult = ReturnType<typeof useDestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationResult = Apollo.MutationResult<DestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;
export const CreateAdjustedFeeDocument = gql`
    mutation createAdjustedFee($input: CreateAdjustedFeeInput!) {
  createAdjustedFee(input: $input) {
    id
  }
}
    `;
export type CreateAdjustedFeeMutationFn = Apollo.MutationFunction<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;

/**
 * __useCreateAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useCreateAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAdjustedFeeMutation, { data, loading, error }] = useCreateAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>(CreateAdjustedFeeDocument, options);
      }
export type CreateAdjustedFeeMutationHookResult = ReturnType<typeof useCreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationResult = Apollo.MutationResult<CreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;
export const GetTaxesForChargesDocument = gql`
    query getTaxesForCharges($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanChargeAccordion
    }
  }
}
    ${TaxForPlanChargeAccordionFragmentDoc}`;

/**
 * __useGetTaxesForChargesQuery__
 *
 * To run a query within a React component, call `useGetTaxesForChargesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForChargesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForChargesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForChargesQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
      }
export function useGetTaxesForChargesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
        }
export function useGetTaxesForChargesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
        }
export type GetTaxesForChargesQueryHookResult = ReturnType<typeof useGetTaxesForChargesQuery>;
export type GetTaxesForChargesLazyQueryHookResult = ReturnType<typeof useGetTaxesForChargesLazyQuery>;
export type GetTaxesForChargesSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForChargesSuspenseQuery>;
export type GetTaxesForChargesQueryResult = Apollo.QueryResult<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>;
export const GetMeteredBillableMetricsDocument = gql`
    query getMeteredBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: false
  ) {
    collection {
      id
      ...BillableMetricForChargeSection
    }
  }
}
    ${BillableMetricForChargeSectionFragmentDoc}`;

/**
 * __useGetMeteredBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetMeteredBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMeteredBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMeteredBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetMeteredBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
      }
export function useGetMeteredBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export function useGetMeteredBillableMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export type GetMeteredBillableMetricsQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsQuery>;
export type GetMeteredBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsLazyQuery>;
export type GetMeteredBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsSuspenseQuery>;
export type GetMeteredBillableMetricsQueryResult = Apollo.QueryResult<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>;
export const GetRecurringBillableMetricsDocument = gql`
    query getRecurringBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: true
  ) {
    collection {
      id
      ...BillableMetricForChargeSection
    }
  }
}
    ${BillableMetricForChargeSectionFragmentDoc}`;

/**
 * __useGetRecurringBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetRecurringBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRecurringBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRecurringBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetRecurringBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
      }
export function useGetRecurringBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export function useGetRecurringBillableMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export type GetRecurringBillableMetricsQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsQuery>;
export type GetRecurringBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsLazyQuery>;
export type GetRecurringBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsSuspenseQuery>;
export type GetRecurringBillableMetricsQueryResult = Apollo.QueryResult<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>;
export const GetTaxesForCommitmentsDocument = gql`
    query getTaxesForCommitments($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanChargeAccordion
    }
  }
}
    ${TaxForPlanChargeAccordionFragmentDoc}`;

/**
 * __useGetTaxesForCommitmentsQuery__
 *
 * To run a query within a React component, call `useGetTaxesForCommitmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForCommitmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForCommitmentsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForCommitmentsQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
      }
export function useGetTaxesForCommitmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export function useGetTaxesForCommitmentsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export type GetTaxesForCommitmentsQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsQuery>;
export type GetTaxesForCommitmentsLazyQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsLazyQuery>;
export type GetTaxesForCommitmentsSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsSuspenseQuery>;
export type GetTaxesForCommitmentsQueryResult = Apollo.QueryResult<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>;
export const DeletePlanDocument = gql`
    mutation deletePlan($input: DestroyPlanInput!) {
  destroyPlan(input: $input) {
    id
  }
}
    `;
export type DeletePlanMutationFn = Apollo.MutationFunction<DeletePlanMutation, DeletePlanMutationVariables>;

/**
 * __useDeletePlanMutation__
 *
 * To run a mutation, you first call `useDeletePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePlanMutation, { data, loading, error }] = useDeletePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeletePlanMutation(baseOptions?: Apollo.MutationHookOptions<DeletePlanMutation, DeletePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePlanMutation, DeletePlanMutationVariables>(DeletePlanDocument, options);
      }
export type DeletePlanMutationHookResult = ReturnType<typeof useDeletePlanMutation>;
export type DeletePlanMutationResult = Apollo.MutationResult<DeletePlanMutation>;
export type DeletePlanMutationOptions = Apollo.BaseMutationOptions<DeletePlanMutation, DeletePlanMutationVariables>;
export const GetTaxesForPlanDocument = gql`
    query getTaxesForPlan($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanSettingsSection
    }
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;

/**
 * __useGetTaxesForPlanQuery__
 *
 * To run a query within a React component, call `useGetTaxesForPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForPlanQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForPlanQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
      }
export function useGetTaxesForPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export function useGetTaxesForPlanSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export type GetTaxesForPlanQueryHookResult = ReturnType<typeof useGetTaxesForPlanQuery>;
export type GetTaxesForPlanLazyQueryHookResult = ReturnType<typeof useGetTaxesForPlanLazyQuery>;
export type GetTaxesForPlanSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForPlanSuspenseQuery>;
export type GetTaxesForPlanQueryResult = Apollo.QueryResult<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>;
export const GetPlanForDetailsOverviewSectionDocument = gql`
    query getPlanForDetailsOverviewSection($plan: ID!) {
  plan(id: $plan) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetPlanForDetailsOverviewSectionQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsOverviewSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsOverviewSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsOverviewSectionQuery({
 *   variables: {
 *      plan: // value for 'plan'
 *   },
 * });
 */
export function useGetPlanForDetailsOverviewSectionQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
      }
export function useGetPlanForDetailsOverviewSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export function useGetPlanForDetailsOverviewSectionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export type GetPlanForDetailsOverviewSectionQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionQuery>;
export type GetPlanForDetailsOverviewSectionLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionLazyQuery>;
export type GetPlanForDetailsOverviewSectionSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionSuspenseQuery>;
export type GetPlanForDetailsOverviewSectionQueryResult = Apollo.QueryResult<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>;
export const GetSubscribtionsForPlanDetailsDocument = gql`
    query getSubscribtionsForPlanDetails($page: Int, $limit: Int, $planCode: String, $status: [StatusTypeEnum!]) {
  subscriptions(page: $page, limit: $limit, planCode: $planCode, status: $status) {
    collection {
      id
      ...PlanSubscriptionListItemForSubscriptionList
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${PlanSubscriptionListItemForSubscriptionListFragmentDoc}`;

/**
 * __useGetSubscribtionsForPlanDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscribtionsForPlanDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscribtionsForPlanDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscribtionsForPlanDetailsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      planCode: // value for 'planCode'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetSubscribtionsForPlanDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
      }
export function useGetSubscribtionsForPlanDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export function useGetSubscribtionsForPlanDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export type GetSubscribtionsForPlanDetailsQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsQuery>;
export type GetSubscribtionsForPlanDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsLazyQuery>;
export type GetSubscribtionsForPlanDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsSuspenseQuery>;
export type GetSubscribtionsForPlanDetailsQueryResult = Apollo.QueryResult<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>;
export const GetTaxRatesForEditOrgaDocument = gql`
    query getTaxRatesForEditOrga($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
    }
  }
}
    `;

/**
 * __useGetTaxRatesForEditOrgaQuery__
 *
 * To run a query within a React component, call `useGetTaxRatesForEditOrgaQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxRatesForEditOrgaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxRatesForEditOrgaQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxRatesForEditOrgaQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
      }
export function useGetTaxRatesForEditOrgaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
        }
export function useGetTaxRatesForEditOrgaSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
        }
export type GetTaxRatesForEditOrgaQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaQuery>;
export type GetTaxRatesForEditOrgaLazyQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaLazyQuery>;
export type GetTaxRatesForEditOrgaSuspenseQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaSuspenseQuery>;
export type GetTaxRatesForEditOrgaQueryResult = Apollo.QueryResult<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>;
export const AssignTaxRateToOrganizationDocument = gql`
    mutation assignTaxRateToOrganization($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    id
  }
}
    `;
export type AssignTaxRateToOrganizationMutationFn = Apollo.MutationFunction<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>;

/**
 * __useAssignTaxRateToOrganizationMutation__
 *
 * To run a mutation, you first call `useAssignTaxRateToOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignTaxRateToOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignTaxRateToOrganizationMutation, { data, loading, error }] = useAssignTaxRateToOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAssignTaxRateToOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>(AssignTaxRateToOrganizationDocument, options);
      }
export type AssignTaxRateToOrganizationMutationHookResult = ReturnType<typeof useAssignTaxRateToOrganizationMutation>;
export type AssignTaxRateToOrganizationMutationResult = Apollo.MutationResult<AssignTaxRateToOrganizationMutation>;
export type AssignTaxRateToOrganizationMutationOptions = Apollo.BaseMutationOptions<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>;
export const UnassignTaxRateToOrganizationDocument = gql`
    mutation unassignTaxRateToOrganization($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    id
    ...DeleteOrganizationVatRate
  }
}
    ${DeleteOrganizationVatRateFragmentDoc}`;
export type UnassignTaxRateToOrganizationMutationFn = Apollo.MutationFunction<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>;

/**
 * __useUnassignTaxRateToOrganizationMutation__
 *
 * To run a mutation, you first call `useUnassignTaxRateToOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnassignTaxRateToOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unassignTaxRateToOrganizationMutation, { data, loading, error }] = useUnassignTaxRateToOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUnassignTaxRateToOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>(UnassignTaxRateToOrganizationDocument, options);
      }
export type UnassignTaxRateToOrganizationMutationHookResult = ReturnType<typeof useUnassignTaxRateToOrganizationMutation>;
export type UnassignTaxRateToOrganizationMutationResult = Apollo.MutationResult<UnassignTaxRateToOrganizationMutation>;
export type UnassignTaxRateToOrganizationMutationOptions = Apollo.BaseMutationOptions<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>;
export const UpdateOrganizationDefaultCurrencyDocument = gql`
    mutation updateOrganizationDefaultCurrency($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationDefaultCurrencyForDialog
  }
}
    ${EditOrganizationDefaultCurrencyForDialogFragmentDoc}`;
export type UpdateOrganizationDefaultCurrencyMutationFn = Apollo.MutationFunction<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>;

/**
 * __useUpdateOrganizationDefaultCurrencyMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationDefaultCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationDefaultCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationDefaultCurrencyMutation, { data, loading, error }] = useUpdateOrganizationDefaultCurrencyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationDefaultCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>(UpdateOrganizationDefaultCurrencyDocument, options);
      }
export type UpdateOrganizationDefaultCurrencyMutationHookResult = ReturnType<typeof useUpdateOrganizationDefaultCurrencyMutation>;
export type UpdateOrganizationDefaultCurrencyMutationResult = Apollo.MutationResult<UpdateOrganizationDefaultCurrencyMutation>;
export type UpdateOrganizationDefaultCurrencyMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>;
export const UpdateCustomerNetPaymentTermDocument = gql`
    mutation updateCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...EditCustomerNetPaymentTermForDialog
  }
}
    ${EditCustomerNetPaymentTermForDialogFragmentDoc}`;
export type UpdateCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;

/**
 * __useUpdateCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerNetPaymentTermMutation, { data, loading, error }] = useUpdateCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>(UpdateCustomerNetPaymentTermDocument, options);
      }
export type UpdateCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationResult = Apollo.MutationResult<UpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;
export const UpdateOrganizationNetPaymentTermDocument = gql`
    mutation updateOrganizationNetPaymentTerm($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationNetPaymentTermForDialog
  }
}
    ${EditOrganizationNetPaymentTermForDialogFragmentDoc}`;
export type UpdateOrganizationNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>;

/**
 * __useUpdateOrganizationNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationNetPaymentTermMutation, { data, loading, error }] = useUpdateOrganizationNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>(UpdateOrganizationNetPaymentTermDocument, options);
      }
export type UpdateOrganizationNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateOrganizationNetPaymentTermMutation>;
export type UpdateOrganizationNetPaymentTermMutationResult = Apollo.MutationResult<UpdateOrganizationNetPaymentTermMutation>;
export type UpdateOrganizationNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>;
export const UpdateDocumentLocaleOrganizationDocument = gql`
    mutation updateDocumentLocaleOrganization($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateDocumentLocaleOrganizationMutationFn = Apollo.MutationFunction<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>;

/**
 * __useUpdateDocumentLocaleOrganizationMutation__
 *
 * To run a mutation, you first call `useUpdateDocumentLocaleOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDocumentLocaleOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDocumentLocaleOrganizationMutation, { data, loading, error }] = useUpdateDocumentLocaleOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDocumentLocaleOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>(UpdateDocumentLocaleOrganizationDocument, options);
      }
export type UpdateDocumentLocaleOrganizationMutationHookResult = ReturnType<typeof useUpdateDocumentLocaleOrganizationMutation>;
export type UpdateDocumentLocaleOrganizationMutationResult = Apollo.MutationResult<UpdateDocumentLocaleOrganizationMutation>;
export type UpdateDocumentLocaleOrganizationMutationOptions = Apollo.BaseMutationOptions<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>;
export const UpdateOrganizationGracePeriodDocument = gql`
    mutation updateOrganizationGracePeriod($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    billingConfiguration {
      id
      invoiceGracePeriod
    }
  }
}
    `;
export type UpdateOrganizationGracePeriodMutationFn = Apollo.MutationFunction<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>;

/**
 * __useUpdateOrganizationGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationGracePeriodMutation, { data, loading, error }] = useUpdateOrganizationGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>(UpdateOrganizationGracePeriodDocument, options);
      }
export type UpdateOrganizationGracePeriodMutationHookResult = ReturnType<typeof useUpdateOrganizationGracePeriodMutation>;
export type UpdateOrganizationGracePeriodMutationResult = Apollo.MutationResult<UpdateOrganizationGracePeriodMutation>;
export type UpdateOrganizationGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>;
export const UpdateOrganizationInformationsDocument = gql`
    mutation updateOrganizationInformations($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    ...OrganizationInformations
    ...EditOrganizationInformationsDialog
  }
}
    ${OrganizationInformationsFragmentDoc}
${EditOrganizationInformationsDialogFragmentDoc}`;
export type UpdateOrganizationInformationsMutationFn = Apollo.MutationFunction<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>;

/**
 * __useUpdateOrganizationInformationsMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInformationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInformationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInformationsMutation, { data, loading, error }] = useUpdateOrganizationInformationsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInformationsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>(UpdateOrganizationInformationsDocument, options);
      }
export type UpdateOrganizationInformationsMutationHookResult = ReturnType<typeof useUpdateOrganizationInformationsMutation>;
export type UpdateOrganizationInformationsMutationResult = Apollo.MutationResult<UpdateOrganizationInformationsMutation>;
export type UpdateOrganizationInformationsMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>;
export const UpdateOrganizationInvoiceNumberingDocument = gql`
    mutation updateOrganizationInvoiceNumbering($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationInvoiceNumberingDialog
  }
}
    ${EditOrganizationInvoiceNumberingDialogFragmentDoc}`;
export type UpdateOrganizationInvoiceNumberingMutationFn = Apollo.MutationFunction<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>;

/**
 * __useUpdateOrganizationInvoiceNumberingMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInvoiceNumberingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInvoiceNumberingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInvoiceNumberingMutation, { data, loading, error }] = useUpdateOrganizationInvoiceNumberingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInvoiceNumberingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>(UpdateOrganizationInvoiceNumberingDocument, options);
      }
export type UpdateOrganizationInvoiceNumberingMutationHookResult = ReturnType<typeof useUpdateOrganizationInvoiceNumberingMutation>;
export type UpdateOrganizationInvoiceNumberingMutationResult = Apollo.MutationResult<UpdateOrganizationInvoiceNumberingMutation>;
export type UpdateOrganizationInvoiceNumberingMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>;
export const UpdateOrganizationInvoiceTemplateDocument = gql`
    mutation updateOrganizationInvoiceTemplate($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationInvoiceTemplateDialog
  }
}
    ${EditOrganizationInvoiceTemplateDialogFragmentDoc}`;
export type UpdateOrganizationInvoiceTemplateMutationFn = Apollo.MutationFunction<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>;

/**
 * __useUpdateOrganizationInvoiceTemplateMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInvoiceTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInvoiceTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInvoiceTemplateMutation, { data, loading, error }] = useUpdateOrganizationInvoiceTemplateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInvoiceTemplateMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>(UpdateOrganizationInvoiceTemplateDocument, options);
      }
export type UpdateOrganizationInvoiceTemplateMutationHookResult = ReturnType<typeof useUpdateOrganizationInvoiceTemplateMutation>;
export type UpdateOrganizationInvoiceTemplateMutationResult = Apollo.MutationResult<UpdateOrganizationInvoiceTemplateMutation>;
export type UpdateOrganizationInvoiceTemplateMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>;
export const UpdateOrganizationTimezoneDocument = gql`
    mutation updateOrganizationTimezone($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    timezone
  }
}
    `;
export type UpdateOrganizationTimezoneMutationFn = Apollo.MutationFunction<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>;

/**
 * __useUpdateOrganizationTimezoneMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationTimezoneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationTimezoneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationTimezoneMutation, { data, loading, error }] = useUpdateOrganizationTimezoneMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationTimezoneMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>(UpdateOrganizationTimezoneDocument, options);
      }
export type UpdateOrganizationTimezoneMutationHookResult = ReturnType<typeof useUpdateOrganizationTimezoneMutation>;
export type UpdateOrganizationTimezoneMutationResult = Apollo.MutationResult<UpdateOrganizationTimezoneMutation>;
export type UpdateOrganizationTimezoneMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>;
export const UpdateOrganizationLogoDocument = gql`
    mutation updateOrganizationLogo($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    logoUrl
  }
}
    `;
export type UpdateOrganizationLogoMutationFn = Apollo.MutationFunction<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>;

/**
 * __useUpdateOrganizationLogoMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationLogoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationLogoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationLogoMutation, { data, loading, error }] = useUpdateOrganizationLogoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationLogoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>(UpdateOrganizationLogoDocument, options);
      }
export type UpdateOrganizationLogoMutationHookResult = ReturnType<typeof useUpdateOrganizationLogoMutation>;
export type UpdateOrganizationLogoMutationResult = Apollo.MutationResult<UpdateOrganizationLogoMutation>;
export type UpdateOrganizationLogoMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>;
export const GetProviderByCodeForAdyenDocument = gql`
    query getProviderByCodeForAdyen($code: String) {
  paymentProvider(code: $code) {
    ... on AdyenProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on StripeProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForAdyenQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForAdyenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForAdyenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForAdyenQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForAdyenQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
      }
export function useGetProviderByCodeForAdyenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export function useGetProviderByCodeForAdyenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export type GetProviderByCodeForAdyenQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenQuery>;
export type GetProviderByCodeForAdyenLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenLazyQuery>;
export type GetProviderByCodeForAdyenSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenSuspenseQuery>;
export type GetProviderByCodeForAdyenQueryResult = Apollo.QueryResult<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>;
export const AddAdyenApiKeyDocument = gql`
    mutation addAdyenApiKey($input: AddAdyenPaymentProviderInput!) {
  addAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type AddAdyenApiKeyMutationFn = Apollo.MutationFunction<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;

/**
 * __useAddAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useAddAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAdyenApiKeyMutation, { data, loading, error }] = useAddAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>(AddAdyenApiKeyDocument, options);
      }
export type AddAdyenApiKeyMutationHookResult = ReturnType<typeof useAddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationResult = Apollo.MutationResult<AddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;
export const UpdateAdyenApiKeyDocument = gql`
    mutation updateAdyenApiKey($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type UpdateAdyenApiKeyMutationFn = Apollo.MutationFunction<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;

/**
 * __useUpdateAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenApiKeyMutation, { data, loading, error }] = useUpdateAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>(UpdateAdyenApiKeyDocument, options);
      }
export type UpdateAdyenApiKeyMutationHookResult = ReturnType<typeof useUpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationResult = Apollo.MutationResult<UpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;
export const UpdateAdyenPaymentProviderDocument = gql`
    mutation updateAdyenPaymentProvider($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateAdyenPaymentProviderMutationFn = Apollo.MutationFunction<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;

/**
 * __useUpdateAdyenPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenPaymentProviderMutation, { data, loading, error }] = useUpdateAdyenPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>(UpdateAdyenPaymentProviderDocument, options);
      }
export type UpdateAdyenPaymentProviderMutationHookResult = ReturnType<typeof useUpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationResult = Apollo.MutationResult<UpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;
export const UpdateGocardlessPaymentProviderDocument = gql`
    mutation updateGocardlessPaymentProvider($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateGocardlessPaymentProviderMutationFn = Apollo.MutationFunction<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;

/**
 * __useUpdateGocardlessPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessPaymentProviderMutation, { data, loading, error }] = useUpdateGocardlessPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>(UpdateGocardlessPaymentProviderDocument, options);
      }
export type UpdateGocardlessPaymentProviderMutationHookResult = ReturnType<typeof useUpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationResult = Apollo.MutationResult<UpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;
export const UpdateStripePaymentProviderDocument = gql`
    mutation updateStripePaymentProvider($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateStripePaymentProviderMutationFn = Apollo.MutationFunction<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;

/**
 * __useUpdateStripePaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateStripePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripePaymentProviderMutation, { data, loading, error }] = useUpdateStripePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>(UpdateStripePaymentProviderDocument, options);
      }
export type UpdateStripePaymentProviderMutationHookResult = ReturnType<typeof useUpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationResult = Apollo.MutationResult<UpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;
export const GetProviderByCodeForGocardlessDocument = gql`
    query getProviderByCodeForGocardless($code: String) {
  paymentProvider(code: $code) {
    ... on GocardlessProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on StripeProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForGocardlessQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForGocardlessQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForGocardlessQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForGocardlessQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForGocardlessQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
      }
export function useGetProviderByCodeForGocardlessLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export function useGetProviderByCodeForGocardlessSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export type GetProviderByCodeForGocardlessQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessQuery>;
export type GetProviderByCodeForGocardlessLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessLazyQuery>;
export type GetProviderByCodeForGocardlessSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessSuspenseQuery>;
export type GetProviderByCodeForGocardlessQueryResult = Apollo.QueryResult<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>;
export const UpdateGocardlessApiKeyDocument = gql`
    mutation updateGocardlessApiKey($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationDetails
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationDetailsFragmentDoc}`;
export type UpdateGocardlessApiKeyMutationFn = Apollo.MutationFunction<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;

/**
 * __useUpdateGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessApiKeyMutation, { data, loading, error }] = useUpdateGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>(UpdateGocardlessApiKeyDocument, options);
      }
export type UpdateGocardlessApiKeyMutationHookResult = ReturnType<typeof useUpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationResult = Apollo.MutationResult<UpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;
export const UpdateOrgaForLagoTaxManagementDocument = gql`
    mutation updateOrgaForLagoTaxManagement($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
  }
}
    `;
export type UpdateOrgaForLagoTaxManagementMutationFn = Apollo.MutationFunction<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>;

/**
 * __useUpdateOrgaForLagoTaxManagementMutation__
 *
 * To run a mutation, you first call `useUpdateOrgaForLagoTaxManagementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrgaForLagoTaxManagementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrgaForLagoTaxManagementMutation, { data, loading, error }] = useUpdateOrgaForLagoTaxManagementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrgaForLagoTaxManagementMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>(UpdateOrgaForLagoTaxManagementDocument, options);
      }
export type UpdateOrgaForLagoTaxManagementMutationHookResult = ReturnType<typeof useUpdateOrgaForLagoTaxManagementMutation>;
export type UpdateOrgaForLagoTaxManagementMutationResult = Apollo.MutationResult<UpdateOrgaForLagoTaxManagementMutation>;
export type UpdateOrgaForLagoTaxManagementMutationOptions = Apollo.BaseMutationOptions<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>;
export const GetProviderByCodeForStripeDocument = gql`
    query getProviderByCodeForStripe($code: String) {
  paymentProvider(code: $code) {
    ... on StripeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForStripeQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForStripeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForStripeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForStripeQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForStripeQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
      }
export function useGetProviderByCodeForStripeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export function useGetProviderByCodeForStripeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export type GetProviderByCodeForStripeQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeQuery>;
export type GetProviderByCodeForStripeLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeLazyQuery>;
export type GetProviderByCodeForStripeSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeSuspenseQuery>;
export type GetProviderByCodeForStripeQueryResult = Apollo.QueryResult<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>;
export const AddStripeApiKeyDocument = gql`
    mutation addStripeApiKey($input: AddStripePaymentProviderInput!) {
  addStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type AddStripeApiKeyMutationFn = Apollo.MutationFunction<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;

/**
 * __useAddStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useAddStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addStripeApiKeyMutation, { data, loading, error }] = useAddStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>(AddStripeApiKeyDocument, options);
      }
export type AddStripeApiKeyMutationHookResult = ReturnType<typeof useAddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationResult = Apollo.MutationResult<AddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;
export const UpdateStripeApiKeyDocument = gql`
    mutation updateStripeApiKey($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type UpdateStripeApiKeyMutationFn = Apollo.MutationFunction<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;

/**
 * __useUpdateStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripeApiKeyMutation, { data, loading, error }] = useUpdateStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>(UpdateStripeApiKeyDocument, options);
      }
export type UpdateStripeApiKeyMutationHookResult = ReturnType<typeof useUpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationResult = Apollo.MutationResult<UpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;
export const DeleteAdyenIntegrationDocument = gql`
    mutation deleteAdyenIntegration($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteAdyenIntegrationMutationFn = Apollo.MutationFunction<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;

/**
 * __useDeleteAdyenIntegrationMutation__
 *
 * To run a mutation, you first call `useDeleteAdyenIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAdyenIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAdyenIntegrationMutation, { data, loading, error }] = useDeleteAdyenIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAdyenIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>(DeleteAdyenIntegrationDocument, options);
      }
export type DeleteAdyenIntegrationMutationHookResult = ReturnType<typeof useDeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationResult = Apollo.MutationResult<DeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationOptions = Apollo.BaseMutationOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;
export const DeleteGocardlessDocument = gql`
    mutation deleteGocardless($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteGocardlessMutationFn = Apollo.MutationFunction<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;

/**
 * __useDeleteGocardlessMutation__
 *
 * To run a mutation, you first call `useDeleteGocardlessMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGocardlessMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGocardlessMutation, { data, loading, error }] = useDeleteGocardlessMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteGocardlessMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>(DeleteGocardlessDocument, options);
      }
export type DeleteGocardlessMutationHookResult = ReturnType<typeof useDeleteGocardlessMutation>;
export type DeleteGocardlessMutationResult = Apollo.MutationResult<DeleteGocardlessMutation>;
export type DeleteGocardlessMutationOptions = Apollo.BaseMutationOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;
export const DeleteStripeDocument = gql`
    mutation deleteStripe($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteStripeMutationFn = Apollo.MutationFunction<DeleteStripeMutation, DeleteStripeMutationVariables>;

/**
 * __useDeleteStripeMutation__
 *
 * To run a mutation, you first call `useDeleteStripeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStripeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStripeMutation, { data, loading, error }] = useDeleteStripeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteStripeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStripeMutation, DeleteStripeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStripeMutation, DeleteStripeMutationVariables>(DeleteStripeDocument, options);
      }
export type DeleteStripeMutationHookResult = ReturnType<typeof useDeleteStripeMutation>;
export type DeleteStripeMutationResult = Apollo.MutationResult<DeleteStripeMutation>;
export type DeleteStripeMutationOptions = Apollo.BaseMutationOptions<DeleteStripeMutation, DeleteStripeMutationVariables>;
export const CreateInviteDocument = gql`
    mutation createInvite($input: CreateInviteInput!) {
  createInvite(input: $input) {
    id
    token
    ...InviteItem
  }
}
    ${InviteItemFragmentDoc}`;
export type CreateInviteMutationFn = Apollo.MutationFunction<CreateInviteMutation, CreateInviteMutationVariables>;

/**
 * __useCreateInviteMutation__
 *
 * To run a mutation, you first call `useCreateInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInviteMutation, { data, loading, error }] = useCreateInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInviteMutation(baseOptions?: Apollo.MutationHookOptions<CreateInviteMutation, CreateInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInviteMutation, CreateInviteMutationVariables>(CreateInviteDocument, options);
      }
export type CreateInviteMutationHookResult = ReturnType<typeof useCreateInviteMutation>;
export type CreateInviteMutationResult = Apollo.MutationResult<CreateInviteMutation>;
export type CreateInviteMutationOptions = Apollo.BaseMutationOptions<CreateInviteMutation, CreateInviteMutationVariables>;
export const RevokeInviteDocument = gql`
    mutation revokeInvite($input: RevokeInviteInput!) {
  revokeInvite(input: $input) {
    id
  }
}
    `;
export type RevokeInviteMutationFn = Apollo.MutationFunction<RevokeInviteMutation, RevokeInviteMutationVariables>;

/**
 * __useRevokeInviteMutation__
 *
 * To run a mutation, you first call `useRevokeInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeInviteMutation, { data, loading, error }] = useRevokeInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeInviteMutation(baseOptions?: Apollo.MutationHookOptions<RevokeInviteMutation, RevokeInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeInviteMutation, RevokeInviteMutationVariables>(RevokeInviteDocument, options);
      }
export type RevokeInviteMutationHookResult = ReturnType<typeof useRevokeInviteMutation>;
export type RevokeInviteMutationResult = Apollo.MutationResult<RevokeInviteMutation>;
export type RevokeInviteMutationOptions = Apollo.BaseMutationOptions<RevokeInviteMutation, RevokeInviteMutationVariables>;
export const RevokeMembershipDocument = gql`
    mutation revokeMembership($input: RevokeMembershipInput!) {
  revokeMembership(input: $input) {
    id
  }
}
    `;
export type RevokeMembershipMutationFn = Apollo.MutationFunction<RevokeMembershipMutation, RevokeMembershipMutationVariables>;

/**
 * __useRevokeMembershipMutation__
 *
 * To run a mutation, you first call `useRevokeMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeMembershipMutation, { data, loading, error }] = useRevokeMembershipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeMembershipMutation(baseOptions?: Apollo.MutationHookOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeMembershipMutation, RevokeMembershipMutationVariables>(RevokeMembershipDocument, options);
      }
export type RevokeMembershipMutationHookResult = ReturnType<typeof useRevokeMembershipMutation>;
export type RevokeMembershipMutationResult = Apollo.MutationResult<RevokeMembershipMutation>;
export type RevokeMembershipMutationOptions = Apollo.BaseMutationOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>;
export const GetSubscriptionForDetailsOverviewDocument = gql`
    query getSubscriptionForDetailsOverview($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    plan {
      id
    }
    ...SubscriptionForSubscriptionInformations
  }
}
    ${SubscriptionForSubscriptionInformationsFragmentDoc}`;

/**
 * __useGetSubscriptionForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsOverviewQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
      }
export function useGetSubscriptionForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export function useGetSubscriptionForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export type GetSubscriptionForDetailsOverviewQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewQuery>;
export type GetSubscriptionForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewLazyQuery>;
export type GetSubscriptionForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewSuspenseQuery>;
export type GetSubscriptionForDetailsOverviewQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>;
export const DeleteTaxDocument = gql`
    mutation deleteTax($input: DestroyTaxInput!) {
  destroyTax(input: $input) {
    id
  }
}
    `;
export type DeleteTaxMutationFn = Apollo.MutationFunction<DeleteTaxMutation, DeleteTaxMutationVariables>;

/**
 * __useDeleteTaxMutation__
 *
 * To run a mutation, you first call `useDeleteTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTaxMutation, { data, loading, error }] = useDeleteTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTaxMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTaxMutation, DeleteTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTaxMutation, DeleteTaxMutationVariables>(DeleteTaxDocument, options);
      }
export type DeleteTaxMutationHookResult = ReturnType<typeof useDeleteTaxMutation>;
export type DeleteTaxMutationResult = Apollo.MutationResult<DeleteTaxMutation>;
export type DeleteTaxMutationOptions = Apollo.BaseMutationOptions<DeleteTaxMutation, DeleteTaxMutationVariables>;
export const GetCustomerWalletListDocument = gql`
    query getCustomerWalletList($customerId: ID!, $page: Int, $limit: Int) {
  wallets(customerId: $customerId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CustomerWallet
    }
  }
}
    ${CustomerWalletFragmentDoc}`;

/**
 * __useGetCustomerWalletListQuery__
 *
 * To run a query within a React component, call `useGetCustomerWalletListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerWalletListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerWalletListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetCustomerWalletListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
      }
export function useGetCustomerWalletListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export function useGetCustomerWalletListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export type GetCustomerWalletListQueryHookResult = ReturnType<typeof useGetCustomerWalletListQuery>;
export type GetCustomerWalletListLazyQueryHookResult = ReturnType<typeof useGetCustomerWalletListLazyQuery>;
export type GetCustomerWalletListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerWalletListSuspenseQuery>;
export type GetCustomerWalletListQueryResult = Apollo.QueryResult<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>;
export const TerminateCustomerWalletDocument = gql`
    mutation terminateCustomerWallet($input: TerminateCustomerWalletInput!) {
  terminateCustomerWallet(input: $input) {
    id
    status
    ...WalletAccordion
    customer {
      id
      hasActiveWallet
    }
  }
}
    ${WalletAccordionFragmentDoc}`;
export type TerminateCustomerWalletMutationFn = Apollo.MutationFunction<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;

/**
 * __useTerminateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerWalletMutation, { data, loading, error }] = useTerminateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>(TerminateCustomerWalletDocument, options);
      }
export type TerminateCustomerWalletMutationHookResult = ReturnType<typeof useTerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationResult = Apollo.MutationResult<TerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;
export const CreateCustomerWalletTransactionDocument = gql`
    mutation createCustomerWalletTransaction($input: CreateCustomerWalletTransactionInput!) {
  createCustomerWalletTransaction(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type CreateCustomerWalletTransactionMutationFn = Apollo.MutationFunction<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;

/**
 * __useCreateCustomerWalletTransactionMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletTransactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletTransactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletTransactionMutation, { data, loading, error }] = useCreateCustomerWalletTransactionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletTransactionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>(CreateCustomerWalletTransactionDocument, options);
      }
export type CreateCustomerWalletTransactionMutationHookResult = ReturnType<typeof useCreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationResult = Apollo.MutationResult<CreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;
export const GetWalletTransactionsDocument = gql`
    query getWalletTransactions($walletId: ID!, $page: Int, $limit: Int) {
  walletTransactions(walletId: $walletId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...WalletTransactionForTransactionListItem
    }
  }
}
    ${WalletTransactionForTransactionListItemFragmentDoc}`;

/**
 * __useGetWalletTransactionsQuery__
 *
 * To run a query within a React component, call `useGetWalletTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletTransactionsQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWalletTransactionsQuery(baseOptions: Apollo.QueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
      }
export function useGetWalletTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export function useGetWalletTransactionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export type GetWalletTransactionsQueryHookResult = ReturnType<typeof useGetWalletTransactionsQuery>;
export type GetWalletTransactionsLazyQueryHookResult = ReturnType<typeof useGetWalletTransactionsLazyQuery>;
export type GetWalletTransactionsSuspenseQueryHookResult = ReturnType<typeof useGetWalletTransactionsSuspenseQuery>;
export type GetWalletTransactionsQueryResult = Apollo.QueryResult<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>;
export const CreateSubscriptionDocument = gql`
    mutation createSubscription($input: CreateSubscriptionInput!) {
  createSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type CreateSubscriptionMutationFn = Apollo.MutationFunction<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;

/**
 * __useCreateSubscriptionMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionMutation, { data, loading, error }] = useCreateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>(CreateSubscriptionDocument, options);
      }
export type CreateSubscriptionMutationHookResult = ReturnType<typeof useCreateSubscriptionMutation>;
export type CreateSubscriptionMutationResult = Apollo.MutationResult<CreateSubscriptionMutation>;
export type CreateSubscriptionMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;
export const UpdateSubscriptionDocument = gql`
    mutation updateSubscription($input: UpdateSubscriptionInput!) {
  updateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type UpdateSubscriptionMutationFn = Apollo.MutationFunction<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;

/**
 * __useUpdateSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionMutation, { data, loading, error }] = useUpdateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>(UpdateSubscriptionDocument, options);
      }
export type UpdateSubscriptionMutationHookResult = ReturnType<typeof useUpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationResult = Apollo.MutationResult<UpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;
export const GetSinglePlanDocument = gql`
    query getSinglePlan($id: ID!) {
  plan(id: $id) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetSinglePlanQuery__
 *
 * To run a query within a React component, call `useGetSinglePlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSinglePlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSinglePlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSinglePlanQuery(baseOptions: Apollo.QueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
      }
export function useGetSinglePlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export function useGetSinglePlanSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export type GetSinglePlanQueryHookResult = ReturnType<typeof useGetSinglePlanQuery>;
export type GetSinglePlanLazyQueryHookResult = ReturnType<typeof useGetSinglePlanLazyQuery>;
export type GetSinglePlanSuspenseQueryHookResult = ReturnType<typeof useGetSinglePlanSuspenseQuery>;
export type GetSinglePlanQueryResult = Apollo.QueryResult<GetSinglePlanQuery, GetSinglePlanQueryVariables>;
export const CreatePlanDocument = gql`
    mutation createPlan($input: CreatePlanInput!) {
  createPlan(input: $input) {
    id
  }
}
    `;
export type CreatePlanMutationFn = Apollo.MutationFunction<CreatePlanMutation, CreatePlanMutationVariables>;

/**
 * __useCreatePlanMutation__
 *
 * To run a mutation, you first call `useCreatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlanMutation, { data, loading, error }] = useCreatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlanMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlanMutation, CreatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlanMutation, CreatePlanMutationVariables>(CreatePlanDocument, options);
      }
export type CreatePlanMutationHookResult = ReturnType<typeof useCreatePlanMutation>;
export type CreatePlanMutationResult = Apollo.MutationResult<CreatePlanMutation>;
export type CreatePlanMutationOptions = Apollo.BaseMutationOptions<CreatePlanMutation, CreatePlanMutationVariables>;
export const UpdatePlanDocument = gql`
    mutation updatePlan($input: UpdatePlanInput!) {
  updatePlan(input: $input) {
    ...PlanItem
    ...DeletePlanDialog
    ...EditPlan
  }
}
    ${PlanItemFragmentDoc}
${DeletePlanDialogFragmentDoc}
${EditPlanFragmentDoc}`;
export type UpdatePlanMutationFn = Apollo.MutationFunction<UpdatePlanMutation, UpdatePlanMutationVariables>;

/**
 * __useUpdatePlanMutation__
 *
 * To run a mutation, you first call `useUpdatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePlanMutation, { data, loading, error }] = useUpdatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePlanMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePlanMutation, UpdatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePlanMutation, UpdatePlanMutationVariables>(UpdatePlanDocument, options);
      }
export type UpdatePlanMutationHookResult = ReturnType<typeof useUpdatePlanMutation>;
export type UpdatePlanMutationResult = Apollo.MutationResult<UpdatePlanMutation>;
export type UpdatePlanMutationOptions = Apollo.BaseMutationOptions<UpdatePlanMutation, UpdatePlanMutationVariables>;
export const GetInvoiceCreateCreditNoteDocument = gql`
    query getInvoiceCreateCreditNote($id: ID!) {
  invoice(id: $id) {
    ...InvoiceCreateCreditNote
  }
}
    ${InvoiceCreateCreditNoteFragmentDoc}`;

/**
 * __useGetInvoiceCreateCreditNoteQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreateCreditNoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreateCreditNoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreateCreditNoteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceCreateCreditNoteQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
      }
export function useGetInvoiceCreateCreditNoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export function useGetInvoiceCreateCreditNoteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export type GetInvoiceCreateCreditNoteQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteQuery>;
export type GetInvoiceCreateCreditNoteLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteLazyQuery>;
export type GetInvoiceCreateCreditNoteSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteSuspenseQuery>;
export type GetInvoiceCreateCreditNoteQueryResult = Apollo.QueryResult<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>;
export const CreateCreditNoteDocument = gql`
    mutation createCreditNote($input: CreateCreditNoteInput!) {
  createCreditNote(input: $input) {
    id
  }
}
    `;
export type CreateCreditNoteMutationFn = Apollo.MutationFunction<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;

/**
 * __useCreateCreditNoteMutation__
 *
 * To run a mutation, you first call `useCreateCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreditNoteMutation, { data, loading, error }] = useCreateCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>(CreateCreditNoteDocument, options);
      }
export type CreateCreditNoteMutationHookResult = ReturnType<typeof useCreateCreditNoteMutation>;
export type CreateCreditNoteMutationResult = Apollo.MutationResult<CreateCreditNoteMutation>;
export type CreateCreditNoteMutationOptions = Apollo.BaseMutationOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;
export const GetSingleAddOnDocument = gql`
    query getSingleAddOn($id: ID!) {
  addOn(id: $id) {
    ...EditAddOn
  }
}
    ${EditAddOnFragmentDoc}`;

/**
 * __useGetSingleAddOnQuery__
 *
 * To run a query within a React component, call `useGetSingleAddOnQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleAddOnQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleAddOnQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleAddOnQuery(baseOptions: Apollo.QueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
      }
export function useGetSingleAddOnLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export function useGetSingleAddOnSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export type GetSingleAddOnQueryHookResult = ReturnType<typeof useGetSingleAddOnQuery>;
export type GetSingleAddOnLazyQueryHookResult = ReturnType<typeof useGetSingleAddOnLazyQuery>;
export type GetSingleAddOnSuspenseQueryHookResult = ReturnType<typeof useGetSingleAddOnSuspenseQuery>;
export type GetSingleAddOnQueryResult = Apollo.QueryResult<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>;
export const CreateAddOnDocument = gql`
    mutation createAddOn($input: CreateAddOnInput!) {
  createAddOn(input: $input) {
    id
  }
}
    `;
export type CreateAddOnMutationFn = Apollo.MutationFunction<CreateAddOnMutation, CreateAddOnMutationVariables>;

/**
 * __useCreateAddOnMutation__
 *
 * To run a mutation, you first call `useCreateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAddOnMutation, { data, loading, error }] = useCreateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<CreateAddOnMutation, CreateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAddOnMutation, CreateAddOnMutationVariables>(CreateAddOnDocument, options);
      }
export type CreateAddOnMutationHookResult = ReturnType<typeof useCreateAddOnMutation>;
export type CreateAddOnMutationResult = Apollo.MutationResult<CreateAddOnMutation>;
export type CreateAddOnMutationOptions = Apollo.BaseMutationOptions<CreateAddOnMutation, CreateAddOnMutationVariables>;
export const UpdateAddOnDocument = gql`
    mutation updateAddOn($input: UpdateAddOnInput!) {
  updateAddOn(input: $input) {
    ...AddOnItem
  }
}
    ${AddOnItemFragmentDoc}`;
export type UpdateAddOnMutationFn = Apollo.MutationFunction<UpdateAddOnMutation, UpdateAddOnMutationVariables>;

/**
 * __useUpdateAddOnMutation__
 *
 * To run a mutation, you first call `useUpdateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAddOnMutation, { data, loading, error }] = useUpdateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAddOnMutation, UpdateAddOnMutationVariables>(UpdateAddOnDocument, options);
      }
export type UpdateAddOnMutationHookResult = ReturnType<typeof useUpdateAddOnMutation>;
export type UpdateAddOnMutationResult = Apollo.MutationResult<UpdateAddOnMutation>;
export type UpdateAddOnMutationOptions = Apollo.BaseMutationOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>;
export const GetSingleBillableMetricDocument = gql`
    query getSingleBillableMetric($id: ID!) {
  billableMetric(id: $id) {
    ...EditBillableMetric
  }
}
    ${EditBillableMetricFragmentDoc}`;

/**
 * __useGetSingleBillableMetricQuery__
 *
 * To run a query within a React component, call `useGetSingleBillableMetricQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleBillableMetricQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleBillableMetricQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleBillableMetricQuery(baseOptions: Apollo.QueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
      }
export function useGetSingleBillableMetricLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export function useGetSingleBillableMetricSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export type GetSingleBillableMetricQueryHookResult = ReturnType<typeof useGetSingleBillableMetricQuery>;
export type GetSingleBillableMetricLazyQueryHookResult = ReturnType<typeof useGetSingleBillableMetricLazyQuery>;
export type GetSingleBillableMetricSuspenseQueryHookResult = ReturnType<typeof useGetSingleBillableMetricSuspenseQuery>;
export type GetSingleBillableMetricQueryResult = Apollo.QueryResult<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>;
export const CreateBillableMetricDocument = gql`
    mutation createBillableMetric($input: CreateBillableMetricInput!) {
  createBillableMetric(input: $input) {
    id
  }
}
    `;
export type CreateBillableMetricMutationFn = Apollo.MutationFunction<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;

/**
 * __useCreateBillableMetricMutation__
 *
 * To run a mutation, you first call `useCreateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillableMetricMutation, { data, loading, error }] = useCreateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>(CreateBillableMetricDocument, options);
      }
export type CreateBillableMetricMutationHookResult = ReturnType<typeof useCreateBillableMetricMutation>;
export type CreateBillableMetricMutationResult = Apollo.MutationResult<CreateBillableMetricMutation>;
export type CreateBillableMetricMutationOptions = Apollo.BaseMutationOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;
export const UpdateBillableMetricDocument = gql`
    mutation updateBillableMetric($input: UpdateBillableMetricInput!) {
  updateBillableMetric(input: $input) {
    ...BillableMetricItem
    ...DeleteBillableMetricDialog
  }
}
    ${BillableMetricItemFragmentDoc}
${DeleteBillableMetricDialogFragmentDoc}`;
export type UpdateBillableMetricMutationFn = Apollo.MutationFunction<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;

/**
 * __useUpdateBillableMetricMutation__
 *
 * To run a mutation, you first call `useUpdateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillableMetricMutation, { data, loading, error }] = useUpdateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>(UpdateBillableMetricDocument, options);
      }
export type UpdateBillableMetricMutationHookResult = ReturnType<typeof useUpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationResult = Apollo.MutationResult<UpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationOptions = Apollo.BaseMutationOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;
export const GetSingleCouponDocument = gql`
    query getSingleCoupon($id: ID!) {
  coupon(id: $id) {
    ...EditCoupon
  }
}
    ${EditCouponFragmentDoc}`;

/**
 * __useGetSingleCouponQuery__
 *
 * To run a query within a React component, call `useGetSingleCouponQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleCouponQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleCouponQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleCouponQuery(baseOptions: Apollo.QueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
      }
export function useGetSingleCouponLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export function useGetSingleCouponSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export type GetSingleCouponQueryHookResult = ReturnType<typeof useGetSingleCouponQuery>;
export type GetSingleCouponLazyQueryHookResult = ReturnType<typeof useGetSingleCouponLazyQuery>;
export type GetSingleCouponSuspenseQueryHookResult = ReturnType<typeof useGetSingleCouponSuspenseQuery>;
export type GetSingleCouponQueryResult = Apollo.QueryResult<GetSingleCouponQuery, GetSingleCouponQueryVariables>;
export const CreateCouponDocument = gql`
    mutation createCoupon($input: CreateCouponInput!) {
  createCoupon(input: $input) {
    id
  }
}
    `;
export type CreateCouponMutationFn = Apollo.MutationFunction<CreateCouponMutation, CreateCouponMutationVariables>;

/**
 * __useCreateCouponMutation__
 *
 * To run a mutation, you first call `useCreateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCouponMutation, { data, loading, error }] = useCreateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCouponMutation(baseOptions?: Apollo.MutationHookOptions<CreateCouponMutation, CreateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCouponMutation, CreateCouponMutationVariables>(CreateCouponDocument, options);
      }
export type CreateCouponMutationHookResult = ReturnType<typeof useCreateCouponMutation>;
export type CreateCouponMutationResult = Apollo.MutationResult<CreateCouponMutation>;
export type CreateCouponMutationOptions = Apollo.BaseMutationOptions<CreateCouponMutation, CreateCouponMutationVariables>;
export const UpdateCouponDocument = gql`
    mutation updateCoupon($input: UpdateCouponInput!) {
  updateCoupon(input: $input) {
    ...CouponItem
  }
}
    ${CouponItemFragmentDoc}`;
export type UpdateCouponMutationFn = Apollo.MutationFunction<UpdateCouponMutation, UpdateCouponMutationVariables>;

/**
 * __useUpdateCouponMutation__
 *
 * To run a mutation, you first call `useUpdateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCouponMutation, { data, loading, error }] = useUpdateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCouponMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCouponMutation, UpdateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCouponMutation, UpdateCouponMutationVariables>(UpdateCouponDocument, options);
      }
export type UpdateCouponMutationHookResult = ReturnType<typeof useUpdateCouponMutation>;
export type UpdateCouponMutationResult = Apollo.MutationResult<UpdateCouponMutation>;
export type UpdateCouponMutationOptions = Apollo.BaseMutationOptions<UpdateCouponMutation, UpdateCouponMutationVariables>;
export const CreateCustomerDocument = gql`
    mutation createCustomer($input: CreateCustomerInput!) {
  createCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type CreateCustomerMutationFn = Apollo.MutationFunction<CreateCustomerMutation, CreateCustomerMutationVariables>;

/**
 * __useCreateCustomerMutation__
 *
 * To run a mutation, you first call `useCreateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerMutation, { data, loading, error }] = useCreateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerMutation, CreateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerMutation, CreateCustomerMutationVariables>(CreateCustomerDocument, options);
      }
export type CreateCustomerMutationHookResult = ReturnType<typeof useCreateCustomerMutation>;
export type CreateCustomerMutationResult = Apollo.MutationResult<CreateCustomerMutation>;
export type CreateCustomerMutationOptions = Apollo.BaseMutationOptions<CreateCustomerMutation, CreateCustomerMutationVariables>;
export const UpdateCustomerDocument = gql`
    mutation updateCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type UpdateCustomerMutationFn = Apollo.MutationFunction<UpdateCustomerMutation, UpdateCustomerMutationVariables>;

/**
 * __useUpdateCustomerMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerMutation, { data, loading, error }] = useUpdateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerMutation, UpdateCustomerMutationVariables>(UpdateCustomerDocument, options);
      }
export type UpdateCustomerMutationHookResult = ReturnType<typeof useUpdateCustomerMutation>;
export type UpdateCustomerMutationResult = Apollo.MutationResult<UpdateCustomerMutation>;
export type UpdateCustomerMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>;
export const IntegrationsListForCustomerCreateEditDocument = gql`
    query integrationsListForCustomerCreateEdit($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        __typename
        id
        name
        code
      }
      ... on GocardlessProvider {
        __typename
        id
        name
        code
      }
      ... on AdyenProvider {
        __typename
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __useIntegrationsListForCustomerCreateEditQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerCreateEditQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerCreateEditQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerCreateEditQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerCreateEditQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>(IntegrationsListForCustomerCreateEditDocument, options);
      }
export function useIntegrationsListForCustomerCreateEditLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>(IntegrationsListForCustomerCreateEditDocument, options);
        }
export function useIntegrationsListForCustomerCreateEditSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>(IntegrationsListForCustomerCreateEditDocument, options);
        }
export type IntegrationsListForCustomerCreateEditQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerCreateEditQuery>;
export type IntegrationsListForCustomerCreateEditLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerCreateEditLazyQuery>;
export type IntegrationsListForCustomerCreateEditSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerCreateEditSuspenseQuery>;
export type IntegrationsListForCustomerCreateEditQueryResult = Apollo.QueryResult<IntegrationsListForCustomerCreateEditQuery, IntegrationsListForCustomerCreateEditQueryVariables>;
export const GetSingleTaxDocument = gql`
    query getSingleTax($id: ID!) {
  tax(id: $id) {
    id
    autoGenerated
    ...TaxFormQueryShape
  }
}
    ${TaxFormQueryShapeFragmentDoc}`;

/**
 * __useGetSingleTaxQuery__
 *
 * To run a query within a React component, call `useGetSingleTaxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleTaxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleTaxQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleTaxQuery(baseOptions: Apollo.QueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
      }
export function useGetSingleTaxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export function useGetSingleTaxSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export type GetSingleTaxQueryHookResult = ReturnType<typeof useGetSingleTaxQuery>;
export type GetSingleTaxLazyQueryHookResult = ReturnType<typeof useGetSingleTaxLazyQuery>;
export type GetSingleTaxSuspenseQueryHookResult = ReturnType<typeof useGetSingleTaxSuspenseQuery>;
export type GetSingleTaxQueryResult = Apollo.QueryResult<GetSingleTaxQuery, GetSingleTaxQueryVariables>;
export const CreateTaxDocument = gql`
    mutation createTax($input: TaxCreateInput!) {
  createTax(input: $input) {
    id
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type CreateTaxMutationFn = Apollo.MutationFunction<CreateTaxMutation, CreateTaxMutationVariables>;

/**
 * __useCreateTaxMutation__
 *
 * To run a mutation, you first call `useCreateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTaxMutation, { data, loading, error }] = useCreateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateTaxMutation, CreateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTaxMutation, CreateTaxMutationVariables>(CreateTaxDocument, options);
      }
export type CreateTaxMutationHookResult = ReturnType<typeof useCreateTaxMutation>;
export type CreateTaxMutationResult = Apollo.MutationResult<CreateTaxMutation>;
export type CreateTaxMutationOptions = Apollo.BaseMutationOptions<CreateTaxMutation, CreateTaxMutationVariables>;
export const UpdateTaxDocument = gql`
    mutation updateTax($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type UpdateTaxMutationFn = Apollo.MutationFunction<UpdateTaxMutation, UpdateTaxMutationVariables>;

/**
 * __useUpdateTaxMutation__
 *
 * To run a mutation, you first call `useUpdateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTaxMutation, { data, loading, error }] = useUpdateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTaxMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTaxMutation, UpdateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTaxMutation, UpdateTaxMutationVariables>(UpdateTaxDocument, options);
      }
export type UpdateTaxMutationHookResult = ReturnType<typeof useUpdateTaxMutation>;
export type UpdateTaxMutationResult = Apollo.MutationResult<UpdateTaxMutation>;
export type UpdateTaxMutationOptions = Apollo.BaseMutationOptions<UpdateTaxMutation, UpdateTaxMutationVariables>;
export const GetCurrentUserInfosDocument = gql`
    query getCurrentUserInfos {
  currentUser {
    ...CurrentUserInfos
  }
}
    ${CurrentUserInfosFragmentDoc}`;

/**
 * __useGetCurrentUserInfosQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
      }
export function useGetCurrentUserInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export function useGetCurrentUserInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export type GetCurrentUserInfosQueryHookResult = ReturnType<typeof useGetCurrentUserInfosQuery>;
export type GetCurrentUserInfosLazyQueryHookResult = ReturnType<typeof useGetCurrentUserInfosLazyQuery>;
export type GetCurrentUserInfosSuspenseQueryHookResult = ReturnType<typeof useGetCurrentUserInfosSuspenseQuery>;
export type GetCurrentUserInfosQueryResult = Apollo.QueryResult<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>;
export const GetEmailSettingsDocument = gql`
    query getEmailSettings {
  organization {
    id
    emailSettings
    logoUrl
    name
  }
}
    `;

/**
 * __useGetEmailSettingsQuery__
 *
 * To run a query within a React component, call `useGetEmailSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEmailSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEmailSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetEmailSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
      }
export function useGetEmailSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
        }
export function useGetEmailSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
        }
export type GetEmailSettingsQueryHookResult = ReturnType<typeof useGetEmailSettingsQuery>;
export type GetEmailSettingsLazyQueryHookResult = ReturnType<typeof useGetEmailSettingsLazyQuery>;
export type GetEmailSettingsSuspenseQueryHookResult = ReturnType<typeof useGetEmailSettingsSuspenseQuery>;
export type GetEmailSettingsQueryResult = Apollo.QueryResult<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>;
export const UpdateEmailSettingDocument = gql`
    mutation updateEmailSetting($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    emailSettings
  }
}
    `;
export type UpdateEmailSettingMutationFn = Apollo.MutationFunction<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>;

/**
 * __useUpdateEmailSettingMutation__
 *
 * To run a mutation, you first call `useUpdateEmailSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEmailSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEmailSettingMutation, { data, loading, error }] = useUpdateEmailSettingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateEmailSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>(UpdateEmailSettingDocument, options);
      }
export type UpdateEmailSettingMutationHookResult = ReturnType<typeof useUpdateEmailSettingMutation>;
export type UpdateEmailSettingMutationResult = Apollo.MutationResult<UpdateEmailSettingMutation>;
export type UpdateEmailSettingMutationOptions = Apollo.BaseMutationOptions<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>;
export const GetOrganizationInfosDocument = gql`
    query getOrganizationInfos {
  organization {
    ...MainOrganizationInfos
  }
}
    ${MainOrganizationInfosFragmentDoc}`;

/**
 * __useGetOrganizationInfosQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
      }
export function useGetOrganizationInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export function useGetOrganizationInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export type GetOrganizationInfosQueryHookResult = ReturnType<typeof useGetOrganizationInfosQuery>;
export type GetOrganizationInfosLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfosLazyQuery>;
export type GetOrganizationInfosSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfosSuspenseQuery>;
export type GetOrganizationInfosQueryResult = Apollo.QueryResult<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>;
export const GetInvoiceDetailsDocument = gql`
    query getInvoiceDetails($id: ID!) {
  invoice(id: $id) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;

/**
 * __useGetInvoiceDetailsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
      }
export function useGetInvoiceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export function useGetInvoiceDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export type GetInvoiceDetailsQueryHookResult = ReturnType<typeof useGetInvoiceDetailsQuery>;
export type GetInvoiceDetailsLazyQueryHookResult = ReturnType<typeof useGetInvoiceDetailsLazyQuery>;
export type GetInvoiceDetailsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceDetailsSuspenseQuery>;
export type GetInvoiceDetailsQueryResult = Apollo.QueryResult<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>;
export const DownloadInvoiceDocument = gql`
    mutation downloadInvoice($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceMutationFn = Apollo.MutationFunction<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;

/**
 * __useDownloadInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceMutation, { data, loading, error }] = useDownloadInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>(DownloadInvoiceDocument, options);
      }
export type DownloadInvoiceMutationHookResult = ReturnType<typeof useDownloadInvoiceMutation>;
export type DownloadInvoiceMutationResult = Apollo.MutationResult<DownloadInvoiceMutation>;
export type DownloadInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;
export const RefreshInvoiceDocument = gql`
    mutation refreshInvoice($input: RefreshInvoiceInput!) {
  refreshInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type RefreshInvoiceMutationFn = Apollo.MutationFunction<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;

/**
 * __useRefreshInvoiceMutation__
 *
 * To run a mutation, you first call `useRefreshInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshInvoiceMutation, { data, loading, error }] = useRefreshInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRefreshInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>(RefreshInvoiceDocument, options);
      }
export type RefreshInvoiceMutationHookResult = ReturnType<typeof useRefreshInvoiceMutation>;
export type RefreshInvoiceMutationResult = Apollo.MutationResult<RefreshInvoiceMutation>;
export type RefreshInvoiceMutationOptions = Apollo.BaseMutationOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;
export const SideNavInfosDocument = gql`
    query SideNavInfos {
  currentVersion {
    githubUrl
    number
  }
}
    `;

/**
 * __useSideNavInfosQuery__
 *
 * To run a query within a React component, call `useSideNavInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useSideNavInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSideNavInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useSideNavInfosQuery(baseOptions?: Apollo.QueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
      }
export function useSideNavInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export function useSideNavInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export type SideNavInfosQueryHookResult = ReturnType<typeof useSideNavInfosQuery>;
export type SideNavInfosLazyQueryHookResult = ReturnType<typeof useSideNavInfosLazyQuery>;
export type SideNavInfosSuspenseQueryHookResult = ReturnType<typeof useSideNavInfosSuspenseQuery>;
export type SideNavInfosQueryResult = Apollo.QueryResult<SideNavInfosQuery, SideNavInfosQueryVariables>;
export const GetAddOnForDetailsDocument = gql`
    query getAddOnForDetails($addOn: ID!) {
  addOn(id: $addOn) {
    id
    name
    amountCents
    amountCurrency
    code
    taxes {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetAddOnForDetailsQuery__
 *
 * To run a query within a React component, call `useGetAddOnForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnForDetailsQuery({
 *   variables: {
 *      addOn: // value for 'addOn'
 *   },
 * });
 */
export function useGetAddOnForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
      }
export function useGetAddOnForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export function useGetAddOnForDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export type GetAddOnForDetailsQueryHookResult = ReturnType<typeof useGetAddOnForDetailsQuery>;
export type GetAddOnForDetailsLazyQueryHookResult = ReturnType<typeof useGetAddOnForDetailsLazyQuery>;
export type GetAddOnForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAddOnForDetailsSuspenseQuery>;
export type GetAddOnForDetailsQueryResult = Apollo.QueryResult<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>;
export const AddOnsDocument = gql`
    query addOns($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AddOnItem
    }
  }
}
    ${AddOnItemFragmentDoc}`;

/**
 * __useAddOnsQuery__
 *
 * To run a query within a React component, call `useAddOnsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddOnsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddOnsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useAddOnsQuery(baseOptions?: Apollo.QueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
      }
export function useAddOnsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export function useAddOnsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export type AddOnsQueryHookResult = ReturnType<typeof useAddOnsQuery>;
export type AddOnsLazyQueryHookResult = ReturnType<typeof useAddOnsLazyQuery>;
export type AddOnsSuspenseQueryHookResult = ReturnType<typeof useAddOnsSuspenseQuery>;
export type AddOnsQueryResult = Apollo.QueryResult<AddOnsQuery, AddOnsQueryVariables>;
export const BillableMetricsDocument = gql`
    query billableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...BillableMetricItem
    }
  }
}
    ${BillableMetricItemFragmentDoc}`;

/**
 * __useBillableMetricsQuery__
 *
 * To run a query within a React component, call `useBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
      }
export function useBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export function useBillableMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export type BillableMetricsQueryHookResult = ReturnType<typeof useBillableMetricsQuery>;
export type BillableMetricsLazyQueryHookResult = ReturnType<typeof useBillableMetricsLazyQuery>;
export type BillableMetricsSuspenseQueryHookResult = ReturnType<typeof useBillableMetricsSuspenseQuery>;
export type BillableMetricsQueryResult = Apollo.QueryResult<BillableMetricsQuery, BillableMetricsQueryVariables>;
export const CouponsDocument = gql`
    query coupons($page: Int, $limit: Int, $searchTerm: String) {
  coupons(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CouponItem
      ...CouponCaption
    }
  }
}
    ${CouponItemFragmentDoc}
${CouponCaptionFragmentDoc}`;

/**
 * __useCouponsQuery__
 *
 * To run a query within a React component, call `useCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCouponsQuery(baseOptions?: Apollo.QueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
      }
export function useCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export function useCouponsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export type CouponsQueryHookResult = ReturnType<typeof useCouponsQuery>;
export type CouponsLazyQueryHookResult = ReturnType<typeof useCouponsLazyQuery>;
export type CouponsSuspenseQueryHookResult = ReturnType<typeof useCouponsSuspenseQuery>;
export type CouponsQueryResult = Apollo.QueryResult<CouponsQuery, CouponsQueryVariables>;
export const GetTaxesForAddOnFormDocument = gql`
    query getTaxesForAddOnForm($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
      ...TaxOnAddOnEditCreate
    }
  }
}
    ${TaxOnAddOnEditCreateFragmentDoc}`;

/**
 * __useGetTaxesForAddOnFormQuery__
 *
 * To run a query within a React component, call `useGetTaxesForAddOnFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForAddOnFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForAddOnFormQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForAddOnFormQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
      }
export function useGetTaxesForAddOnFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
        }
export function useGetTaxesForAddOnFormSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
        }
export type GetTaxesForAddOnFormQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormQuery>;
export type GetTaxesForAddOnFormLazyQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormLazyQuery>;
export type GetTaxesForAddOnFormSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormSuspenseQuery>;
export type GetTaxesForAddOnFormQueryResult = Apollo.QueryResult<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>;
export const CreateInvoiceDocument = gql`
    mutation createInvoice($input: CreateInvoiceInput!) {
  createInvoice(input: $input) {
    id
  }
}
    `;
export type CreateInvoiceMutationFn = Apollo.MutationFunction<CreateInvoiceMutation, CreateInvoiceMutationVariables>;

/**
 * __useCreateInvoiceMutation__
 *
 * To run a mutation, you first call `useCreateInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoiceMutation, { data, loading, error }] = useCreateInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoiceMutation, CreateInvoiceMutationVariables>(CreateInvoiceDocument, options);
      }
export type CreateInvoiceMutationHookResult = ReturnType<typeof useCreateInvoiceMutation>;
export type CreateInvoiceMutationResult = Apollo.MutationResult<CreateInvoiceMutation>;
export type CreateInvoiceMutationOptions = Apollo.BaseMutationOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>;
export const GetInfosForCreateInvoiceDocument = gql`
    query getInfosForCreateInvoice($id: ID!) {
  customer(id: $id) {
    id
    addressLine1
    addressLine2
    city
    country
    currency
    email
    name
    legalName
    legalNumber
    taxIdentificationNumber
    state
    zipcode
    taxes {
      id
      ...TaxInfosForCreateInvoice
    }
  }
  organization {
    id
    addressLine1
    addressLine2
    city
    country
    email
    name
    legalName
    legalNumber
    taxIdentificationNumber
    logoUrl
    state
    zipcode
    defaultCurrency
  }
  taxes(page: 1, limit: 1000, appliedToOrganization: true) {
    collection {
      id
      ...TaxInfosForCreateInvoice
    }
  }
}
    ${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetInfosForCreateInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInfosForCreateInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInfosForCreateInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInfosForCreateInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInfosForCreateInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
      }
export function useGetInfosForCreateInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export function useGetInfosForCreateInvoiceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export type GetInfosForCreateInvoiceQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceQuery>;
export type GetInfosForCreateInvoiceLazyQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceLazyQuery>;
export type GetInfosForCreateInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceSuspenseQuery>;
export type GetInfosForCreateInvoiceQueryResult = Apollo.QueryResult<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>;
export const GetAddonListForInfoiceDocument = gql`
    query getAddonListForInfoice($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      description
      amountCents
      amountCurrency
      invoiceDisplayName
      ...AddOnForInvoiceEditTaxDialog
      taxes {
        id
        ...TaxInfosForCreateInvoice
      }
    }
  }
}
    ${AddOnForInvoiceEditTaxDialogFragmentDoc}
${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetAddonListForInfoiceQuery__
 *
 * To run a query within a React component, call `useGetAddonListForInfoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddonListForInfoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddonListForInfoiceQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetAddonListForInfoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
      }
export function useGetAddonListForInfoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export function useGetAddonListForInfoiceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export type GetAddonListForInfoiceQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceQuery>;
export type GetAddonListForInfoiceLazyQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceLazyQuery>;
export type GetAddonListForInfoiceSuspenseQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceSuspenseQuery>;
export type GetAddonListForInfoiceQueryResult = Apollo.QueryResult<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>;
export const GetPlansDocument = gql`
    query getPlans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetPlansQuery__
 *
 * To run a query within a React component, call `useGetPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
      }
export function useGetPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export function useGetPlansSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export type GetPlansQueryHookResult = ReturnType<typeof useGetPlansQuery>;
export type GetPlansLazyQueryHookResult = ReturnType<typeof useGetPlansLazyQuery>;
export type GetPlansSuspenseQueryHookResult = ReturnType<typeof useGetPlansSuspenseQuery>;
export type GetPlansQueryResult = Apollo.QueryResult<GetPlansQuery, GetPlansQueryVariables>;
export const GetCustomerForCreateSubscriptionDocument = gql`
    query getCustomerForCreateSubscription($id: ID!) {
  customer(id: $id) {
    id
    applicableTimezone
    name
    externalId
  }
}
    `;

/**
 * __useGetCustomerForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetCustomerForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
      }
export function useGetCustomerForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export function useGetCustomerForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export type GetCustomerForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionQuery>;
export type GetCustomerForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionLazyQuery>;
export type GetCustomerForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionSuspenseQuery>;
export type GetCustomerForCreateSubscriptionQueryResult = Apollo.QueryResult<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>;
export const GetSubscriptionForCreateSubscriptionDocument = gql`
    query getSubscriptionForCreateSubscription($id: ID!) {
  subscription(id: $id) {
    id
    name
    externalId
    subscriptionAt
    endingAt
    billingTime
    periodEndDate
    status
    startedAt
    plan {
      id
      parent {
        id
      }
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetSubscriptionForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSubscriptionForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
      }
export function useGetSubscriptionForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export function useGetSubscriptionForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export type GetSubscriptionForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionQuery>;
export type GetSubscriptionForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionLazyQuery>;
export type GetSubscriptionForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionSuspenseQuery>;
export type GetSubscriptionForCreateSubscriptionQueryResult = Apollo.QueryResult<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>;
export const GetCreditNoteDocument = gql`
    query getCreditNote($id: ID!) {
  creditNote(id: $id) {
    id
    balanceAmountCents
    canBeVoided
    couponsAdjustmentAmountCents
    createdAt
    creditAmountCents
    creditStatus
    currency
    number
    refundAmountCents
    refundedAt
    refundStatus
    subTotalExcludingTaxesAmountCents
    totalAmountCents
    customer {
      id
      name
      deletedAt
      applicableTimezone
    }
    invoice {
      id
      number
    }
    appliedTaxes {
      id
      amountCents
      baseAmountCents
      taxRate
      taxName
    }
    items {
      amountCents
      amountCurrency
      fee {
        id
        amountCents
        eventsCount
        units
        feeType
        itemName
        groupedBy
        invoiceName
        appliedTaxes {
          id
          tax {
            id
            rate
          }
        }
        trueUpParentFee {
          id
        }
        charge {
          id
          billableMetric {
            id
            name
            aggregationType
          }
        }
        subscription {
          id
          name
          plan {
            id
            name
            invoiceDisplayName
          }
        }
        chargeFilter {
          invoiceDisplayName
          values
        }
      }
    }
  }
}
    `;

/**
 * __useGetCreditNoteQuery__
 *
 * To run a query within a React component, call `useGetCreditNoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNoteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCreditNoteQuery(baseOptions: Apollo.QueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
      }
export function useGetCreditNoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
        }
export function useGetCreditNoteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
        }
export type GetCreditNoteQueryHookResult = ReturnType<typeof useGetCreditNoteQuery>;
export type GetCreditNoteLazyQueryHookResult = ReturnType<typeof useGetCreditNoteLazyQuery>;
export type GetCreditNoteSuspenseQueryHookResult = ReturnType<typeof useGetCreditNoteSuspenseQuery>;
export type GetCreditNoteQueryResult = Apollo.QueryResult<GetCreditNoteQuery, GetCreditNoteQueryVariables>;
export const GetCustomerDocument = gql`
    query getCustomer($id: ID!) {
  customer(id: $id) {
    ...CustomerDetails
  }
}
    ${CustomerDetailsFragmentDoc}`;

/**
 * __useGetCustomerQuery__
 *
 * To run a query within a React component, call `useGetCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
      }
export function useGetCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export function useGetCustomerSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export type GetCustomerQueryHookResult = ReturnType<typeof useGetCustomerQuery>;
export type GetCustomerLazyQueryHookResult = ReturnType<typeof useGetCustomerLazyQuery>;
export type GetCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSuspenseQuery>;
export type GetCustomerQueryResult = Apollo.QueryResult<GetCustomerQuery, GetCustomerQueryVariables>;
export const GenerateCustomerPortalUrlDocument = gql`
    mutation generateCustomerPortalUrl($input: GenerateCustomerPortalUrlInput!) {
  generateCustomerPortalUrl(input: $input) {
    url
  }
}
    `;
export type GenerateCustomerPortalUrlMutationFn = Apollo.MutationFunction<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;

/**
 * __useGenerateCustomerPortalUrlMutation__
 *
 * To run a mutation, you first call `useGenerateCustomerPortalUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateCustomerPortalUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateCustomerPortalUrlMutation, { data, loading, error }] = useGenerateCustomerPortalUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGenerateCustomerPortalUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>(GenerateCustomerPortalUrlDocument, options);
      }
export type GenerateCustomerPortalUrlMutationHookResult = ReturnType<typeof useGenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationResult = Apollo.MutationResult<GenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationOptions = Apollo.BaseMutationOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;
export const GetCustomerDraftInvoicesDocument = gql`
    query getCustomerDraftInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerDraftInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerDraftInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerDraftInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerDraftInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerDraftInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
      }
export function useGetCustomerDraftInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export function useGetCustomerDraftInvoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export type GetCustomerDraftInvoicesQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesQuery>;
export type GetCustomerDraftInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesLazyQuery>;
export type GetCustomerDraftInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesSuspenseQuery>;
export type GetCustomerDraftInvoicesQueryResult = Apollo.QueryResult<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>;
export const GetCustomerInfosForDraftInvoicesListDocument = gql`
    query getCustomerInfosForDraftInvoicesList($customerId: ID!, $status: [InvoiceStatusTypeEnum!]) {
  customer(id: $customerId) {
    id
    name
    applicableTimezone
  }
  customerInvoices(customerId: $customerId, status: $status) {
    metadata {
      totalCount
    }
  }
}
    `;

/**
 * __useGetCustomerInfosForDraftInvoicesListQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForDraftInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForDraftInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForDraftInvoicesListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetCustomerInfosForDraftInvoicesListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
      }
export function useGetCustomerInfosForDraftInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export function useGetCustomerInfosForDraftInvoicesListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export type GetCustomerInfosForDraftInvoicesListQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListQuery>;
export type GetCustomerInfosForDraftInvoicesListLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListLazyQuery>;
export type GetCustomerInfosForDraftInvoicesListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListSuspenseQuery>;
export type GetCustomerInfosForDraftInvoicesListQueryResult = Apollo.QueryResult<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>;
export const CustomersDocument = gql`
    query customers($page: Int, $limit: Int, $searchTerm: String) {
  customers(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CustomerItem
    }
  }
}
    ${CustomerItemFragmentDoc}`;

/**
 * __useCustomersQuery__
 *
 * To run a query within a React component, call `useCustomersQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCustomersQuery(baseOptions?: Apollo.QueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
      }
export function useCustomersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export function useCustomersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export type CustomersQueryHookResult = ReturnType<typeof useCustomersQuery>;
export type CustomersLazyQueryHookResult = ReturnType<typeof useCustomersLazyQuery>;
export type CustomersSuspenseQueryHookResult = ReturnType<typeof useCustomersSuspenseQuery>;
export type CustomersQueryResult = Apollo.QueryResult<CustomersQuery, CustomersQueryVariables>;
export const GetinviteDocument = gql`
    query getinvite($token: String!) {
  invite(token: $token) {
    id
    email
    organization {
      id
      name
    }
  }
}
    `;

/**
 * __useGetinviteQuery__
 *
 * To run a query within a React component, call `useGetinviteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetinviteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetinviteQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetinviteQuery(baseOptions: Apollo.QueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
      }
export function useGetinviteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export function useGetinviteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export type GetinviteQueryHookResult = ReturnType<typeof useGetinviteQuery>;
export type GetinviteLazyQueryHookResult = ReturnType<typeof useGetinviteLazyQuery>;
export type GetinviteSuspenseQueryHookResult = ReturnType<typeof useGetinviteSuspenseQuery>;
export type GetinviteQueryResult = Apollo.QueryResult<GetinviteQuery, GetinviteQueryVariables>;
export const AcceptInviteDocument = gql`
    mutation acceptInvite($input: AcceptInviteInput!) {
  acceptInvite(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type AcceptInviteMutationFn = Apollo.MutationFunction<AcceptInviteMutation, AcceptInviteMutationVariables>;

/**
 * __useAcceptInviteMutation__
 *
 * To run a mutation, you first call `useAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptInviteMutation, { data, loading, error }] = useAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<AcceptInviteMutation, AcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AcceptInviteMutation, AcceptInviteMutationVariables>(AcceptInviteDocument, options);
      }
export type AcceptInviteMutationHookResult = ReturnType<typeof useAcceptInviteMutation>;
export type AcceptInviteMutationResult = Apollo.MutationResult<AcceptInviteMutation>;
export type AcceptInviteMutationOptions = Apollo.BaseMutationOptions<AcceptInviteMutation, AcceptInviteMutationVariables>;
export const GoogleAcceptInviteDocument = gql`
    mutation googleAcceptInvite($input: GoogleAcceptInviteInput!) {
  googleAcceptInvite(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleAcceptInviteMutationFn = Apollo.MutationFunction<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;

/**
 * __useGoogleAcceptInviteMutation__
 *
 * To run a mutation, you first call `useGoogleAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleAcceptInviteMutation, { data, loading, error }] = useGoogleAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>(GoogleAcceptInviteDocument, options);
      }
export type GoogleAcceptInviteMutationHookResult = ReturnType<typeof useGoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationResult = Apollo.MutationResult<GoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationOptions = Apollo.BaseMutationOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;
export const GetInvoiceCreditNotesDocument = gql`
    query getInvoiceCreditNotes($invoiceId: ID!, $page: Int, $limit: Int) {
  invoiceCreditNotes(invoiceId: $invoiceId, page: $page, limit: $limit) {
    ...CreditNotesForList
  }
  invoice(id: $invoiceId) {
    id
    refundableAmountCents
    creditableAmountCents
    status
    customer {
      id
      applicableTimezone
    }
  }
}
    ${CreditNotesForListFragmentDoc}`;

/**
 * __useGetInvoiceCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreditNotesQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvoiceCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
      }
export function useGetInvoiceCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export function useGetInvoiceCreditNotesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export type GetInvoiceCreditNotesQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesQuery>;
export type GetInvoiceCreditNotesLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesLazyQuery>;
export type GetInvoiceCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesSuspenseQuery>;
export type GetInvoiceCreditNotesQueryResult = Apollo.QueryResult<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>;
export const InvoicesListDocument = gql`
    query invoicesList($limit: Int, $page: Int, $status: InvoiceStatusTypeEnum, $paymentStatus: [InvoicePaymentStatusTypeEnum!], $searchTerm: String, $paymentDisputeLost: Boolean) {
  invoices(
    limit: $limit
    page: $page
    status: $status
    paymentStatus: $paymentStatus
    searchTerm: $searchTerm
    paymentDisputeLost: $paymentDisputeLost
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...InvoiceListItem
    }
  }
}
    ${InvoiceListItemFragmentDoc}`;

/**
 * __useInvoicesListQuery__
 *
 * To run a query within a React component, call `useInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvoicesListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      paymentStatus: // value for 'paymentStatus'
 *      searchTerm: // value for 'searchTerm'
 *      paymentDisputeLost: // value for 'paymentDisputeLost'
 *   },
 * });
 */
export function useInvoicesListQuery(baseOptions?: Apollo.QueryHookOptions<InvoicesListQuery, InvoicesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvoicesListQuery, InvoicesListQueryVariables>(InvoicesListDocument, options);
      }
export function useInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvoicesListQuery, InvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvoicesListQuery, InvoicesListQueryVariables>(InvoicesListDocument, options);
        }
export function useInvoicesListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<InvoicesListQuery, InvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvoicesListQuery, InvoicesListQueryVariables>(InvoicesListDocument, options);
        }
export type InvoicesListQueryHookResult = ReturnType<typeof useInvoicesListQuery>;
export type InvoicesListLazyQueryHookResult = ReturnType<typeof useInvoicesListLazyQuery>;
export type InvoicesListSuspenseQueryHookResult = ReturnType<typeof useInvoicesListSuspenseQuery>;
export type InvoicesListQueryResult = Apollo.QueryResult<InvoicesListQuery, InvoicesListQueryVariables>;
export const RetryAllInvoicePaymentsDocument = gql`
    mutation retryAllInvoicePayments($input: RetryAllInvoicePaymentsInput!) {
  retryAllInvoicePayments(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type RetryAllInvoicePaymentsMutationFn = Apollo.MutationFunction<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;

/**
 * __useRetryAllInvoicePaymentsMutation__
 *
 * To run a mutation, you first call `useRetryAllInvoicePaymentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllInvoicePaymentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllInvoicePaymentsMutation, { data, loading, error }] = useRetryAllInvoicePaymentsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllInvoicePaymentsMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>(RetryAllInvoicePaymentsDocument, options);
      }
export type RetryAllInvoicePaymentsMutationHookResult = ReturnType<typeof useRetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationResult = Apollo.MutationResult<RetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationOptions = Apollo.BaseMutationOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;
export const GetPlanForDetailsDocument = gql`
    query getPlanForDetails($planId: ID!) {
  plan(id: $planId) {
    id
    name
    code
    parent {
      id
    }
    ...DeletePlanDialog
  }
}
    ${DeletePlanDialogFragmentDoc}`;

/**
 * __useGetPlanForDetailsQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsQuery({
 *   variables: {
 *      planId: // value for 'planId'
 *   },
 * });
 */
export function useGetPlanForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
      }
export function useGetPlanForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export function useGetPlanForDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export type GetPlanForDetailsQueryHookResult = ReturnType<typeof useGetPlanForDetailsQuery>;
export type GetPlanForDetailsLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsLazyQuery>;
export type GetPlanForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsSuspenseQuery>;
export type GetPlanForDetailsQueryResult = Apollo.QueryResult<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>;
export const PlansDocument = gql`
    query plans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...PlanItem
    }
  }
}
    ${PlanItemFragmentDoc}`;

/**
 * __usePlansQuery__
 *
 * To run a query within a React component, call `usePlansQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function usePlansQuery(baseOptions?: Apollo.QueryHookOptions<PlansQuery, PlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
      }
export function usePlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export function usePlansSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export type PlansQueryHookResult = ReturnType<typeof usePlansQuery>;
export type PlansLazyQueryHookResult = ReturnType<typeof usePlansLazyQuery>;
export type PlansSuspenseQueryHookResult = ReturnType<typeof usePlansSuspenseQuery>;
export type PlansQueryResult = Apollo.QueryResult<PlansQuery, PlansQueryVariables>;
export const GetSubscriptionForDetailsDocument = gql`
    query getSubscriptionForDetails($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    name
    status
    externalId
    plan {
      id
      name
      code
      parent {
        id
        name
        code
      }
    }
    customer {
      id
    }
  }
}
    `;

/**
 * __useGetSubscriptionForDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
      }
export function useGetSubscriptionForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export function useGetSubscriptionForDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export type GetSubscriptionForDetailsQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsQuery>;
export type GetSubscriptionForDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsLazyQuery>;
export type GetSubscriptionForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsSuspenseQuery>;
export type GetSubscriptionForDetailsQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>;
export const GetCustomerInfosForWalletFormDocument = gql`
    query getCustomerInfosForWalletForm($id: ID!) {
  customer(id: $id) {
    id
    currency
    timezone
  }
}
    `;

/**
 * __useGetCustomerInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
      }
export function useGetCustomerInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export function useGetCustomerInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export type GetCustomerInfosForWalletFormQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormQuery>;
export type GetCustomerInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormLazyQuery>;
export type GetCustomerInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormSuspenseQuery>;
export type GetCustomerInfosForWalletFormQueryResult = Apollo.QueryResult<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>;
export const GetWalletInfosForWalletFormDocument = gql`
    query getWalletInfosForWalletForm($id: ID!) {
  wallet(id: $id) {
    id
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;

/**
 * __useGetWalletInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetWalletInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWalletInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
      }
export function useGetWalletInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export function useGetWalletInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export type GetWalletInfosForWalletFormQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormQuery>;
export type GetWalletInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormLazyQuery>;
export type GetWalletInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormSuspenseQuery>;
export type GetWalletInfosForWalletFormQueryResult = Apollo.QueryResult<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>;
export const CreateCustomerWalletDocument = gql`
    mutation createCustomerWallet($input: CreateCustomerWalletInput!) {
  createCustomerWallet(input: $input) {
    id
    customer {
      id
      hasActiveWallet
    }
  }
}
    `;
export type CreateCustomerWalletMutationFn = Apollo.MutationFunction<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;

/**
 * __useCreateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletMutation, { data, loading, error }] = useCreateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>(CreateCustomerWalletDocument, options);
      }
export type CreateCustomerWalletMutationHookResult = ReturnType<typeof useCreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationResult = Apollo.MutationResult<CreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;
export const UpdateCustomerWalletDocument = gql`
    mutation updateCustomerWallet($input: UpdateCustomerWalletInput!) {
  updateCustomerWallet(input: $input) {
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;
export type UpdateCustomerWalletMutationFn = Apollo.MutationFunction<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;

/**
 * __useUpdateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerWalletMutation, { data, loading, error }] = useUpdateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>(UpdateCustomerWalletDocument, options);
      }
export type UpdateCustomerWalletMutationHookResult = ReturnType<typeof useUpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationResult = Apollo.MutationResult<UpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;
export const CreatePasswordResetDocument = gql`
    mutation createPasswordReset($input: CreatePasswordResetInput!) {
  createPasswordReset(input: $input) {
    id
  }
}
    `;
export type CreatePasswordResetMutationFn = Apollo.MutationFunction<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;

/**
 * __useCreatePasswordResetMutation__
 *
 * To run a mutation, you first call `useCreatePasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPasswordResetMutation, { data, loading, error }] = useCreatePasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePasswordResetMutation(baseOptions?: Apollo.MutationHookOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>(CreatePasswordResetDocument, options);
      }
export type CreatePasswordResetMutationHookResult = ReturnType<typeof useCreatePasswordResetMutation>;
export type CreatePasswordResetMutationResult = Apollo.MutationResult<CreatePasswordResetMutation>;
export type CreatePasswordResetMutationOptions = Apollo.BaseMutationOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;
export const GoogleLoginUserDocument = gql`
    mutation googleLoginUser($input: GoogleLoginUserInput!) {
  googleLoginUser(input: $input) {
    user {
      id
      ...CurrentUser
    }
    token
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleLoginUserMutationFn = Apollo.MutationFunction<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;

/**
 * __useGoogleLoginUserMutation__
 *
 * To run a mutation, you first call `useGoogleLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleLoginUserMutation, { data, loading, error }] = useGoogleLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>(GoogleLoginUserDocument, options);
      }
export type GoogleLoginUserMutationHookResult = ReturnType<typeof useGoogleLoginUserMutation>;
export type GoogleLoginUserMutationResult = Apollo.MutationResult<GoogleLoginUserMutation>;
export type GoogleLoginUserMutationOptions = Apollo.BaseMutationOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;
export const LoginUserDocument = gql`
    mutation loginUser($input: LoginUserInput!) {
  loginUser(input: $input) {
    user {
      id
      ...CurrentUser
    }
    token
  }
}
    ${CurrentUserFragmentDoc}`;
export type LoginUserMutationFn = Apollo.MutationFunction<LoginUserMutation, LoginUserMutationVariables>;

/**
 * __useLoginUserMutation__
 *
 * To run a mutation, you first call `useLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginUserMutation, { data, loading, error }] = useLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<LoginUserMutation, LoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginUserMutation, LoginUserMutationVariables>(LoginUserDocument, options);
      }
export type LoginUserMutationHookResult = ReturnType<typeof useLoginUserMutation>;
export type LoginUserMutationResult = Apollo.MutationResult<LoginUserMutation>;
export type LoginUserMutationOptions = Apollo.BaseMutationOptions<LoginUserMutation, LoginUserMutationVariables>;
export const GetPortalLocaleDocument = gql`
    query getPortalLocale {
  customerPortalOrganization {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
  customerPortalUser {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;

/**
 * __useGetPortalLocaleQuery__
 *
 * To run a query within a React component, call `useGetPortalLocaleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalLocaleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalLocaleQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalLocaleQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
      }
export function useGetPortalLocaleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export function useGetPortalLocaleSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export type GetPortalLocaleQueryHookResult = ReturnType<typeof useGetPortalLocaleQuery>;
export type GetPortalLocaleLazyQueryHookResult = ReturnType<typeof useGetPortalLocaleLazyQuery>;
export type GetPortalLocaleSuspenseQueryHookResult = ReturnType<typeof useGetPortalLocaleSuspenseQuery>;
export type GetPortalLocaleQueryResult = Apollo.QueryResult<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>;
export const GetPasswordResetDocument = gql`
    query getPasswordReset($token: String!) {
  passwordReset(token: $token) {
    id
    user {
      id
      email
    }
  }
}
    `;

/**
 * __useGetPasswordResetQuery__
 *
 * To run a query within a React component, call `useGetPasswordResetQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPasswordResetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPasswordResetQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetPasswordResetQuery(baseOptions: Apollo.QueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
      }
export function useGetPasswordResetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export function useGetPasswordResetSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export type GetPasswordResetQueryHookResult = ReturnType<typeof useGetPasswordResetQuery>;
export type GetPasswordResetLazyQueryHookResult = ReturnType<typeof useGetPasswordResetLazyQuery>;
export type GetPasswordResetSuspenseQueryHookResult = ReturnType<typeof useGetPasswordResetSuspenseQuery>;
export type GetPasswordResetQueryResult = Apollo.QueryResult<GetPasswordResetQuery, GetPasswordResetQueryVariables>;
export const ResetPasswordDocument = gql`
    mutation resetPassword($input: ResetPasswordInput!) {
  resetPassword(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, options);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const SignupDocument = gql`
    mutation signup($input: RegisterUserInput!) {
  registerUser(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type SignupMutationFn = Apollo.MutationFunction<SignupMutation, SignupMutationVariables>;

/**
 * __useSignupMutation__
 *
 * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupMutation, { data, loading, error }] = useSignupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignupMutation(baseOptions?: Apollo.MutationHookOptions<SignupMutation, SignupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, options);
      }
export type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;
export type SignupMutationResult = Apollo.MutationResult<SignupMutation>;
export type SignupMutationOptions = Apollo.BaseMutationOptions<SignupMutation, SignupMutationVariables>;
export const GoogleRegisterDocument = gql`
    mutation googleRegister($input: GoogleRegisterUserInput!) {
  googleRegisterUser(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleRegisterMutationFn = Apollo.MutationFunction<GoogleRegisterMutation, GoogleRegisterMutationVariables>;

/**
 * __useGoogleRegisterMutation__
 *
 * To run a mutation, you first call `useGoogleRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleRegisterMutation, { data, loading, error }] = useGoogleRegisterMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleRegisterMutation(baseOptions?: Apollo.MutationHookOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleRegisterMutation, GoogleRegisterMutationVariables>(GoogleRegisterDocument, options);
      }
export type GoogleRegisterMutationHookResult = ReturnType<typeof useGoogleRegisterMutation>;
export type GoogleRegisterMutationResult = Apollo.MutationResult<GoogleRegisterMutation>;
export type GoogleRegisterMutationOptions = Apollo.BaseMutationOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>;
export const GetPortalOrgaInfosDocument = gql`
    query getPortalOrgaInfos {
  customerPortalOrganization {
    id
    name
    logoUrl
  }
}
    `;

/**
 * __useGetPortalOrgaInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalOrgaInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalOrgaInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalOrgaInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalOrgaInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
      }
export function useGetPortalOrgaInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export function useGetPortalOrgaInfosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export type GetPortalOrgaInfosQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosQuery>;
export type GetPortalOrgaInfosLazyQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosLazyQuery>;
export type GetPortalOrgaInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosSuspenseQuery>;
export type GetPortalOrgaInfosQueryResult = Apollo.QueryResult<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>;
export const GetOrganizationApiKeyDocument = gql`
    query getOrganizationApiKey {
  organization {
    id
    apiKey
  }
}
    `;

/**
 * __useGetOrganizationApiKeyQuery__
 *
 * To run a query within a React component, call `useGetOrganizationApiKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationApiKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationApiKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationApiKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
      }
export function useGetOrganizationApiKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
        }
export function useGetOrganizationApiKeySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
        }
export type GetOrganizationApiKeyQueryHookResult = ReturnType<typeof useGetOrganizationApiKeyQuery>;
export type GetOrganizationApiKeyLazyQueryHookResult = ReturnType<typeof useGetOrganizationApiKeyLazyQuery>;
export type GetOrganizationApiKeySuspenseQueryHookResult = ReturnType<typeof useGetOrganizationApiKeySuspenseQuery>;
export type GetOrganizationApiKeyQueryResult = Apollo.QueryResult<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>;
export const EventsDocument = gql`
    query events($page: Int, $limit: Int) {
  events(page: $page, limit: $limit) {
    collection {
      ...EventList
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsQuery__
 *
 * To run a query within a React component, call `useEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useEventsQuery(baseOptions?: Apollo.QueryHookOptions<EventsQuery, EventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
      }
export function useEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export function useEventsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export type EventsQueryHookResult = ReturnType<typeof useEventsQuery>;
export type EventsLazyQueryHookResult = ReturnType<typeof useEventsLazyQuery>;
export type EventsSuspenseQueryHookResult = ReturnType<typeof useEventsSuspenseQuery>;
export type EventsQueryResult = Apollo.QueryResult<EventsQuery, EventsQueryVariables>;
export const GetWebhookInformationsDocument = gql`
    query getWebhookInformations($id: ID!) {
  webhookEndpoint(id: $id) {
    id
    webhookUrl
  }
}
    `;

/**
 * __useGetWebhookInformationsQuery__
 *
 * To run a query within a React component, call `useGetWebhookInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookInformationsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWebhookInformationsQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
      }
export function useGetWebhookInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export function useGetWebhookInformationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export type GetWebhookInformationsQueryHookResult = ReturnType<typeof useGetWebhookInformationsQuery>;
export type GetWebhookInformationsLazyQueryHookResult = ReturnType<typeof useGetWebhookInformationsLazyQuery>;
export type GetWebhookInformationsSuspenseQueryHookResult = ReturnType<typeof useGetWebhookInformationsSuspenseQuery>;
export type GetWebhookInformationsQueryResult = Apollo.QueryResult<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>;
export const GetWebhookLogDocument = gql`
    query getWebhookLog($page: Int, $limit: Int, $webhookEndpointId: String!, $status: WebhookStatusEnum, $searchTerm: String) {
  webhooks(
    page: $page
    limit: $limit
    webhookEndpointId: $webhookEndpointId
    status: $status
    searchTerm: $searchTerm
  ) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...WebhookLog
    }
  }
}
    ${WebhookLogFragmentDoc}`;

/**
 * __useGetWebhookLogQuery__
 *
 * To run a query within a React component, call `useGetWebhookLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookLogQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      webhookEndpointId: // value for 'webhookEndpointId'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetWebhookLogQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
      }
export function useGetWebhookLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export function useGetWebhookLogSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export type GetWebhookLogQueryHookResult = ReturnType<typeof useGetWebhookLogQuery>;
export type GetWebhookLogLazyQueryHookResult = ReturnType<typeof useGetWebhookLogLazyQuery>;
export type GetWebhookLogSuspenseQueryHookResult = ReturnType<typeof useGetWebhookLogSuspenseQuery>;
export type GetWebhookLogQueryResult = Apollo.QueryResult<GetWebhookLogQuery, GetWebhookLogQueryVariables>;
export const GetWebhookListDocument = gql`
    query getWebhookList($limit: Int) {
  webhookEndpoints(limit: $limit) {
    collection {
      id
      webhookUrl
      signatureAlgo
      ...WebhookForCreateAndEdit
    }
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;

/**
 * __useGetWebhookListQuery__
 *
 * To run a query within a React component, call `useGetWebhookListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWebhookListQuery(baseOptions?: Apollo.QueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
      }
export function useGetWebhookListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export function useGetWebhookListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export type GetWebhookListQueryHookResult = ReturnType<typeof useGetWebhookListQuery>;
export type GetWebhookListLazyQueryHookResult = ReturnType<typeof useGetWebhookListLazyQuery>;
export type GetWebhookListSuspenseQueryHookResult = ReturnType<typeof useGetWebhookListSuspenseQuery>;
export type GetWebhookListQueryResult = Apollo.QueryResult<GetWebhookListQuery, GetWebhookListQueryVariables>;
export const GetAdyenIntegrationsDetailsDocument = gql`
    query getAdyenIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on AdyenProvider {
      id
      ...AdyenIntegrationDetails
      ...DeleteAdyenIntegrationDialog
      ...AddAdyenProviderDialog
      ...AdyenForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
      }
    }
  }
}
    ${AdyenIntegrationDetailsFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
      }
export function useGetAdyenIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export function useGetAdyenIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export type GetAdyenIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsQuery>;
export type GetAdyenIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsLazyQuery>;
export type GetAdyenIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsSuspenseQuery>;
export type GetAdyenIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>;
export const GetAdyenIntegrationsListDocument = gql`
    query getAdyenIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
        ...AdyenIntegrations
        ...AddAdyenProviderDialog
        ...DeleteAdyenIntegrationDialog
      }
    }
  }
}
    ${AdyenIntegrationsFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
      }
export function useGetAdyenIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export function useGetAdyenIntegrationsListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export type GetAdyenIntegrationsListQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListQuery>;
export type GetAdyenIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListLazyQuery>;
export type GetAdyenIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListSuspenseQuery>;
export type GetAdyenIntegrationsListQueryResult = Apollo.QueryResult<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>;
export const GetGocardlessIntegrationsDetailsDocument = gql`
    query getGocardlessIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on GocardlessProvider {
      id
      ...GocardlessIntegrationDetails
      ...DeleteGocardlessIntegrationDialog
      ...AddGocardlessProviderDialog
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
      }
    }
  }
}
    ${GocardlessIntegrationDetailsFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
      }
export function useGetGocardlessIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export function useGetGocardlessIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export type GetGocardlessIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsQuery>;
export type GetGocardlessIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsLazyQuery>;
export type GetGocardlessIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsSuspenseQuery>;
export type GetGocardlessIntegrationsDetailsQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>;
export const AddGocardlessApiKeyDocument = gql`
    mutation addGocardlessApiKey($input: AddGocardlessPaymentProviderInput!) {
  addGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationOauthCallback
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationOauthCallbackFragmentDoc}`;
export type AddGocardlessApiKeyMutationFn = Apollo.MutationFunction<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;

/**
 * __useAddGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useAddGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addGocardlessApiKeyMutation, { data, loading, error }] = useAddGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>(AddGocardlessApiKeyDocument, options);
      }
export type AddGocardlessApiKeyMutationHookResult = ReturnType<typeof useAddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationResult = Apollo.MutationResult<AddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;
export const GetGocardlessIntegrationsListDocument = gql`
    query getGocardlessIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
        ...GocardlessIntegrations
        ...AddGocardlessProviderDialog
        ...DeleteGocardlessIntegrationDialog
      }
    }
  }
}
    ${GocardlessIntegrationsFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
      }
export function useGetGocardlessIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export function useGetGocardlessIntegrationsListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export type GetGocardlessIntegrationsListQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListQuery>;
export type GetGocardlessIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListLazyQuery>;
export type GetGocardlessIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListSuspenseQuery>;
export type GetGocardlessIntegrationsListQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>;
export const IntegrationsSettingDocument = gql`
    query integrationsSetting($limit: Int) {
  organization {
    id
    euTaxManagement
    country
  }
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        id
      }
      ... on GocardlessProvider {
        id
      }
      ... on AdyenProvider {
        id
      }
    }
  }
}
    `;

/**
 * __useIntegrationsSettingQuery__
 *
 * To run a query within a React component, call `useIntegrationsSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsSettingQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsSettingQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
      }
export function useIntegrationsSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export function useIntegrationsSettingSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export type IntegrationsSettingQueryHookResult = ReturnType<typeof useIntegrationsSettingQuery>;
export type IntegrationsSettingLazyQueryHookResult = ReturnType<typeof useIntegrationsSettingLazyQuery>;
export type IntegrationsSettingSuspenseQueryHookResult = ReturnType<typeof useIntegrationsSettingSuspenseQuery>;
export type IntegrationsSettingQueryResult = Apollo.QueryResult<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>;
export const GetOrganizationSettingsDocument = gql`
    query getOrganizationSettings($appliedToOrganization: Boolean = true) {
  organization {
    id
    netPaymentTerm
    defaultCurrency
    documentNumbering
    documentNumberPrefix
    billingConfiguration {
      id
      invoiceGracePeriod
      invoiceFooter
      documentLocale
    }
    ...EditOrganizationInvoiceTemplateDialog
    ...EditOrganizationNetPaymentTermForDialog
    ...EditOrganizationDefaultCurrencyForDialog
    ...EditOrganizationInvoiceNumberingDialog
  }
  taxes(appliedToOrganization: $appliedToOrganization) {
    collection {
      id
      name
      code
      rate
      ...DeleteOrganizationVatRate
    }
  }
}
    ${EditOrganizationInvoiceTemplateDialogFragmentDoc}
${EditOrganizationNetPaymentTermForDialogFragmentDoc}
${EditOrganizationDefaultCurrencyForDialogFragmentDoc}
${EditOrganizationInvoiceNumberingDialogFragmentDoc}
${DeleteOrganizationVatRateFragmentDoc}`;

/**
 * __useGetOrganizationSettingsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationSettingsQuery({
 *   variables: {
 *      appliedToOrganization: // value for 'appliedToOrganization'
 *   },
 * });
 */
export function useGetOrganizationSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
      }
export function useGetOrganizationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
        }
export function useGetOrganizationSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
        }
export type GetOrganizationSettingsQueryHookResult = ReturnType<typeof useGetOrganizationSettingsQuery>;
export type GetOrganizationSettingsLazyQueryHookResult = ReturnType<typeof useGetOrganizationSettingsLazyQuery>;
export type GetOrganizationSettingsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationSettingsSuspenseQuery>;
export type GetOrganizationSettingsQueryResult = Apollo.QueryResult<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>;
export const LagoTaxManagementIntegrationsSettingDocument = gql`
    query lagoTaxManagementIntegrationsSetting {
  organization {
    id
    country
    euTaxManagement
  }
}
    `;

/**
 * __useLagoTaxManagementIntegrationsSettingQuery__
 *
 * To run a query within a React component, call `useLagoTaxManagementIntegrationsSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useLagoTaxManagementIntegrationsSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLagoTaxManagementIntegrationsSettingQuery({
 *   variables: {
 *   },
 * });
 */
export function useLagoTaxManagementIntegrationsSettingQuery(baseOptions?: Apollo.QueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
      }
export function useLagoTaxManagementIntegrationsSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
        }
export function useLagoTaxManagementIntegrationsSettingSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
        }
export type LagoTaxManagementIntegrationsSettingQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingQuery>;
export type LagoTaxManagementIntegrationsSettingLazyQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingLazyQuery>;
export type LagoTaxManagementIntegrationsSettingSuspenseQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingSuspenseQuery>;
export type LagoTaxManagementIntegrationsSettingQueryResult = Apollo.QueryResult<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>;
export const GetTaxesForTaxManagementIntegrationDetailsPageDocument = gql`
    query getTaxesForTaxManagementIntegrationDetailsPage {
  taxes(page: 1, limit: 1000, order: "rate", autoGenerated: true) {
    collection {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetTaxesForTaxManagementIntegrationDetailsPageQuery__
 *
 * To run a query within a React component, call `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForTaxManagementIntegrationDetailsPageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTaxesForTaxManagementIntegrationDetailsPageQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
      }
export function useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export function useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageLazyQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryResult = Apollo.QueryResult<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>;
export const RemoveTaxManagementIntegrationDocument = gql`
    mutation removeTaxManagementIntegration($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    euTaxManagement
  }
}
    `;
export type RemoveTaxManagementIntegrationMutationFn = Apollo.MutationFunction<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>;

/**
 * __useRemoveTaxManagementIntegrationMutation__
 *
 * To run a mutation, you first call `useRemoveTaxManagementIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveTaxManagementIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeTaxManagementIntegrationMutation, { data, loading, error }] = useRemoveTaxManagementIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveTaxManagementIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>(RemoveTaxManagementIntegrationDocument, options);
      }
export type RemoveTaxManagementIntegrationMutationHookResult = ReturnType<typeof useRemoveTaxManagementIntegrationMutation>;
export type RemoveTaxManagementIntegrationMutationResult = Apollo.MutationResult<RemoveTaxManagementIntegrationMutation>;
export type RemoveTaxManagementIntegrationMutationOptions = Apollo.BaseMutationOptions<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>;
export const GetInvitesDocument = gql`
    query getInvites($page: Int, $limit: Int) {
  invites(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      ...InviteItem
    }
  }
}
    ${InviteItemFragmentDoc}`;

/**
 * __useGetInvitesQuery__
 *
 * To run a query within a React component, call `useGetInvitesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvitesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvitesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvitesQuery(baseOptions?: Apollo.QueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
      }
export function useGetInvitesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export function useGetInvitesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export type GetInvitesQueryHookResult = ReturnType<typeof useGetInvitesQuery>;
export type GetInvitesLazyQueryHookResult = ReturnType<typeof useGetInvitesLazyQuery>;
export type GetInvitesSuspenseQueryHookResult = ReturnType<typeof useGetInvitesSuspenseQuery>;
export type GetInvitesQueryResult = Apollo.QueryResult<GetInvitesQuery, GetInvitesQueryVariables>;
export const GetMembersDocument = gql`
    query getMembers($page: Int, $limit: Int) {
  memberships(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      ...MembershipItem
    }
  }
}
    ${MembershipItemFragmentDoc}`;

/**
 * __useGetMembersQuery__
 *
 * To run a query within a React component, call `useGetMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetMembersQuery(baseOptions?: Apollo.QueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
      }
export function useGetMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export function useGetMembersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export type GetMembersQueryHookResult = ReturnType<typeof useGetMembersQuery>;
export type GetMembersLazyQueryHookResult = ReturnType<typeof useGetMembersLazyQuery>;
export type GetMembersSuspenseQueryHookResult = ReturnType<typeof useGetMembersSuspenseQuery>;
export type GetMembersQueryResult = Apollo.QueryResult<GetMembersQuery, GetMembersQueryVariables>;
export const GetOrganizationInformationsDocument = gql`
    query getOrganizationInformations {
  organization {
    id
    ...OrganizationInformations
    ...EditOrganizationInformationsDialog
  }
}
    ${OrganizationInformationsFragmentDoc}
${EditOrganizationInformationsDialogFragmentDoc}`;

/**
 * __useGetOrganizationInformationsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInformationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInformationsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
      }
export function useGetOrganizationInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
        }
export function useGetOrganizationInformationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
        }
export type GetOrganizationInformationsQueryHookResult = ReturnType<typeof useGetOrganizationInformationsQuery>;
export type GetOrganizationInformationsLazyQueryHookResult = ReturnType<typeof useGetOrganizationInformationsLazyQuery>;
export type GetOrganizationInformationsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInformationsSuspenseQuery>;
export type GetOrganizationInformationsQueryResult = Apollo.QueryResult<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>;
export const GetStripeIntegrationsDetailsDocument = gql`
    query getStripeIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on StripeProvider {
      id
      ...StripeIntegrationDetails
      ...DeleteStripeIntegrationDialog
      ...AddStripeProviderDialog
      ...StripeForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
      }
    }
  }
}
    ${StripeIntegrationDetailsFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${StripeForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetStripeIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
      }
export function useGetStripeIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export function useGetStripeIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export type GetStripeIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsQuery>;
export type GetStripeIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsLazyQuery>;
export type GetStripeIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsSuspenseQuery>;
export type GetStripeIntegrationsDetailsQueryResult = Apollo.QueryResult<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>;
export const GetStripeIntegrationsListDocument = gql`
    query getStripeIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
        ...StripeIntegrations
        ...AddStripeProviderDialog
        ...DeleteStripeIntegrationDialog
      }
    }
  }
}
    ${StripeIntegrationsFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}`;

/**
 * __useGetStripeIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
      }
export function useGetStripeIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export function useGetStripeIntegrationsListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export type GetStripeIntegrationsListQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListQuery>;
export type GetStripeIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListLazyQuery>;
export type GetStripeIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListSuspenseQuery>;
export type GetStripeIntegrationsListQueryResult = Apollo.QueryResult<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>;
export const GetTaxesDocument = gql`
    query getTaxes($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page, order: "name") {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxItem
    }
  }
}
    ${TaxItemFragmentDoc}`;

/**
 * __useGetTaxesQuery__
 *
 * To run a query within a React component, call `useGetTaxesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesQuery, GetTaxesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesQuery, GetTaxesQueryVariables>(GetTaxesDocument, options);
      }
export function useGetTaxesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesQuery, GetTaxesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesQuery, GetTaxesQueryVariables>(GetTaxesDocument, options);
        }
export function useGetTaxesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTaxesQuery, GetTaxesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesQuery, GetTaxesQueryVariables>(GetTaxesDocument, options);
        }
export type GetTaxesQueryHookResult = ReturnType<typeof useGetTaxesQuery>;
export type GetTaxesLazyQueryHookResult = ReturnType<typeof useGetTaxesLazyQuery>;
export type GetTaxesSuspenseQueryHookResult = ReturnType<typeof useGetTaxesSuspenseQuery>;
export type GetTaxesQueryResult = Apollo.QueryResult<GetTaxesQuery, GetTaxesQueryVariables>;