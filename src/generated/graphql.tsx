import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: { input: any; output: any; }
  ChargeFilterValues: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: any; output: any; }
  /** Represents untyped JSON */
  JSON: { input: any; output: any; }
};

/** Autogenerated input type of AcceptInvite */
export type AcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  /** Uniq token of the Invite */
  token: Scalars['String']['input'];
};

/** Adyen input arguments */
export type AddAdyenPaymentProviderInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  hmacKey?: InputMaybe<Scalars['String']['input']>;
  livePrefix?: InputMaybe<Scalars['String']['input']>;
  merchantAccount: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Gocardless input arguments */
export type AddGocardlessPaymentProviderInput = {
  accessCode?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export type AddOn = {
  __typename?: 'AddOn';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  appliedAddOnsCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this add-on */
  customersCount: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};


export type AddOnIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};

/** AddOnCollection type */
export type AddOnCollection = {
  __typename?: 'AddOnCollection';
  /** A collection of paginated AddOnCollection */
  collection: Array<AddOn>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Stripe input arguments */
export type AddStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
  secretKey?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

export enum AdjustedFeeTypeEnum {
  AdjustedAmount = 'adjusted_amount',
  AdjustedUnits = 'adjusted_units'
}

export type AdyenProvider = {
  __typename?: 'AdyenProvider';
  apiKey?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  hmacKey?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  livePrefix?: Maybe<Scalars['String']['output']>;
  merchantAccount?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export enum AggregationTypeEnum {
  CountAgg = 'count_agg',
  CustomAgg = 'custom_agg',
  LatestAgg = 'latest_agg',
  MaxAgg = 'max_agg',
  SumAgg = 'sum_agg',
  UniqueCountAgg = 'unique_count_agg',
  WeightedSumAgg = 'weighted_sum_agg'
}

export type AnrokBreakdownObject = {
  __typename?: 'AnrokBreakdownObject';
  enumedTaxCode?: Maybe<InvoiceAppliedTaxOnWholeInvoiceCodeEnum>;
  name?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['BigInt']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type AnrokCustomer = {
  __typename?: 'AnrokCustomer';
  externalAccountId?: Maybe<Scalars['String']['output']>;
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type AnrokFeeObject = {
  __typename?: 'AnrokFeeObject';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  itemCode?: Maybe<Scalars['String']['output']>;
  itemId?: Maybe<Scalars['String']['output']>;
  taxAmountCents?: Maybe<Scalars['BigInt']['output']>;
  taxBreakdown?: Maybe<Array<AnrokBreakdownObject>>;
};

/** AnrokFeeObjectCollection type */
export type AnrokFeeObjectCollection = {
  __typename?: 'AnrokFeeObjectCollection';
  /** A collection of paginated AnrokFeeObjectCollection */
  collection: Array<AnrokFeeObject>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type AnrokIntegration = {
  __typename?: 'AnrokIntegration';
  apiKey: Scalars['String']['output'];
  code: Scalars['String']['output'];
  externalAccountId?: Maybe<Scalars['String']['output']>;
  failedInvoicesCount?: Maybe<Scalars['Int']['output']>;
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type ApiKey = {
  __typename?: 'ApiKey';
  createdAt: Scalars['ISO8601DateTime']['output'];
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  value: Scalars['String']['output'];
};

export type AppliedAddOn = {
  __typename?: 'AppliedAddOn';
  addOn: AddOn;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
};

export type AppliedCoupon = {
  __typename?: 'AppliedCoupon';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCentsRemaining?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  coupon: Coupon;
  createdAt: Scalars['ISO8601DateTime']['output'];
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  frequencyDurationRemaining?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  percentageRate?: Maybe<Scalars['Float']['output']>;
  terminatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AppliedTax = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type AuthUrl = {
  __typename?: 'AuthUrl';
  url: Scalars['String']['output'];
};

export type Authorize = {
  __typename?: 'Authorize';
  url: Scalars['String']['output'];
};

/** Base billable metric */
export type BillableMetric = {
  __typename?: 'BillableMetric';
  activeSubscriptionsCount: Scalars['Int']['output'];
  aggregationType: AggregationTypeEnum;
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  draftInvoicesCount: Scalars['Int']['output'];
  expression?: Maybe<Scalars['String']['output']>;
  fieldName?: Maybe<Scalars['String']['output']>;
  filters?: Maybe<Array<BillableMetricFilter>>;
  id: Scalars['ID']['output'];
  integrationMappings?: Maybe<Array<Mapping>>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  plansCount: Scalars['Int']['output'];
  recurring: Scalars['Boolean']['output'];
  roundingFunction?: Maybe<RoundingFunctionEnum>;
  roundingPrecision?: Maybe<Scalars['Int']['output']>;
  subscriptionsCount: Scalars['Int']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  weightedInterval?: Maybe<WeightedIntervalEnum>;
};


/** Base billable metric */
export type BillableMetricIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};

/** BillableMetricCollection type */
export type BillableMetricCollection = {
  __typename?: 'BillableMetricCollection';
  /** A collection of paginated BillableMetricCollection */
  collection: Array<BillableMetric>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Billable metric filters */
export type BillableMetricFilter = {
  __typename?: 'BillableMetricFilter';
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

/** Billable metric filters input arguments */
export type BillableMetricFiltersInput = {
  key: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export enum BillingTimeEnum {
  Anniversary = 'anniversary',
  Calendar = 'calendar'
}

export type Charge = {
  __typename?: 'Charge';
  billableMetric: BillableMetric;
  chargeModel: ChargeModelEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  filters?: Maybe<Array<ChargeFilter>>;
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceable: Scalars['Boolean']['output'];
  minAmountCents: Scalars['BigInt']['output'];
  payInAdvance: Scalars['Boolean']['output'];
  properties?: Maybe<Properties>;
  prorated: Scalars['Boolean']['output'];
  regroupPaidFees?: Maybe<RegroupPaidFeesEnum>;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Charge filters object */
export type ChargeFilter = {
  __typename?: 'ChargeFilter';
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  properties: Properties;
  values: Scalars['ChargeFilterValues']['output'];
};

/** Charge filters input arguments */
export type ChargeFilterInput = {
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  properties: PropertiesInput;
  values: Scalars['ChargeFilterValues']['input'];
};

export type ChargeFilterUsage = {
  __typename?: 'ChargeFilterUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  id?: Maybe<Scalars['ID']['output']>;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  units: Scalars['Float']['output'];
  values: Scalars['ChargeFilterValues']['output'];
};

export type ChargeInput = {
  billableMetricId: Scalars['ID']['input'];
  chargeModel: ChargeModelEnum;
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  invoiceable?: InputMaybe<Scalars['Boolean']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  payInAdvance?: InputMaybe<Scalars['Boolean']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  prorated?: InputMaybe<Scalars['Boolean']['input']>;
  regroupPaidFees?: InputMaybe<RegroupPaidFeesEnum>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum ChargeModelEnum {
  Custom = 'custom',
  Dynamic = 'dynamic',
  Graduated = 'graduated',
  GraduatedPercentage = 'graduated_percentage',
  Package = 'package',
  Percentage = 'percentage',
  Standard = 'standard',
  Volume = 'volume'
}

export type ChargeOverridesInput = {
  billableMetricId: Scalars['ID']['input'];
  filters?: InputMaybe<Array<ChargeFilterInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  properties?: InputMaybe<PropertiesInput>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ChargeUsage = {
  __typename?: 'ChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  billableMetric: BillableMetric;
  charge: Charge;
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedUsage: Array<GroupedChargeUsage>;
  id: Scalars['ID']['output'];
  units: Scalars['Float']['output'];
};

export type CollectionMapping = {
  __typename?: 'CollectionMapping';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappingType: MappingTypeEnum;
  taxCode?: Maybe<Scalars['String']['output']>;
  taxNexus?: Maybe<Scalars['String']['output']>;
  taxType?: Maybe<Scalars['String']['output']>;
};

/** CollectionMappingCollection type */
export type CollectionMappingCollection = {
  __typename?: 'CollectionMappingCollection';
  /** A collection of paginated CollectionMappingCollection */
  collection: Array<CollectionMapping>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Type for CollectionMetadataType */
export type CollectionMetadata = {
  __typename?: 'CollectionMetadata';
  /** Current Page of loaded data */
  currentPage: Scalars['Int']['output'];
  /** The number of items per page */
  limitValue: Scalars['Int']['output'];
  /** The total number of items to be paginated */
  totalCount: Scalars['Int']['output'];
  /** The total number of pages in the pagination */
  totalPages: Scalars['Int']['output'];
};

export type Commitment = {
  __typename?: 'Commitment';
  amountCents: Scalars['BigInt']['output'];
  commitmentType: CommitmentTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  plan: Plan;
  taxes?: Maybe<Array<Tax>>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CommitmentInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  commitmentType?: InputMaybe<CommitmentTypeEnum>;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum CommitmentTypeEnum {
  MinimumCommitment = 'minimum_commitment'
}

export enum CountryCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland Islands */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia (Plurinational State of) */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands */
  Cc = 'CC',
  /** Congo (Democratic Republic of the) */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Congo */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cuba */
  Cu = 'CU',
  /** Cabo Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czechia */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands (Malvinas) */
  Fk = 'FK',
  /** Micronesia (Federated States of) */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom of Great Britain and Northern Ireland */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and the South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard Island and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran (Islamic Republic of) */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea (Democratic People's Republic of) */
  Kp = 'KP',
  /** Korea (Republic of) */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Lao People's Democratic Republic */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova (Republic of) */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** North Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macao */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine, State of */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Réunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena, Ascension and Tristan da Cunha */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Syrian Arab Republic */
  Sy = 'SY',
  /** Eswatini */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Territories */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Türkiye */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan, Province of China */
  Tw = 'TW',
  /** Tanzania, United Republic of */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands */
  Um = 'UM',
  /** United States of America */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Holy See */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela (Bolivarian Republic of) */
  Ve = 'VE',
  /** Virgin Islands (British) */
  Vg = 'VG',
  /** Virgin Islands (U.S.) */
  Vi = 'VI',
  /** Viet Nam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW'
}

export type Coupon = {
  __typename?: 'Coupon';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  amountCurrency?: Maybe<CurrencyEnum>;
  appliedCouponsCount: Scalars['Int']['output'];
  billableMetrics?: Maybe<Array<BillableMetric>>;
  code?: Maybe<Scalars['String']['output']>;
  couponType: CouponTypeEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this coupon */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  expiration: CouponExpiration;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  frequency: CouponFrequency;
  frequencyDuration?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  limitedBillableMetrics: Scalars['Boolean']['output'];
  limitedPlans: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  percentageRate?: Maybe<Scalars['Float']['output']>;
  plans?: Maybe<Array<Plan>>;
  reusable: Scalars['Boolean']['output'];
  status: CouponStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** CouponCollection type */
export type CouponCollection = {
  __typename?: 'CouponCollection';
  /** A collection of paginated CouponCollection */
  collection: Array<Coupon>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum CouponExpiration {
  NoExpiration = 'no_expiration',
  TimeLimit = 'time_limit'
}

export enum CouponFrequency {
  Forever = 'forever',
  Once = 'once',
  Recurring = 'recurring'
}

export enum CouponStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export enum CouponTypeEnum {
  FixedAmount = 'fixed_amount',
  Percentage = 'percentage'
}

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Create Adjusted Fee Input */
export type CreateAdjustedFeeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  feeId: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of CreateAnrokIntegration */
export type CreateAnrokIntegrationInput = {
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated input type of CreateAppliedCoupon */
export type CreateAppliedCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  couponId: Scalars['ID']['input'];
  customerId: Scalars['ID']['input'];
  frequency?: InputMaybe<CouponFrequency>;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
};

/** Create Billable metric input arguments */
export type CreateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  expression?: InputMaybe<Scalars['String']['input']>;
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  roundingFunction?: InputMaybe<RoundingFunctionEnum>;
  roundingPrecision?: InputMaybe<Scalars['Int']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Autogenerated input type of CreateCoupon */
export type CreateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateCreditNote */
export type CreateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
  reason: CreditNoteReasonEnum;
  refundAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Create Customer input arguments */
export type CreateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  integrationCustomers?: InputMaybe<Array<IntegrationCustomerInput>>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateCustomerPortalWalletTransaction */
export type CreateCustomerPortalWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  walletId: Scalars['ID']['input'];
};

/** Create Wallet Input */
export type CreateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency: CurrencyEnum;
  customerId: Scalars['ID']['input'];
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  grantedCredits: Scalars['String']['input'];
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paidCredits: Scalars['String']['input'];
  rateAmount: Scalars['String']['input'];
  recurringTransactionRules?: InputMaybe<Array<CreateRecurringTransactionRuleInput>>;
};

/** Autogenerated input type of CreateCustomerWalletTransaction */
export type CreateCustomerWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  voidedCredits?: InputMaybe<Scalars['String']['input']>;
  walletId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateInvoicesDataExport */
export type CreateDataExportsInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  filters: DataExportInvoiceFiltersInput;
  format: DataExportFormatTypeEnum;
  resourceType: ExportTypeEnum;
};

/** Autogenerated input type of CreateDunningCampaign */
export type CreateDunningCampaignInput = {
  appliedToOrganization: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  daysBetweenAttempts: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  maxAttempts: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  thresholds: Array<CreateDunningCampaignThresholdInput>;
};

export type CreateDunningCampaignThresholdInput = {
  amountCents: Scalars['BigInt']['input'];
  currency: CurrencyEnum;
};

/** Autogenerated input type of CreateHubspotIntegration */
export type CreateHubspotIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  defaultTargetedObject: HubspotTargetedObjectsEnum;
  name: Scalars['String']['input'];
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncSubscriptions?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of CreateIntegrationCollectionMapping */
export type CreateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappingType: MappingTypeEnum;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxNexus?: InputMaybe<Scalars['String']['input']>;
  taxType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateIntegrationMapping */
export type CreateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId: Scalars['String']['input'];
  externalName?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
  mappableId: Scalars['ID']['input'];
  mappableType: MappableTypeEnum;
};

/** Autogenerated input type of CreateInvite */
export type CreateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  role: MembershipRole;
};

/** Create Invoice input arguments */
export type CreateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerId: Scalars['ID']['input'];
  fees: Array<FeeInput>;
};

/** Autogenerated input type of CreateNetsuiteIntegration */
export type CreateNetsuiteIntegrationInput = {
  accountId: Scalars['String']['input'];
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  scriptEndpointUrl: Scalars['String']['input'];
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  syncSalesOrders?: InputMaybe<Scalars['Boolean']['input']>;
  tokenId: Scalars['String']['input'];
  tokenSecret: Scalars['String']['input'];
};

/** Autogenerated input type of CreateOktaIntegration */
export type CreateOktaIntegrationInput = {
  clientId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret: Scalars['String']['input'];
  domain: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

/** Autogenerated input type of CreatePasswordReset */
export type CreatePasswordResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePasswordReset. */
export type CreatePasswordResetPayload = {
  __typename?: 'CreatePasswordResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
};

/** Autogenerated input type of CreatePlan */
export type CreatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdInput>>;
};

export type CreateRecurringTransactionRuleInput = {
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  method?: InputMaybe<RecurringTransactionMethodEnum>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  targetOngoingBalance?: InputMaybe<Scalars['String']['input']>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  trigger: RecurringTransactionTriggerEnum;
};

/** Create Subscription input arguments */
export type CreateSubscriptionInput = {
  billingTime: BillingTimeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['ID']['input'];
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  planId: Scalars['ID']['input'];
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  subscriptionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of CreateXeroIntegration */
export type CreateXeroIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  connectionId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

/** CreditNote */
export type CreditNote = {
  __typename?: 'CreditNote';
  appliedTaxes?: Maybe<Array<CreditNoteAppliedTax>>;
  balanceAmountCents: Scalars['BigInt']['output'];
  /** Check if credit note can be voided */
  canBeVoided: Scalars['Boolean']['output'];
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmountCents: Scalars['BigInt']['output'];
  creditStatus?: Maybe<CreditNoteCreditStatusEnum>;
  currency: CurrencyEnum;
  customer: Customer;
  description?: Maybe<Scalars['String']['output']>;
  errorDetails?: Maybe<Array<ErrorDetail>>;
  externalIntegrationId?: Maybe<Scalars['String']['output']>;
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationSyncable: Scalars['Boolean']['output'];
  invoice?: Maybe<Invoice>;
  issuingDate: Scalars['ISO8601Date']['output'];
  items: Array<CreditNoteItem>;
  number: Scalars['String']['output'];
  reason: CreditNoteReasonEnum;
  refundAmountCents: Scalars['BigInt']['output'];
  refundStatus?: Maybe<CreditNoteRefundStatusEnum>;
  refundedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  sequentialId: Scalars['ID']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxProviderId?: Maybe<Scalars['String']['output']>;
  taxProviderSyncable: Scalars['Boolean']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  voidedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

export type CreditNoteAppliedTax = AppliedTax & {
  __typename?: 'CreditNoteAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  baseAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNote: CreditNote;
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** CreditNoteCollection type */
export type CreditNoteCollection = {
  __typename?: 'CreditNoteCollection';
  /** A collection of paginated CreditNoteCollection */
  collection: Array<CreditNote>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum CreditNoteCreditStatusEnum {
  Available = 'available',
  Consumed = 'consumed',
  Voided = 'voided'
}

/** Estimate amounts for credit note creation */
export type CreditNoteEstimate = {
  __typename?: 'CreditNoteEstimate';
  appliedTaxes: Array<CreditNoteAppliedTax>;
  couponsAdjustmentAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  items: Array<CreditNoteItemEstimate>;
  maxCreditableAmountCents: Scalars['BigInt']['output'];
  maxRefundableAmountCents: Scalars['BigInt']['output'];
  preciseCouponsAdjustmentAmountCents: Scalars['Float']['output'];
  preciseTaxesAmountCents: Scalars['Float']['output'];
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
};

export type CreditNoteItem = {
  __typename?: 'CreditNoteItem';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
};

export type CreditNoteItemEstimate = {
  __typename?: 'CreditNoteItemEstimate';
  amountCents: Scalars['BigInt']['output'];
  fee: Fee;
};

export type CreditNoteItemInput = {
  amountCents: Scalars['BigInt']['input'];
  feeId: Scalars['ID']['input'];
};

export enum CreditNoteReasonEnum {
  DuplicatedCharge = 'duplicated_charge',
  FraudulentCharge = 'fraudulent_charge',
  OrderCancellation = 'order_cancellation',
  OrderChange = 'order_change',
  Other = 'other',
  ProductUnsatisfactory = 'product_unsatisfactory'
}

export enum CreditNoteRefundStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum CurrencyEnum {
  /** United Arab Emirates Dirham */
  Aed = 'AED',
  /** Afghan Afghani */
  Afn = 'AFN',
  /** Albanian Lek */
  All = 'ALL',
  /** Armenian Dram */
  Amd = 'AMD',
  /** Netherlands Antillean Gulden */
  Ang = 'ANG',
  /** Angolan Kwanza */
  Aoa = 'AOA',
  /** Argentine Peso */
  Ars = 'ARS',
  /** Australian Dollar */
  Aud = 'AUD',
  /** Aruban Florin */
  Awg = 'AWG',
  /** Azerbaijani Manat */
  Azn = 'AZN',
  /** Bosnia and Herzegovina Convertible Mark */
  Bam = 'BAM',
  /** Barbadian Dollar */
  Bbd = 'BBD',
  /** Bangladeshi Taka */
  Bdt = 'BDT',
  /** Bulgarian Lev */
  Bgn = 'BGN',
  /** Bahraini Dinar */
  Bhd = 'BHD',
  /** Burundian Franc */
  Bif = 'BIF',
  /** Bermudian Dollar */
  Bmd = 'BMD',
  /** Brunei Dollar */
  Bnd = 'BND',
  /** Bolivian Boliviano */
  Bob = 'BOB',
  /** Brazilian Real */
  Brl = 'BRL',
  /** Bahamian Dollar */
  Bsd = 'BSD',
  /** Botswana Pula */
  Bwp = 'BWP',
  /** Belarusian Ruble */
  Byn = 'BYN',
  /** Belize Dollar */
  Bzd = 'BZD',
  /** Canadian Dollar */
  Cad = 'CAD',
  /** Congolese Franc */
  Cdf = 'CDF',
  /** Swiss Franc */
  Chf = 'CHF',
  /** Unidad de Fomento */
  Clf = 'CLF',
  /** Chilean Peso */
  Clp = 'CLP',
  /** Chinese Renminbi Yuan */
  Cny = 'CNY',
  /** Colombian Peso */
  Cop = 'COP',
  /** Costa Rican Colón */
  Crc = 'CRC',
  /** Cape Verdean Escudo */
  Cve = 'CVE',
  /** Czech Koruna */
  Czk = 'CZK',
  /** Djiboutian Franc */
  Djf = 'DJF',
  /** Danish Krone */
  Dkk = 'DKK',
  /** Dominican Peso */
  Dop = 'DOP',
  /** Algerian Dinar */
  Dzd = 'DZD',
  /** Egyptian Pound */
  Egp = 'EGP',
  /** Ethiopian Birr */
  Etb = 'ETB',
  /** Euro */
  Eur = 'EUR',
  /** Fijian Dollar */
  Fjd = 'FJD',
  /** Falkland Pound */
  Fkp = 'FKP',
  /** British Pound */
  Gbp = 'GBP',
  /** Georgian Lari */
  Gel = 'GEL',
  /** Gibraltar Pound */
  Gip = 'GIP',
  /** Gambian Dalasi */
  Gmd = 'GMD',
  /** Guinean Franc */
  Gnf = 'GNF',
  /** Guatemalan Quetzal */
  Gtq = 'GTQ',
  /** Guyanese Dollar */
  Gyd = 'GYD',
  /** Hong Kong Dollar */
  Hkd = 'HKD',
  /** Honduran Lempira */
  Hnl = 'HNL',
  /** Croatian Kuna */
  Hrk = 'HRK',
  /** Haitian Gourde */
  Htg = 'HTG',
  /** Hungarian Forint */
  Huf = 'HUF',
  /** Indonesian Rupiah */
  Idr = 'IDR',
  /** Israeli New Sheqel */
  Ils = 'ILS',
  /** Indian Rupee */
  Inr = 'INR',
  /** Iranian Rial */
  Irr = 'IRR',
  /** Icelandic Króna */
  Isk = 'ISK',
  /** Jamaican Dollar */
  Jmd = 'JMD',
  /** Jordanian Dinar */
  Jod = 'JOD',
  /** Japanese Yen */
  Jpy = 'JPY',
  /** Kenyan Shilling */
  Kes = 'KES',
  /** Kyrgyzstani Som */
  Kgs = 'KGS',
  /** Cambodian Riel */
  Khr = 'KHR',
  /** Comorian Franc */
  Kmf = 'KMF',
  /** South Korean Won */
  Krw = 'KRW',
  /** Kuwaiti Dinar */
  Kwd = 'KWD',
  /** Cayman Islands Dollar */
  Kyd = 'KYD',
  /** Kazakhstani Tenge */
  Kzt = 'KZT',
  /** Lao Kip */
  Lak = 'LAK',
  /** Lebanese Pound */
  Lbp = 'LBP',
  /** Sri Lankan Rupee */
  Lkr = 'LKR',
  /** Liberian Dollar */
  Lrd = 'LRD',
  /** Lesotho Loti */
  Lsl = 'LSL',
  /** Moroccan Dirham */
  Mad = 'MAD',
  /** Moldovan Leu */
  Mdl = 'MDL',
  /** Malagasy Ariary */
  Mga = 'MGA',
  /** Macedonian Denar */
  Mkd = 'MKD',
  /** Myanmar Kyat */
  Mmk = 'MMK',
  /** Mongolian Tögrög */
  Mnt = 'MNT',
  /** Macanese Pataca */
  Mop = 'MOP',
  /** Mauritanian Ouguiya */
  Mro = 'MRO',
  /** Mauritian Rupee */
  Mur = 'MUR',
  /** Maldivian Rufiyaa */
  Mvr = 'MVR',
  /** Malawian Kwacha */
  Mwk = 'MWK',
  /** Mexican Peso */
  Mxn = 'MXN',
  /** Malaysian Ringgit */
  Myr = 'MYR',
  /** Mozambican Metical */
  Mzn = 'MZN',
  /** Namibian Dollar */
  Nad = 'NAD',
  /** Nigerian Naira */
  Ngn = 'NGN',
  /** Nicaraguan Córdoba */
  Nio = 'NIO',
  /** Norwegian Krone */
  Nok = 'NOK',
  /** Nepalese Rupee */
  Npr = 'NPR',
  /** New Zealand Dollar */
  Nzd = 'NZD',
  /** Panamanian Balboa */
  Pab = 'PAB',
  /** Peruvian Sol */
  Pen = 'PEN',
  /** Papua New Guinean Kina */
  Pgk = 'PGK',
  /** Philippine Peso */
  Php = 'PHP',
  /** Pakistani Rupee */
  Pkr = 'PKR',
  /** Polish Złoty */
  Pln = 'PLN',
  /** Paraguayan Guaraní */
  Pyg = 'PYG',
  /** Qatari Riyal */
  Qar = 'QAR',
  /** Romanian Leu */
  Ron = 'RON',
  /** Serbian Dinar */
  Rsd = 'RSD',
  /** Russian Ruble */
  Rub = 'RUB',
  /** Rwandan Franc */
  Rwf = 'RWF',
  /** Saudi Riyal */
  Sar = 'SAR',
  /** Solomon Islands Dollar */
  Sbd = 'SBD',
  /** Seychellois Rupee */
  Scr = 'SCR',
  /** Swedish Krona */
  Sek = 'SEK',
  /** Singapore Dollar */
  Sgd = 'SGD',
  /** Saint Helenian Pound */
  Shp = 'SHP',
  /** Sierra Leonean Leone */
  Sll = 'SLL',
  /** Somali Shilling */
  Sos = 'SOS',
  /** Surinamese Dollar */
  Srd = 'SRD',
  /** São Tomé and Príncipe Dobra */
  Std = 'STD',
  /** Swazi Lilangeni */
  Szl = 'SZL',
  /** Thai Baht */
  Thb = 'THB',
  /** Tajikistani Somoni */
  Tjs = 'TJS',
  /** Tongan Paʻanga */
  Top = 'TOP',
  /** Turkish Lira */
  Try = 'TRY',
  /** Trinidad and Tobago Dollar */
  Ttd = 'TTD',
  /** New Taiwan Dollar */
  Twd = 'TWD',
  /** Tanzanian Shilling */
  Tzs = 'TZS',
  /** Ukrainian Hryvnia */
  Uah = 'UAH',
  /** Ugandan Shilling */
  Ugx = 'UGX',
  /** United States Dollar */
  Usd = 'USD',
  /** Uruguayan Peso */
  Uyu = 'UYU',
  /** Uzbekistan Som */
  Uzs = 'UZS',
  /** Vietnamese Đồng */
  Vnd = 'VND',
  /** Vanuatu Vatu */
  Vuv = 'VUV',
  /** Samoan Tala */
  Wst = 'WST',
  /** Central African Cfa Franc */
  Xaf = 'XAF',
  /** East Caribbean Dollar */
  Xcd = 'XCD',
  /** West African Cfa Franc */
  Xof = 'XOF',
  /** Cfp Franc */
  Xpf = 'XPF',
  /** Yemeni Rial */
  Yer = 'YER',
  /** South African Rand */
  Zar = 'ZAR',
  /** Zambian Kwacha */
  Zmw = 'ZMW'
}

/** Current Organization Type */
export type CurrentOrganization = {
  __typename?: 'CurrentOrganization';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  adyenPaymentProviders?: Maybe<Array<AdyenProvider>>;
  apiKey?: Maybe<Scalars['String']['output']>;
  appliedDunningCampaign?: Maybe<DunningCampaign>;
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  defaultCurrency: CurrencyEnum;
  documentNumberPrefix: Scalars['String']['output'];
  documentNumbering: DocumentNumberingEnum;
  email?: Maybe<Scalars['String']['output']>;
  emailSettings?: Maybe<Array<EmailSettingsEnum>>;
  euTaxManagement: Scalars['Boolean']['output'];
  finalizeZeroAmountInvoice: Scalars['Boolean']['output'];
  gocardlessPaymentProviders?: Maybe<Array<GocardlessProvider>>;
  id: Scalars['ID']['output'];
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  netPaymentTerm: Scalars['Int']['output'];
  premiumIntegrations: Array<PremiumIntegrationTypeEnum>;
  state?: Maybe<Scalars['String']['output']>;
  stripePaymentProviders?: Maybe<Array<StripeProvider>>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  /** Query taxes of an organization */
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


/** Current Organization Type */
export type CurrentOrganizationTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};

export type CurrentVersion = {
  __typename?: 'CurrentVersion';
  githubUrl: Scalars['String']['output'];
  number: Scalars['String']['output'];
};

export type Customer = {
  __typename?: 'Customer';
  /** Number of active subscriptions per customer */
  activeSubscriptionsCount: Scalars['Int']['output'];
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  anrokCustomer?: Maybe<AnrokCustomer>;
  applicableTimezone: TimezoneEnum;
  appliedAddOns?: Maybe<Array<AppliedAddOn>>;
  appliedCoupons?: Maybe<Array<AppliedCoupon>>;
  appliedDunningCampaign?: Maybe<DunningCampaign>;
  billingConfiguration?: Maybe<CustomerBillingConfiguration>;
  /** Check if customer attributes are editable */
  canEditAttributes: Scalars['Boolean']['output'];
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  /** Credit notes credits balance available per customer */
  creditNotesBalanceAmountCents: Scalars['BigInt']['output'];
  /** Number of available credits from credit notes per customer */
  creditNotesCreditsAvailableCount: Scalars['Int']['output'];
  currency?: Maybe<CurrencyEnum>;
  customerType?: Maybe<CustomerTypeEnum>;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  excludeFromDunningCampaign: Scalars['Boolean']['output'];
  externalId: Scalars['String']['output'];
  externalSalesforceId?: Maybe<Scalars['String']['output']>;
  /** Options for handling invoices with a zero total amount. */
  finalizeZeroAmountInvoice?: Maybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: Maybe<Scalars['String']['output']>;
  /** Define if a customer has an active wallet */
  hasActiveWallet: Scalars['Boolean']['output'];
  /** Define if a customer has any credit note */
  hasCreditNotes: Scalars['Boolean']['output'];
  /** Define if a customer has overdue invoices */
  hasOverdueInvoices: Scalars['Boolean']['output'];
  hubspotCustomer?: Maybe<HubspotCustomer>;
  id: Scalars['ID']['output'];
  invoiceGracePeriod?: Maybe<Scalars['Int']['output']>;
  invoices?: Maybe<Array<Invoice>>;
  lastDunningCampaignAttempt: Scalars['Int']['output'];
  lastDunningCampaignAttemptAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastname?: Maybe<Scalars['String']['output']>;
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  metadata?: Maybe<Array<CustomerMetadata>>;
  name?: Maybe<Scalars['String']['output']>;
  netPaymentTerm?: Maybe<Scalars['Int']['output']>;
  netsuiteCustomer?: Maybe<NetsuiteCustomer>;
  paymentProvider?: Maybe<ProviderTypeEnum>;
  paymentProviderCode?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  providerCustomer?: Maybe<ProviderCustomer>;
  sequentialId: Scalars['String']['output'];
  shippingAddress?: Maybe<CustomerAddress>;
  slug: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  /** Query subscriptions of a customer */
  subscriptions: Array<Subscription>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  taxes?: Maybe<Array<Tax>>;
  timezone?: Maybe<TimezoneEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  url?: Maybe<Scalars['String']['output']>;
  xeroCustomer?: Maybe<XeroCustomer>;
  zipcode?: Maybe<Scalars['String']['output']>;
};


export type CustomerSubscriptionsArgs = {
  status?: InputMaybe<Array<StatusTypeEnum>>;
};

export type CustomerAddress = {
  __typename?: 'CustomerAddress';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  state?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};

export type CustomerAddressInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  state?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerBillingConfiguration = {
  __typename?: 'CustomerBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
};

export type CustomerBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
};

/** CustomerCollection type */
export type CustomerCollection = {
  __typename?: 'CustomerCollection';
  /** A collection of paginated CustomerCollection */
  collection: Array<Customer>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type CustomerMetadata = {
  __typename?: 'CustomerMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayInInvoice: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

export type CustomerMetadataInput = {
  displayInInvoice: Scalars['Boolean']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type CustomerPortalCustomer = {
  __typename?: 'CustomerPortalCustomer';
  addressLine1?: Maybe<Scalars['String']['output']>;
  addressLine2?: Maybe<Scalars['String']['output']>;
  applicableTimezone: TimezoneEnum;
  billingConfiguration?: Maybe<CustomerBillingConfiguration>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<CountryCode>;
  currency?: Maybe<CurrencyEnum>;
  customerType?: Maybe<CustomerTypeEnum>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  firstname?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastname?: Maybe<Scalars['String']['output']>;
  legalName?: Maybe<Scalars['String']['output']>;
  legalNumber?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  premium: Scalars['Boolean']['output'];
  shippingAddress?: Maybe<CustomerAddress>;
  state?: Maybe<Scalars['String']['output']>;
  taxIdentificationNumber?: Maybe<Scalars['String']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};

/** CustomerPortalOrganization */
export type CustomerPortalOrganization = {
  __typename?: 'CustomerPortalOrganization';
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  defaultCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  premiumIntegrations: Array<PremiumIntegrationTypeEnum>;
  timezone?: Maybe<TimezoneEnum>;
};

/** CustomerPortalWallet */
export type CustomerPortalWallet = {
  __typename?: 'CustomerPortalWallet';
  balanceCents: Scalars['BigInt']['output'];
  consumedAmountCents: Scalars['BigInt']['output'];
  consumedCredits: Scalars['Float']['output'];
  creditsBalance: Scalars['Float']['output'];
  creditsOngoingBalance: Scalars['Float']['output'];
  currency: CurrencyEnum;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ongoingBalanceCents: Scalars['BigInt']['output'];
  ongoingUsageBalanceCents: Scalars['BigInt']['output'];
  rateAmount: Scalars['Float']['output'];
  status: WalletStatusEnum;
};

/** CustomerPortalWalletCollection type */
export type CustomerPortalWalletCollection = {
  __typename?: 'CustomerPortalWalletCollection';
  /** A collection of paginated CustomerPortalWalletCollection */
  collection: Array<CustomerPortalWallet>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type CustomerPortalWalletTransaction = {
  __typename?: 'CustomerPortalWalletTransaction';
  amount: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmount: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status: WalletTransactionStatusEnum;
  transactionStatus: WalletTransactionTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  wallet?: Maybe<CustomerPortalWallet>;
};

/** CustomerPortalWalletTransactionCollection type */
export type CustomerPortalWalletTransactionCollection = {
  __typename?: 'CustomerPortalWalletTransactionCollection';
  /** A collection of paginated CustomerPortalWalletTransactionCollection */
  collection: Array<CustomerPortalWalletTransaction>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum CustomerTypeEnum {
  Company = 'company',
  Individual = 'individual'
}

export type CustomerUsage = {
  __typename?: 'CustomerUsage';
  amountCents: Scalars['BigInt']['output'];
  chargesUsage: Array<ChargeUsage>;
  currency: CurrencyEnum;
  fromDatetime: Scalars['ISO8601DateTime']['output'];
  issuingDate: Scalars['ISO8601Date']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  toDatetime: Scalars['ISO8601DateTime']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
};

export type DataExport = {
  __typename?: 'DataExport';
  id: Scalars['ID']['output'];
  status: DataExportStatusEnum;
};

export enum DataExportFormatTypeEnum {
  Csv = 'csv'
}

/** Export Invoices search query and filters input argument */
export type DataExportInvoiceFiltersInput = {
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum>>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};

export enum DataExportStatusEnum {
  Completed = 'completed',
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing'
}

/** Autogenerated input type of DestroyAddOn */
export type DestroyAddOnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAddOn. */
export type DestroyAddOnPayload = {
  __typename?: 'DestroyAddOnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyAdjustedFee */
export type DestroyAdjustedFeeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyAdjustedFee. */
export type DestroyAdjustedFeePayload = {
  __typename?: 'DestroyAdjustedFeePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyBillableMetric */
export type DestroyBillableMetricInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** Autogenerated return type of DestroyBillableMetric. */
export type DestroyBillableMetricPayload = {
  __typename?: 'DestroyBillableMetricPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyCoupon */
export type DestroyCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCoupon. */
export type DestroyCouponPayload = {
  __typename?: 'DestroyCouponPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyCustomer */
export type DestroyCustomerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyCustomer. */
export type DestroyCustomerPayload = {
  __typename?: 'DestroyCustomerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyIntegrationCollectionMapping */
export type DestroyIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationCollectionMapping. */
export type DestroyIntegrationCollectionMappingPayload = {
  __typename?: 'DestroyIntegrationCollectionMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyIntegration */
export type DestroyIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DestroyIntegrationMapping */
export type DestroyIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyIntegrationMapping. */
export type DestroyIntegrationMappingPayload = {
  __typename?: 'DestroyIntegrationMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DestroyIntegration. */
export type DestroyIntegrationPayload = {
  __typename?: 'DestroyIntegrationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPaymentProvider */
export type DestroyPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPaymentProvider. */
export type DestroyPaymentProviderPayload = {
  __typename?: 'DestroyPaymentProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyPlan */
export type DestroyPlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPlan. */
export type DestroyPlanPayload = {
  __typename?: 'DestroyPlanPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyTax */
export type DestroyTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyTax. */
export type DestroyTaxPayload = {
  __typename?: 'DestroyTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DestroyWebhookEndpoint */
export type DestroyWebhookEndpointInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyWebhookEndpoint. */
export type DestroyWebhookEndpointPayload = {
  __typename?: 'DestroyWebhookEndpointPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
};

/** Document numbering type */
export enum DocumentNumberingEnum {
  PerCustomer = 'per_customer',
  PerOrganization = 'per_organization'
}

/** Autogenerated input type of DownloadCreditNote */
export type DownloadCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadCustomerPortalInvoice */
export type DownloadCustomerPortalInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DownloadInvoice */
export type DownloadInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type DunningCampaign = {
  __typename?: 'DunningCampaign';
  appliedToOrganization: Scalars['Boolean']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  daysBetweenAttempts: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  maxAttempts: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  thresholds: Array<DunningCampaignThreshold>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** DunningCampaignCollection type */
export type DunningCampaignCollection = {
  __typename?: 'DunningCampaignCollection';
  /** A collection of paginated DunningCampaignCollection */
  collection: Array<DunningCampaign>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type DunningCampaignThreshold = {
  __typename?: 'DunningCampaignThreshold';
  amountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
};

/** Organization Email Settings Values */
export enum EmailSettingsEnum {
  /** credit_note.created */
  CreditNoteCreated = 'credit_note_created',
  /** invoice.finalized */
  InvoiceFinalized = 'invoice_finalized'
}

export enum ErrorCodesEnum {
  NotProvided = 'not_provided',
  TaxError = 'tax_error',
  TaxVoidingError = 'tax_voiding_error'
}

export type ErrorDetail = {
  __typename?: 'ErrorDetail';
  errorCode: ErrorCodesEnum;
  errorDetails?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
};

export type Event = {
  __typename?: 'Event';
  apiClient?: Maybe<Scalars['String']['output']>;
  billableMetricName?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  customerTimezone: TimezoneEnum;
  deletedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalSubscriptionId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  matchBillableMetric?: Maybe<Scalars['Boolean']['output']>;
  matchCustomField?: Maybe<Scalars['Boolean']['output']>;
  matchCustomer?: Maybe<Scalars['Boolean']['output']>;
  matchSubscription?: Maybe<Scalars['Boolean']['output']>;
  payload: Scalars['JSON']['output'];
  receivedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  timestamp?: Maybe<Scalars['ISO8601DateTime']['output']>;
  transactionId?: Maybe<Scalars['String']['output']>;
};

/** EventCollection type */
export type EventCollection = {
  __typename?: 'EventCollection';
  /** A collection of paginated EventCollection */
  collection: Array<Event>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum ExportTypeEnum {
  InvoiceFees = 'invoice_fees',
  Invoices = 'invoices'
}

export type Fee = InvoiceItem & {
  __typename?: 'Fee';
  adjustedFee: Scalars['Boolean']['output'];
  adjustedFeeType?: Maybe<AdjustedFeeTypeEnum>;
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  amountDetails?: Maybe<FeeAmountDetails>;
  appliedTaxes?: Maybe<Array<FeeAppliedTax>>;
  charge?: Maybe<Charge>;
  chargeFilter?: Maybe<ChargeFilter>;
  creditableAmountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  description?: Maybe<Scalars['String']['output']>;
  eventsCount?: Maybe<Scalars['BigInt']['output']>;
  feeType: FeeTypesEnum;
  groupedBy: Scalars['JSON']['output'];
  id: Scalars['ID']['output'];
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  invoiceName?: Maybe<Scalars['String']['output']>;
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
  preciseUnitAmount: Scalars['Float']['output'];
  subscription?: Maybe<Subscription>;
  succeededAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate?: Maybe<Scalars['Float']['output']>;
  trueUpFee?: Maybe<Fee>;
  trueUpParentFee?: Maybe<Fee>;
  units: Scalars['Float']['output'];
};

export type FeeAmountDetails = {
  __typename?: 'FeeAmountDetails';
  fixedFeeTotalAmount?: Maybe<Scalars['String']['output']>;
  fixedFeeUnitAmount?: Maybe<Scalars['String']['output']>;
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  freeEvents?: Maybe<Scalars['Int']['output']>;
  freeUnits?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<FeeAmountDetailsGraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<FeeAmountDetailsGraduatedRange>>;
  minMaxAdjustmentTotalAmount?: Maybe<Scalars['String']['output']>;
  paidEvents?: Maybe<Scalars['Int']['output']>;
  paidUnits?: Maybe<Scalars['String']['output']>;
  perPackageSize?: Maybe<Scalars['Int']['output']>;
  perPackageUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedPercentageRange = {
  __typename?: 'FeeAmountDetailsGraduatedPercentageRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAmountDetailsGraduatedRange = {
  __typename?: 'FeeAmountDetailsGraduatedRange';
  flatUnitAmount?: Maybe<Scalars['String']['output']>;
  fromValue?: Maybe<Scalars['BigInt']['output']>;
  perUnitAmount?: Maybe<Scalars['String']['output']>;
  perUnitTotalAmount?: Maybe<Scalars['String']['output']>;
  toValue?: Maybe<Scalars['BigInt']['output']>;
  totalWithFlatAmount?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
};

export type FeeAppliedTax = AppliedTax & {
  __typename?: 'FeeAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  fee: Fee;
  id: Scalars['ID']['output'];
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Fee input for creating invoice */
export type FeeInput = {
  addOnId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  unitAmountCents?: InputMaybe<Scalars['BigInt']['input']>;
  units?: InputMaybe<Scalars['Float']['input']>;
};

export enum FeeTypesEnum {
  AddOn = 'add_on',
  Charge = 'charge',
  Commitment = 'commitment',
  Credit = 'credit',
  Subscription = 'subscription'
}

/** Create Invoice input arguments */
export type FetchDraftInvoiceTaxesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyEnum>;
  customerId: Scalars['ID']['input'];
  fees: Array<FeeInput>;
};

/** Autogenerated input type of FetchIntegrationAccounts */
export type FetchIntegrationAccountsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FetchIntegrationItems */
export type FetchIntegrationItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FetchIntegrationTaxItems */
export type FetchIntegrationTaxItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FinalizeAllInvoices */
export type FinalizeAllInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of FinalizeInvoice */
export type FinalizeInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum FinalizeZeroAmountInvoiceEnum {
  Finalize = 'finalize',
  Inherit = 'inherit',
  Skip = 'skip'
}

export type FinalizedInvoiceCollection = {
  __typename?: 'FinalizedInvoiceCollection';
  amountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  invoicesCount: Scalars['BigInt']['output'];
  month: Scalars['ISO8601DateTime']['output'];
  paymentStatus?: Maybe<InvoicePaymentStatusTypeEnum>;
};

/** FinalizedInvoiceCollectionCollection type */
export type FinalizedInvoiceCollectionCollection = {
  __typename?: 'FinalizedInvoiceCollectionCollection';
  /** A collection of paginated FinalizedInvoiceCollectionCollection */
  collection: Array<FinalizedInvoiceCollection>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of GenerateCustomerPortalUrl */
export type GenerateCustomerPortalUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of GenerateCustomerPortalUrl. */
export type GenerateCustomerPortalUrlPayload = {
  __typename?: 'GenerateCustomerPortalUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type GocardlessProvider = {
  __typename?: 'GocardlessProvider';
  code: Scalars['String']['output'];
  hasAccessToken?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
  webhookSecret?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of GoogleAcceptInvite */
export type GoogleAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleLoginUser */
export type GoogleLoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** Autogenerated input type of GoogleRegisterUser */
export type GoogleRegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
};

export type GraduatedPercentageRange = {
  __typename?: 'GraduatedPercentageRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  rate: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedPercentageRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  rate: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GraduatedRange = {
  __typename?: 'GraduatedRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type GraduatedRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

export type GrossRevenue = {
  __typename?: 'GrossRevenue';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  invoicesCount: Scalars['BigInt']['output'];
  month: Scalars['ISO8601DateTime']['output'];
};

/** GrossRevenueCollection type */
export type GrossRevenueCollection = {
  __typename?: 'GrossRevenueCollection';
  /** A collection of paginated GrossRevenueCollection */
  collection: Array<GrossRevenue>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type GroupedChargeUsage = {
  __typename?: 'GroupedChargeUsage';
  amountCents: Scalars['BigInt']['output'];
  eventsCount: Scalars['Int']['output'];
  filters?: Maybe<Array<ChargeFilterUsage>>;
  groupedBy?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['ID']['output'];
  units: Scalars['Float']['output'];
};

export type HubspotCustomer = {
  __typename?: 'HubspotCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
  targetedObject?: Maybe<HubspotTargetedObjectsEnum>;
};

export type HubspotIntegration = {
  __typename?: 'HubspotIntegration';
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  defaultTargetedObject: HubspotTargetedObjectsEnum;
  id: Scalars['ID']['output'];
  invoicesObjectTypeId?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  portalId?: Maybe<Scalars['String']['output']>;
  subscriptionsObjectTypeId?: Maybe<Scalars['String']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncSubscriptions?: Maybe<Scalars['Boolean']['output']>;
};

export enum HubspotTargetedObjectsEnum {
  Companies = 'companies',
  Contacts = 'contacts'
}

export type Integration = AnrokIntegration | HubspotIntegration | NetsuiteIntegration | OktaIntegration | XeroIntegration;

/** IntegrationCollection type */
export type IntegrationCollection = {
  __typename?: 'IntegrationCollection';
  /** A collection of paginated IntegrationCollection */
  collection: Array<Integration>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type IntegrationCustomerInput = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  integrationCode?: InputMaybe<Scalars['String']['input']>;
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  integrationType?: InputMaybe<IntegrationTypeEnum>;
  subsidiaryId?: InputMaybe<Scalars['String']['input']>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
  targetedObject?: InputMaybe<HubspotTargetedObjectsEnum>;
};

export type IntegrationItem = {
  __typename?: 'IntegrationItem';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  itemType: IntegrationItemTypeEnum;
};

/** IntegrationItemCollection type */
export type IntegrationItemCollection = {
  __typename?: 'IntegrationItemCollection';
  /** A collection of paginated IntegrationItemCollection */
  collection: Array<IntegrationItem>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum IntegrationItemTypeEnum {
  Account = 'account',
  Standard = 'standard',
  Tax = 'tax'
}

export enum IntegrationTypeEnum {
  Anrok = 'anrok',
  AutoDunning = 'auto_dunning',
  Hubspot = 'hubspot',
  Netsuite = 'netsuite',
  Okta = 'okta',
  ProgressiveBilling = 'progressive_billing',
  RevenueAnalytics = 'revenue_analytics',
  Xero = 'xero'
}

export type Invite = {
  __typename?: 'Invite';
  acceptedAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  recipient: Membership;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role: MembershipRole;
  status: InviteStatusTypeEnum;
  token: Scalars['String']['output'];
};

/** InviteCollection type */
export type InviteCollection = {
  __typename?: 'InviteCollection';
  /** A collection of paginated InviteCollection */
  collection: Array<Invite>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum InviteStatusTypeEnum {
  Accepted = 'accepted',
  Pending = 'pending',
  Revoked = 'revoked'
}

/** Invoice */
export type Invoice = {
  __typename?: 'Invoice';
  appliedTaxes?: Maybe<Array<InvoiceAppliedTax>>;
  associatedActiveWalletPresent: Scalars['Boolean']['output'];
  availableToCreditAmountCents: Scalars['BigInt']['output'];
  chargeAmountCents: Scalars['BigInt']['output'];
  couponsAmountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditNotes?: Maybe<Array<CreditNote>>;
  creditNotesAmountCents: Scalars['BigInt']['output'];
  creditableAmountCents: Scalars['BigInt']['output'];
  currency?: Maybe<CurrencyEnum>;
  customer: Customer;
  errorDetails?: Maybe<Array<ErrorDetail>>;
  externalCrmIntegrationId?: Maybe<Scalars['String']['output']>;
  externalIntegrationId?: Maybe<Scalars['String']['output']>;
  fees?: Maybe<Array<Fee>>;
  feesAmountCents: Scalars['BigInt']['output'];
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCrmSyncable: Scalars['Boolean']['output'];
  integrationSyncable: Scalars['Boolean']['output'];
  invoiceSubscriptions?: Maybe<Array<InvoiceSubscription>>;
  invoiceType: InvoiceTypeEnum;
  issuingDate: Scalars['ISO8601Date']['output'];
  metadata?: Maybe<Array<InvoiceMetadata>>;
  number: Scalars['String']['output'];
  paymentDisputeLosable: Scalars['Boolean']['output'];
  paymentDisputeLostAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  paymentDueDate: Scalars['ISO8601Date']['output'];
  paymentOverdue: Scalars['Boolean']['output'];
  paymentStatus: InvoicePaymentStatusTypeEnum;
  prepaidCreditAmountCents: Scalars['BigInt']['output'];
  progressiveBillingCreditAmountCents: Scalars['BigInt']['output'];
  refundableAmountCents: Scalars['BigInt']['output'];
  sequentialId: Scalars['ID']['output'];
  status: InvoiceStatusTypeEnum;
  subTotalExcludingTaxesAmountCents: Scalars['BigInt']['output'];
  subTotalIncludingTaxesAmountCents: Scalars['BigInt']['output'];
  subscriptions?: Maybe<Array<Subscription>>;
  taxProviderVoidable: Scalars['Boolean']['output'];
  taxesAmountCents: Scalars['BigInt']['output'];
  taxesRate: Scalars['Float']['output'];
  totalAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  versionNumber: Scalars['Int']['output'];
  voidable: Scalars['Boolean']['output'];
};

export type InvoiceAppliedTax = AppliedTax & {
  __typename?: 'InvoiceAppliedTax';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  appliedOnWholeInvoice: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  enumedTaxCode?: Maybe<InvoiceAppliedTaxOnWholeInvoiceCodeEnum>;
  feesAmountCents: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  invoice: Invoice;
  tax?: Maybe<Tax>;
  taxCode: Scalars['String']['output'];
  taxDescription?: Maybe<Scalars['String']['output']>;
  taxName: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
  taxableAmountCents: Scalars['BigInt']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export enum InvoiceAppliedTaxOnWholeInvoiceCodeEnum {
  CustomerExempt = 'customer_exempt',
  JurisHasNoTax = 'juris_has_no_tax',
  JurisNotTaxed = 'juris_not_taxed',
  NotCollecting = 'not_collecting',
  ReverseCharge = 'reverse_charge',
  TransactionExempt = 'transaction_exempt',
  UnknownTaxation = 'unknown_taxation'
}

/** InvoiceCollection type */
export type InvoiceCollection = {
  __typename?: 'InvoiceCollection';
  /** A collection of paginated InvoiceCollection */
  collection: Array<Invoice>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Invoice Item */
export type InvoiceItem = {
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  itemCode: Scalars['String']['output'];
  itemName: Scalars['String']['output'];
  itemType: Scalars['String']['output'];
};

/** Attributes for invoice metadata object */
export type InvoiceMetadata = {
  __typename?: 'InvoiceMetadata';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  value: Scalars['String']['output'];
};

/** Attributes for creating or updating invoice metadata object */
export type InvoiceMetadataInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export enum InvoicePaymentStatusTypeEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum InvoiceStatusTypeEnum {
  Closed = 'closed',
  Draft = 'draft',
  Failed = 'failed',
  Finalized = 'finalized',
  Generating = 'generating',
  Open = 'open',
  Voided = 'voided'
}

export type InvoiceSubscription = {
  __typename?: 'InvoiceSubscription';
  chargeAmountCents: Scalars['BigInt']['output'];
  chargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  chargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  fees?: Maybe<Array<Fee>>;
  fromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesFromDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  inAdvanceChargesToDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  invoice: Invoice;
  subscription: Subscription;
  subscriptionAmountCents: Scalars['BigInt']['output'];
  toDatetime?: Maybe<Scalars['ISO8601DateTime']['output']>;
  totalAmountCents: Scalars['BigInt']['output'];
};

export enum InvoiceTypeEnum {
  AddOn = 'add_on',
  AdvanceCharges = 'advance_charges',
  Credit = 'credit',
  OneOff = 'one_off',
  ProgressiveBilling = 'progressive_billing',
  Subscription = 'subscription'
}

export type InvoicedUsage = {
  __typename?: 'InvoicedUsage';
  amountCents: Scalars['BigInt']['output'];
  code?: Maybe<Scalars['String']['output']>;
  currency: CurrencyEnum;
  month: Scalars['ISO8601DateTime']['output'];
};

/** InvoicedUsageCollection type */
export type InvoicedUsageCollection = {
  __typename?: 'InvoicedUsageCollection';
  /** A collection of paginated InvoicedUsageCollection */
  collection: Array<InvoicedUsage>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum LagoApiError {
  AccountingTimeZoneNotSetForSeller = 'accountingTimeZoneNotSetForSeller',
  AccountingTimeZoneNotSupported = 'accountingTimeZoneNotSupported',
  CouponIsNotReusable = 'coupon_is_not_reusable',
  CurrenciesDoesNotMatch = 'currencies_does_not_match',
  CurrencyCodeNotSupported = 'currencyCodeNotSupported',
  CustomerAddressCouldNotResolve = 'customerAddressCouldNotResolve',
  CustomerAddressCountryNotSupported = 'customerAddressCountryNotSupported',
  CustomerIdNotFound = 'customerIdNotFound',
  DoesNotMatchItemAmounts = 'does_not_match_item_amounts',
  DomainNotConfigured = 'domain_not_configured',
  EmailAlreadyUsed = 'email_already_used',
  ExpiredJwtToken = 'expired_jwt_token',
  ExternalServiceError = 'externalServiceError',
  Forbidden = 'forbidden',
  GoogleAuthMissingSetup = 'google_auth_missing_setup',
  IncorrectLoginOrPassword = 'incorrect_login_or_password',
  InternalError = 'internal_error',
  InvalidGoogleCode = 'invalid_google_code',
  InvalidGoogleToken = 'invalid_google_token',
  InviteAlreadyExists = 'invite_already_exists',
  InviteEmailMistmatch = 'invite_email_mistmatch',
  InviteNotFound = 'invite_not_found',
  InvoicesNotOverdue = 'invoices_not_overdue',
  NotFound = 'not_found',
  NotOrganizationMember = 'not_organization_member',
  OktaUserinfoError = 'okta_userinfo_error',
  PaymentProcessorIsCurrentlyHandlingPayment = 'payment_processor_is_currently_handling_payment',
  PlanNotFound = 'plan_not_found',
  PlanOverlapping = 'plan_overlapping',
  ProductExternalIdUnknown = 'productExternalIdUnknown',
  TaxDateTooFarInFuture = 'taxDateTooFarInFuture',
  TaxDateTooFarInPast = 'taxDateTooFarInPast',
  TokenEncodingError = 'token_encoding_error',
  Unauthorized = 'unauthorized',
  UnprocessableEntity = 'unprocessable_entity',
  UrlIsInvalid = 'url_is_invalid',
  UserAlreadyExists = 'user_already_exists',
  UserDoesNotExist = 'user_does_not_exist',
  ValueAlreadyExist = 'value_already_exist',
  ValueIsInvalid = 'value_is_invalid',
  ValueIsOutOfRange = 'value_is_out_of_range'
}

export type LimitationInput = {
  billableMetricIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  planIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type LoginUser = {
  __typename?: 'LoginUser';
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of LoginUser */
export type LoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated input type of LoseInvoiceDispute */
export type LoseInvoiceDisputeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum MappableTypeEnum {
  AddOn = 'AddOn',
  BillableMetric = 'BillableMetric'
}

export type Mapping = {
  __typename?: 'Mapping';
  externalAccountCode?: Maybe<Scalars['String']['output']>;
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationId: Scalars['ID']['output'];
  mappableId: Scalars['ID']['output'];
  mappableType: MappableTypeEnum;
};

/** MappingCollection type */
export type MappingCollection = {
  __typename?: 'MappingCollection';
  /** A collection of paginated MappingCollection */
  collection: Array<Mapping>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum MappingTypeEnum {
  Account = 'account',
  Coupon = 'coupon',
  CreditNote = 'credit_note',
  FallbackItem = 'fallback_item',
  MinimumCommitment = 'minimum_commitment',
  PrepaidCredit = 'prepaid_credit',
  SubscriptionFee = 'subscription_fee',
  Tax = 'tax'
}

export type Membership = {
  __typename?: 'Membership';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization: Organization;
  permissions: Permissions;
  revokedAt: Scalars['ISO8601DateTime']['output'];
  role: MembershipRole;
  status: MembershipStatus;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

/** MembershipCollection type */
export type MembershipCollection = {
  __typename?: 'MembershipCollection';
  /** A collection of paginated MembershipCollection */
  collection: Array<Membership>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: Metadata;
};

export enum MembershipRole {
  Admin = 'admin',
  Finance = 'finance',
  Manager = 'manager'
}

export enum MembershipStatus {
  Active = 'active',
  Revoked = 'revoked'
}

/** Type for CollectionMetadataType */
export type Metadata = {
  __typename?: 'Metadata';
  adminCount: Scalars['Int']['output'];
  /** Current Page of loaded data */
  currentPage: Scalars['Int']['output'];
  /** The number of items per page */
  limitValue: Scalars['Int']['output'];
  /** The total number of items to be paginated */
  totalCount: Scalars['Int']['output'];
  /** The total number of pages in the pagination */
  totalPages: Scalars['Int']['output'];
};

export type Mrr = {
  __typename?: 'Mrr';
  amountCents?: Maybe<Scalars['BigInt']['output']>;
  currency?: Maybe<CurrencyEnum>;
  month: Scalars['ISO8601DateTime']['output'];
};

/** MrrCollection type */
export type MrrCollection = {
  __typename?: 'MrrCollection';
  /** A collection of paginated MrrCollection */
  collection: Array<Mrr>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a new Invite */
  acceptInvite?: Maybe<RegisterUser>;
  /** Add Adyen payment provider */
  addAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Add or update Gocardless payment provider */
  addGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Add Stripe API keys to the organization */
  addStripePaymentProvider?: Maybe<StripeProvider>;
  /** Creates a new add-on */
  createAddOn?: Maybe<AddOn>;
  /** Creates Adjusted Fee */
  createAdjustedFee?: Maybe<Fee>;
  /** Create Anrok integration */
  createAnrokIntegration?: Maybe<AnrokIntegration>;
  /** Assigns a Coupon to a Customer */
  createAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Creates a new Billable metric */
  createBillableMetric?: Maybe<BillableMetric>;
  /** Creates a new Coupon */
  createCoupon?: Maybe<Coupon>;
  /** Creates a new Credit Note */
  createCreditNote?: Maybe<CreditNote>;
  /** Creates a new customer */
  createCustomer?: Maybe<Customer>;
  /** Creates a new Customer Wallet Transaction from Customer Portal */
  createCustomerPortalWalletTransaction?: Maybe<CustomerPortalWalletTransactionCollection>;
  /** Creates a new Customer Wallet */
  createCustomerWallet?: Maybe<Wallet>;
  /** Creates a new Customer Wallet Transaction */
  createCustomerWalletTransaction?: Maybe<WalletTransactionCollection>;
  /** Creates a new dunning campaign */
  createDunningCampaign?: Maybe<DunningCampaign>;
  /** Create Hubspot integration */
  createHubspotIntegration?: Maybe<HubspotIntegration>;
  /** Create integration collection mapping */
  createIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Create integration mapping */
  createIntegrationMapping?: Maybe<Mapping>;
  /** Creates a new Invite */
  createInvite?: Maybe<Invite>;
  /** Creates a new Invoice */
  createInvoice?: Maybe<Invoice>;
  /** Request data export of invoices */
  createInvoicesDataExport?: Maybe<DataExport>;
  /** Create Netsuite integration */
  createNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Create Okta integration */
  createOktaIntegration?: Maybe<OktaIntegration>;
  /** Creates a new password reset */
  createPasswordReset?: Maybe<CreatePasswordResetPayload>;
  /** Creates a payment request */
  createPaymentRequest?: Maybe<PaymentRequest>;
  /** Creates a new Plan */
  createPlan?: Maybe<Plan>;
  /** Create a new Subscription */
  createSubscription?: Maybe<Subscription>;
  /** Creates a tax */
  createTax?: Maybe<Tax>;
  /** Create a new webhook endpoint */
  createWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Create Xero integration */
  createXeroIntegration?: Maybe<XeroIntegration>;
  /** Deletes an add-on */
  destroyAddOn?: Maybe<DestroyAddOnPayload>;
  /** Deletes an adjusted fee */
  destroyAdjustedFee?: Maybe<DestroyAdjustedFeePayload>;
  /** Deletes a Billable metric */
  destroyBillableMetric?: Maybe<DestroyBillableMetricPayload>;
  /** Deletes a coupon */
  destroyCoupon?: Maybe<DestroyCouponPayload>;
  /** Delete a Customer */
  destroyCustomer?: Maybe<DestroyCustomerPayload>;
  /** Destroy an integration */
  destroyIntegration?: Maybe<DestroyIntegrationPayload>;
  /** Destroy an integration collection mapping */
  destroyIntegrationCollectionMapping?: Maybe<DestroyIntegrationCollectionMappingPayload>;
  /** Destroy an integration mapping */
  destroyIntegrationMapping?: Maybe<DestroyIntegrationMappingPayload>;
  /** Destroy a payment provider */
  destroyPaymentProvider?: Maybe<DestroyPaymentProviderPayload>;
  /** Deletes a Plan */
  destroyPlan?: Maybe<DestroyPlanPayload>;
  /** Deletes a tax */
  destroyTax?: Maybe<DestroyTaxPayload>;
  /** Deletes a webhook endpoint */
  destroyWebhookEndpoint?: Maybe<DestroyWebhookEndpointPayload>;
  /** Download a Credit Note PDF */
  downloadCreditNote?: Maybe<CreditNote>;
  /** Download customer portal invoice PDF */
  downloadCustomerPortalInvoice?: Maybe<Invoice>;
  /** Download an Invoice PDF */
  downloadInvoice?: Maybe<Invoice>;
  /** Fetches taxes for one-off invoice */
  fetchDraftInvoiceTaxes?: Maybe<AnrokFeeObjectCollection>;
  /** Fetch integration accounts */
  fetchIntegrationAccounts: IntegrationItemCollection;
  /** Fetch integration items */
  fetchIntegrationItems: IntegrationItemCollection;
  /** Fetch integration tax items */
  fetchIntegrationTaxItems: IntegrationItemCollection;
  /** Finalize all draft invoices */
  finalizeAllInvoices?: Maybe<InvoiceCollection>;
  /** Finalize a draft invoice */
  finalizeInvoice?: Maybe<Invoice>;
  /** Generate customer portal URL */
  generateCustomerPortalUrl?: Maybe<GenerateCustomerPortalUrlPayload>;
  /** Accepts a membership invite with Google Oauth */
  googleAcceptInvite?: Maybe<RegisterUser>;
  /** Opens a session for an existing user with Google Oauth */
  googleLoginUser?: Maybe<LoginUser>;
  /** Register a new user with Google Oauth */
  googleRegisterUser?: Maybe<RegisterUser>;
  /** Opens a session for an existing user */
  loginUser?: Maybe<LoginUser>;
  /** Mark payment dispute as lost */
  loseInvoiceDispute?: Maybe<Invoice>;
  /** Accepts a membership invite with Okta Oauth */
  oktaAcceptInvite?: Maybe<LoginUser>;
  oktaAuthorize?: Maybe<Authorize>;
  oktaLogin?: Maybe<LoginUser>;
  /** Refresh a draft invoice */
  refreshInvoice?: Maybe<Invoice>;
  /** Registers a new user and creates related organization */
  registerUser?: Maybe<RegisterUser>;
  /** Reset password for user and log in */
  resetPassword?: Maybe<LoginUser>;
  /** Retry all invoice payments */
  retryAllInvoicePayments?: Maybe<InvoiceCollection>;
  /** Retry all failed invoices */
  retryAllInvoices?: Maybe<InvoiceCollection>;
  /** Retry failed invoice */
  retryInvoice?: Maybe<Invoice>;
  /** Retry invoice payment */
  retryInvoicePayment?: Maybe<Invoice>;
  /** Retry voided invoice sync */
  retryTaxProviderVoiding?: Maybe<Invoice>;
  /** Retry tax reporting */
  retryTaxReporting?: Maybe<CreditNote>;
  /** Retry a Webhook */
  retryWebhook?: Maybe<Webhook>;
  /** Revokes an invite */
  revokeInvite?: Maybe<Invite>;
  /** Revoke a membership */
  revokeMembership?: Maybe<Membership>;
  /** Create new ApiKey while expiring provided */
  rotateApiKey?: Maybe<ApiKey>;
  /** Sync crm integration invoice */
  syncCrmIntegrationInvoice?: Maybe<SyncCrmIntegrationInvoicePayload>;
  /** Sync integration credit note */
  syncIntegrationCreditNote?: Maybe<SyncIntegrationCreditNotePayload>;
  /** Sync integration invoice */
  syncIntegrationInvoice?: Maybe<SyncIntegrationInvoicePayload>;
  /** Unassign a coupon from a customer */
  terminateAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Deletes a coupon */
  terminateCoupon?: Maybe<Coupon>;
  /** Terminates a new Customer Wallet */
  terminateCustomerWallet?: Maybe<Wallet>;
  /** Terminate a Subscription */
  terminateSubscription?: Maybe<Subscription>;
  /** Update an existing add-on */
  updateAddOn?: Maybe<AddOn>;
  /** Update Adyen payment provider */
  updateAdyenPaymentProvider?: Maybe<AdyenProvider>;
  /** Update Anrok integration */
  updateAnrokIntegration?: Maybe<AnrokIntegration>;
  /** Updates an existing Billable metric */
  updateBillableMetric?: Maybe<BillableMetric>;
  /** Update an existing coupon */
  updateCoupon?: Maybe<Coupon>;
  /** Updates an existing Credit Note */
  updateCreditNote?: Maybe<CreditNote>;
  /** Updates an existing Customer */
  updateCustomer?: Maybe<Customer>;
  /** Assign the invoice grace period to Customers */
  updateCustomerInvoiceGracePeriod?: Maybe<Customer>;
  /** Update customer data from Customer Portal */
  updateCustomerPortalCustomer?: Maybe<CustomerPortalCustomer>;
  /** Updates a new Customer Wallet */
  updateCustomerWallet?: Maybe<Wallet>;
  /** Updates a dunning campaign */
  updateDunningCampaign?: Maybe<DunningCampaign>;
  /** Update Gocardless payment provider */
  updateGocardlessPaymentProvider?: Maybe<GocardlessProvider>;
  /** Update Hubspot integration */
  updateHubspotIntegration?: Maybe<HubspotIntegration>;
  /** Update integration mapping */
  updateIntegrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Update integration mapping */
  updateIntegrationMapping?: Maybe<Mapping>;
  /** Update an invite */
  updateInvite?: Maybe<Invite>;
  /** Update an existing invoice */
  updateInvoice?: Maybe<Invoice>;
  /** Update a membership */
  updateMembership?: Maybe<Membership>;
  /** Update Netsuite integration */
  updateNetsuiteIntegration?: Maybe<NetsuiteIntegration>;
  /** Update Okta integration */
  updateOktaIntegration?: Maybe<OktaIntegration>;
  /** Updates an Organization */
  updateOrganization?: Maybe<CurrentOrganization>;
  /** Updates an existing Plan */
  updatePlan?: Maybe<Plan>;
  /** Update Stripe payment provider */
  updateStripePaymentProvider?: Maybe<StripeProvider>;
  /** Update a Subscription */
  updateSubscription?: Maybe<Subscription>;
  /** Update an existing tax */
  updateTax?: Maybe<Tax>;
  /** Update a new webhook endpoint */
  updateWebhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Update Xero integration */
  updateXeroIntegration?: Maybe<XeroIntegration>;
  /** Voids a Credit Note */
  voidCreditNote?: Maybe<CreditNote>;
  /** Void an invoice */
  voidInvoice?: Maybe<Invoice>;
};


export type MutationAcceptInviteArgs = {
  input: AcceptInviteInput;
};


export type MutationAddAdyenPaymentProviderArgs = {
  input: AddAdyenPaymentProviderInput;
};


export type MutationAddGocardlessPaymentProviderArgs = {
  input: AddGocardlessPaymentProviderInput;
};


export type MutationAddStripePaymentProviderArgs = {
  input: AddStripePaymentProviderInput;
};


export type MutationCreateAddOnArgs = {
  input: CreateAddOnInput;
};


export type MutationCreateAdjustedFeeArgs = {
  input: CreateAdjustedFeeInput;
};


export type MutationCreateAnrokIntegrationArgs = {
  input: CreateAnrokIntegrationInput;
};


export type MutationCreateAppliedCouponArgs = {
  input: CreateAppliedCouponInput;
};


export type MutationCreateBillableMetricArgs = {
  input: CreateBillableMetricInput;
};


export type MutationCreateCouponArgs = {
  input: CreateCouponInput;
};


export type MutationCreateCreditNoteArgs = {
  input: CreateCreditNoteInput;
};


export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


export type MutationCreateCustomerPortalWalletTransactionArgs = {
  input: CreateCustomerPortalWalletTransactionInput;
};


export type MutationCreateCustomerWalletArgs = {
  input: CreateCustomerWalletInput;
};


export type MutationCreateCustomerWalletTransactionArgs = {
  input: CreateCustomerWalletTransactionInput;
};


export type MutationCreateDunningCampaignArgs = {
  input: CreateDunningCampaignInput;
};


export type MutationCreateHubspotIntegrationArgs = {
  input: CreateHubspotIntegrationInput;
};


export type MutationCreateIntegrationCollectionMappingArgs = {
  input: CreateIntegrationCollectionMappingInput;
};


export type MutationCreateIntegrationMappingArgs = {
  input: CreateIntegrationMappingInput;
};


export type MutationCreateInviteArgs = {
  input: CreateInviteInput;
};


export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


export type MutationCreateInvoicesDataExportArgs = {
  input: CreateDataExportsInvoicesInput;
};


export type MutationCreateNetsuiteIntegrationArgs = {
  input: CreateNetsuiteIntegrationInput;
};


export type MutationCreateOktaIntegrationArgs = {
  input: CreateOktaIntegrationInput;
};


export type MutationCreatePasswordResetArgs = {
  input: CreatePasswordResetInput;
};


export type MutationCreatePaymentRequestArgs = {
  input: PaymentRequestCreateInput;
};


export type MutationCreatePlanArgs = {
  input: CreatePlanInput;
};


export type MutationCreateSubscriptionArgs = {
  input: CreateSubscriptionInput;
};


export type MutationCreateTaxArgs = {
  input: TaxCreateInput;
};


export type MutationCreateWebhookEndpointArgs = {
  input: WebhookEndpointCreateInput;
};


export type MutationCreateXeroIntegrationArgs = {
  input: CreateXeroIntegrationInput;
};


export type MutationDestroyAddOnArgs = {
  input: DestroyAddOnInput;
};


export type MutationDestroyAdjustedFeeArgs = {
  input: DestroyAdjustedFeeInput;
};


export type MutationDestroyBillableMetricArgs = {
  input: DestroyBillableMetricInput;
};


export type MutationDestroyCouponArgs = {
  input: DestroyCouponInput;
};


export type MutationDestroyCustomerArgs = {
  input: DestroyCustomerInput;
};


export type MutationDestroyIntegrationArgs = {
  input: DestroyIntegrationInput;
};


export type MutationDestroyIntegrationCollectionMappingArgs = {
  input: DestroyIntegrationCollectionMappingInput;
};


export type MutationDestroyIntegrationMappingArgs = {
  input: DestroyIntegrationMappingInput;
};


export type MutationDestroyPaymentProviderArgs = {
  input: DestroyPaymentProviderInput;
};


export type MutationDestroyPlanArgs = {
  input: DestroyPlanInput;
};


export type MutationDestroyTaxArgs = {
  input: DestroyTaxInput;
};


export type MutationDestroyWebhookEndpointArgs = {
  input: DestroyWebhookEndpointInput;
};


export type MutationDownloadCreditNoteArgs = {
  input: DownloadCreditNoteInput;
};


export type MutationDownloadCustomerPortalInvoiceArgs = {
  input: DownloadCustomerPortalInvoiceInput;
};


export type MutationDownloadInvoiceArgs = {
  input: DownloadInvoiceInput;
};


export type MutationFetchDraftInvoiceTaxesArgs = {
  input: FetchDraftInvoiceTaxesInput;
};


export type MutationFetchIntegrationAccountsArgs = {
  input: FetchIntegrationAccountsInput;
};


export type MutationFetchIntegrationItemsArgs = {
  input: FetchIntegrationItemsInput;
};


export type MutationFetchIntegrationTaxItemsArgs = {
  input: FetchIntegrationTaxItemsInput;
};


export type MutationFinalizeAllInvoicesArgs = {
  input: FinalizeAllInvoicesInput;
};


export type MutationFinalizeInvoiceArgs = {
  input: FinalizeInvoiceInput;
};


export type MutationGenerateCustomerPortalUrlArgs = {
  input: GenerateCustomerPortalUrlInput;
};


export type MutationGoogleAcceptInviteArgs = {
  input: GoogleAcceptInviteInput;
};


export type MutationGoogleLoginUserArgs = {
  input: GoogleLoginUserInput;
};


export type MutationGoogleRegisterUserArgs = {
  input: GoogleRegisterUserInput;
};


export type MutationLoginUserArgs = {
  input: LoginUserInput;
};


export type MutationLoseInvoiceDisputeArgs = {
  input: LoseInvoiceDisputeInput;
};


export type MutationOktaAcceptInviteArgs = {
  input: OktaAcceptInviteInput;
};


export type MutationOktaAuthorizeArgs = {
  input: OktaAuthorizeInput;
};


export type MutationOktaLoginArgs = {
  input: OktaLoginInput;
};


export type MutationRefreshInvoiceArgs = {
  input: RefreshInvoiceInput;
};


export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


export type MutationRetryAllInvoicePaymentsArgs = {
  input: RetryAllInvoicePaymentsInput;
};


export type MutationRetryAllInvoicesArgs = {
  input: RetryAllInvoicesInput;
};


export type MutationRetryInvoiceArgs = {
  input: RetryInvoiceInput;
};


export type MutationRetryInvoicePaymentArgs = {
  input: RetryInvoicePaymentInput;
};


export type MutationRetryTaxProviderVoidingArgs = {
  input: RetryTaxProviderVoidingInput;
};


export type MutationRetryTaxReportingArgs = {
  input: RetryTaxReportingInput;
};


export type MutationRetryWebhookArgs = {
  input: RetryWebhookInput;
};


export type MutationRevokeInviteArgs = {
  input: RevokeInviteInput;
};


export type MutationRevokeMembershipArgs = {
  input: RevokeMembershipInput;
};


export type MutationRotateApiKeyArgs = {
  input: RotateApiKeyInput;
};


export type MutationSyncCrmIntegrationInvoiceArgs = {
  input: SyncCrmIntegrationInvoiceInput;
};


export type MutationSyncIntegrationCreditNoteArgs = {
  input: SyncIntegrationCreditNoteInput;
};


export type MutationSyncIntegrationInvoiceArgs = {
  input: SyncIntegrationInvoiceInput;
};


export type MutationTerminateAppliedCouponArgs = {
  input: TerminateAppliedCouponInput;
};


export type MutationTerminateCouponArgs = {
  input: TerminateCouponInput;
};


export type MutationTerminateCustomerWalletArgs = {
  input: TerminateCustomerWalletInput;
};


export type MutationTerminateSubscriptionArgs = {
  input: TerminateSubscriptionInput;
};


export type MutationUpdateAddOnArgs = {
  input: UpdateAddOnInput;
};


export type MutationUpdateAdyenPaymentProviderArgs = {
  input: UpdateAdyenPaymentProviderInput;
};


export type MutationUpdateAnrokIntegrationArgs = {
  input: UpdateAnrokIntegrationInput;
};


export type MutationUpdateBillableMetricArgs = {
  input: UpdateBillableMetricInput;
};


export type MutationUpdateCouponArgs = {
  input: UpdateCouponInput;
};


export type MutationUpdateCreditNoteArgs = {
  input: UpdateCreditNoteInput;
};


export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


export type MutationUpdateCustomerInvoiceGracePeriodArgs = {
  input: UpdateCustomerInvoiceGracePeriodInput;
};


export type MutationUpdateCustomerPortalCustomerArgs = {
  input: UpdateCustomerPortalCustomerInput;
};


export type MutationUpdateCustomerWalletArgs = {
  input: UpdateCustomerWalletInput;
};


export type MutationUpdateDunningCampaignArgs = {
  input: UpdateDunningCampaignInput;
};


export type MutationUpdateGocardlessPaymentProviderArgs = {
  input: UpdateGocardlessPaymentProviderInput;
};


export type MutationUpdateHubspotIntegrationArgs = {
  input: UpdateHubspotIntegrationInput;
};


export type MutationUpdateIntegrationCollectionMappingArgs = {
  input: UpdateIntegrationCollectionMappingInput;
};


export type MutationUpdateIntegrationMappingArgs = {
  input: UpdateIntegrationMappingInput;
};


export type MutationUpdateInviteArgs = {
  input: UpdateInviteInput;
};


export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


export type MutationUpdateMembershipArgs = {
  input: UpdateMembershipInput;
};


export type MutationUpdateNetsuiteIntegrationArgs = {
  input: UpdateNetsuiteIntegrationInput;
};


export type MutationUpdateOktaIntegrationArgs = {
  input: UpdateOktaIntegrationInput;
};


export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


export type MutationUpdatePlanArgs = {
  input: UpdatePlanInput;
};


export type MutationUpdateStripePaymentProviderArgs = {
  input: UpdateStripePaymentProviderInput;
};


export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


export type MutationUpdateTaxArgs = {
  input: TaxUpdateInput;
};


export type MutationUpdateWebhookEndpointArgs = {
  input: WebhookEndpointUpdateInput;
};


export type MutationUpdateXeroIntegrationArgs = {
  input: UpdateXeroIntegrationInput;
};


export type MutationVoidCreditNoteArgs = {
  input: VoidCreditNoteInput;
};


export type MutationVoidInvoiceArgs = {
  input: VoidInvoiceInput;
};

export type NetsuiteCustomer = {
  __typename?: 'NetsuiteCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  subsidiaryId?: Maybe<Scalars['String']['output']>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type NetsuiteIntegration = {
  __typename?: 'NetsuiteIntegration';
  accountId?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  scriptEndpointUrl: Scalars['String']['output'];
  syncCreditNotes?: Maybe<Scalars['Boolean']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncPayments?: Maybe<Scalars['Boolean']['output']>;
  syncSalesOrders?: Maybe<Scalars['Boolean']['output']>;
  tokenId?: Maybe<Scalars['String']['output']>;
  tokenSecret?: Maybe<Scalars['String']['output']>;
};

/** Accept Invite with Okta Oauth input arguments */
export type OktaAcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  inviteToken: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

/** Autogenerated input type of OktaAuthorize */
export type OktaAuthorizeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  inviteToken?: InputMaybe<Scalars['String']['input']>;
};

export type OktaIntegration = {
  __typename?: 'OktaIntegration';
  clientId?: Maybe<Scalars['String']['output']>;
  clientSecret?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  domain: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organizationName: Scalars['String']['output'];
};

/** Autogenerated input type of OktaLogin */
export type OktaLoginInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

/** Safe Organization Type */
export type Organization = {
  __typename?: 'Organization';
  billingConfiguration?: Maybe<OrganizationBillingConfiguration>;
  defaultCurrency: CurrencyEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  timezone?: Maybe<TimezoneEnum>;
};

export type OrganizationBillingConfiguration = {
  __typename?: 'OrganizationBillingConfiguration';
  documentLocale?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceFooter?: Maybe<Scalars['String']['output']>;
  invoiceGracePeriod: Scalars['Int']['output'];
};

export type OrganizationBillingConfigurationInput = {
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  invoiceFooter?: InputMaybe<Scalars['String']['input']>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

export type OverdueBalance = {
  __typename?: 'OverdueBalance';
  amountCents: Scalars['BigInt']['output'];
  currency: CurrencyEnum;
  lagoInvoiceIds: Array<Scalars['String']['output']>;
  month: Scalars['ISO8601DateTime']['output'];
};

/** OverdueBalanceCollection type */
export type OverdueBalanceCollection = {
  __typename?: 'OverdueBalanceCollection';
  /** A collection of paginated OverdueBalanceCollection */
  collection: Array<OverdueBalance>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PaymentProvider = AdyenProvider | GocardlessProvider | StripeProvider;

/** PaymentProviderCollection type */
export type PaymentProviderCollection = {
  __typename?: 'PaymentProviderCollection';
  /** A collection of paginated PaymentProviderCollection */
  collection: Array<PaymentProvider>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type PaymentRequest = {
  __typename?: 'PaymentRequest';
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime']['output'];
  customer: Customer;
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  invoices: Array<Invoice>;
  paymentStatus: InvoicePaymentStatusTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** PaymentRequestCollection type */
export type PaymentRequestCollection = {
  __typename?: 'PaymentRequestCollection';
  /** A collection of paginated PaymentRequestCollection */
  collection: Array<PaymentRequest>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreatePaymentRequest */
export type PaymentRequestCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalCustomerId: Scalars['String']['input'];
  lagoInvoiceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Permissions Type */
export type Permissions = {
  __typename?: 'Permissions';
  addonsCreate: Scalars['Boolean']['output'];
  addonsDelete: Scalars['Boolean']['output'];
  addonsUpdate: Scalars['Boolean']['output'];
  addonsView: Scalars['Boolean']['output'];
  analyticsOverdueBalancesView: Scalars['Boolean']['output'];
  analyticsView: Scalars['Boolean']['output'];
  billableMetricsCreate: Scalars['Boolean']['output'];
  billableMetricsDelete: Scalars['Boolean']['output'];
  billableMetricsUpdate: Scalars['Boolean']['output'];
  billableMetricsView: Scalars['Boolean']['output'];
  couponsAttach: Scalars['Boolean']['output'];
  couponsCreate: Scalars['Boolean']['output'];
  couponsDelete: Scalars['Boolean']['output'];
  couponsDetach: Scalars['Boolean']['output'];
  couponsUpdate: Scalars['Boolean']['output'];
  couponsView: Scalars['Boolean']['output'];
  creditNotesCreate: Scalars['Boolean']['output'];
  creditNotesUpdate: Scalars['Boolean']['output'];
  creditNotesView: Scalars['Boolean']['output'];
  creditNotesVoid: Scalars['Boolean']['output'];
  customerSettingsUpdateGracePeriod: Scalars['Boolean']['output'];
  customerSettingsUpdateLang: Scalars['Boolean']['output'];
  customerSettingsUpdatePaymentTerms: Scalars['Boolean']['output'];
  customerSettingsUpdateTaxRates: Scalars['Boolean']['output'];
  customerSettingsView: Scalars['Boolean']['output'];
  customersCreate: Scalars['Boolean']['output'];
  customersDelete: Scalars['Boolean']['output'];
  customersUpdate: Scalars['Boolean']['output'];
  customersView: Scalars['Boolean']['output'];
  developersKeysManage: Scalars['Boolean']['output'];
  developersManage: Scalars['Boolean']['output'];
  draftInvoicesUpdate: Scalars['Boolean']['output'];
  dunningCampaignsCreate: Scalars['Boolean']['output'];
  dunningCampaignsUpdate: Scalars['Boolean']['output'];
  dunningCampaignsView: Scalars['Boolean']['output'];
  invoicesCreate: Scalars['Boolean']['output'];
  invoicesExport: Scalars['Boolean']['output'];
  invoicesSend: Scalars['Boolean']['output'];
  invoicesUpdate: Scalars['Boolean']['output'];
  invoicesView: Scalars['Boolean']['output'];
  invoicesVoid: Scalars['Boolean']['output'];
  organizationEmailsUpdate: Scalars['Boolean']['output'];
  organizationEmailsView: Scalars['Boolean']['output'];
  organizationIntegrationsCreate: Scalars['Boolean']['output'];
  organizationIntegrationsDelete: Scalars['Boolean']['output'];
  organizationIntegrationsUpdate: Scalars['Boolean']['output'];
  organizationIntegrationsView: Scalars['Boolean']['output'];
  organizationInvoicesUpdate: Scalars['Boolean']['output'];
  organizationInvoicesView: Scalars['Boolean']['output'];
  organizationMembersCreate: Scalars['Boolean']['output'];
  organizationMembersDelete: Scalars['Boolean']['output'];
  organizationMembersUpdate: Scalars['Boolean']['output'];
  organizationMembersView: Scalars['Boolean']['output'];
  organizationTaxesUpdate: Scalars['Boolean']['output'];
  organizationTaxesView: Scalars['Boolean']['output'];
  organizationUpdate: Scalars['Boolean']['output'];
  organizationView: Scalars['Boolean']['output'];
  paymentRequestsCreate: Scalars['Boolean']['output'];
  paymentRequestsView: Scalars['Boolean']['output'];
  plansCreate: Scalars['Boolean']['output'];
  plansDelete: Scalars['Boolean']['output'];
  plansUpdate: Scalars['Boolean']['output'];
  plansView: Scalars['Boolean']['output'];
  subscriptionsCreate: Scalars['Boolean']['output'];
  subscriptionsUpdate: Scalars['Boolean']['output'];
  subscriptionsView: Scalars['Boolean']['output'];
  walletsCreate: Scalars['Boolean']['output'];
  walletsTerminate: Scalars['Boolean']['output'];
  walletsTopUp: Scalars['Boolean']['output'];
  walletsUpdate: Scalars['Boolean']['output'];
};

export type Plan = {
  __typename?: 'Plan';
  activeSubscriptionsCount: Scalars['Int']['output'];
  amountCents: Scalars['BigInt']['output'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: Maybe<Scalars['Boolean']['output']>;
  charges?: Maybe<Array<Charge>>;
  /** Number of charges attached to a plan */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers attached to a plan */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  draftInvoicesCount: Scalars['Int']['output'];
  hasOverriddenPlans?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  interval: PlanInterval;
  invoiceDisplayName?: Maybe<Scalars['String']['output']>;
  minimumCommitment?: Maybe<Commitment>;
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  parent?: Maybe<Plan>;
  payInAdvance: Scalars['Boolean']['output'];
  subscriptionsCount: Scalars['Int']['output'];
  taxes?: Maybe<Array<Tax>>;
  trialPeriod?: Maybe<Scalars['Float']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  usageThresholds?: Maybe<Array<UsageThreshold>>;
};

/** PlanCollection type */
export type PlanCollection = {
  __typename?: 'PlanCollection';
  /** A collection of paginated PlanCollection */
  collection: Array<Plan>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum PlanInterval {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export type PlanOverridesInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  charges?: InputMaybe<Array<ChargeOverridesInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdOverridesInput>>;
};

export enum PremiumIntegrationTypeEnum {
  AutoDunning = 'auto_dunning',
  Hubspot = 'hubspot',
  Netsuite = 'netsuite',
  Okta = 'okta',
  ProgressiveBilling = 'progressive_billing',
  RevenueAnalytics = 'revenue_analytics',
  Xero = 'xero'
}

export type Properties = {
  __typename?: 'Properties';
  amount?: Maybe<Scalars['String']['output']>;
  customProperties?: Maybe<Scalars['JSON']['output']>;
  fixedAmount?: Maybe<Scalars['String']['output']>;
  freeUnits?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerEvents?: Maybe<Scalars['BigInt']['output']>;
  freeUnitsPerTotalAggregation?: Maybe<Scalars['String']['output']>;
  graduatedPercentageRanges?: Maybe<Array<GraduatedPercentageRange>>;
  graduatedRanges?: Maybe<Array<GraduatedRange>>;
  groupedBy?: Maybe<Array<Scalars['String']['output']>>;
  packageSize?: Maybe<Scalars['BigInt']['output']>;
  perTransactionMaxAmount?: Maybe<Scalars['String']['output']>;
  perTransactionMinAmount?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['String']['output']>;
  volumeRanges?: Maybe<Array<VolumeRange>>;
};

export type PropertiesInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  customProperties?: InputMaybe<Scalars['JSON']['input']>;
  fixedAmount?: InputMaybe<Scalars['String']['input']>;
  freeUnits?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerEvents?: InputMaybe<Scalars['BigInt']['input']>;
  freeUnitsPerTotalAggregation?: InputMaybe<Scalars['String']['input']>;
  graduatedPercentageRanges?: InputMaybe<Array<GraduatedPercentageRangeInput>>;
  graduatedRanges?: InputMaybe<Array<GraduatedRangeInput>>;
  groupedBy?: InputMaybe<Array<Scalars['String']['input']>>;
  packageSize?: InputMaybe<Scalars['BigInt']['input']>;
  perTransactionMaxAmount?: InputMaybe<Scalars['String']['input']>;
  perTransactionMinAmount?: InputMaybe<Scalars['String']['input']>;
  rate?: InputMaybe<Scalars['String']['input']>;
  volumeRanges?: InputMaybe<Array<VolumeRangeInput>>;
};

export type ProviderCustomer = {
  __typename?: 'ProviderCustomer';
  id: Scalars['ID']['output'];
  providerCustomerId?: Maybe<Scalars['ID']['output']>;
  providerPaymentMethods?: Maybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type ProviderCustomerInput = {
  providerCustomerId?: InputMaybe<Scalars['ID']['input']>;
  providerPaymentMethods?: InputMaybe<Array<ProviderPaymentMethodsEnum>>;
  syncWithProvider?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ProviderPaymentMethodsEnum {
  BacsDebit = 'bacs_debit',
  Card = 'card',
  Link = 'link',
  SepaDebit = 'sepa_debit',
  UsBankAccount = 'us_bank_account'
}

export enum ProviderTypeEnum {
  Adyen = 'adyen',
  Gocardless = 'gocardless',
  Stripe = 'stripe'
}

export type Query = {
  __typename?: 'Query';
  /** Query a single add-on of an organization */
  addOn?: Maybe<AddOn>;
  /** Query add-ons of an organization */
  addOns: AddOnCollection;
  /** Query the API key */
  apiKey: ApiKey;
  /** Query the API keys of current organization */
  apiKeys: SanitizedApiKeyCollection;
  /** Query a single billable metric of an organization */
  billableMetric?: Maybe<BillableMetric>;
  /** Query billable metrics of an organization */
  billableMetrics: BillableMetricCollection;
  /** Query a single coupon of an organization */
  coupon?: Maybe<Coupon>;
  /** Query coupons of an organization */
  coupons: CouponCollection;
  /** Query a single credit note */
  creditNote?: Maybe<CreditNote>;
  /** Fetch amounts for credit note creation */
  creditNoteEstimate: CreditNoteEstimate;
  /** Query credit notes */
  creditNotes: CreditNoteCollection;
  /** Retrieves currently connected user */
  currentUser: User;
  /** Retrieve the version of the application */
  currentVersion: CurrentVersion;
  /** Query a single customer of an organization */
  customer?: Maybe<Customer>;
  /** Query invoices of a customer */
  customerInvoices: InvoiceCollection;
  /** Query the usage of the customer on the current billing period */
  customerPortalCustomerUsage: CustomerUsage;
  /** Query invoice collections of a customer portal user */
  customerPortalInvoiceCollections: FinalizedInvoiceCollectionCollection;
  /** Query invoices of a customer */
  customerPortalInvoices: InvoiceCollection;
  /** Query customer portal organization */
  customerPortalOrganization?: Maybe<CustomerPortalOrganization>;
  /** Query overdue balances of a customer portal user */
  customerPortalOverdueBalances: OverdueBalanceCollection;
  /** Query a single subscription from the customer portal */
  customerPortalSubscription?: Maybe<Subscription>;
  /** Query customer portal subscriptions */
  customerPortalSubscriptions: SubscriptionCollection;
  /** Query a customer portal user */
  customerPortalUser?: Maybe<CustomerPortalCustomer>;
  /** Query wallets */
  customerPortalWallets: CustomerPortalWalletCollection;
  /** Query the usage of the customer on the current billing period */
  customerUsage: CustomerUsage;
  /** Query customers of an organization */
  customers: CustomerCollection;
  /** Query dunning campaigns of an organization */
  dunningCampaigns: DunningCampaignCollection;
  /** Query events of an organization */
  events?: Maybe<EventCollection>;
  /** Get Google auth url. */
  googleAuthUrl: AuthUrl;
  /** Query gross revenue of an organization */
  grossRevenues: GrossRevenueCollection;
  /** Query a single integration */
  integration?: Maybe<Integration>;
  /** Query a single integration collection mapping */
  integrationCollectionMapping?: Maybe<CollectionMapping>;
  /** Query integration collection mappings */
  integrationCollectionMappings?: Maybe<CollectionMappingCollection>;
  /** Query integration items of an integration */
  integrationItems: IntegrationItemCollection;
  /** Query a single integration mapping */
  integrationMapping?: Maybe<Mapping>;
  /** Query netsuite integration mappings */
  integrationMappings?: Maybe<MappingCollection>;
  /** Query integration subsidiaries */
  integrationSubsidiaries?: Maybe<SubsidiaryCollection>;
  /** Query organization's integrations */
  integrations?: Maybe<IntegrationCollection>;
  /** Query a single Invite */
  invite?: Maybe<Invite>;
  /** Query pending invites of an organization */
  invites: InviteCollection;
  /** Query a single Invoice of an organization */
  invoice?: Maybe<Invoice>;
  /** Query invoice collections of an organization */
  invoiceCollections: FinalizedInvoiceCollectionCollection;
  /** Query invoice's credit note */
  invoiceCreditNotes?: Maybe<CreditNoteCollection>;
  /** Query invoiced usage of an organization */
  invoicedUsages: InvoicedUsageCollection;
  /** Query invoices */
  invoices: InvoiceCollection;
  /** Query memberships of an organization */
  memberships: MembershipCollection;
  /** Query MRR of an organization */
  mrrs: MrrCollection;
  /** Query the current organization */
  organization?: Maybe<CurrentOrganization>;
  /** Query overdue balances of an organization */
  overdueBalances: OverdueBalanceCollection;
  /** Query a password reset by token */
  passwordReset: ResetPassword;
  /** Query a single payment provider */
  paymentProvider?: Maybe<PaymentProvider>;
  /** Query organization's payment providers */
  paymentProviders?: Maybe<PaymentProviderCollection>;
  /** Query payment requests of an organization */
  paymentRequests: PaymentRequestCollection;
  /** Query a single plan of an organization */
  plan?: Maybe<Plan>;
  /** Query plans of an organization */
  plans: PlanCollection;
  /** Query a single subscription of an organization */
  subscription?: Maybe<Subscription>;
  /** Query subscriptions of an organization */
  subscriptions: SubscriptionCollection;
  /** Query a single tax of an organization */
  tax?: Maybe<Tax>;
  /** Query taxes of an organization */
  taxes: TaxCollection;
  /** Query a single wallet of an organization */
  wallet?: Maybe<Wallet>;
  /** Query wallet transactions */
  walletTransactions: WalletTransactionCollection;
  /** Query wallets */
  wallets: WalletCollection;
  /** Query a single webhook endpoint */
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  /** Query webhook endpoints of an organization */
  webhookEndpoints: WebhookEndpointCollection;
  /** Query Webhooks */
  webhooks: WebhookCollection;
};


export type QueryAddOnArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAddOnsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryApiKeyArgs = {
  id: Scalars['ID']['input'];
};


export type QueryApiKeysArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryBillableMetricArgs = {
  id: Scalars['ID']['input'];
};


export type QueryBillableMetricsArgs = {
  aggregationTypes?: InputMaybe<Array<AggregationTypeEnum>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCouponArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCouponsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
};


export type QueryCreditNoteArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCreditNoteEstimateArgs = {
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput>;
};


export type QueryCreditNotesArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomerArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCustomerInvoicesArgs = {
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerPortalCustomerUsageArgs = {
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomerPortalInvoiceCollectionsArgs = {
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerPortalInvoicesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryCustomerPortalOverdueBalancesArgs = {
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerPortalSubscriptionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryCustomerPortalSubscriptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum>>;
};


export type QueryCustomerPortalWalletsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerUsageArgs = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionId: Scalars['ID']['input'];
};


export type QueryCustomersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryDunningCampaignsArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  currency?: InputMaybe<Array<CurrencyEnum>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryEventsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGrossRevenuesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationCollectionMappingArgs = {
  id: Scalars['ID']['input'];
};


export type QueryIntegrationCollectionMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  mappingType?: InputMaybe<MappingTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationItemsArgs = {
  integrationId: Scalars['ID']['input'];
  itemType?: InputMaybe<IntegrationItemTypeEnum>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryIntegrationMappingArgs = {
  id: Scalars['ID']['input'];
};


export type QueryIntegrationMappingsArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  mappableType?: InputMaybe<MappableTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIntegrationSubsidiariesArgs = {
  integrationId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryIntegrationsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
};


export type QueryInviteArgs = {
  token: Scalars['String']['input'];
};


export type QueryInvitesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoiceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryInvoiceCollectionsArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryInvoiceCreditNotesArgs = {
  invoiceId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryInvoicedUsagesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryInvoicesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  customerId?: InputMaybe<Scalars['ID']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum>>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum>>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum>>;
};


export type QueryMembershipsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMrrsArgs = {
  currency?: InputMaybe<CurrencyEnum>;
};


export type QueryOverdueBalancesArgs = {
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPasswordResetArgs = {
  token: Scalars['String']['input'];
};


export type QueryPaymentProviderArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentProvidersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
};


export type QueryPaymentRequestsArgs = {
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPlansArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySubscriptionArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySubscriptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum>>;
};


export type QueryTaxArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaxesArgs = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  autoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWalletArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWalletTransactionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletTransactionStatusEnum>;
  transactionType?: InputMaybe<WalletTransactionTransactionTypeEnum>;
  walletId: Scalars['ID']['input'];
};


export type QueryWalletsArgs = {
  customerId: Scalars['ID']['input'];
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<WalletStatusEnum>;
};


export type QueryWebhookEndpointArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookEndpointsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryWebhooksArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<WebhookStatusEnum>;
  webhookEndpointId: Scalars['String']['input'];
};

export enum RecurringTransactionIntervalEnum {
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Weekly = 'weekly',
  Yearly = 'yearly'
}

export enum RecurringTransactionMethodEnum {
  Fixed = 'fixed',
  Target = 'target'
}

export type RecurringTransactionRule = {
  __typename?: 'RecurringTransactionRule';
  createdAt: Scalars['ISO8601DateTime']['output'];
  grantedCredits: Scalars['String']['output'];
  interval?: Maybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  lagoId: Scalars['ID']['output'];
  method: RecurringTransactionMethodEnum;
  paidCredits: Scalars['String']['output'];
  startedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  targetOngoingBalance?: Maybe<Scalars['String']['output']>;
  thresholdCredits?: Maybe<Scalars['String']['output']>;
  trigger: RecurringTransactionTriggerEnum;
};

export enum RecurringTransactionTriggerEnum {
  Interval = 'interval',
  Threshold = 'threshold'
}

/** Autogenerated input type of RefreshInvoice */
export type RefreshInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type RegisterUser = {
  __typename?: 'RegisterUser';
  membership: Membership;
  organization: Organization;
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of RegisterUser */
export type RegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  organizationName: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export enum RegroupPaidFeesEnum {
  Invoice = 'invoice'
}

/** ResetPassword type */
export type ResetPassword = {
  __typename?: 'ResetPassword';
  expireAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  user: User;
};

/** Autogenerated input type of ResetPassword */
export type ResetPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

/** Autogenerated input type of RetryAllInvoicePayments */
export type RetryAllInvoicePaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RetryAllInvoices */
export type RetryAllInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RetryInvoice */
export type RetryInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryInvoicePayment */
export type RetryInvoicePaymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryTaxProviderVoiding */
export type RetryTaxProviderVoidingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryTaxReporting */
export type RetryTaxReportingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RetryWebhook */
export type RetryWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeInvite */
export type RevokeInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RevokeMembership */
export type RevokeMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RotateApiKey */
export type RotateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum RoundingFunctionEnum {
  Ceil = 'ceil',
  Floor = 'floor',
  Round = 'round'
}

export type SanitizedApiKey = {
  __typename?: 'SanitizedApiKey';
  createdAt: Scalars['ISO8601DateTime']['output'];
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  value: Scalars['String']['output'];
};

/** SanitizedApiKeyCollection type */
export type SanitizedApiKeyCollection = {
  __typename?: 'SanitizedApiKeyCollection';
  /** A collection of paginated SanitizedApiKeyCollection */
  collection: Array<SanitizedApiKey>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum StatusTypeEnum {
  Active = 'active',
  Canceled = 'canceled',
  Pending = 'pending',
  Terminated = 'terminated'
}

export type StripeProvider = {
  __typename?: 'StripeProvider';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  secretKey?: Maybe<Scalars['String']['output']>;
  successRedirectUrl?: Maybe<Scalars['String']['output']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  billingTime?: Maybe<BillingTimeEnum>;
  canceledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  currentBillingPeriodEndingAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  currentBillingPeriodStartedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  customer: Customer;
  endingAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  externalId: Scalars['String']['output'];
  fees?: Maybe<Array<Fee>>;
  id: Scalars['ID']['output'];
  lifetimeUsage?: Maybe<SubscriptionLifetimeUsage>;
  name?: Maybe<Scalars['String']['output']>;
  nextName?: Maybe<Scalars['String']['output']>;
  nextPendingStartDate?: Maybe<Scalars['ISO8601Date']['output']>;
  nextPlan?: Maybe<Plan>;
  nextSubscription?: Maybe<Subscription>;
  periodEndDate?: Maybe<Scalars['ISO8601Date']['output']>;
  plan: Plan;
  startedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status?: Maybe<StatusTypeEnum>;
  subscriptionAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** SubscriptionCollection type */
export type SubscriptionCollection = {
  __typename?: 'SubscriptionCollection';
  /** A collection of paginated SubscriptionCollection */
  collection: Array<Subscription>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type SubscriptionLifetimeUsage = {
  __typename?: 'SubscriptionLifetimeUsage';
  lastThresholdAmountCents?: Maybe<Scalars['BigInt']['output']>;
  nextThresholdAmountCents?: Maybe<Scalars['BigInt']['output']>;
  nextThresholdRatio?: Maybe<Scalars['Float']['output']>;
  totalUsageAmountCents: Scalars['BigInt']['output'];
  totalUsageFromDatetime: Scalars['ISO8601DateTime']['output'];
  totalUsageToDatetime: Scalars['ISO8601DateTime']['output'];
};

export type Subsidiary = {
  __typename?: 'Subsidiary';
  externalId: Scalars['String']['output'];
  externalName?: Maybe<Scalars['String']['output']>;
};

/** SubsidiaryCollection type */
export type SubsidiaryCollection = {
  __typename?: 'SubsidiaryCollection';
  /** A collection of paginated SubsidiaryCollection */
  collection: Array<Subsidiary>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of SyncCrmIntegrationInvoice */
export type SyncCrmIntegrationInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncCrmIntegrationInvoice. */
export type SyncCrmIntegrationInvoicePayload = {
  __typename?: 'SyncCrmIntegrationInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoiceId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of SyncIntegrationCreditNote */
export type SyncIntegrationCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditNoteId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncIntegrationCreditNote. */
export type SyncIntegrationCreditNotePayload = {
  __typename?: 'SyncIntegrationCreditNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  creditNoteId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of SyncIntegrationInvoice */
export type SyncIntegrationInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of SyncIntegrationInvoice. */
export type SyncIntegrationInvoicePayload = {
  __typename?: 'SyncIntegrationInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoiceId?: Maybe<Scalars['ID']['output']>;
};

export type Tax = {
  __typename?: 'Tax';
  /** Number of add ons using this tax */
  addOnsCount: Scalars['Int']['output'];
  appliedToOrganization: Scalars['Boolean']['output'];
  autoGenerated: Scalars['Boolean']['output'];
  /** Number of charges using this tax */
  chargesCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of customers using this tax */
  customersCount: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  organization?: Maybe<Organization>;
  /** Number of plans using this tax */
  plansCount: Scalars['Int']['output'];
  rate: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** TaxCollection type */
export type TaxCollection = {
  __typename?: 'TaxCollection';
  /** A collection of paginated TaxCollection */
  collection: Array<Tax>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateTax */
export type TaxCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  rate: Scalars['Float']['input'];
};

/** Autogenerated input type of UpdateTax */
export type TaxUpdateInput = {
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  rate?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated input type of TerminateAppliedCoupon */
export type TerminateAppliedCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCoupon */
export type TerminateCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateCustomerWallet */
export type TerminateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of TerminateSubscription */
export type TerminateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export enum TimezoneEnum {
  /** Africa/Algiers */
  TzAfricaAlgiers = 'TZ_AFRICA_ALGIERS',
  /** Africa/Cairo */
  TzAfricaCairo = 'TZ_AFRICA_CAIRO',
  /** Africa/Casablanca */
  TzAfricaCasablanca = 'TZ_AFRICA_CASABLANCA',
  /** Africa/Harare */
  TzAfricaHarare = 'TZ_AFRICA_HARARE',
  /** Africa/Johannesburg */
  TzAfricaJohannesburg = 'TZ_AFRICA_JOHANNESBURG',
  /** Africa/Monrovia */
  TzAfricaMonrovia = 'TZ_AFRICA_MONROVIA',
  /** Africa/Nairobi */
  TzAfricaNairobi = 'TZ_AFRICA_NAIROBI',
  /** America/Argentina/Buenos_Aires */
  TzAmericaArgentinaBuenosAires = 'TZ_AMERICA_ARGENTINA_BUENOS_AIRES',
  /** America/Bogota */
  TzAmericaBogota = 'TZ_AMERICA_BOGOTA',
  /** America/Caracas */
  TzAmericaCaracas = 'TZ_AMERICA_CARACAS',
  /** America/Chicago */
  TzAmericaChicago = 'TZ_AMERICA_CHICAGO',
  /** America/Chihuahua */
  TzAmericaChihuahua = 'TZ_AMERICA_CHIHUAHUA',
  /** America/Denver */
  TzAmericaDenver = 'TZ_AMERICA_DENVER',
  /** America/Godthab */
  TzAmericaGodthab = 'TZ_AMERICA_GODTHAB',
  /** America/Guatemala */
  TzAmericaGuatemala = 'TZ_AMERICA_GUATEMALA',
  /** America/Guyana */
  TzAmericaGuyana = 'TZ_AMERICA_GUYANA',
  /** America/Halifax */
  TzAmericaHalifax = 'TZ_AMERICA_HALIFAX',
  /** America/Indiana/Indianapolis */
  TzAmericaIndianaIndianapolis = 'TZ_AMERICA_INDIANA_INDIANAPOLIS',
  /** America/Juneau */
  TzAmericaJuneau = 'TZ_AMERICA_JUNEAU',
  /** America/La_Paz */
  TzAmericaLaPaz = 'TZ_AMERICA_LA_PAZ',
  /** America/Lima */
  TzAmericaLima = 'TZ_AMERICA_LIMA',
  /** America/Los_Angeles */
  TzAmericaLosAngeles = 'TZ_AMERICA_LOS_ANGELES',
  /** America/Mazatlan */
  TzAmericaMazatlan = 'TZ_AMERICA_MAZATLAN',
  /** America/Mexico_City */
  TzAmericaMexicoCity = 'TZ_AMERICA_MEXICO_CITY',
  /** America/Monterrey */
  TzAmericaMonterrey = 'TZ_AMERICA_MONTERREY',
  /** America/Montevideo */
  TzAmericaMontevideo = 'TZ_AMERICA_MONTEVIDEO',
  /** America/New_York */
  TzAmericaNewYork = 'TZ_AMERICA_NEW_YORK',
  /** America/Phoenix */
  TzAmericaPhoenix = 'TZ_AMERICA_PHOENIX',
  /** America/Puerto_Rico */
  TzAmericaPuertoRico = 'TZ_AMERICA_PUERTO_RICO',
  /** America/Regina */
  TzAmericaRegina = 'TZ_AMERICA_REGINA',
  /** America/Santiago */
  TzAmericaSantiago = 'TZ_AMERICA_SANTIAGO',
  /** America/Sao_Paulo */
  TzAmericaSaoPaulo = 'TZ_AMERICA_SAO_PAULO',
  /** America/St_Johns */
  TzAmericaStJohns = 'TZ_AMERICA_ST_JOHNS',
  /** America/Tijuana */
  TzAmericaTijuana = 'TZ_AMERICA_TIJUANA',
  /** Asia/Almaty */
  TzAsiaAlmaty = 'TZ_ASIA_ALMATY',
  /** Asia/Baghdad */
  TzAsiaBaghdad = 'TZ_ASIA_BAGHDAD',
  /** Asia/Baku */
  TzAsiaBaku = 'TZ_ASIA_BAKU',
  /** Asia/Bangkok */
  TzAsiaBangkok = 'TZ_ASIA_BANGKOK',
  /** Asia/Chongqing */
  TzAsiaChongqing = 'TZ_ASIA_CHONGQING',
  /** Asia/Colombo */
  TzAsiaColombo = 'TZ_ASIA_COLOMBO',
  /** Asia/Dhaka */
  TzAsiaDhaka = 'TZ_ASIA_DHAKA',
  /** Asia/Hong_Kong */
  TzAsiaHongKong = 'TZ_ASIA_HONG_KONG',
  /** Asia/Irkutsk */
  TzAsiaIrkutsk = 'TZ_ASIA_IRKUTSK',
  /** Asia/Jakarta */
  TzAsiaJakarta = 'TZ_ASIA_JAKARTA',
  /** Asia/Jerusalem */
  TzAsiaJerusalem = 'TZ_ASIA_JERUSALEM',
  /** Asia/Kabul */
  TzAsiaKabul = 'TZ_ASIA_KABUL',
  /** Asia/Kamchatka */
  TzAsiaKamchatka = 'TZ_ASIA_KAMCHATKA',
  /** Asia/Karachi */
  TzAsiaKarachi = 'TZ_ASIA_KARACHI',
  /** Asia/Kathmandu */
  TzAsiaKathmandu = 'TZ_ASIA_KATHMANDU',
  /** Asia/Kolkata */
  TzAsiaKolkata = 'TZ_ASIA_KOLKATA',
  /** Asia/Krasnoyarsk */
  TzAsiaKrasnoyarsk = 'TZ_ASIA_KRASNOYARSK',
  /** Asia/Kuala_Lumpur */
  TzAsiaKualaLumpur = 'TZ_ASIA_KUALA_LUMPUR',
  /** Asia/Kuwait */
  TzAsiaKuwait = 'TZ_ASIA_KUWAIT',
  /** Asia/Magadan */
  TzAsiaMagadan = 'TZ_ASIA_MAGADAN',
  /** Asia/Muscat */
  TzAsiaMuscat = 'TZ_ASIA_MUSCAT',
  /** Asia/Novosibirsk */
  TzAsiaNovosibirsk = 'TZ_ASIA_NOVOSIBIRSK',
  /** Asia/Rangoon */
  TzAsiaRangoon = 'TZ_ASIA_RANGOON',
  /** Asia/Riyadh */
  TzAsiaRiyadh = 'TZ_ASIA_RIYADH',
  /** Asia/Seoul */
  TzAsiaSeoul = 'TZ_ASIA_SEOUL',
  /** Asia/Shanghai */
  TzAsiaShanghai = 'TZ_ASIA_SHANGHAI',
  /** Asia/Singapore */
  TzAsiaSingapore = 'TZ_ASIA_SINGAPORE',
  /** Asia/Srednekolymsk */
  TzAsiaSrednekolymsk = 'TZ_ASIA_SREDNEKOLYMSK',
  /** Asia/Taipei */
  TzAsiaTaipei = 'TZ_ASIA_TAIPEI',
  /** Asia/Tashkent */
  TzAsiaTashkent = 'TZ_ASIA_TASHKENT',
  /** Asia/Tbilisi */
  TzAsiaTbilisi = 'TZ_ASIA_TBILISI',
  /** Asia/Tehran */
  TzAsiaTehran = 'TZ_ASIA_TEHRAN',
  /** Asia/Tokyo */
  TzAsiaTokyo = 'TZ_ASIA_TOKYO',
  /** Asia/Ulaanbaatar */
  TzAsiaUlaanbaatar = 'TZ_ASIA_ULAANBAATAR',
  /** Asia/Urumqi */
  TzAsiaUrumqi = 'TZ_ASIA_URUMQI',
  /** Asia/Vladivostok */
  TzAsiaVladivostok = 'TZ_ASIA_VLADIVOSTOK',
  /** Asia/Yakutsk */
  TzAsiaYakutsk = 'TZ_ASIA_YAKUTSK',
  /** Asia/Yekaterinburg */
  TzAsiaYekaterinburg = 'TZ_ASIA_YEKATERINBURG',
  /** Asia/Yerevan */
  TzAsiaYerevan = 'TZ_ASIA_YEREVAN',
  /** Atlantic/Azores */
  TzAtlanticAzores = 'TZ_ATLANTIC_AZORES',
  /** Atlantic/Cape_Verde */
  TzAtlanticCapeVerde = 'TZ_ATLANTIC_CAPE_VERDE',
  /** Atlantic/South_Georgia */
  TzAtlanticSouthGeorgia = 'TZ_ATLANTIC_SOUTH_GEORGIA',
  /** Australia/Adelaide */
  TzAustraliaAdelaide = 'TZ_AUSTRALIA_ADELAIDE',
  /** Australia/Brisbane */
  TzAustraliaBrisbane = 'TZ_AUSTRALIA_BRISBANE',
  /** Australia/Canberra */
  TzAustraliaCanberra = 'TZ_AUSTRALIA_CANBERRA',
  /** Australia/Darwin */
  TzAustraliaDarwin = 'TZ_AUSTRALIA_DARWIN',
  /** Australia/Hobart */
  TzAustraliaHobart = 'TZ_AUSTRALIA_HOBART',
  /** Australia/Melbourne */
  TzAustraliaMelbourne = 'TZ_AUSTRALIA_MELBOURNE',
  /** Australia/Perth */
  TzAustraliaPerth = 'TZ_AUSTRALIA_PERTH',
  /** Australia/Sydney */
  TzAustraliaSydney = 'TZ_AUSTRALIA_SYDNEY',
  /** Etc/GMT+12 */
  TzEtcGmt_12 = 'TZ_ETC_GMT_12',
  /** Europe/Amsterdam */
  TzEuropeAmsterdam = 'TZ_EUROPE_AMSTERDAM',
  /** Europe/Athens */
  TzEuropeAthens = 'TZ_EUROPE_ATHENS',
  /** Europe/Belgrade */
  TzEuropeBelgrade = 'TZ_EUROPE_BELGRADE',
  /** Europe/Berlin */
  TzEuropeBerlin = 'TZ_EUROPE_BERLIN',
  /** Europe/Bratislava */
  TzEuropeBratislava = 'TZ_EUROPE_BRATISLAVA',
  /** Europe/Brussels */
  TzEuropeBrussels = 'TZ_EUROPE_BRUSSELS',
  /** Europe/Bucharest */
  TzEuropeBucharest = 'TZ_EUROPE_BUCHAREST',
  /** Europe/Budapest */
  TzEuropeBudapest = 'TZ_EUROPE_BUDAPEST',
  /** Europe/Copenhagen */
  TzEuropeCopenhagen = 'TZ_EUROPE_COPENHAGEN',
  /** Europe/Dublin */
  TzEuropeDublin = 'TZ_EUROPE_DUBLIN',
  /** Europe/Helsinki */
  TzEuropeHelsinki = 'TZ_EUROPE_HELSINKI',
  /** Europe/Istanbul */
  TzEuropeIstanbul = 'TZ_EUROPE_ISTANBUL',
  /** Europe/Kaliningrad */
  TzEuropeKaliningrad = 'TZ_EUROPE_KALININGRAD',
  /** Europe/Kiev */
  TzEuropeKiev = 'TZ_EUROPE_KIEV',
  /** Europe/Lisbon */
  TzEuropeLisbon = 'TZ_EUROPE_LISBON',
  /** Europe/Ljubljana */
  TzEuropeLjubljana = 'TZ_EUROPE_LJUBLJANA',
  /** Europe/London */
  TzEuropeLondon = 'TZ_EUROPE_LONDON',
  /** Europe/Madrid */
  TzEuropeMadrid = 'TZ_EUROPE_MADRID',
  /** Europe/Minsk */
  TzEuropeMinsk = 'TZ_EUROPE_MINSK',
  /** Europe/Moscow */
  TzEuropeMoscow = 'TZ_EUROPE_MOSCOW',
  /** Europe/Paris */
  TzEuropeParis = 'TZ_EUROPE_PARIS',
  /** Europe/Prague */
  TzEuropePrague = 'TZ_EUROPE_PRAGUE',
  /** Europe/Riga */
  TzEuropeRiga = 'TZ_EUROPE_RIGA',
  /** Europe/Rome */
  TzEuropeRome = 'TZ_EUROPE_ROME',
  /** Europe/Samara */
  TzEuropeSamara = 'TZ_EUROPE_SAMARA',
  /** Europe/Sarajevo */
  TzEuropeSarajevo = 'TZ_EUROPE_SARAJEVO',
  /** Europe/Skopje */
  TzEuropeSkopje = 'TZ_EUROPE_SKOPJE',
  /** Europe/Sofia */
  TzEuropeSofia = 'TZ_EUROPE_SOFIA',
  /** Europe/Stockholm */
  TzEuropeStockholm = 'TZ_EUROPE_STOCKHOLM',
  /** Europe/Tallinn */
  TzEuropeTallinn = 'TZ_EUROPE_TALLINN',
  /** Europe/Vienna */
  TzEuropeVienna = 'TZ_EUROPE_VIENNA',
  /** Europe/Vilnius */
  TzEuropeVilnius = 'TZ_EUROPE_VILNIUS',
  /** Europe/Volgograd */
  TzEuropeVolgograd = 'TZ_EUROPE_VOLGOGRAD',
  /** Europe/Warsaw */
  TzEuropeWarsaw = 'TZ_EUROPE_WARSAW',
  /** Europe/Zagreb */
  TzEuropeZagreb = 'TZ_EUROPE_ZAGREB',
  /** Europe/Zurich */
  TzEuropeZurich = 'TZ_EUROPE_ZURICH',
  /** Pacific/Apia */
  TzPacificApia = 'TZ_PACIFIC_APIA',
  /** Pacific/Auckland */
  TzPacificAuckland = 'TZ_PACIFIC_AUCKLAND',
  /** Pacific/Chatham */
  TzPacificChatham = 'TZ_PACIFIC_CHATHAM',
  /** Pacific/Fakaofo */
  TzPacificFakaofo = 'TZ_PACIFIC_FAKAOFO',
  /** Pacific/Fiji */
  TzPacificFiji = 'TZ_PACIFIC_FIJI',
  /** Pacific/Guadalcanal */
  TzPacificGuadalcanal = 'TZ_PACIFIC_GUADALCANAL',
  /** Pacific/Guam */
  TzPacificGuam = 'TZ_PACIFIC_GUAM',
  /** Pacific/Honolulu */
  TzPacificHonolulu = 'TZ_PACIFIC_HONOLULU',
  /** Pacific/Majuro */
  TzPacificMajuro = 'TZ_PACIFIC_MAJURO',
  /** Pacific/Midway */
  TzPacificMidway = 'TZ_PACIFIC_MIDWAY',
  /** Pacific/Noumea */
  TzPacificNoumea = 'TZ_PACIFIC_NOUMEA',
  /** Pacific/Pago_Pago */
  TzPacificPagoPago = 'TZ_PACIFIC_PAGO_PAGO',
  /** Pacific/Port_Moresby */
  TzPacificPortMoresby = 'TZ_PACIFIC_PORT_MORESBY',
  /** Pacific/Tongatapu */
  TzPacificTongatapu = 'TZ_PACIFIC_TONGATAPU',
  /** UTC */
  TzUtc = 'TZ_UTC'
}

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Update input arguments */
export type UpdateAdyenPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateAnrokIntegration */
export type UpdateAnrokIntegrationInput = {
  apiKey?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Update Billable metric input arguments */
export type UpdateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  expression?: InputMaybe<Scalars['String']['input']>;
  fieldName?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<BillableMetricFiltersInput>>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  roundingFunction?: InputMaybe<RoundingFunctionEnum>;
  roundingPrecision?: InputMaybe<Scalars['Int']['input']>;
  weightedInterval?: InputMaybe<WeightedIntervalEnum>;
};

/** Autogenerated input type of UpdateCoupon */
export type UpdateCouponInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  appliesTo?: InputMaybe<LimitationInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  couponType: CouponTypeEnum;
  description?: InputMaybe<Scalars['String']['input']>;
  expiration: CouponExpiration;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  frequency: CouponFrequency;
  frequencyDuration?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  percentageRate?: InputMaybe<Scalars['Float']['input']>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateCreditNote */
export type UpdateCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  refundStatus: CreditNoteRefundStatusEnum;
};

/** Update Customer input arguments */
export type UpdateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  appliedDunningCampaignId?: InputMaybe<Scalars['ID']['input']>;
  billingConfiguration?: InputMaybe<CustomerBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  excludeFromDunningCampaign?: InputMaybe<Scalars['Boolean']['input']>;
  externalId: Scalars['String']['input'];
  externalSalesforceId?: InputMaybe<Scalars['String']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<FinalizeZeroAmountInvoiceEnum>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationCustomers?: InputMaybe<Array<IntegrationCustomerInput>>;
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Array<CustomerMetadataInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  paymentProviderCode?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  providerCustomer?: InputMaybe<ProviderCustomerInput>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  url?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateCustomerInvoiceGracePeriod */
export type UpdateCustomerInvoiceGracePeriodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  invoiceGracePeriod?: InputMaybe<Scalars['Int']['input']>;
};

/** Customer Portal Customer Update input arguments */
export type UpdateCustomerPortalCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  customerType?: InputMaybe<CustomerTypeEnum>;
  documentLocale?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstname?: InputMaybe<Scalars['String']['input']>;
  lastname?: InputMaybe<Scalars['String']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  shippingAddress?: InputMaybe<CustomerAddressInput>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Update Wallet Input */
export type UpdateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  expirationAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  recurringTransactionRules?: InputMaybe<Array<UpdateRecurringTransactionRuleInput>>;
};

/** Autogenerated input type of UpdateDunningCampaign */
export type UpdateDunningCampaignInput = {
  appliedToOrganization: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Update input arguments */
export type UpdateGocardlessPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateHubspotIntegration */
export type UpdateHubspotIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  defaultTargetedObject?: InputMaybe<HubspotTargetedObjectsEnum>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncSubscriptions?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateIntegrationCollectionMapping */
export type UpdateIntegrationCollectionMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappingType?: InputMaybe<MappingTypeEnum>;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxNexus?: InputMaybe<Scalars['String']['input']>;
  taxType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateIntegrationMapping */
export type UpdateIntegrationMappingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  externalAccountCode?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  externalName?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  integrationId?: InputMaybe<Scalars['ID']['input']>;
  mappableId?: InputMaybe<Scalars['ID']['input']>;
  mappableType?: InputMaybe<MappableTypeEnum>;
};

/** Autogenerated input type of UpdateInvite */
export type UpdateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: MembershipRole;
};

/** Update Invoice input arguments */
export type UpdateInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<Array<InvoiceMetadataInput>>;
  paymentStatus?: InputMaybe<InvoicePaymentStatusTypeEnum>;
};

/** Autogenerated input type of UpdateMembership */
export type UpdateMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: MembershipRole;
};

/** Autogenerated input type of UpdateNetsuiteIntegration */
export type UpdateNetsuiteIntegrationInput = {
  accountId?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  scriptEndpointUrl?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
  syncSalesOrders?: InputMaybe<Scalars['Boolean']['input']>;
  tokenId?: InputMaybe<Scalars['String']['input']>;
  tokenSecret?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateOktaIntegration */
export type UpdateOktaIntegrationInput = {
  clientId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  domain?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  organizationName?: InputMaybe<Scalars['String']['input']>;
};

/** Update Organization input arguments */
export type UpdateOrganizationInput = {
  addressLine1?: InputMaybe<Scalars['String']['input']>;
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  billingConfiguration?: InputMaybe<OrganizationBillingConfigurationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  defaultCurrency?: InputMaybe<CurrencyEnum>;
  documentNumberPrefix?: InputMaybe<Scalars['String']['input']>;
  documentNumbering?: InputMaybe<DocumentNumberingEnum>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<Array<EmailSettingsEnum>>;
  euTaxManagement?: InputMaybe<Scalars['Boolean']['input']>;
  finalizeZeroAmountInvoice?: InputMaybe<Scalars['Boolean']['input']>;
  legalName?: InputMaybe<Scalars['String']['input']>;
  legalNumber?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  netPaymentTerm?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<TimezoneEnum>;
  webhookUrl?: InputMaybe<Scalars['String']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdatePlan */
export type UpdatePlanInput = {
  amountCents: Scalars['BigInt']['input'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']['input']>;
  cascadeUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  interval: PlanInterval;
  invoiceDisplayName?: InputMaybe<Scalars['String']['input']>;
  minimumCommitment?: InputMaybe<CommitmentInput>;
  name: Scalars['String']['input'];
  payInAdvance: Scalars['Boolean']['input'];
  taxCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  trialPeriod?: InputMaybe<Scalars['Float']['input']>;
  usageThresholds?: InputMaybe<Array<UsageThresholdInput>>;
};

export type UpdateRecurringTransactionRuleInput = {
  grantedCredits?: InputMaybe<Scalars['String']['input']>;
  interval?: InputMaybe<RecurringTransactionIntervalEnum>;
  invoiceRequiresSuccessfulPayment?: InputMaybe<Scalars['Boolean']['input']>;
  lagoId?: InputMaybe<Scalars['ID']['input']>;
  method?: InputMaybe<RecurringTransactionMethodEnum>;
  paidCredits?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  targetOngoingBalance?: InputMaybe<Scalars['String']['input']>;
  thresholdCredits?: InputMaybe<Scalars['String']['input']>;
  trigger?: InputMaybe<RecurringTransactionTriggerEnum>;
};

/** Update input arguments */
export type UpdateStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  successRedirectUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Update Subscription input arguments */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endingAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  planOverrides?: InputMaybe<PlanOverridesInput>;
  subscriptionAt?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
};

/** Autogenerated input type of UpdateXeroIntegration */
export type UpdateXeroIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  connectionId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  syncCreditNotes?: InputMaybe<Scalars['Boolean']['input']>;
  syncInvoices?: InputMaybe<Scalars['Boolean']['input']>;
  syncPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UsageThreshold = {
  __typename?: 'UsageThreshold';
  amountCents: Scalars['BigInt']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  recurring: Scalars['Boolean']['output'];
  thresholdDisplayName?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type UsageThresholdInput = {
  amountCents?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdDisplayName?: InputMaybe<Scalars['String']['input']>;
};

export type UsageThresholdOverridesInput = {
  amountCents: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  thresholdDisplayName?: InputMaybe<Scalars['String']['input']>;
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  memberships: Array<Membership>;
  organizations: Array<Organization>;
  premium: Scalars['Boolean']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of VoidCreditNote */
export type VoidCreditNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of VoidInvoice */
export type VoidInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

export type VolumeRange = {
  __typename?: 'VolumeRange';
  flatAmount: Scalars['String']['output'];
  fromValue: Scalars['BigInt']['output'];
  perUnitAmount: Scalars['String']['output'];
  toValue?: Maybe<Scalars['BigInt']['output']>;
};

export type VolumeRangeInput = {
  flatAmount: Scalars['String']['input'];
  fromValue: Scalars['BigInt']['input'];
  perUnitAmount: Scalars['String']['input'];
  toValue?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Wallet */
export type Wallet = {
  __typename?: 'Wallet';
  balanceCents: Scalars['BigInt']['output'];
  consumedAmountCents: Scalars['BigInt']['output'];
  consumedCredits: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditsBalance: Scalars['Float']['output'];
  creditsOngoingBalance: Scalars['Float']['output'];
  creditsOngoingUsageBalance: Scalars['Float']['output'];
  currency: CurrencyEnum;
  customer?: Maybe<Customer>;
  expirationAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  lastConsumedCreditAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ongoingBalanceCents: Scalars['BigInt']['output'];
  ongoingUsageBalanceCents: Scalars['BigInt']['output'];
  rateAmount: Scalars['Float']['output'];
  recurringTransactionRules?: Maybe<Array<RecurringTransactionRule>>;
  status: WalletStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** WalletCollection type */
export type WalletCollection = {
  __typename?: 'WalletCollection';
  /** A collection of paginated WalletCollection */
  collection: Array<Wallet>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum WalletStatusEnum {
  Active = 'active',
  Terminated = 'terminated'
}

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  amount: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  creditAmount: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  invoiceRequiresSuccessfulPayment: Scalars['Boolean']['output'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status: WalletTransactionStatusEnum;
  transactionStatus: WalletTransactionTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  wallet?: Maybe<Wallet>;
};

/** WalletTransactionCollection type */
export type WalletTransactionCollection = {
  __typename?: 'WalletTransactionCollection';
  /** A collection of paginated WalletTransactionCollection */
  collection: Array<WalletTransaction>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export enum WalletTransactionStatusEnum {
  Pending = 'pending',
  Settled = 'settled'
}

export enum WalletTransactionTransactionStatusEnum {
  Granted = 'granted',
  Invoiced = 'invoiced',
  Purchased = 'purchased',
  Voided = 'voided'
}

export enum WalletTransactionTransactionTypeEnum {
  Inbound = 'inbound',
  Outbound = 'outbound'
}

export type Webhook = {
  __typename?: 'Webhook';
  createdAt: Scalars['ISO8601DateTime']['output'];
  endpoint: Scalars['String']['output'];
  httpStatus?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  lastRetriedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  objectType: Scalars['String']['output'];
  payload?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  retries: Scalars['Int']['output'];
  status: WebhookStatusEnum;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookEndpoint?: Maybe<WebhookEndpoint>;
  webhookType: Scalars['String']['output'];
};

/** WebhookCollection type */
export type WebhookCollection = {
  __typename?: 'WebhookCollection';
  /** A collection of paginated WebhookCollection */
  collection: Array<Webhook>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

export type WebhookEndpoint = {
  __typename?: 'WebhookEndpoint';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  organization?: Maybe<Organization>;
  signatureAlgo?: Maybe<WebhookEndpointSignatureAlgoEnum>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  webhookUrl: Scalars['String']['output'];
};

/** WebhookEndpointCollection type */
export type WebhookEndpointCollection = {
  __typename?: 'WebhookEndpointCollection';
  /** A collection of paginated WebhookEndpointCollection */
  collection: Array<WebhookEndpoint>;
  /** Pagination Metadata for navigating the Pagination */
  metadata: CollectionMetadata;
};

/** Autogenerated input type of CreateWebhookEndpoint */
export type WebhookEndpointCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookEndpointSignatureAlgoEnum {
  Hmac = 'hmac',
  Jwt = 'jwt'
}

/** Autogenerated input type of UpdateWebhookEndpoint */
export type WebhookEndpointUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  signatureAlgo?: InputMaybe<WebhookEndpointSignatureAlgoEnum>;
  webhookUrl: Scalars['String']['input'];
};

export enum WebhookStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded'
}

export enum WeightedIntervalEnum {
  Seconds = 'seconds'
}

export type XeroCustomer = {
  __typename?: 'XeroCustomer';
  externalCustomerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  integrationCode?: Maybe<Scalars['String']['output']>;
  integrationId?: Maybe<Scalars['ID']['output']>;
  integrationType?: Maybe<IntegrationTypeEnum>;
  syncWithProvider?: Maybe<Scalars['Boolean']['output']>;
};

export type XeroIntegration = {
  __typename?: 'XeroIntegration';
  code: Scalars['String']['output'];
  connectionId: Scalars['ID']['output'];
  hasMappingsConfigured?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  syncCreditNotes?: Maybe<Scalars['Boolean']['output']>;
  syncInvoices?: Maybe<Scalars['Boolean']['output']>;
  syncPayments?: Maybe<Scalars['Boolean']['output']>;
};

export type UserIdentifierQueryVariables = Exact<{ [key: string]: never; }>;


export type UserIdentifierQuery = { __typename?: 'Query', me: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> }, organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum> } | null };

export type AddOnItemFragment = { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any };

export type DeleteAddOnFragment = { __typename?: 'AddOn', id: string, name: string };

export type DeleteAddOnMutationVariables = Exact<{
  input: DestroyAddOnInput;
}>;


export type DeleteAddOnMutation = { __typename?: 'Mutation', destroyAddOn?: { __typename?: 'DestroyAddOnPayload', id?: string | null } | null };

export type GetGoogleAuthUrlQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGoogleAuthUrlQuery = { __typename?: 'Query', googleAuthUrl: { __typename?: 'AuthUrl', url: string } };

export type BillableMetricItemFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any };

export type DeleteBillableMetricDialogFragment = { __typename?: 'BillableMetric', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type GetBillableMetricToDeleteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetBillableMetricToDeleteQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number } | null };

export type DeleteBillableMetricMutationVariables = Exact<{
  input: DestroyBillableMetricInput;
}>;


export type DeleteBillableMetricMutation = { __typename?: 'Mutation', destroyBillableMetric?: { __typename?: 'DestroyBillableMetricPayload', id?: string | null } | null };

export type BillableMetricsForCouponsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string };

export type GetBillableMetricsForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetBillableMetricsForCouponsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> } };

export type PlansForCouponsFragment = { __typename?: 'Plan', id: string, name: string, code: string };

export type GetPlansForCouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansForCouponsQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> } };

export type CouponCaptionFragment = { __typename?: 'Coupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type AppliedCouponCaptionFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null };

export type CouponItemFragment = { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null };

export type DeleteCouponFragment = { __typename?: 'Coupon', id: string, name: string };

export type DeleteCouponMutationVariables = Exact<{
  input: DestroyCouponInput;
}>;


export type DeleteCouponMutation = { __typename?: 'Mutation', destroyCoupon?: { __typename?: 'DestroyCouponPayload', id?: string | null } | null };

export type TerminateCouponFragment = { __typename?: 'Coupon', id: string, name: string };

export type TerminateCouponMutationVariables = Exact<{
  input: TerminateCouponInput;
}>;


export type TerminateCouponMutation = { __typename?: 'Mutation', terminateCoupon?: { __typename?: 'Coupon', id: string } | null };

export type InvoiceForCreditNoteFormCalculationFragment = { __typename?: 'Invoice', id: string, couponsAmountCents: any, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, feesAmountCents: any, currency?: CurrencyEnum | null, versionNumber: number, paymentDisputeLostAt?: any | null, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null }> | null };

export type CreditNoteEstimateQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  items: Array<CreditNoteItemInput> | CreditNoteItemInput;
}>;


export type CreditNoteEstimateQuery = { __typename?: 'Query', creditNoteEstimate: { __typename?: 'CreditNoteEstimate', couponsAdjustmentAmountCents: any, currency: CurrencyEnum, maxCreditableAmountCents: any, maxRefundableAmountCents: any, subTotalExcludingTaxesAmountCents: any, taxesAmountCents: any, taxesRate: number, appliedTaxes: Array<{ __typename?: 'CreditNoteAppliedTax', taxCode: string, taxName: string, taxRate: number, amountCents: any }>, items: Array<{ __typename?: 'CreditNoteItemEstimate', amountCents: any, fee: { __typename?: 'Fee', id: string } }> } };

export type CreditNoteTableItemFragment = { __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null };

export type CreditNotesForTableFragment = { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null }> };

export type DownloadCreditNoteMutationVariables = Exact<{
  input: DownloadCreditNoteInput;
}>;


export type DownloadCreditNoteMutation = { __typename?: 'Mutation', downloadCreditNote?: { __typename?: 'CreditNote', id: string, fileUrl?: string | null } | null };

export type GetPortalCustomerInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalCustomerInfosQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null } | null };

export type PortalInvoiceListItemFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, paymentDisputeLostAt?: any | null, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum };

export type CustomerPortalInvoicesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type CustomerPortalInvoicesQuery = { __typename?: 'Query', customerPortalInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, paymentDisputeLostAt?: any | null, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum }> } };

export type DownloadCustomerPortalInvoiceMutationVariables = Exact<{
  input: DownloadCustomerPortalInvoiceInput;
}>;


export type DownloadCustomerPortalInvoiceMutation = { __typename?: 'Mutation', downloadCustomerPortalInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type GetCustomerPortalInvoicesCollectionQueryVariables = Exact<{
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerPortalInvoicesCollectionQuery = { __typename?: 'Query', customerPortalInvoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', amountCents: any, invoicesCount: any, currency?: CurrencyEnum | null }> } };

export type GetCustomerPortalOverdueBalancesQueryVariables = Exact<{
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerPortalOverdueBalancesQuery = { __typename?: 'Query', customerPortalOverdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, lagoInvoiceIds: Array<string> }> } };

export type GetCustomerPortalUserCurrencyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCustomerPortalUserCurrencyQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', currency?: CurrencyEnum | null } | null };

export type GetPortalLocaleQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalLocaleQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'CustomerPortalOrganization', id: string, premiumIntegrations: Array<PremiumIntegrationTypeEnum>, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, documentLocale?: string | null } | null } | null, customerPortalUser?: { __typename?: 'CustomerPortalCustomer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type UpdatePortalCustomerMutationVariables = Exact<{
  input: UpdateCustomerPortalCustomerInput;
}>;


export type UpdatePortalCustomerMutation = { __typename?: 'Mutation', updateCustomerPortalCustomer?: { __typename?: 'CustomerPortalCustomer', id: string } | null };

export type SubscriptionForPortalUsageFragment = { __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null };

export type GetSubscriptionForPortalQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForPortalQuery = { __typename?: 'Query', customerPortalSubscription?: { __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null } | null };

export type GetCustomerUsageForPortalQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetCustomerUsageForPortalQuery = { __typename?: 'Query', customerPortalCustomerUsage: { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, id: string, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null }> }> } };

export type GetPortalUsageQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalUsageQuery = { __typename?: 'Query', customerPortalSubscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, currentBillingPeriodEndingAt?: any | null, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, code: string, amountCents: any, amountCurrency: CurrencyEnum, interval: PlanInterval }, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null }> } };

export type TopUpPortalWalletMutationVariables = Exact<{
  input: CreateCustomerPortalWalletTransactionInput;
}>;


export type TopUpPortalWalletMutation = { __typename?: 'Mutation', createCustomerPortalWalletTransaction?: { __typename?: 'CustomerPortalWalletTransactionCollection', collection: Array<{ __typename?: 'CustomerPortalWalletTransaction', id: string }> } | null };

export type CustomerPortalWalletInfoFragment = { __typename?: 'CustomerPortalWallet', id: string, currency: CurrencyEnum, balanceCents: any, creditsBalance: number, expirationAt?: any | null, consumedCredits: number, consumedAmountCents: any, status: WalletStatusEnum, creditsOngoingBalance: number, ongoingBalanceCents: any, rateAmount: number, lastBalanceSyncAt?: any | null };

export type GetPortalCustomerDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalCustomerDataQuery = { __typename?: 'Query', customerPortalUser?: { __typename?: 'CustomerPortalCustomer', applicableTimezone: TimezoneEnum, premium: boolean } | null };

export type GetPortalWalletsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalWalletsQuery = { __typename?: 'Query', customerPortalWallets: { __typename?: 'CustomerPortalWalletCollection', collection: Array<{ __typename?: 'CustomerPortalWallet', id: string, currency: CurrencyEnum, balanceCents: any, creditsBalance: number, expirationAt?: any | null, consumedCredits: number, consumedAmountCents: any, status: WalletStatusEnum, creditsOngoingBalance: number, ongoingBalanceCents: any, rateAmount: number, lastBalanceSyncAt?: any | null }> } };

export type CouponPlansForCustomerFragment = { __typename?: 'Plan', id: string, name: string };

export type CouponBillableMetricsForCustomerFragment = { __typename?: 'BillableMetric', id: string, name: string };

export type GetCouponForCustomerQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<CouponStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCouponForCustomerQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null }> } };

export type AddCouponMutationVariables = Exact<{
  input: CreateAppliedCouponInput;
}>;


export type AddCouponMutation = { __typename?: 'Mutation', createAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } } | null };

export type GetCustomerCreditNotesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerCreditNotesQuery = { __typename?: 'Query', creditNotes: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null }> } };

export type InvoiceListItemFragment = { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null };

export type InvoiceForInvoiceListFragment = { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } };

export type DownloadInvoiceItemMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceItemMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RetryInvoicePaymentMutationVariables = Exact<{
  input: RetryInvoicePaymentInput;
}>;


export type RetryInvoicePaymentMutation = { __typename?: 'Mutation', retryInvoicePayment?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null } | null };

export type GetCustomerInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type CustomerItemFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type CustomerMainInfosFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, phone?: string | null, email?: string | null, currency?: CurrencyEnum | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, url?: string | null, zipcode?: string | null, paymentProvider?: ProviderTypeEnum | null, timezone?: TimezoneEnum | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string }> | null };

export type PaymentProvidersListForCustomerMainInfosQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PaymentProvidersListForCustomerMainInfosQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string, name: string, code: string } | { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | { __typename?: 'StripeProvider', id: string, name: string, code: string }> } | null };

export type IntegrationsListForCustomerMainInfosQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerMainInfosQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename: 'AnrokIntegration', id: string, name: string, apiKey: string, externalAccountId?: string | null } | { __typename: 'HubspotIntegration', id: string, name: string, portalId?: string | null } | { __typename: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null } | { __typename?: 'OktaIntegration' } | { __typename: 'XeroIntegration', id: string, name: string }> } | null };

export type CustomerAppliedTaxRatesForSettingsFragment = { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null };

export type GetCustomerSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSettingsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null, netPaymentTerm?: number | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null, name?: string | null, displayName: string, externalId: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null } | null, organization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number, finalizeZeroAmountInvoice: boolean, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number, documentLocale?: string | null } | null } | null };

export type DeleteCustomerDialogFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string };

export type DeleteCustomerMutationVariables = Exact<{
  input: DestroyCustomerInput;
}>;


export type DeleteCustomerMutation = { __typename?: 'Mutation', destroyCustomer?: { __typename?: 'DestroyCustomerPayload', id?: string | null } | null };

export type DeleteCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string };

export type DeleteCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type DeleteCustomerFinalizeZeroAmountInvoiceFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null };

export type DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null } | null };

export type DeleteCustomerGracePeriodFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string };

export type DeleteCustomerGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type DeleteCustomerGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type DeleteCustomerNetPaymentTermFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, netPaymentTerm?: number | null };

export type DeleteCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type DeleteCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, displayName: string, netPaymentTerm?: number | null } | null };

export type CustomerForDeleteVatRateDialogFragment = { __typename?: 'Customer', id: string, name?: string | null, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type TaxRateForDeleteCustomerVatRateDialogFragment = { __typename?: 'Tax', id: string, name: string };

export type RemoveAppliedTaxRateOnCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type RemoveAppliedTaxRateOnCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string } | null };

export type EditCustomerDocumentLocaleFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null };

export type UpdateCustomerDocumentLocaleMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerDocumentLocaleMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type EditCustomerInvoiceGracePeriodFragment = { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null };

export type UpdateCustomerInvoiceGracePeriodMutationVariables = Exact<{
  input: UpdateCustomerInvoiceGracePeriodInput;
}>;


export type UpdateCustomerInvoiceGracePeriodMutation = { __typename?: 'Mutation', updateCustomerInvoiceGracePeriod?: { __typename?: 'Customer', id: string, invoiceGracePeriod?: number | null } | null };

export type EditCustomerVatRateFragment = { __typename?: 'Customer', id: string, name?: string | null, displayName: string, externalId: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string }> | null };

export type GetTaxRatesForEditCustomerQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxRatesForEditCustomerQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type CreateCustomerAppliedTaxMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type CreateCustomerAppliedTaxMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, autoGenerated: boolean }> | null } | null };

export type CustomerForExternalAppsAccordionFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null };

export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename: 'AdyenProvider', id: string, name: string, code: string } | { __typename: 'GocardlessProvider', id: string, name: string, code: string } | { __typename: 'StripeProvider', id: string, name: string, code: string }> } | null };

export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename: 'AnrokIntegration', id: string, code: string, name: string } | { __typename: 'HubspotIntegration', id: string, code: string, name: string, defaultTargetedObject: HubspotTargetedObjectsEnum } | { __typename: 'NetsuiteIntegration', id: string, code: string, name: string } | { __typename?: 'OktaIntegration' } | { __typename: 'XeroIntegration', id: string, code: string, name: string }> } | null };

export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables = Exact<{
  integrationId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery = { __typename?: 'Query', integrationSubsidiaries?: { __typename?: 'SubsidiaryCollection', collection: Array<{ __typename?: 'Subsidiary', externalId: string, externalName?: string | null }> } | null };

export type CreditNoteForVoidCreditNoteDialogFragment = { __typename?: 'CreditNote', id: string, totalAmountCents: any, currency: CurrencyEnum };

export type VoidCreditNoteMutationVariables = Exact<{
  input: VoidCreditNoteInput;
}>;


export type VoidCreditNoteMutation = { __typename?: 'Mutation', voidCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type CustomerCouponFragment = { __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } };

export type CustomerAppliedCouponsFragment = { __typename?: 'Customer', id: string, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } }> | null };

export type GetCustomerCouponsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerCouponsQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, appliedCoupons?: Array<{ __typename?: 'AppliedCoupon', id: string, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, amountCentsRemaining?: any | null, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null, frequencyDurationRemaining?: number | null, coupon: { __typename?: 'Coupon', id: string, name: string } }> | null } | null };

export type RemoveCouponMutationVariables = Exact<{
  input: TerminateAppliedCouponInput;
}>;


export type RemoveCouponMutation = { __typename?: 'Mutation', terminateAppliedCoupon?: { __typename?: 'AppliedCoupon', id: string } | null };

export type GetCustomerOverdueBalancesQueryVariables = Exact<{
  externalCustomerId: Scalars['String']['input'];
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerOverdueBalancesQuery = { __typename?: 'Query', paymentRequests: { __typename?: 'PaymentRequestCollection', collection: Array<{ __typename?: 'PaymentRequest', createdAt: any }> }, overdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, lagoInvoiceIds: Array<string> }> } };

export type GetCustomerGrossRevenuesQueryVariables = Exact<{
  externalCustomerId: Scalars['String']['input'];
  currency?: InputMaybe<CurrencyEnum>;
  expireCache?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetCustomerGrossRevenuesQuery = { __typename?: 'Query', grossRevenues: { __typename?: 'GrossRevenueCollection', collection: Array<{ __typename?: 'GrossRevenue', amountCents?: any | null, currency?: CurrencyEnum | null, invoicesCount: any, month: any }> } };

export type GetCustomerSubscriptionForListQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, subscriptions: Array<{ __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextPendingStartDate?: any | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, plan: { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum, name: string, code: string }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string } | null, nextSubscription?: { __typename?: 'Subscription', id: string } | null }> } | null };

export type SubscriptionItemFragment = { __typename?: 'Subscription', id: string, status?: StatusTypeEnum | null, startedAt?: any | null, nextPendingStartDate?: any | null, name?: string | null, nextName?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, plan: { __typename?: 'Plan', id: string, name: string, code: string }, nextPlan?: { __typename?: 'Plan', id: string, name: string, code: string } | null, nextSubscription?: { __typename?: 'Subscription', id: string } | null };

export type SubscriptionLinePlanFragment = { __typename?: 'Plan', id: string, name: string, code: string };

export type TerminateCustomerSubscriptionMutationVariables = Exact<{
  input: TerminateSubscriptionInput;
}>;


export type TerminateCustomerSubscriptionMutation = { __typename?: 'Mutation', terminateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number } } | null };

export type GetCustomerSubscriptionForUsageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerSubscriptionForUsageQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, externalId: string, currency?: CurrencyEnum | null } | null };

export type CustomerUsageForUsageDetailsFragment = { __typename?: 'CustomerUsage', fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', id: string, amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null }> }> };

export type GetCustomersForFilterItemCustomerQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomersForFilterItemCustomerQuery = { __typename?: 'Query', customers: { __typename?: 'CustomerCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Customer', id: string, displayName: string, externalId: string }> } };

export type WebhookForCreateAndEditFragment = { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null };

export type CreateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointCreateInput;
}>;


export type CreateWebhookEndpointMutation = { __typename?: 'Mutation', createWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type UpdateWebhookEndpointMutationVariables = Exact<{
  input: WebhookEndpointUpdateInput;
}>;


export type UpdateWebhookEndpointMutation = { __typename?: 'Mutation', updateWebhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null } | null };

export type DebuggerEventDetailsFragment = { __typename?: 'Event', id: string, code: string, transactionId?: string | null, timestamp?: any | null, receivedAt?: any | null, payload: any, billableMetricName?: string | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum };

export type DeleteWebhookMutationVariables = Exact<{
  input: DestroyWebhookEndpointInput;
}>;


export type DeleteWebhookMutation = { __typename?: 'Mutation', destroyWebhookEndpoint?: { __typename?: 'DestroyWebhookEndpointPayload', id?: string | null } | null };

export type EventItemFragment = { __typename?: 'Event', id: string, code: string, receivedAt?: any | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null };

export type WebhookLogDetailsFragment = { __typename?: 'Webhook', id: string, webhookType: string, status: WebhookStatusEnum, payload?: string | null, response?: string | null, httpStatus?: number | null, endpoint: string, retries: number, updatedAt: any };

export type RetryWebhookMutationVariables = Exact<{
  input: RetryWebhookInput;
}>;


export type RetryWebhookMutation = { __typename?: 'Mutation', retryWebhook?: { __typename?: 'Webhook', id: string } | null };

export type WebhookLogItemFragment = { __typename?: 'Webhook', id: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string };

export type CustomerForDunningEmailFragment = { __typename?: 'Customer', displayName: string, paymentProvider?: ProviderTypeEnum | null, netPaymentTerm?: number | null, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', documentLocale?: string | null } | null };

export type OrganizationForDunningEmailFragment = { __typename?: 'CurrentOrganization', name: string, logoUrl?: string | null, email?: string | null, netPaymentTerm: number, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', documentLocale?: string | null } | null };

export type InvoicesForDunningEmailFragment = { __typename?: 'Invoice', id: string, number: string, totalAmountCents: any, currency?: CurrencyEnum | null };

export type OrganizationForDatePickerFragment = { __typename?: 'CurrentOrganization', id: string, timezone?: TimezoneEnum | null };

export type GetGrossRevenuesQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetGrossRevenuesQuery = { __typename?: 'Query', grossRevenues: { __typename?: 'GrossRevenueCollection', collection: Array<{ __typename?: 'GrossRevenue', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetInvoiceCollectionsQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoiceCollectionsQuery = { __typename?: 'Query', invoiceCollections: { __typename?: 'FinalizedInvoiceCollectionCollection', collection: Array<{ __typename?: 'FinalizedInvoiceCollection', paymentStatus?: InvoicePaymentStatusTypeEnum | null, invoicesCount: any, amountCents: any, currency?: CurrencyEnum | null, month: any }> } };

export type GetMrrQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetMrrQuery = { __typename?: 'Query', mrrs: { __typename?: 'MrrCollection', collection: Array<{ __typename?: 'Mrr', amountCents?: any | null, currency?: CurrencyEnum | null, month: any }> } };

export type GetOverdueQueryVariables = Exact<{
  currency: CurrencyEnum;
  externalCustomerId?: InputMaybe<Scalars['String']['input']>;
  months: Scalars['Int']['input'];
}>;


export type GetOverdueQuery = { __typename?: 'Query', overdueBalances: { __typename?: 'OverdueBalanceCollection', collection: Array<{ __typename?: 'OverdueBalance', amountCents: any, currency: CurrencyEnum, month: any, lagoInvoiceIds: Array<string> }> } };

export type GetInvoicedUsagesQueryVariables = Exact<{
  currency: CurrencyEnum;
}>;


export type GetInvoicedUsagesQuery = { __typename?: 'Query', invoicedUsages: { __typename?: 'InvoicedUsageCollection', collection: Array<{ __typename?: 'InvoicedUsage', amountCents: any, month: any, currency: CurrencyEnum, code?: string | null }> } };

export type InvoiceMetadatasForMetadataDrawerFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type UpdateInvoiceMetadataMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoiceMetadataMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null } | null };

export type DisputeInvoiceMutationVariables = Exact<{
  input: LoseInvoiceDisputeInput;
}>;


export type DisputeInvoiceMutation = { __typename?: 'Mutation', loseInvoiceDispute?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, issuingDate: any, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type TaxForInvoiceEditTaxDialogFragment = { __typename?: 'Tax', id: string, name: string, rate: number, code: string };

export type AddOnForInvoiceEditTaxDialogFragment = { __typename?: 'AddOn', id: string, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> | null };

export type GetTaxesForInvoiceEditTaxDialogQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForInvoiceEditTaxDialogQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type InvoiceForUpdateInvoicePaymentStatusFragment = { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum };

export type UpdateInvoicePaymentStatusMutationVariables = Exact<{
  input: UpdateInvoiceInput;
}>;


export type UpdateInvoicePaymentStatusMutation = { __typename?: 'Mutation', updateInvoice?: { __typename?: 'Invoice', id: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, refundableAmountCents: any, creditableAmountCents: any, integrationSyncable: boolean, externalIntegrationId?: string | null, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type CreateInvoicesDataExportMutationVariables = Exact<{
  input: CreateDataExportsInvoicesInput;
}>;


export type CreateInvoicesDataExportMutation = { __typename?: 'Mutation', createInvoicesDataExport?: { __typename?: 'DataExport', id: string } | null };

export type InvoiceForFinalizeInvoiceFragment = { __typename?: 'Invoice', id: string, issuingDate: any, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } };

export type FinalizeInvoiceMutationVariables = Exact<{
  input: FinalizeInvoiceInput;
}>;


export type FinalizeInvoiceMutation = { __typename?: 'Mutation', finalizeInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, issuingDate: any, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type InvoiceForCreditNotesTableFragment = { __typename?: 'Invoice', id: string, customer: { __typename?: 'Customer', id: string }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null };

export type InvoiceForInvoiceInfosFragment = { __typename?: 'Invoice', number: string, issuingDate: any, paymentDueDate: any, paymentOverdue: boolean, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, applicableTimezone: TimezoneEnum, deletedAt?: any | null } };

export type CustomerMetadatasForInvoiceOverviewFragment = { __typename?: 'Customer', id: string, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null };

export type InvoiceMetadatasForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null };

export type InvoiceForVoidInvoiceDialogFragment = { __typename?: 'Invoice', id: string, number: string };

export type VoidInvoiceMutationVariables = Exact<{
  input: VoidInvoiceInput;
}>;


export type VoidInvoiceMutation = { __typename?: 'Mutation', voidInvoice?: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, invoiceType: InvoiceTypeEnum, refundableAmountCents: any, creditableAmountCents: any, integrationSyncable: boolean, externalIntegrationId?: string | null, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type FeeForDeleteAdjustmentFeeDialogFragment = { __typename?: 'Fee', id: string };

export type DestroyAdjustedFeeMutationVariables = Exact<{
  input: DestroyAdjustedFeeInput;
}>;


export type DestroyAdjustedFeeMutation = { __typename?: 'Mutation', destroyAdjustedFee?: { __typename?: 'DestroyAdjustedFeePayload', id?: string | null } | null };

export type FeeForEditfeeDrawerFragment = { __typename?: 'Fee', id: string, currency: CurrencyEnum };

export type CreateAdjustedFeeMutationVariables = Exact<{
  input: CreateAdjustedFeeInput;
}>;


export type CreateAdjustedFeeMutation = { __typename?: 'Mutation', createAdjustedFee?: { __typename?: 'Fee', id: string } | null };

export type FeeForInvoiceDetailsTableFragment = { __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type InvoiceForDetailsTableFragment = { __typename?: 'Invoice', invoiceType: InvoiceTypeEnum, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any, versionNumber: number, couponsAmountCents: any, creditNotesAmountCents: any, status: InvoiceStatusTypeEnum, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type FeeForInvoiceDetailsTableBodyLineFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragment = { __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, toValue?: any | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceDetailsTableBodyLinePackageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null } | null };

export type FeeForInvoiceDetailsTableBodyLinePercentageFragment = { __typename?: 'Fee', id: string, units: number, amountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', fixedFeeTotalAmount?: string | null, fixedFeeUnitAmount?: string | null, freeEvents?: number | null, freeUnits?: string | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, paidUnits?: string | null, perUnitTotalAmount?: string | null, rate?: string | null, units?: string | null } | null };

export type FeeForInvoiceDetailsTableBodyLineVolumeFragment = { __typename?: 'Fee', id: string, units: number, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null } | null };

export type InvoiceForDetailsTableFooterFragment = { __typename?: 'Invoice', couponsAmountCents: any, creditNotesAmountCents: any, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, totalAmountCents: any, currency?: CurrencyEnum | null, invoiceType: InvoiceTypeEnum, status: InvoiceStatusTypeEnum, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, versionNumber: number, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type FeeForInvoiceFeeAdvanceDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type FeeForInvoiceFeeArrearsDetailsTableFragment = { __typename?: 'Fee', id: string, units: number, preciseUnitAmount: number, amountCents: any, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, charge?: { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, minAmountCents: any, payInAdvance: boolean, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, recurring: boolean } } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null };

export type TaxForPlanChargeAccordionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type ChargeAccordionFragment = { __typename?: 'Charge', id: string, chargeModel: ChargeModelEnum, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null }, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetTaxesForChargesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForChargesQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type ChargeForChargeOptionsAccordionFragment = { __typename?: 'Charge', id: string, invoiceable: boolean, minAmountCents: any, payInAdvance: boolean, regroupPaidFees?: RegroupPaidFeesEnum | null };

export type PercentageChargeFragment = { __typename?: 'Properties', fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null };

export type PlanForChargeAccordionFragment = { __typename?: 'Plan', billChargesMonthly?: boolean | null };

export type BillableMetricForChargeSectionFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type GetMeteredBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetMeteredBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type GetRecurringBillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetRecurringBillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null }> } };

export type GetTaxesForCommitmentsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForCommitmentsQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type CustomChargeFragment = { __typename?: 'Properties', customProperties?: any | null };

export type DeletePlanDialogFragment = { __typename?: 'Plan', id: string, name: string, draftInvoicesCount: number, activeSubscriptionsCount: number };

export type DeletePlanMutationVariables = Exact<{
  input: DestroyPlanInput;
}>;


export type DeletePlanMutation = { __typename?: 'Mutation', destroyPlan?: { __typename?: 'DestroyPlanPayload', id?: string | null } | null };

export type DynamicChargeFragment = { __typename?: 'Properties', groupedBy?: Array<string> | null };

export type PlanForFixedFeeSectionFragment = { __typename?: 'Plan', id: string, amountCents: any, payInAdvance: boolean, trialPeriod?: number | null, invoiceDisplayName?: string | null };

export type GraduatedChargeFragment = { __typename?: 'Properties', graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null };

export type GraduatedPercentageChargeFragment = { __typename?: 'Properties', graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null };

export type PackageChargeFragment = { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null };

export type PlanItemFragment = { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number };

export type TaxForPlanSettingsSectionFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type PlanForSettingsSectionFragment = { __typename?: 'Plan', id: string, amountCurrency: CurrencyEnum, code: string, description?: string | null, interval: PlanInterval, name: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null };

export type GetTaxesForPlanQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesForPlanQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type StandardChargeFragment = { __typename?: 'Properties', amount?: string | null, groupedBy?: Array<string> | null };

export type VolumeRangesFragment = { __typename?: 'Properties', volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null };

export type GetPlanForDetailsOverviewSectionQueryVariables = Exact<{
  plan: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsOverviewSectionQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null } | null };

export type GetSubscribtionsForPlanDetailsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  planCode?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<StatusTypeEnum> | StatusTypeEnum>;
}>;


export type GetSubscribtionsForPlanDetailsQuery = { __typename?: 'Query', subscriptions: { __typename?: 'SubscriptionCollection', collection: Array<{ __typename?: 'Subscription', id: string, endingAt?: any | null, subscriptionAt?: any | null, plan: { __typename?: 'Plan', id: string, parent?: { __typename?: 'Plan', id: string } | null }, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string } }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } };

export type PlanSubscriptionListItemForSubscriptionListFragment = { __typename?: 'Subscription', id: string, endingAt?: any | null, subscriptionAt?: any | null, plan: { __typename?: 'Plan', id: string, parent?: { __typename?: 'Plan', id: string } | null }, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string } };

export type GetTaxRatesForEditOrgaQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxRatesForEditOrgaQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number }> } };

export type AssignTaxRateToOrganizationMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type AssignTaxRateToOrganizationMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string } | null };

export type DeleteOrganizationVatRateFragment = { __typename?: 'Tax', id: string, name: string, appliedToOrganization: boolean };

export type UnassignTaxRateToOrganizationMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type UnassignTaxRateToOrganizationMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string, name: string, appliedToOrganization: boolean } | null };

export type EditOrganizationDefaultCurrencyForDialogFragment = { __typename?: 'CurrentOrganization', id: string, defaultCurrency: CurrencyEnum };

export type UpdateOrganizationDefaultCurrencyMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationDefaultCurrencyMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, defaultCurrency: CurrencyEnum } | null };

export type EditCustomerFinalizeZeroAmountInvoiceForDialogFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null };

export type EditOrganizationFinalizeZeroAmountInvoiceForDialogFragment = { __typename?: 'CurrentOrganization', id: string, finalizeZeroAmountInvoice: boolean };

export type UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, finalizeZeroAmountInvoice?: FinalizeZeroAmountInvoiceEnum | null } | null };

export type UpdateOrganizationFinalizeZeroAmountInvoiceMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationFinalizeZeroAmountInvoiceMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, finalizeZeroAmountInvoice: boolean } | null };

export type EditCustomerNetPaymentTermForDialogFragment = { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null };

export type EditOrganizationNetPaymentTermForDialogFragment = { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number };

export type UpdateCustomerNetPaymentTermMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerNetPaymentTermMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, externalId: string, name?: string | null, netPaymentTerm?: number | null } | null };

export type UpdateOrganizationNetPaymentTermMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationNetPaymentTermMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number } | null };

export type UpdateDocumentLocaleOrganizationMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateDocumentLocaleOrganizationMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, documentLocale?: string | null } | null } | null };

export type UpdateOrganizationGracePeriodMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationGracePeriodMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number } | null } | null };

export type EditOrganizationInformationsDialogFragment = { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null };

export type UpdateOrganizationInformationsMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInformationsMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null } | null };

export type EditOrganizationInvoiceNumberingDialogFragment = { __typename?: 'CurrentOrganization', id: string, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string };

export type UpdateOrganizationInvoiceNumberingMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInvoiceNumberingMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string } | null };

export type EditOrganizationInvoiceTemplateDialogFragment = { __typename?: 'CurrentOrganization', billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceFooter?: string | null } | null };

export type UpdateOrganizationInvoiceTemplateMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationInvoiceTemplateMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceFooter?: string | null } | null } | null };

export type UpdateOrganizationTimezoneMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationTimezoneMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, timezone?: TimezoneEnum | null } | null };

export type DeleteOktaIntegrationDialogFragment = { __typename?: 'OktaIntegration', id: string, name: string };

export type DestroyIntegrationMutationVariables = Exact<{
  input: DestroyIntegrationInput;
}>;


export type DestroyIntegrationMutation = { __typename?: 'Mutation', destroyIntegration?: { __typename?: 'DestroyIntegrationPayload', id?: string | null } | null };

export type AddOktaIntegrationDialogFragment = { __typename?: 'OktaIntegration', id: string, domain: string, clientId?: string | null, clientSecret?: string | null, organizationName: string, name: string };

export type CreateOktaIntegrationMutationVariables = Exact<{
  input: CreateOktaIntegrationInput;
}>;


export type CreateOktaIntegrationMutation = { __typename?: 'Mutation', createOktaIntegration?: { __typename?: 'OktaIntegration', id: string } | null };

export type UpdateOktaIntegrationMutationVariables = Exact<{
  input: UpdateOktaIntegrationInput;
}>;


export type UpdateOktaIntegrationMutation = { __typename?: 'Mutation', updateOktaIntegration?: { __typename?: 'OktaIntegration', id: string } | null };

export type OrganizationInfoForPreviewDunningCampaignFragment = { __typename?: 'CurrentOrganization', name: string, email?: string | null };

export type GetOrganizationInfoForPreviewDunningCampaignQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfoForPreviewDunningCampaignQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', name: string, email?: string | null } | null };

export type UpdateOrganizationLogoMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrganizationLogoMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null } | null };

export type AddAdyenProviderDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null };

export type GetProviderByCodeForAdyenQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForAdyenQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type AddAdyenApiKeyMutationVariables = Exact<{
  input: AddAdyenPaymentProviderInput;
}>;


export type AddAdyenApiKeyMutation = { __typename?: 'Mutation', addAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateAdyenApiKeyMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenApiKeyMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null } | null };

export type AddAnrokIntegrationDialogFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string };

export type CreateAnrokIntegrationMutationVariables = Exact<{
  input: CreateAnrokIntegrationInput;
}>;


export type CreateAnrokIntegrationMutation = { __typename?: 'Mutation', createAnrokIntegration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string } | null };

export type UpdateAnrokIntegrationMutationVariables = Exact<{
  input: UpdateAnrokIntegrationInput;
}>;


export type UpdateAnrokIntegrationMutation = { __typename?: 'Mutation', updateAnrokIntegration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string } | null };

export type AdyenForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null };

export type GocardlessForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null };

export type StripeForCreateAndEditSuccessRedirectUrlFragment = { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null };

export type UpdateAdyenPaymentProviderMutationVariables = Exact<{
  input: UpdateAdyenPaymentProviderInput;
}>;


export type UpdateAdyenPaymentProviderMutation = { __typename?: 'Mutation', updateAdyenPaymentProvider?: { __typename?: 'AdyenProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateGocardlessPaymentProviderMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessPaymentProviderMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, successRedirectUrl?: string | null } | null };

export type UpdateStripePaymentProviderMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripePaymentProviderMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, successRedirectUrl?: string | null } | null };

export type AddGocardlessProviderDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetProviderByCodeForGocardlessQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForGocardlessQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type UpdateGocardlessApiKeyMutationVariables = Exact<{
  input: UpdateGocardlessPaymentProviderInput;
}>;


export type UpdateGocardlessApiKeyMutation = { __typename?: 'Mutation', updateGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string, successRedirectUrl?: string | null, webhookSecret?: string | null } | null };

export type HubspotForCreateDialogFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type CreateHubspotIntegrationMutationVariables = Exact<{
  input: CreateHubspotIntegrationInput;
}>;


export type CreateHubspotIntegrationMutation = { __typename?: 'Mutation', createHubspotIntegration?: { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | null };

export type UpdateHubspotIntegrationMutationVariables = Exact<{
  input: UpdateHubspotIntegrationInput;
}>;


export type UpdateHubspotIntegrationMutation = { __typename?: 'Mutation', updateHubspotIntegration?: { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | null };

export type UpdateOrgaForLagoTaxManagementMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateOrgaForLagoTaxManagementMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string } | null };

export type NetsuiteForCreateDialogDialogFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null };

export type CreateNetsuiteIntegrationMutationVariables = Exact<{
  input: CreateNetsuiteIntegrationInput;
}>;


export type CreateNetsuiteIntegrationMutation = { __typename?: 'Mutation', createNetsuiteIntegration?: { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null } | null };

export type UpdateNetsuiteIntegrationMutationVariables = Exact<{
  input: UpdateNetsuiteIntegrationInput;
}>;


export type UpdateNetsuiteIntegrationMutation = { __typename?: 'Mutation', updateNetsuiteIntegration?: { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null } | null };

export type AddStripeProviderDialogFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null };

export type GetProviderByCodeForStripeQueryVariables = Exact<{
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetProviderByCodeForStripeQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string } | null };

export type AddStripeApiKeyMutationVariables = Exact<{
  input: AddStripePaymentProviderInput;
}>;


export type AddStripeApiKeyMutation = { __typename?: 'Mutation', addStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null, successRedirectUrl?: string | null } | null };

export type UpdateStripeApiKeyMutationVariables = Exact<{
  input: UpdateStripePaymentProviderInput;
}>;


export type UpdateStripeApiKeyMutation = { __typename?: 'Mutation', updateStripePaymentProvider?: { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null, successRedirectUrl?: string | null } | null };

export type XeroForCreateDialogDialogFragment = { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type CreateXeroIntegrationMutationVariables = Exact<{
  input: CreateXeroIntegrationInput;
}>;


export type CreateXeroIntegrationMutation = { __typename?: 'Mutation', createXeroIntegration?: { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null };

export type UpdateXeroIntegrationMutationVariables = Exact<{
  input: UpdateXeroIntegrationInput;
}>;


export type UpdateXeroIntegrationMutation = { __typename?: 'Mutation', updateXeroIntegration?: { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null };

export type AnrokIntegrationItemsFragment = { __typename?: 'AnrokIntegration', id: string };

export type GetAnrokIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetAnrokIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null }> } | null };

export type GetAddOnsForAnrokItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForAnrokItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForAnrokItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForAnrokItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type AnrokIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AnrokIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type AnrokIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null };

export type AnrokIntegrationMapItemDialogFragment = { __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum };

export type AnrokIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type AnrokIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type CreateAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateAnrokIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateAnrokIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateAnrokIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateAnrokIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteAnrokIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteAnrokIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteAnrokIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteAnrokIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type AnrokIntegrationSettingsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string, hasMappingsConfigured?: boolean | null, failedInvoicesCount?: number | null };

export type GetAnrokIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetAnrokIntegrationsSettingsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string, hasMappingsConfigured?: boolean | null, failedInvoicesCount?: number | null } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration', id: string } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type RetryAllInvoicesMutationVariables = Exact<{
  input: RetryAllInvoicesInput;
}>;


export type RetryAllInvoicesMutation = { __typename?: 'Mutation', retryAllInvoices?: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } | null };

export type DeleteAdyenIntegrationDialogFragment = { __typename?: 'AdyenProvider', id: string, name: string };

export type DeleteAdyenIntegrationMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteAdyenIntegrationMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteAnrokIntegrationDialogFragment = { __typename?: 'AnrokIntegration', id: string, name: string };

export type DestroyNangoIntegrationMutationVariables = Exact<{
  input: DestroyIntegrationInput;
}>;


export type DestroyNangoIntegrationMutation = { __typename?: 'Mutation', destroyIntegration?: { __typename?: 'DestroyIntegrationPayload', id?: string | null } | null };

export type DeleteGocardlessIntegrationDialogFragment = { __typename?: 'GocardlessProvider', id: string, name: string };

export type DeleteGocardlessMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteGocardlessMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteHubspotIntegrationDialogFragment = { __typename?: 'HubspotIntegration', id: string, name: string };

export type DeleteNetsuiteIntegrationDialogFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string };

export type DeleteStripeIntegrationDialogFragment = { __typename?: 'StripeProvider', id: string, name: string };

export type DeleteStripeMutationVariables = Exact<{
  input: DestroyPaymentProviderInput;
}>;


export type DeleteStripeMutation = { __typename?: 'Mutation', destroyPaymentProvider?: { __typename?: 'DestroyPaymentProviderPayload', id?: string | null } | null };

export type DeleteXeroIntegrationDialogFragment = { __typename?: 'XeroIntegration', id: string, name: string };

export type NetsuiteIntegrationItemsFragment = { __typename?: 'NetsuiteIntegration', id: string };

export type GetNetsuiteIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetNetsuiteIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null, taxCode?: string | null, taxNexus?: string | null, taxType?: string | null }> } | null };

export type GetAddOnsForNetsuiteItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForNetsuiteItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForNetsuiteItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForNetsuiteItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type NetsuiteIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type NetsuiteIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type NetsuiteIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null, taxCode?: string | null, taxNexus?: string | null, taxType?: string | null };

export type NetsuiteIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type NetsuiteIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type CreateNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteNetsuiteIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteNetsuiteIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteNetsuiteIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteNetsuiteIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type NetsuiteIntegrationSettingsFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, hasMappingsConfigured?: boolean | null, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null };

export type GetNetsuiteIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetNetsuiteIntegrationsSettingsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, hasMappingsConfigured?: boolean | null, name: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration', id: string } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type XeroIntegrationItemsFragment = { __typename?: 'XeroIntegration', id: string };

export type GetXeroIntegrationCollectionMappingsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
}>;


export type GetXeroIntegrationCollectionMappingsQuery = { __typename?: 'Query', integrationCollectionMappings?: { __typename?: 'CollectionMappingCollection', collection: Array<{ __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null }> } | null };

export type GetAddOnsForXeroItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetAddOnsForXeroItemsListQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type GetBillableMetricsForXeroItemsListQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  integrationId: Scalars['ID']['input'];
}>;


export type GetBillableMetricsForXeroItemsListQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null }> } };

export type XeroIntegrationItemsListAddonsFragment = { __typename?: 'AddOn', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type XeroIntegrationItemsListBillableMetricsFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, integrationMappings?: Array<{ __typename?: 'Mapping', id: string, externalId: string, externalAccountCode?: string | null, externalName?: string | null, mappableType: MappableTypeEnum }> | null };

export type XeroIntegrationItemsListDefaultFragment = { __typename?: 'CollectionMapping', id: string, mappingType: MappingTypeEnum, externalId: string, externalAccountCode?: string | null, externalName?: string | null };

export type XeroIntegrationMapItemDialogFragment = { __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum };

export type XeroIntegrationMapItemDialogCollectionMappingItemFragment = { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type XeroIntegrationMapItemDialogCollectionItemFragment = { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null };

export type GetXeroIntegrationItemsQueryVariables = Exact<{
  integrationId: Scalars['ID']['input'];
  itemType?: InputMaybe<IntegrationItemTypeEnum>;
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetXeroIntegrationItemsQuery = { __typename?: 'Query', integrationItems: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number } } };

export type TriggerXeroIntegrationAccountsRefetchMutationVariables = Exact<{
  input: FetchIntegrationAccountsInput;
}>;


export type TriggerXeroIntegrationAccountsRefetchMutation = { __typename?: 'Mutation', fetchIntegrationAccounts: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }> } };

export type TriggerXeroIntegrationItemsRefetchMutationVariables = Exact<{
  input: FetchIntegrationItemsInput;
}>;


export type TriggerXeroIntegrationItemsRefetchMutation = { __typename?: 'Mutation', fetchIntegrationItems: { __typename?: 'IntegrationItemCollection', collection: Array<{ __typename?: 'IntegrationItem', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null, itemType: IntegrationItemTypeEnum }> } };

export type CreateXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: CreateIntegrationCollectionMappingInput;
}>;


export type CreateXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', createIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type CreateXeroIntegrationMappingMutationVariables = Exact<{
  input: CreateIntegrationMappingInput;
}>;


export type CreateXeroIntegrationMappingMutation = { __typename?: 'Mutation', createIntegrationMapping?: { __typename?: 'Mapping', id: string, externalId: string, externalName?: string | null, externalAccountCode?: string | null } | null };

export type UpdateXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: UpdateIntegrationCollectionMappingInput;
}>;


export type UpdateXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', updateIntegrationCollectionMapping?: { __typename?: 'CollectionMapping', id: string } | null };

export type UpdateXeroIntegrationMappingMutationVariables = Exact<{
  input: UpdateIntegrationMappingInput;
}>;


export type UpdateXeroIntegrationMappingMutation = { __typename?: 'Mutation', updateIntegrationMapping?: { __typename?: 'Mapping', id: string } | null };

export type DeleteXeroIntegrationCollectionMappingMutationVariables = Exact<{
  input: DestroyIntegrationCollectionMappingInput;
}>;


export type DeleteXeroIntegrationCollectionMappingMutation = { __typename?: 'Mutation', destroyIntegrationCollectionMapping?: { __typename?: 'DestroyIntegrationCollectionMappingPayload', id?: string | null } | null };

export type DeleteXeroIntegrationMappingMutationVariables = Exact<{
  input: DestroyIntegrationMappingInput;
}>;


export type DeleteXeroIntegrationMappingMutation = { __typename?: 'Mutation', destroyIntegrationMapping?: { __typename?: 'DestroyIntegrationMappingPayload', id?: string | null } | null };

export type XeroIntegrationSettingsFragment = { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsSettingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetXeroIntegrationsSettingsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, name: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string }> } | null };

export type CreateInviteMutationVariables = Exact<{
  input: CreateInviteInput;
}>;


export type CreateInviteMutation = { __typename?: 'Mutation', createInvite?: { __typename?: 'Invite', id: string, token: string, email: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type InviteForEditRoleForDialogFragment = { __typename?: 'Invite', id: string, role: MembershipRole, email: string };

export type UpdateInviteRoleMutationVariables = Exact<{
  input: UpdateInviteInput;
}>;


export type UpdateInviteRoleMutation = { __typename?: 'Mutation', updateInvite?: { __typename?: 'Invite', id: string, role: MembershipRole, email: string } | null };

export type MemberForEditRoleForDialogFragment = { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type UpdateMembershipRoleMutationVariables = Exact<{
  input: UpdateMembershipInput;
}>;


export type UpdateMembershipRoleMutation = { __typename?: 'Mutation', updateMembership?: { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } } | null };

export type RevokeInviteMutationVariables = Exact<{
  input: RevokeInviteInput;
}>;


export type RevokeInviteMutation = { __typename?: 'Mutation', revokeInvite?: { __typename?: 'Invite', id: string } | null };

export type RevokeMembershipMutationVariables = Exact<{
  input: RevokeMembershipInput;
}>;


export type RevokeMembershipMutation = { __typename?: 'Mutation', revokeMembership?: { __typename?: 'Membership', id: string } | null };

export type InviteForRolePickerFieldFragment = { __typename?: 'Invite', id: string, role: MembershipRole };

export type CustomerForSubscriptionUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
}>;


export type CustomerForSubscriptionUsageQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } | null };

export type SubscrptionForSubscriptionUsageQueryVariables = Exact<{
  subscription: Scalars['ID']['input'];
}>;


export type SubscrptionForSubscriptionUsageQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, code: string }, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum } } | null };

export type SubscriptionCurrentUsageTableComponentCustomerUsageFragment = { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null }> | null }> }> };

export type UsageForSubscriptionUsageQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  subscriptionId: Scalars['ID']['input'];
}>;


export type UsageForSubscriptionUsageQuery = { __typename?: 'Query', customerUsage: { __typename?: 'CustomerUsage', amountCents: any, currency: CurrencyEnum, fromDatetime: any, toDatetime: any, chargesUsage: Array<{ __typename?: 'ChargeUsage', id: string, units: number, amountCents: any, charge: { __typename?: 'Charge', id: string, invoiceDisplayName?: string | null }, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string }, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null, groupedUsage: Array<{ __typename?: 'GroupedChargeUsage', amountCents: any, groupedBy?: any | null, eventsCount: number, units: number, id: string, filters?: Array<{ __typename?: 'ChargeFilterUsage', id?: string | null, amountCents: any, units: number, values: any, invoiceDisplayName?: string | null }> | null }> }> } };

export type GetSubscriptionForDetailsOverviewQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsOverviewQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, nextPendingStartDate?: any | null, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null }, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string } } | null };

export type SubscriptionForSubscriptionInformationsFragment = { __typename?: 'Subscription', id: string, externalId: string, status?: StatusTypeEnum | null, subscriptionAt?: any | null, endingAt?: any | null, nextPendingStartDate?: any | null, nextPlan?: { __typename?: 'Plan', id: string, name: string } | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string }, plan: { __typename?: 'Plan', id: string, name: string, parent?: { __typename?: 'Plan', id: string, name: string } | null } };

export type SubscriptionUsageLifetimeGraphForLifetimeGraphFragment = { __typename?: 'Subscription', id: string, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string } };

export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForSubscriptionUsageLifetimeGraphQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, lifetimeUsage?: { __typename?: 'SubscriptionLifetimeUsage', lastThresholdAmountCents?: any | null, nextThresholdAmountCents?: any | null, totalUsageAmountCents: any, totalUsageFromDatetime: any, totalUsageToDatetime: any } | null, customer: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, applicableTimezone: TimezoneEnum }, plan: { __typename?: 'Plan', id: string } } | null };

export type DeleteTaxFragment = { __typename?: 'Tax', id: string, name: string, customersCount: number };

export type DeleteTaxMutationVariables = Exact<{
  input: DestroyTaxInput;
}>;


export type DeleteTaxMutation = { __typename?: 'Mutation', destroyTax?: { __typename?: 'DestroyTaxPayload', id?: string | null } | null };

export type CustomerWalletFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, expirationAt?: any | null, name?: string | null, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, method: RecurringTransactionMethodEnum, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, targetOngoingBalance?: string | null, paidCredits: string, grantedCredits: string, thresholdCredits?: string | null, startedAt?: any | null, invoiceRequiresSuccessfulPayment: boolean }> | null };

export type GetCustomerWalletListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetCustomerWalletListQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, expirationAt?: any | null, name?: string | null, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, method: RecurringTransactionMethodEnum, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, targetOngoingBalance?: string | null, paidCredits: string, grantedCredits: string, thresholdCredits?: string | null, startedAt?: any | null, invoiceRequiresSuccessfulPayment: boolean }> | null }> } };

export type TerminateCustomerWalletMutationVariables = Exact<{
  input: TerminateCustomerWalletInput;
}>;


export type TerminateCustomerWalletMutation = { __typename?: 'Mutation', terminateCustomerWallet?: { __typename?: 'Wallet', id: string, status: WalletStatusEnum, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, name?: string | null, rateAmount: number, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type CreateCustomerWalletTransactionMutationVariables = Exact<{
  input: CreateCustomerWalletTransactionInput;
}>;


export type CreateCustomerWalletTransactionMutation = { __typename?: 'Mutation', createCustomerWalletTransaction?: { __typename?: 'WalletTransactionCollection', collection: Array<{ __typename?: 'WalletTransaction', id: string }> } | null };

export type WalletForTopupFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean };

export type WalletForVoidTransactionFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, rateAmount: number, creditsBalance: number };

export type WalletAccordionFragment = { __typename?: 'Wallet', id: string, balanceCents: any, consumedAmountCents: any, consumedCredits: number, createdAt: any, creditsBalance: number, currency: CurrencyEnum, expirationAt?: any | null, lastBalanceSyncAt?: any | null, lastConsumedCreditAt?: any | null, name?: string | null, rateAmount: number, status: WalletStatusEnum, terminatedAt?: any | null, ongoingBalanceCents: any, creditsOngoingBalance: number, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type WalletInfosForTransactionsFragment = { __typename?: 'Wallet', id: string, currency: CurrencyEnum, status: WalletStatusEnum, ongoingUsageBalanceCents: any, creditsOngoingUsageBalance: number };

export type GetWalletTransactionsQueryVariables = Exact<{
  walletId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWalletTransactionsQuery = { __typename?: 'Query', walletTransactions: { __typename?: 'WalletTransactionCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'WalletTransaction', id: string, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, amount: string, creditAmount: string, settledAt?: any | null, createdAt: any, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null }> } };

export type WalletTransactionForTransactionListItemFragment = { __typename?: 'WalletTransaction', id: string, status: WalletTransactionStatusEnum, transactionStatus: WalletTransactionTransactionStatusEnum, transactionType: WalletTransactionTransactionTypeEnum, amount: string, creditAmount: string, settledAt?: any | null, createdAt: any, wallet?: { __typename?: 'Wallet', id: string, currency: CurrencyEnum } | null };

export type CurrentUserFragment = { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> };

export type InvoiceSubscriptionFormatingFragment = { __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, minAmountCents: any, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, subscription?: { __typename?: 'Subscription', id: string, plan: { __typename?: 'Plan', id: string, interval: PlanInterval } } | null }> | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } };

export type CreateSubscriptionMutationVariables = Exact<{
  input: CreateSubscriptionInput;
}>;


export type CreateSubscriptionMutation = { __typename?: 'Mutation', createSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } } | null };

export type UpdateSubscriptionMutationVariables = Exact<{
  input: UpdateSubscriptionInput;
}>;


export type UpdateSubscriptionMutation = { __typename?: 'Mutation', updateSubscription?: { __typename?: 'Subscription', id: string, customer: { __typename?: 'Customer', id: string, activeSubscriptionsCount: number, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null }, plan: { __typename?: 'Plan', id: string } } | null };

export type GetSinglePlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSinglePlanQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null } | null };

export type CreatePlanMutationVariables = Exact<{
  input: CreatePlanInput;
}>;


export type CreatePlanMutation = { __typename?: 'Mutation', createPlan?: { __typename?: 'Plan', id: string } | null };

export type UpdatePlanMutationVariables = Exact<{
  input: UpdatePlanInput;
}>;


export type UpdatePlanMutation = { __typename?: 'Mutation', updatePlan?: { __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null } | null };

export type InvoiceFeeFragment = { __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null };

export type InvoiceCreateCreditNoteFragment = { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, succeededAt?: any | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null };

export type GetInvoiceCreateCreditNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceCreateCreditNoteQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, refundableAmountCents: any, creditableAmountCents: any, invoiceType: InvoiceTypeEnum, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, paymentDisputeLostAt?: any | null, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, itemCode: string, itemName: string, invoiceName?: string | null, invoiceDisplayName?: string | null, creditableAmountCents: any, succeededAt?: any | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCurrency: CurrencyEnum, feeType: FeeTypesEnum, invoiceName?: string | null, invoiceDisplayName?: string | null, groupedBy: any, succeededAt?: any | null, creditableAmountCents: any, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string } } | null, chargeFilter?: { __typename?: 'ChargeFilter', id: string, invoiceDisplayName?: string | null, values: any } | null }> | null }> | null } | null };

export type CreateCreditNoteMutationVariables = Exact<{
  input: CreateCreditNoteInput;
}>;


export type CreateCreditNoteMutation = { __typename?: 'Mutation', createCreditNote?: { __typename?: 'CreditNote', id: string } | null };

export type TaxOnAddOnEditCreateFragment = { __typename?: 'Tax', id: string, name: string, code: string, rate: number };

export type EditAddOnFragment = { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null };

export type GetSingleAddOnQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleAddOnQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, code: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null } | null };

export type CreateAddOnMutationVariables = Exact<{
  input: CreateAddOnInput;
}>;


export type CreateAddOnMutation = { __typename?: 'Mutation', createAddOn?: { __typename?: 'AddOn', id: string } | null };

export type UpdateAddOnMutationVariables = Exact<{
  input: UpdateAddOnInput;
}>;


export type UpdateAddOnMutation = { __typename?: 'Mutation', updateAddOn?: { __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any } | null };

export type GetSingleBillableMetricQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleBillableMetricQuery = { __typename?: 'Query', billableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, expression?: string | null, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, subscriptionsCount: number, plansCount: number, recurring: boolean, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null } | null };

export type CreateBillableMetricMutationVariables = Exact<{
  input: CreateBillableMetricInput;
}>;


export type CreateBillableMetricMutation = { __typename?: 'Mutation', createBillableMetric?: { __typename?: 'BillableMetric', id: string } | null };

export type UpdateBillableMetricMutationVariables = Exact<{
  input: UpdateBillableMetricInput;
}>;


export type UpdateBillableMetricMutation = { __typename?: 'Mutation', updateBillableMetric?: { __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any } | null };

export type EditCouponFragment = { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null };

export type GetSingleCouponQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleCouponQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, appliedCouponsCount: number, code?: string | null, couponType: CouponTypeEnum, description?: string | null, expiration: CouponExpiration, expirationAt?: any | null, frequency: CouponFrequency, frequencyDuration?: number | null, limitedBillableMetrics: boolean, limitedPlans: boolean, name: string, percentageRate?: number | null, reusable: boolean, plans?: Array<{ __typename?: 'Plan', id: string, name: string, code: string }> | null, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string }> | null } | null };

export type CreateCouponMutationVariables = Exact<{
  input: CreateCouponInput;
}>;


export type CreateCouponMutation = { __typename?: 'Mutation', createCoupon?: { __typename?: 'Coupon', id: string } | null };

export type UpdateCouponMutationVariables = Exact<{
  input: UpdateCouponInput;
}>;


export type UpdateCouponMutation = { __typename?: 'Mutation', updateCoupon?: { __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null } | null };

export type AddCustomerDrawerFragment = { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type CreateCustomerMutationVariables = Exact<{
  input: CreateCustomerInput;
}>;


export type CreateCustomerMutation = { __typename?: 'Mutation', createCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, displayName: string, createdAt: any, activeSubscriptionsCount: number, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type UpdateCustomerMutationVariables = Exact<{
  input: UpdateCustomerInput;
}>;


export type UpdateCustomerMutation = { __typename?: 'Mutation', updateCustomer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalId: string, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, name?: string | null, firstname?: string | null, lastname?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, displayName: string, createdAt: any, activeSubscriptionsCount: number, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type TaxFormFragment = { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type TaxFormQueryShapeFragment = { __typename?: 'Tax', autoGenerated: boolean, id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number };

export type GetSingleTaxQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSingleTaxQuery = { __typename?: 'Query', tax?: { __typename?: 'Tax', id: string, autoGenerated: boolean, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CreateTaxMutationVariables = Exact<{
  input: TaxCreateInput;
}>;


export type CreateTaxMutation = { __typename?: 'Mutation', createTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type UpdateTaxMutationVariables = Exact<{
  input: TaxUpdateInput;
}>;


export type UpdateTaxMutation = { __typename?: 'Mutation', updateTax?: { __typename?: 'Tax', id: string, code: string, description?: string | null, name: string, rate: number, customersCount: number } | null };

export type CurrentUserInfosFragment = { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> };

export type GetCurrentUserInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserInfosQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, email?: string | null, premium: boolean, memberships: Array<{ __typename?: 'Membership', id: string, organization: { __typename?: 'Organization', id: string, name: string, logoUrl?: string | null }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> } };

export type GetEmailSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetEmailSettingsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, emailSettings?: Array<EmailSettingsEnum> | null, logoUrl?: string | null, name: string } | null };

export type UpdateEmailSettingMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type UpdateEmailSettingMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, emailSettings?: Array<EmailSettingsEnum> | null } | null };

export type GetTaxProviderPresenceQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType?: InputMaybe<IntegrationTypeEnum>;
}>;


export type GetTaxProviderPresenceQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration', id: string } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type MainOrganizationInfosFragment = { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum> };

export type GetOrganizationInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInfosQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, name: string, logoUrl?: string | null, timezone?: TimezoneEnum | null, defaultCurrency: CurrencyEnum, premiumIntegrations: Array<PremiumIntegrationTypeEnum> } | null };

export type MembershipPermissionsFragment = { __typename?: 'Membership', id: string, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type AllInvoiceDetailsForCustomerInvoiceDetailsFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, issuingDate: any, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null };

export type GetInvoiceDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInvoiceDetailsQuery = { __typename?: 'Query', invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, issuingDate: any, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type IntegrationsListForCustomerInvoiceDetailsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCustomerInvoiceDetailsQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename: 'HubspotIntegration', id: string, portalId?: string | null, invoicesObjectTypeId?: string | null } | { __typename: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type DownloadInvoiceMutationVariables = Exact<{
  input: DownloadInvoiceInput;
}>;


export type DownloadInvoiceMutation = { __typename?: 'Mutation', downloadInvoice?: { __typename?: 'Invoice', id: string, fileUrl?: string | null } | null };

export type RefreshInvoiceMutationVariables = Exact<{
  input: RefreshInvoiceInput;
}>;


export type RefreshInvoiceMutation = { __typename?: 'Mutation', refreshInvoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, status: InvoiceStatusTypeEnum, totalAmountCents: any, currency?: CurrencyEnum | null, refundableAmountCents: any, creditableAmountCents: any, voidable: boolean, paymentDisputeLostAt?: any | null, integrationSyncable: boolean, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, associatedActiveWalletPresent: boolean, issuingDate: any, externalCrmIntegrationId?: string | null, subTotalExcludingTaxesAmountCents: any, subTotalIncludingTaxesAmountCents: any, versionNumber: number, paymentDueDate: any, paymentOverdue: boolean, couponsAmountCents: any, creditNotesAmountCents: any, prepaidCreditAmountCents: any, progressiveBillingCreditAmountCents: any, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, customer: { __typename?: 'Customer', name?: string | null, displayName: string, id: string, applicableTimezone: TimezoneEnum, currency?: CurrencyEnum | null, legalNumber?: string | null, legalName?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, state?: string | null, country?: CountryCode | null, city?: string | null, zipcode?: string | null, deletedAt?: any | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, displayInInvoice: boolean, key: string, value: string }> | null }, creditNotes?: Array<{ __typename?: 'CreditNote', id: string, couponsAdjustmentAmountCents: any, number: string, subTotalExcludingTaxesAmountCents: any, currency: CurrencyEnum, totalAmountCents: any, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, groupedBy: any, itemName: string, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> }> | null, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, description?: string | null, feeType: FeeTypesEnum, invoiceDisplayName?: string | null, invoiceName?: string | null, itemName: string, units: number, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoiceSubscriptions?: Array<{ __typename?: 'InvoiceSubscription', fromDatetime?: any | null, toDatetime?: any | null, chargesFromDatetime?: any | null, chargesToDatetime?: any | null, inAdvanceChargesFromDatetime?: any | null, inAdvanceChargesToDatetime?: any | null, subscription: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, interval: PlanInterval, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null } }, fees?: Array<{ __typename?: 'Fee', id: string, amountCents: any, invoiceName?: string | null, invoiceDisplayName?: string | null, units: number, groupedBy: any, description?: string | null, feeType: FeeTypesEnum, itemName: string, preciseUnitAmount: number, eventsCount?: any | null, adjustedFee: boolean, adjustedFeeType?: AdjustedFeeTypeEnum | null, succeededAt?: any | null, currency: CurrencyEnum, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null, interval: PlanInterval } } | null, charge?: { __typename?: 'Charge', id: string, payInAdvance: boolean, invoiceDisplayName?: string | null, chargeModel: ChargeModelEnum, minAmountCents: any, prorated: boolean, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpFee?: { __typename?: 'Fee', id: string } | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, amountDetails?: { __typename?: 'FeeAmountDetails', freeUnits?: string | null, fixedFeeUnitAmount?: string | null, flatUnitAmount?: string | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, paidUnits?: string | null, perPackageSize?: number | null, perPackageUnitAmount?: string | null, fixedFeeTotalAmount?: string | null, freeEvents?: number | null, minMaxAdjustmentTotalAmount?: string | null, paidEvents?: number | null, rate?: string | null, units?: string | null, graduatedRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitAmount?: string | null, perUnitTotalAmount?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'FeeAmountDetailsGraduatedPercentageRange', toValue?: any | null, flatUnitAmount?: string | null, fromValue?: any | null, perUnitTotalAmount?: string | null, rate?: string | null, totalWithFlatAmount?: string | null, units?: string | null }> | null } | null }> | null, invoice: { __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum } }> | null, metadata?: Array<{ __typename?: 'InvoiceMetadata', id: string, key: string, value: string }> | null, appliedTaxes?: Array<{ __typename?: 'InvoiceAppliedTax', id: string, amountCents: any, feesAmountCents: any, taxableAmountCents: any, taxRate: number, taxName: string, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null } | null };

export type SyncIntegrationInvoiceMutationVariables = Exact<{
  input: SyncIntegrationInvoiceInput;
}>;


export type SyncIntegrationInvoiceMutation = { __typename?: 'Mutation', syncIntegrationInvoice?: { __typename?: 'SyncIntegrationInvoicePayload', invoiceId?: string | null } | null };

export type SyncCrmIntegrationInvoiceMutationVariables = Exact<{
  input: SyncCrmIntegrationInvoiceInput;
}>;


export type SyncCrmIntegrationInvoiceMutation = { __typename?: 'Mutation', syncCrmIntegrationInvoice?: { __typename?: 'SyncCrmIntegrationInvoicePayload', invoiceId?: string | null } | null };

export type RetryInvoiceMutationVariables = Exact<{
  input: RetryInvoiceInput;
}>;


export type RetryInvoiceMutation = { __typename?: 'Mutation', retryInvoice?: { __typename?: 'Invoice', id: string } | null };

export type RetryTaxProviderVoidingMutationVariables = Exact<{
  input: RetryTaxProviderVoidingInput;
}>;


export type RetryTaxProviderVoidingMutation = { __typename?: 'Mutation', retryTaxProviderVoiding?: { __typename?: 'Invoice', id: string } | null };

export type SideNavInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type SideNavInfosQuery = { __typename?: 'Query', currentVersion: { __typename?: 'CurrentVersion', githubUrl: string, number: string } };

export type GetAddOnForDetailsQueryVariables = Exact<{
  addOn: Scalars['ID']['input'];
}>;


export type GetAddOnForDetailsQuery = { __typename?: 'Query', addOn?: { __typename?: 'AddOn', id: string, name: string, amountCents: any, amountCurrency: CurrencyEnum, code: string, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null };

export type AddOnsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type AddOnsQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, amountCurrency: CurrencyEnum, amountCents: any, customersCount: number, createdAt: any }> } };

export type BillableMetricsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type BillableMetricsQuery = { __typename?: 'Query', billableMetrics: { __typename?: 'BillableMetricCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'BillableMetric', id: string, name: string, code: string, createdAt: any }> } };

export type GetCouponForDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCouponForDetailsQuery = { __typename?: 'Query', coupon?: { __typename?: 'Coupon', id: string, amountCents?: any | null, amountCurrency?: CurrencyEnum | null, percentageRate?: number | null, code?: string | null, expirationAt?: any | null, name: string, frequency: CouponFrequency, reusable: boolean, couponType: CouponTypeEnum, billableMetrics?: Array<{ __typename?: 'BillableMetric', id: string, name: string }> | null, plans?: Array<{ __typename?: 'Plan', id: string, name: string }> | null } | null };

export type CouponsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type CouponsQuery = { __typename?: 'Query', coupons: { __typename?: 'CouponCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Coupon', id: string, name: string, customersCount: number, status: CouponStatusEnum, amountCurrency?: CurrencyEnum | null, amountCents?: any | null, appliedCouponsCount: number, expiration: CouponExpiration, expirationAt?: any | null, couponType: CouponTypeEnum, percentageRate?: number | null, frequency: CouponFrequency, frequencyDuration?: number | null }> } };

export type GetTaxesForAddOnFormQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTaxesForAddOnFormQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, name: string, rate: number, code: string }> } };

export type EditBillableMetricFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, expression?: string | null, description?: string | null, aggregationType: AggregationTypeEnum, fieldName?: string | null, subscriptionsCount: number, plansCount: number, recurring: boolean, roundingFunction?: RoundingFunctionEnum | null, roundingPrecision?: number | null, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string> }> | null };

export type CreateCreditNoteInvoiceFragment = { __typename?: 'Invoice', id: string, currency?: CurrencyEnum | null, number: string, paymentStatus: InvoicePaymentStatusTypeEnum, creditableAmountCents: any, refundableAmountCents: any, subTotalIncludingTaxesAmountCents: any, availableToCreditAmountCents: any, paymentDisputeLostAt?: any | null, invoiceType: InvoiceTypeEnum, couponsAmountCents: any, feesAmountCents: any, versionNumber: number, fees?: Array<{ __typename?: 'Fee', id: string, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxName: string, taxRate: number }> | null }> | null };

export type TaxInfosForCreateInvoiceFragment = { __typename?: 'Tax', id: string, name: string, code: string, rate: number };

export type CreateInvoiceMutationVariables = Exact<{
  input: CreateInvoiceInput;
}>;


export type CreateInvoiceMutation = { __typename?: 'Mutation', createInvoice?: { __typename?: 'Invoice', id: string } | null };

export type GetInfosForCreateInvoiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInfosForCreateInvoiceQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, name?: string | null, displayName: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, state?: string | null, zipcode?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string } | null } | null, organization?: { __typename?: 'CurrentOrganization', id: string, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, email?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, logoUrl?: string | null, state?: string | null, zipcode?: string | null, defaultCurrency: CurrencyEnum } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number }> } };

export type GetAddonListForInfoiceQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetAddonListForInfoiceQuery = { __typename?: 'Query', addOns: { __typename?: 'AddOnCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'AddOn', id: string, name: string, description?: string | null, amountCents: any, amountCurrency: CurrencyEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null }> } };

export type FetchDraftInvoiceTaxesMutationVariables = Exact<{
  input: FetchDraftInvoiceTaxesInput;
}>;


export type FetchDraftInvoiceTaxesMutation = { __typename?: 'Mutation', fetchDraftInvoiceTaxes?: { __typename?: 'AnrokFeeObjectCollection', collection: Array<{ __typename?: 'AnrokFeeObject', amountCents?: any | null, itemId?: string | null, taxAmountCents?: any | null, taxBreakdown?: Array<{ __typename?: 'AnrokBreakdownObject', name?: string | null, rate?: number | null, taxAmount?: any | null, enumedTaxCode?: InvoiceAppliedTaxOnWholeInvoiceCodeEnum | null }> | null }> } | null };

export type TaxForPlanAndChargesInPlanFormFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number };

export type BillableMetricForPlanFragment = { __typename?: 'BillableMetric', id: string, name: string, code: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', id: string, key: string, values: Array<string> }> | null };

export type EditPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, description?: string | null, interval: PlanInterval, payInAdvance: boolean, invoiceDisplayName?: string | null, amountCents: any, amountCurrency: CurrencyEnum, trialPeriod?: number | null, subscriptionsCount: number, billChargesMonthly?: boolean | null, minimumCommitment?: { __typename?: 'Commitment', amountCents: any, commitmentType: CommitmentTypeEnum, invoiceDisplayName?: string | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null } | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, charges?: Array<{ __typename?: 'Charge', id: string, minAmountCents: any, payInAdvance: boolean, chargeModel: ChargeModelEnum, invoiceable: boolean, prorated: boolean, invoiceDisplayName?: string | null, regroupPaidFees?: RegroupPaidFeesEnum | null, taxes?: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> | null, billableMetric: { __typename?: 'BillableMetric', id: string, code: string, name: string, aggregationType: AggregationTypeEnum, recurring: boolean, filters?: Array<{ __typename?: 'BillableMetricFilter', key: string, values: Array<string>, id: string }> | null }, properties?: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } | null, filters?: Array<{ __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any, properties: { __typename?: 'Properties', amount?: string | null, packageSize?: any | null, freeUnits?: any | null, groupedBy?: Array<string> | null, fixedAmount?: string | null, freeUnitsPerEvents?: any | null, freeUnitsPerTotalAggregation?: string | null, rate?: string | null, perTransactionMinAmount?: string | null, perTransactionMaxAmount?: string | null, customProperties?: any | null, graduatedRanges?: Array<{ __typename?: 'GraduatedRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null, graduatedPercentageRanges?: Array<{ __typename?: 'GraduatedPercentageRange', flatAmount: string, fromValue: any, rate: string, toValue?: any | null }> | null, volumeRanges?: Array<{ __typename?: 'VolumeRange', flatAmount: string, fromValue: any, perUnitAmount: string, toValue?: any | null }> | null } }> | null }> | null, usageThresholds?: Array<{ __typename?: 'UsageThreshold', id: string, amountCents: any, recurring: boolean, thresholdDisplayName?: string | null }> | null };

export type AddSubscriptionPlanFragment = { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval };

export type GetPlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval }> } };

export type GetCustomerForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerForCreateSubscriptionQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, name?: string | null, displayName: string, externalId: string } | null };

export type GetSubscriptionForCreateSubscriptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSubscriptionForCreateSubscriptionQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, externalId: string, subscriptionAt?: any | null, endingAt?: any | null, billingTime?: BillingTimeEnum | null, periodEndDate?: any | null, status?: StatusTypeEnum | null, startedAt?: any | null, plan: { __typename?: 'Plan', id: string, name: string, code: string, interval: PlanInterval, parent?: { __typename?: 'Plan', id: string } | null } } | null };

export type GetCreditNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCreditNoteQuery = { __typename?: 'Query', creditNote?: { __typename?: 'CreditNote', id: string, balanceAmountCents: any, canBeVoided: boolean, couponsAdjustmentAmountCents: any, createdAt: any, creditAmountCents: any, creditStatus?: CreditNoteCreditStatusEnum | null, currency: CurrencyEnum, number: string, refundAmountCents: any, refundedAt?: any | null, refundStatus?: CreditNoteRefundStatusEnum | null, subTotalExcludingTaxesAmountCents: any, totalAmountCents: any, integrationSyncable: boolean, taxProviderSyncable: boolean, taxProviderId?: string | null, externalIntegrationId?: string | null, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, deletedAt?: any | null, applicableTimezone: TimezoneEnum, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', id: string, integrationId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', id: string, integrationId?: string | null } | null, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, integrationId?: string | null, externalAccountId?: string | null } | null }, invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, number: string } | null, appliedTaxes?: Array<{ __typename?: 'CreditNoteAppliedTax', id: string, amountCents: any, baseAmountCents: any, taxRate: number, taxName: string }> | null, items: Array<{ __typename?: 'CreditNoteItem', amountCents: any, amountCurrency: CurrencyEnum, fee: { __typename?: 'Fee', id: string, amountCents: any, eventsCount?: any | null, units: number, feeType: FeeTypesEnum, itemName: string, groupedBy: any, invoiceName?: string | null, appliedTaxes?: Array<{ __typename?: 'FeeAppliedTax', id: string, taxRate: number }> | null, trueUpParentFee?: { __typename?: 'Fee', id: string } | null, charge?: { __typename?: 'Charge', id: string, billableMetric: { __typename?: 'BillableMetric', id: string, name: string, aggregationType: AggregationTypeEnum } } | null, subscription?: { __typename?: 'Subscription', id: string, name?: string | null, plan: { __typename?: 'Plan', id: string, name: string, invoiceDisplayName?: string | null } } | null, chargeFilter?: { __typename?: 'ChargeFilter', invoiceDisplayName?: string | null, values: any } | null } }> } | null };

export type IntegrationsListForCreditNoteDetailsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsListForCreditNoteDetailsQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type SyncIntegrationCreditNoteMutationVariables = Exact<{
  input: SyncIntegrationCreditNoteInput;
}>;


export type SyncIntegrationCreditNoteMutation = { __typename?: 'Mutation', syncIntegrationCreditNote?: { __typename?: 'SyncIntegrationCreditNotePayload', creditNoteId?: string | null } | null };

export type RetryTaxReportingMutationVariables = Exact<{
  input: RetryTaxReportingInput;
}>;


export type RetryTaxReportingMutation = { __typename?: 'Mutation', retryTaxReporting?: { __typename?: 'CreditNote', id: string } | null };

export type CustomerDetailsFragment = { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null };

export type GetCustomerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, customerType?: CustomerTypeEnum | null, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, hasActiveWallet: boolean, currency?: CurrencyEnum | null, hasCreditNotes: boolean, creditNotesCreditsAvailableCount: number, creditNotesBalanceAmountCents: any, applicableTimezone: TimezoneEnum, hasOverdueInvoices: boolean, addressLine1?: string | null, addressLine2?: string | null, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, targetedObject?: HubspotTargetedObjectsEnum | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null } | null };

export type GenerateCustomerPortalUrlMutationVariables = Exact<{
  input: GenerateCustomerPortalUrlInput;
}>;


export type GenerateCustomerPortalUrlMutation = { __typename?: 'Mutation', generateCustomerPortalUrl?: { __typename?: 'GenerateCustomerPortalUrlPayload', url: string } | null };

export type GetCustomerDraftInvoicesQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCustomerDraftInvoicesQuery = { __typename?: 'Query', customerInvoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalCount: number, totalPages: number } } };

export type GetCustomerInfosForDraftInvoicesListQueryVariables = Exact<{
  customerId: Scalars['ID']['input'];
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type GetCustomerInfosForDraftInvoicesListQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } | null, customerInvoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } };

export type CustomerForRequestOverduePaymentFormFragment = { __typename?: 'Customer', email?: string | null };

export type InvoicesForRequestOverduePaymentFormFragment = { __typename?: 'Invoice', id: string, number: string, totalAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any };

export type LastPaymentRequestFragment = { __typename?: 'PaymentRequest', createdAt: any };

export type GetRequestOverduePaymentInfosQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetRequestOverduePaymentInfosQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', defaultCurrency: CurrencyEnum, name: string, logoUrl?: string | null, email?: string | null, netPaymentTerm: number, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', documentLocale?: string | null } | null } | null, customer?: { __typename?: 'Customer', externalId: string, currency?: CurrencyEnum | null, email?: string | null, displayName: string, paymentProvider?: ProviderTypeEnum | null, netPaymentTerm?: number | null, billingConfiguration?: { __typename?: 'CustomerBillingConfiguration', documentLocale?: string | null } | null } | null, paymentRequests: { __typename?: 'PaymentRequestCollection', collection: Array<{ __typename?: 'PaymentRequest', createdAt: any }> }, invoices: { __typename?: 'InvoiceCollection', collection: Array<{ __typename?: 'Invoice', id: string, number: string, totalAmountCents: any, currency?: CurrencyEnum | null, issuingDate: any }> } };

export type CreatePaymentRequestMutationVariables = Exact<{
  input: PaymentRequestCreateInput;
}>;


export type CreatePaymentRequestMutation = { __typename?: 'Mutation', createPaymentRequest?: { __typename?: 'PaymentRequest', id: string } | null };

export type CustomersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type CustomersQuery = { __typename?: 'Query', customers: { __typename?: 'CustomerCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Customer', id: string, name?: string | null, displayName: string, firstname?: string | null, lastname?: string | null, externalId: string, createdAt: any, activeSubscriptionsCount: number, addressLine1?: string | null, addressLine2?: string | null, applicableTimezone: TimezoneEnum, canEditAttributes: boolean, city?: string | null, country?: CountryCode | null, currency?: CurrencyEnum | null, email?: string | null, externalSalesforceId?: string | null, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, customerType?: CustomerTypeEnum | null, paymentProvider?: ProviderTypeEnum | null, phone?: string | null, state?: string | null, timezone?: TimezoneEnum | null, zipcode?: string | null, url?: string | null, paymentProviderCode?: string | null, shippingAddress?: { __typename?: 'CustomerAddress', addressLine1?: string | null, addressLine2?: string | null, city?: string | null, country?: CountryCode | null, state?: string | null, zipcode?: string | null } | null, providerCustomer?: { __typename?: 'ProviderCustomer', id: string, providerCustomerId?: string | null, syncWithProvider?: boolean | null, providerPaymentMethods?: Array<ProviderPaymentMethodsEnum> | null } | null, netsuiteCustomer?: { __typename: 'NetsuiteCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, subsidiaryId?: string | null, syncWithProvider?: boolean | null } | null, anrokCustomer?: { __typename: 'AnrokCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, xeroCustomer?: { __typename: 'XeroCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, hubspotCustomer?: { __typename: 'HubspotCustomer', id: string, integrationId?: string | null, externalCustomerId?: string | null, integrationCode?: string | null, integrationType?: IntegrationTypeEnum | null, syncWithProvider?: boolean | null } | null, metadata?: Array<{ __typename?: 'CustomerMetadata', id: string, key: string, value: string, displayInInvoice: boolean }> | null }> } };

export type GetinviteQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetinviteQuery = { __typename?: 'Query', invite?: { __typename?: 'Invite', id: string, email: string, organization: { __typename?: 'Organization', id: string, name: string } } | null };

export type AcceptInviteMutationVariables = Exact<{
  input: AcceptInviteInput;
}>;


export type AcceptInviteMutation = { __typename?: 'Mutation', acceptInvite?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GoogleAcceptInviteMutationVariables = Exact<{
  input: GoogleAcceptInviteInput;
}>;


export type GoogleAcceptInviteMutation = { __typename?: 'Mutation', googleAcceptInvite?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type FetchOktaAuthorizeUrlMutationVariables = Exact<{
  input: OktaAuthorizeInput;
}>;


export type FetchOktaAuthorizeUrlMutation = { __typename?: 'Mutation', oktaAuthorize?: { __typename?: 'Authorize', url: string } | null };

export type OktaAcceptInviteMutationVariables = Exact<{
  input: OktaAcceptInviteInput;
}>;


export type OktaAcceptInviteMutation = { __typename?: 'Mutation', oktaAcceptInvite?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetInvoiceCreditNotesQueryVariables = Exact<{
  invoiceId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvoiceCreditNotesQuery = { __typename?: 'Query', invoiceCreditNotes?: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null }> } | null, invoice?: { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, associatedActiveWalletPresent: boolean, paymentStatus: InvoicePaymentStatusTypeEnum, refundableAmountCents: any, creditableAmountCents: any, status: InvoiceStatusTypeEnum, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, displayName: string } } | null };

export type InvoiceDetailsForInvoiceOverviewFragment = { __typename?: 'Invoice', id: string, invoiceType: InvoiceTypeEnum, status: InvoiceStatusTypeEnum, issuingDate: any, externalIntegrationId?: string | null, taxProviderVoidable: boolean, integrationCrmSyncable: boolean, externalCrmIntegrationId?: string | null, customer: { __typename?: 'Customer', id: string, applicableTimezone: TimezoneEnum, anrokCustomer?: { __typename?: 'AnrokCustomer', id: string, externalAccountId?: string | null } | null, netsuiteCustomer?: { __typename?: 'NetsuiteCustomer', externalCustomerId?: string | null } | null, xeroCustomer?: { __typename?: 'XeroCustomer', externalCustomerId?: string | null } | null, hubspotCustomer?: { __typename?: 'HubspotCustomer', externalCustomerId?: string | null } | null } };

export type NetsuiteIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'NetsuiteIntegration', id: string, accountId?: string | null, name: string };

export type HubspotIntegrationInfosForInvoiceOverviewFragment = { __typename?: 'HubspotIntegration', id: string, portalId?: string | null, invoicesObjectTypeId?: string | null };

export type GetInvoicesListQueryVariables = Exact<{
  currency?: InputMaybe<CurrencyEnum>;
  customerExternalId?: InputMaybe<Scalars['String']['input']>;
  invoiceType?: InputMaybe<Array<InvoiceTypeEnum> | InvoiceTypeEnum>;
  issuingDateFrom?: InputMaybe<Scalars['ISO8601Date']['input']>;
  issuingDateTo?: InputMaybe<Scalars['ISO8601Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  paymentDisputeLost?: InputMaybe<Scalars['Boolean']['input']>;
  paymentOverdue?: InputMaybe<Scalars['Boolean']['input']>;
  paymentStatus?: InputMaybe<Array<InvoicePaymentStatusTypeEnum> | InvoicePaymentStatusTypeEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InvoiceStatusTypeEnum> | InvoiceStatusTypeEnum>;
}>;


export type GetInvoicesListQuery = { __typename?: 'Query', invoices: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invoice', id: string, status: InvoiceStatusTypeEnum, paymentStatus: InvoicePaymentStatusTypeEnum, paymentOverdue: boolean, number: string, issuingDate: any, totalAmountCents: any, currency?: CurrencyEnum | null, voidable: boolean, paymentDisputeLostAt?: any | null, taxProviderVoidable: boolean, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum }, errorDetails?: Array<{ __typename?: 'ErrorDetail', errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null }> } };

export type GetCreditNotesListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCreditNotesListQuery = { __typename?: 'Query', creditNotes: { __typename?: 'CreditNoteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'CreditNote', id: string, number: string, totalAmountCents: any, refundAmountCents: any, creditAmountCents: any, currency: CurrencyEnum, createdAt: any, canBeVoided: boolean, voidedAt?: any | null, taxProviderSyncable: boolean, errorDetails?: Array<{ __typename?: 'ErrorDetail', id: string, errorCode: ErrorCodesEnum, errorDetails?: string | null }> | null, invoice?: { __typename?: 'Invoice', id: string, number: string, customer: { __typename?: 'Customer', id: string, name?: string | null, displayName: string, applicableTimezone: TimezoneEnum } } | null }> } };

export type RetryAllInvoicePaymentsMutationVariables = Exact<{
  input: RetryAllInvoicePaymentsInput;
}>;


export type RetryAllInvoicePaymentsMutation = { __typename?: 'Mutation', retryAllInvoicePayments?: { __typename?: 'InvoiceCollection', metadata: { __typename?: 'CollectionMetadata', totalCount: number } } | null };

export type GetPlanForDetailsQueryVariables = Exact<{
  planId: Scalars['ID']['input'];
}>;


export type GetPlanForDetailsQuery = { __typename?: 'Query', plan?: { __typename?: 'Plan', id: string, name: string, code: string, draftInvoicesCount: number, activeSubscriptionsCount: number, parent?: { __typename?: 'Plan', id: string } | null } | null };

export type PlansQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type PlansQuery = { __typename?: 'Query', plans: { __typename?: 'PlanCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Plan', id: string, name: string, code: string, chargesCount: number, activeSubscriptionsCount: number, createdAt: any, draftInvoicesCount: number }> } };

export type GetSubscriptionForDetailsQueryVariables = Exact<{
  subscriptionId: Scalars['ID']['input'];
}>;


export type GetSubscriptionForDetailsQuery = { __typename?: 'Query', subscription?: { __typename?: 'Subscription', id: string, name?: string | null, status?: StatusTypeEnum | null, externalId: string, plan: { __typename?: 'Plan', id: string, name: string, code: string, parent?: { __typename?: 'Plan', id: string, name: string, code: string } | null }, customer: { __typename?: 'Customer', id: string } } | null };

export type WalletForUpdateFragment = { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, method: RecurringTransactionMethodEnum, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, targetOngoingBalance?: string | null, paidCredits: string, grantedCredits: string, thresholdCredits?: string | null, startedAt?: any | null, invoiceRequiresSuccessfulPayment: boolean }> | null };

export type GetCustomerInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetCustomerInfosForWalletFormQuery = { __typename?: 'Query', customer?: { __typename?: 'Customer', id: string, currency?: CurrencyEnum | null, timezone?: TimezoneEnum | null } | null };

export type GetWalletInfosForWalletFormQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWalletInfosForWalletFormQuery = { __typename?: 'Query', wallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, method: RecurringTransactionMethodEnum, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, targetOngoingBalance?: string | null, paidCredits: string, grantedCredits: string, thresholdCredits?: string | null, startedAt?: any | null, invoiceRequiresSuccessfulPayment: boolean }> | null } | null };

export type CreateCustomerWalletMutationVariables = Exact<{
  input: CreateCustomerWalletInput;
}>;


export type CreateCustomerWalletMutation = { __typename?: 'Mutation', createCustomerWallet?: { __typename?: 'Wallet', id: string, customer?: { __typename?: 'Customer', id: string, hasActiveWallet: boolean } | null } | null };

export type UpdateCustomerWalletMutationVariables = Exact<{
  input: UpdateCustomerWalletInput;
}>;


export type UpdateCustomerWalletMutation = { __typename?: 'Mutation', updateCustomerWallet?: { __typename?: 'Wallet', id: string, expirationAt?: any | null, name?: string | null, rateAmount: number, invoiceRequiresSuccessfulPayment: boolean, recurringTransactionRules?: Array<{ __typename?: 'RecurringTransactionRule', lagoId: string, method: RecurringTransactionMethodEnum, trigger: RecurringTransactionTriggerEnum, interval?: RecurringTransactionIntervalEnum | null, targetOngoingBalance?: string | null, paidCredits: string, grantedCredits: string, thresholdCredits?: string | null, startedAt?: any | null, invoiceRequiresSuccessfulPayment: boolean }> | null } | null };

export type CreatePasswordResetMutationVariables = Exact<{
  input: CreatePasswordResetInput;
}>;


export type CreatePasswordResetMutation = { __typename?: 'Mutation', createPasswordReset?: { __typename?: 'CreatePasswordResetPayload', id: string } | null };

export type GoogleLoginUserMutationVariables = Exact<{
  input: GoogleLoginUserInput;
}>;


export type GoogleLoginUserMutation = { __typename?: 'Mutation', googleLoginUser?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type LoginUserMutationVariables = Exact<{
  input: LoginUserInput;
}>;


export type LoginUserMutation = { __typename?: 'Mutation', loginUser?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type OktaLoginUserMutationVariables = Exact<{
  input: OktaLoginInput;
}>;


export type OktaLoginUserMutation = { __typename?: 'Mutation', oktaLogin?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetPasswordResetQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetPasswordResetQuery = { __typename?: 'Query', passwordReset: { __typename?: 'ResetPassword', id: string, user: { __typename?: 'User', id: string, email?: string | null } } };

export type ResetPasswordMutationVariables = Exact<{
  input: ResetPasswordInput;
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword?: { __typename?: 'LoginUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type SignupMutationVariables = Exact<{
  input: RegisterUserInput;
}>;


export type SignupMutation = { __typename?: 'Mutation', registerUser?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GoogleRegisterMutationVariables = Exact<{
  input: GoogleRegisterUserInput;
}>;


export type GoogleRegisterMutation = { __typename?: 'Mutation', googleRegisterUser?: { __typename?: 'RegisterUser', token: string, user: { __typename?: 'User', id: string, organizations: Array<{ __typename?: 'Organization', id: string, name: string, timezone?: TimezoneEnum | null }> } } | null };

export type GetPortalOrgaInfosQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPortalOrgaInfosQuery = { __typename?: 'Query', customerPortalOrganization?: { __typename?: 'CustomerPortalOrganization', id: string, name: string, logoUrl?: string | null, premiumIntegrations: Array<PremiumIntegrationTypeEnum> } | null };

export type GetOrganizationApiKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationApiKeyQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, apiKey?: string | null } | null };

export type EventListFragment = { __typename?: 'Event', id: string, code: string, transactionId?: string | null, timestamp?: any | null, receivedAt?: any | null, payload: any, billableMetricName?: string | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum };

export type EventsQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type EventsQuery = { __typename?: 'Query', events?: { __typename?: 'EventCollection', collection: Array<{ __typename?: 'Event', id: string, code: string, transactionId?: string | null, timestamp?: any | null, receivedAt?: any | null, payload: any, billableMetricName?: string | null, matchBillableMetric?: boolean | null, matchCustomField?: boolean | null, apiClient?: string | null, ipAddress?: string | null, externalSubscriptionId?: string | null, customerTimezone: TimezoneEnum }>, metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number } } | null };

export type GetWebhookInformationsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetWebhookInformationsQuery = { __typename?: 'Query', webhookEndpoint?: { __typename?: 'WebhookEndpoint', id: string, webhookUrl: string } | null };

export type WebhookLogFragment = { __typename?: 'Webhook', id: string, createdAt: any, endpoint: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string, payload?: string | null, response?: string | null, httpStatus?: number | null, retries: number };

export type GetWebhookLogQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  webhookEndpointId: Scalars['String']['input'];
  status?: InputMaybe<WebhookStatusEnum>;
  searchTerm?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetWebhookLogQuery = { __typename?: 'Query', webhooks: { __typename?: 'WebhookCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Webhook', id: string, createdAt: any, endpoint: string, status: WebhookStatusEnum, updatedAt: any, webhookType: string, payload?: string | null, response?: string | null, httpStatus?: number | null, retries: number }> } };

export type GetWebhookListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetWebhookListQuery = { __typename?: 'Query', webhookEndpoints: { __typename?: 'WebhookEndpointCollection', collection: Array<{ __typename?: 'WebhookEndpoint', id: string, webhookUrl: string, signatureAlgo?: WebhookEndpointSignatureAlgoEnum | null }> } };

export type AdyenIntegrationDetailsFragment = { __typename?: 'AdyenProvider', id: string, apiKey?: string | null, code: string, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null, name: string };

export type GetAdyenIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider', id: string, apiKey?: string | null, code: string, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null, successRedirectUrl?: string | null, name: string } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' }> } | null };

export type AdyenIntegrationsFragment = { __typename?: 'AdyenProvider', id: string, name: string, code: string };

export type GetAdyenIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetAdyenIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string, name: string, code: string, apiKey?: string | null, hmacKey?: string | null, livePrefix?: string | null, merchantAccount?: string | null } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider' }> } | null };

export type AnrokIntegrationDetailsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string };

export type GetAnrokIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetAnrokIntegrationsDetailsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration', id: string } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type AnrokIntegrationsFragment = { __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string };

export type GetAnrokIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
}>;


export type GetAnrokIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration', id: string, name: string, code: string, apiKey: string } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type GetAuthIntegrationsQueryVariables = Exact<{
  limit: Scalars['Int']['input'];
}>;


export type GetAuthIntegrationsQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration', id: string, domain: string, clientId?: string | null, clientSecret?: string | null, organizationName: string, name: string } | { __typename?: 'XeroIntegration' }> } | null };

export type OktaIntegrationDetailsFragment = { __typename?: 'OktaIntegration', id: string, clientId?: string | null, clientSecret?: string | null, code: string, organizationName: string, domain: string, name: string };

export type GetOktaIntegrationQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetOktaIntegrationQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration', id: string, clientId?: string | null, clientSecret?: string | null, code: string, organizationName: string, domain: string, name: string } | { __typename?: 'XeroIntegration' } | null };

export type CreateDunningCampaignMutationVariables = Exact<{
  input: CreateDunningCampaignInput;
}>;


export type CreateDunningCampaignMutation = { __typename?: 'Mutation', createDunningCampaign?: { __typename?: 'DunningCampaign', name: string, code: string, description?: string | null, daysBetweenAttempts: number, maxAttempts: number, appliedToOrganization: boolean, thresholds: Array<{ __typename?: 'DunningCampaignThreshold', amountCents: any, currency: CurrencyEnum }> } | null };

export type CreateDunningCampaignPaymentProviderQueryVariables = Exact<{ [key: string]: never; }>;


export type CreateDunningCampaignPaymentProviderQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename: 'AdyenProvider' } | { __typename: 'GocardlessProvider' } | { __typename: 'StripeProvider' }> } | null };

export type DunningCampaignItemFragment = { __typename?: 'DunningCampaign', id: string, name: string, code: string, appliedToOrganization: boolean };

export type GetDunningCampaignsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetDunningCampaignsQuery = { __typename?: 'Query', dunningCampaigns: { __typename?: 'DunningCampaignCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'DunningCampaign', id: string, name: string, code: string, appliedToOrganization: boolean }> } };

export type UpdateDunningCampaignStatusMutationVariables = Exact<{
  input: UpdateDunningCampaignInput;
}>;


export type UpdateDunningCampaignStatusMutation = { __typename?: 'Mutation', updateDunningCampaign?: { __typename?: 'DunningCampaign', id: string, appliedToOrganization: boolean } | null };

export type GocardlessIntegrationDetailsFragment = { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null };

export type GetGocardlessIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string, code: string, name: string, successRedirectUrl?: string | null, webhookSecret?: string | null } | { __typename?: 'StripeProvider' } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider' }> } | null };

export type GocardlessIntegrationOauthCallbackFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type AddGocardlessApiKeyMutationVariables = Exact<{
  input: AddGocardlessPaymentProviderInput;
}>;


export type AddGocardlessApiKeyMutation = { __typename?: 'Mutation', addGocardlessPaymentProvider?: { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | null };

export type GocardlessIntegrationsFragment = { __typename?: 'GocardlessProvider', id: string, name: string, code: string };

export type GetGocardlessIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetGocardlessIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider', id: string, name: string, code: string } | { __typename?: 'StripeProvider' }> } | null };

export type HubspotIntegrationDetailsFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type GetHubspotIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetHubspotIntegrationsDetailsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration', id: string } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type HubspotIntegrationsFragment = { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null };

export type GetHubspotIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
}>;


export type GetHubspotIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration', id: string, name: string, code: string, defaultTargetedObject: HubspotTargetedObjectsEnum, syncInvoices?: boolean | null, syncSubscriptions?: boolean | null } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type IntegrationsSettingQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type IntegrationsSettingQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, euTaxManagement: boolean, country?: CountryCode | null } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider', id: string } | { __typename?: 'GocardlessProvider', id: string } | { __typename?: 'StripeProvider', id: string }> } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration', id: string } | { __typename?: 'HubspotIntegration', id: string } | { __typename?: 'NetsuiteIntegration', id: string } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string }> } | null };

export type GetOrganizationSettingsQueryVariables = Exact<{
  appliedToOrganization?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetOrganizationSettingsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, netPaymentTerm: number, defaultCurrency: CurrencyEnum, documentNumbering: DocumentNumberingEnum, documentNumberPrefix: string, finalizeZeroAmountInvoice: boolean, billingConfiguration?: { __typename?: 'OrganizationBillingConfiguration', id: string, invoiceGracePeriod: number, invoiceFooter?: string | null, documentLocale?: string | null } | null } | null, taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, name: string, code: string, rate: number, appliedToOrganization: boolean }> } };

export type LagoTaxManagementIntegrationsSettingQueryVariables = Exact<{ [key: string]: never; }>;


export type LagoTaxManagementIntegrationsSettingQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, country?: CountryCode | null, euTaxManagement: boolean } | null };

export type GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTaxesForTaxManagementIntegrationDetailsPageQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number }> } };

export type RemoveTaxManagementIntegrationMutationVariables = Exact<{
  input: UpdateOrganizationInput;
}>;


export type RemoveTaxManagementIntegrationMutation = { __typename?: 'Mutation', updateOrganization?: { __typename?: 'CurrentOrganization', id: string, euTaxManagement: boolean } | null };

export type InviteItemForMembersSettingsFragment = { __typename?: 'Invite', id: string, email: string, token: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } };

export type MembershipItemForMembershipSettingsFragment = { __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, organization: { __typename?: 'Organization', id: string, name: string }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } };

export type GetInvitesQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetInvitesQuery = { __typename?: 'Query', invites: { __typename?: 'InviteCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number, totalCount: number }, collection: Array<{ __typename?: 'Invite', id: string, email: string, token: string, role: MembershipRole, organization: { __typename?: 'Organization', id: string, name: string } }> } };

export type GetMembersQueryVariables = Exact<{
  page?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetMembersQuery = { __typename?: 'Query', memberships: { __typename?: 'MembershipCollection', metadata: { __typename?: 'Metadata', currentPage: number, totalPages: number, totalCount: number, adminCount: number }, collection: Array<{ __typename?: 'Membership', id: string, role: MembershipRole, user: { __typename?: 'User', id: string, email?: string | null }, organization: { __typename?: 'Organization', id: string, name: string }, permissions: { __typename?: 'Permissions', addonsCreate: boolean, addonsDelete: boolean, addonsUpdate: boolean, addonsView: boolean, analyticsView: boolean, analyticsOverdueBalancesView: boolean, billableMetricsCreate: boolean, billableMetricsDelete: boolean, billableMetricsUpdate: boolean, billableMetricsView: boolean, couponsAttach: boolean, couponsCreate: boolean, couponsDelete: boolean, couponsDetach: boolean, couponsUpdate: boolean, couponsView: boolean, creditNotesCreate: boolean, creditNotesView: boolean, creditNotesVoid: boolean, customerSettingsUpdateGracePeriod: boolean, customerSettingsUpdateLang: boolean, customerSettingsUpdatePaymentTerms: boolean, customerSettingsUpdateTaxRates: boolean, customerSettingsView: boolean, customersCreate: boolean, customersDelete: boolean, customersUpdate: boolean, customersView: boolean, developersKeysManage: boolean, developersManage: boolean, draftInvoicesUpdate: boolean, dunningCampaignsCreate: boolean, dunningCampaignsUpdate: boolean, dunningCampaignsView: boolean, invoicesCreate: boolean, invoicesSend: boolean, invoicesUpdate: boolean, invoicesView: boolean, invoicesVoid: boolean, organizationEmailsUpdate: boolean, organizationEmailsView: boolean, organizationIntegrationsCreate: boolean, organizationIntegrationsDelete: boolean, organizationIntegrationsUpdate: boolean, organizationIntegrationsView: boolean, organizationInvoicesUpdate: boolean, organizationInvoicesView: boolean, organizationMembersCreate: boolean, organizationMembersDelete: boolean, organizationMembersUpdate: boolean, organizationMembersView: boolean, organizationTaxesUpdate: boolean, organizationTaxesView: boolean, organizationUpdate: boolean, organizationView: boolean, plansCreate: boolean, plansDelete: boolean, plansUpdate: boolean, plansView: boolean, subscriptionsCreate: boolean, subscriptionsUpdate: boolean, subscriptionsView: boolean, walletsCreate: boolean, walletsTerminate: boolean, walletsTopUp: boolean, walletsUpdate: boolean } }> } };

export type NetsuiteIntegrationDetailsFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null };

export type GetNetsuiteIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetNetsuiteIntegrationsDetailsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration', id: string, name: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, code: string, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration', id: string } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type NetsuiteIntegrationsFragment = { __typename?: 'NetsuiteIntegration', id: string, name: string, code: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null };

export type GetNetsuiteIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
}>;


export type GetNetsuiteIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration', id: string, name: string, code: string, accountId?: string | null, clientId?: string | null, clientSecret?: string | null, scriptEndpointUrl: string, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null, syncSalesOrders?: boolean | null, tokenId?: string | null, tokenSecret?: string | null } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration' }> } | null };

export type OrganizationInformationsFragment = { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null };

export type GetOrganizationInformationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationInformationsQuery = { __typename?: 'Query', organization?: { __typename?: 'CurrentOrganization', id: string, logoUrl?: string | null, name: string, legalName?: string | null, legalNumber?: string | null, taxIdentificationNumber?: string | null, email?: string | null, addressLine1?: string | null, addressLine2?: string | null, zipcode?: string | null, city?: string | null, state?: string | null, country?: CountryCode | null, timezone?: TimezoneEnum | null } | null };

export type StripeIntegrationDetailsFragment = { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: string | null, successRedirectUrl?: string | null };

export type GetStripeIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsDetailsQuery = { __typename?: 'Query', paymentProvider?: { __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string, code: string, name: string, secretKey?: string | null, successRedirectUrl?: string | null } | null, paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string }> } | null };

export type StripeIntegrationsFragment = { __typename?: 'StripeProvider', id: string, name: string, code: string };

export type GetStripeIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<ProviderTypeEnum>;
}>;


export type GetStripeIntegrationsListQuery = { __typename?: 'Query', paymentProviders?: { __typename?: 'PaymentProviderCollection', collection: Array<{ __typename?: 'AdyenProvider' } | { __typename?: 'GocardlessProvider' } | { __typename?: 'StripeProvider', id: string, name: string, code: string, secretKey?: string | null }> } | null };

export type TaxItemForTaxSettingsFragment = { __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number };

export type GetTaxesSettingsInformationsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetTaxesSettingsInformationsQuery = { __typename?: 'Query', taxes: { __typename?: 'TaxCollection', metadata: { __typename?: 'CollectionMetadata', currentPage: number, totalPages: number }, collection: Array<{ __typename?: 'Tax', id: string, code: string, name: string, rate: number, autoGenerated: boolean, customersCount: number }> } };

export type XeroIntegrationDetailsFragment = { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  integrationsType: IntegrationTypeEnum;
}>;


export type GetXeroIntegrationsDetailsQuery = { __typename?: 'Query', integration?: { __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null } | null, integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string }> } | null };

export type XeroIntegrationsFragment = { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null };

export type GetXeroIntegrationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<IntegrationTypeEnum>;
}>;


export type GetXeroIntegrationsListQuery = { __typename?: 'Query', integrations?: { __typename?: 'IntegrationCollection', collection: Array<{ __typename?: 'AnrokIntegration' } | { __typename?: 'HubspotIntegration' } | { __typename?: 'NetsuiteIntegration' } | { __typename?: 'OktaIntegration' } | { __typename?: 'XeroIntegration', id: string, name: string, code: string, connectionId: string, hasMappingsConfigured?: boolean | null, syncCreditNotes?: boolean | null, syncInvoices?: boolean | null, syncPayments?: boolean | null }> } | null };

export const AddOnItemFragmentDoc = gql`
    fragment AddOnItem on AddOn {
  id
  name
  amountCurrency
  amountCents
  customersCount
  createdAt
}
    `;
export const DeleteAddOnFragmentDoc = gql`
    fragment DeleteAddOn on AddOn {
  id
  name
}
    `;
export const BillableMetricItemFragmentDoc = gql`
    fragment BillableMetricItem on BillableMetric {
  id
  name
  code
  createdAt
}
    `;
export const DeleteBillableMetricDialogFragmentDoc = gql`
    fragment DeleteBillableMetricDialog on BillableMetric {
  id
  name
  draftInvoicesCount
  activeSubscriptionsCount
}
    `;
export const CouponCaptionFragmentDoc = gql`
    fragment CouponCaption on Coupon {
  id
  amountCurrency
  amountCents
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const CouponItemFragmentDoc = gql`
    fragment CouponItem on Coupon {
  id
  name
  customersCount
  status
  amountCurrency
  amountCents
  appliedCouponsCount
  expiration
  expirationAt
  couponType
  percentageRate
  frequency
  frequencyDuration
}
    `;
export const DeleteCouponFragmentDoc = gql`
    fragment DeleteCoupon on Coupon {
  id
  name
}
    `;
export const TerminateCouponFragmentDoc = gql`
    fragment TerminateCoupon on Coupon {
  id
  name
}
    `;
export const CreditNoteTableItemFragmentDoc = gql`
    fragment CreditNoteTableItem on CreditNote {
  id
  number
  totalAmountCents
  refundAmountCents
  creditAmountCents
  currency
  createdAt
  canBeVoided
  voidedAt
  taxProviderSyncable
  errorDetails {
    id
    errorCode
    errorDetails
  }
  invoice {
    id
    number
    customer {
      id
      name
      displayName
      applicableTimezone
    }
  }
}
    `;
export const CreditNotesForTableFragmentDoc = gql`
    fragment CreditNotesForTable on CreditNoteCollection {
  metadata {
    currentPage
    totalPages
    totalCount
  }
  collection {
    id
    ...CreditNoteTableItem
  }
}
    ${CreditNoteTableItemFragmentDoc}`;
export const PortalInvoiceListItemFragmentDoc = gql`
    fragment PortalInvoiceListItem on Invoice {
  id
  paymentStatus
  paymentOverdue
  paymentDisputeLostAt
  number
  issuingDate
  totalAmountCents
  currency
  invoiceType
}
    `;
export const SubscriptionForPortalUsageFragmentDoc = gql`
    fragment SubscriptionForPortalUsage on Subscription {
  id
  currentBillingPeriodEndingAt
  name
  plan {
    id
    name
    invoiceDisplayName
    code
    amountCents
    amountCurrency
    interval
  }
  customer {
    id
    currency
    applicableTimezone
  }
  lifetimeUsage {
    lastThresholdAmountCents
    nextThresholdAmountCents
    totalUsageAmountCents
    totalUsageFromDatetime
    totalUsageToDatetime
  }
}
    `;
export const CustomerPortalWalletInfoFragmentDoc = gql`
    fragment CustomerPortalWalletInfo on CustomerPortalWallet {
  id
  currency
  balanceCents
  creditsBalance
  expirationAt
  consumedCredits
  consumedAmountCents
  status
  creditsOngoingBalance
  ongoingBalanceCents
  rateAmount
  lastBalanceSyncAt
}
    `;
export const CouponPlansForCustomerFragmentDoc = gql`
    fragment CouponPlansForCustomer on Plan {
  id
  name
}
    `;
export const CouponBillableMetricsForCustomerFragmentDoc = gql`
    fragment CouponBillableMetricsForCustomer on BillableMetric {
  id
  name
}
    `;
export const InvoiceForFinalizeInvoiceFragmentDoc = gql`
    fragment InvoiceForFinalizeInvoice on Invoice {
  id
  issuingDate
  customer {
    id
    applicableTimezone
  }
}
    `;
export const InvoiceForUpdateInvoicePaymentStatusFragmentDoc = gql`
    fragment InvoiceForUpdateInvoicePaymentStatus on Invoice {
  id
  paymentStatus
}
    `;
export const InvoiceListItemFragmentDoc = gql`
    fragment InvoiceListItem on Invoice {
  id
  status
  paymentStatus
  paymentOverdue
  number
  issuingDate
  totalAmountCents
  currency
  voidable
  paymentDisputeLostAt
  taxProviderVoidable
  customer {
    id
    name
    displayName
    applicableTimezone
  }
  errorDetails {
    errorCode
    errorDetails
  }
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
}
    ${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}`;
export const InvoiceForInvoiceListFragmentDoc = gql`
    fragment InvoiceForInvoiceList on InvoiceCollection {
  collection {
    id
    customer {
      id
      applicableTimezone
    }
    ...InvoiceListItem
  }
  metadata {
    currentPage
    totalCount
    totalPages
  }
}
    ${InvoiceListItemFragmentDoc}`;
export const CustomerForExternalAppsAccordionFragmentDoc = gql`
    fragment CustomerForExternalAppsAccordion on Customer {
  id
  customerType
  netsuiteCustomer {
    externalCustomerId
    integrationCode
    integrationType
    subsidiaryId
    syncWithProvider
  }
  anrokCustomer {
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  xeroCustomer {
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
  hubspotCustomer {
    externalCustomerId
    integrationCode
    integrationType
    syncWithProvider
  }
}
    `;
export const AddCustomerDrawerFragmentDoc = gql`
    fragment AddCustomerDrawer on Customer {
  id
  addressLine1
  addressLine2
  applicableTimezone
  canEditAttributes
  city
  country
  currency
  email
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  customerType
  name
  firstname
  lastname
  paymentProvider
  phone
  state
  timezone
  zipcode
  shippingAddress {
    addressLine1
    addressLine2
    city
    country
    state
    zipcode
  }
  url
  paymentProviderCode
  providerCustomer {
    id
    providerCustomerId
    syncWithProvider
    providerPaymentMethods
  }
  netsuiteCustomer {
    __typename
    id
    integrationId
  }
  anrokCustomer {
    __typename
    id
    integrationId
  }
  xeroCustomer {
    __typename
    id
    integrationId
  }
  hubspotCustomer {
    __typename
    id
    integrationId
  }
  metadata {
    id
    key
    value
    displayInInvoice
  }
  ...CustomerForExternalAppsAccordion
}
    ${CustomerForExternalAppsAccordionFragmentDoc}`;
export const CustomerItemFragmentDoc = gql`
    fragment CustomerItem on Customer {
  id
  name
  displayName
  firstname
  lastname
  externalId
  createdAt
  activeSubscriptionsCount
  ...AddCustomerDrawer
}
    ${AddCustomerDrawerFragmentDoc}`;
export const CustomerAppliedTaxRatesForSettingsFragmentDoc = gql`
    fragment CustomerAppliedTaxRatesForSettings on Customer {
  id
  taxes {
    id
    name
    code
    rate
    autoGenerated
  }
}
    `;
export const DeleteCustomerDialogFragmentDoc = gql`
    fragment DeleteCustomerDialog on Customer {
  id
  name
  displayName
}
    `;
export const DeleteCustomerDocumentLocaleFragmentDoc = gql`
    fragment DeleteCustomerDocumentLocale on Customer {
  id
  name
  displayName
  externalId
}
    `;
export const DeleteCustomerFinalizeZeroAmountInvoiceFragmentDoc = gql`
    fragment DeleteCustomerFinalizeZeroAmountInvoice on Customer {
  id
  externalId
  name
  displayName
  finalizeZeroAmountInvoice
}
    `;
export const DeleteCustomerGracePeriodFragmentDoc = gql`
    fragment DeleteCustomerGracePeriod on Customer {
  id
  name
  displayName
}
    `;
export const DeleteCustomerNetPaymentTermFragmentDoc = gql`
    fragment DeleteCustomerNetPaymentTerm on Customer {
  id
  externalId
  name
  displayName
  netPaymentTerm
}
    `;
export const CustomerForDeleteVatRateDialogFragmentDoc = gql`
    fragment CustomerForDeleteVatRateDialog on Customer {
  id
  name
  externalId
  taxes {
    id
    code
  }
}
    `;
export const TaxRateForDeleteCustomerVatRateDialogFragmentDoc = gql`
    fragment TaxRateForDeleteCustomerVatRateDialog on Tax {
  id
  name
}
    `;
export const EditCustomerDocumentLocaleFragmentDoc = gql`
    fragment EditCustomerDocumentLocale on Customer {
  id
  name
  displayName
  externalId
  billingConfiguration {
    id
    documentLocale
  }
}
    `;
export const EditCustomerInvoiceGracePeriodFragmentDoc = gql`
    fragment EditCustomerInvoiceGracePeriod on Customer {
  id
  invoiceGracePeriod
}
    `;
export const EditCustomerVatRateFragmentDoc = gql`
    fragment EditCustomerVatRate on Customer {
  id
  name
  displayName
  externalId
  taxes {
    id
    code
  }
}
    `;
export const CreditNoteForVoidCreditNoteDialogFragmentDoc = gql`
    fragment CreditNoteForVoidCreditNoteDialog on CreditNote {
  id
  totalAmountCents
  currency
}
    `;
export const AppliedCouponCaptionFragmentDoc = gql`
    fragment AppliedCouponCaption on AppliedCoupon {
  id
  amountCurrency
  amountCents
  amountCentsRemaining
  percentageRate
  frequency
  frequencyDuration
  frequencyDurationRemaining
}
    `;
export const CustomerCouponFragmentDoc = gql`
    fragment CustomerCoupon on AppliedCoupon {
  id
  ...AppliedCouponCaption
  coupon {
    id
    name
  }
}
    ${AppliedCouponCaptionFragmentDoc}`;
export const CustomerAppliedCouponsFragmentDoc = gql`
    fragment CustomerAppliedCoupons on Customer {
  id
  appliedCoupons {
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export const SubscriptionLinePlanFragmentDoc = gql`
    fragment SubscriptionLinePlan on Plan {
  id
  name
  code
}
    `;
export const SubscriptionItemFragmentDoc = gql`
    fragment SubscriptionItem on Subscription {
  id
  status
  startedAt
  nextPendingStartDate
  name
  nextName
  externalId
  subscriptionAt
  endingAt
  plan {
    ...SubscriptionLinePlan
  }
  nextPlan {
    ...SubscriptionLinePlan
  }
  nextSubscription {
    id
  }
}
    ${SubscriptionLinePlanFragmentDoc}`;
export const CustomerUsageForUsageDetailsFragmentDoc = gql`
    fragment CustomerUsageForUsageDetails on CustomerUsage {
  fromDatetime
  toDatetime
  chargesUsage {
    charge {
      id
      invoiceDisplayName
    }
    billableMetric {
      name
    }
    filters {
      id
      amountCents
      units
      values
      invoiceDisplayName
    }
    groupedUsage {
      id
      amountCents
      groupedBy
      eventsCount
      units
      filters {
        id
        amountCents
        units
        values
        invoiceDisplayName
      }
    }
  }
}
    `;
export const WebhookForCreateAndEditFragmentDoc = gql`
    fragment WebhookForCreateAndEdit on WebhookEndpoint {
  id
  webhookUrl
  signatureAlgo
}
    `;
export const CustomerForDunningEmailFragmentDoc = gql`
    fragment CustomerForDunningEmail on Customer {
  displayName
  paymentProvider
  netPaymentTerm
  billingConfiguration {
    documentLocale
  }
}
    `;
export const OrganizationForDunningEmailFragmentDoc = gql`
    fragment OrganizationForDunningEmail on CurrentOrganization {
  name
  logoUrl
  email
  netPaymentTerm
  billingConfiguration {
    documentLocale
  }
}
    `;
export const InvoicesForDunningEmailFragmentDoc = gql`
    fragment InvoicesForDunningEmail on Invoice {
  id
  number
  totalAmountCents
  currency
}
    `;
export const TaxForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment TaxForInvoiceEditTaxDialog on Tax {
  id
  name
  rate
  code
}
    `;
export const AddOnForInvoiceEditTaxDialogFragmentDoc = gql`
    fragment AddOnForInvoiceEditTaxDialog on AddOn {
  id
  taxes {
    id
    ...TaxForInvoiceEditTaxDialog
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;
export const InvoiceForVoidInvoiceDialogFragmentDoc = gql`
    fragment InvoiceForVoidInvoiceDialog on Invoice {
  id
  number
}
    `;
export const BillableMetricForChargeSectionFragmentDoc = gql`
    fragment BillableMetricForChargeSection on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const DeletePlanDialogFragmentDoc = gql`
    fragment DeletePlanDialog on Plan {
  id
  name
  draftInvoicesCount
  activeSubscriptionsCount
}
    `;
export const PlanItemFragmentDoc = gql`
    fragment PlanItem on Plan {
  id
  name
  code
  chargesCount
  activeSubscriptionsCount
  createdAt
  ...DeletePlanDialog
}
    ${DeletePlanDialogFragmentDoc}`;
export const PlanSubscriptionListItemForSubscriptionListFragmentDoc = gql`
    fragment PlanSubscriptionListItemForSubscriptionList on Subscription {
  id
  endingAt
  subscriptionAt
  plan {
    id
    parent {
      id
    }
  }
  customer {
    id
    name
    displayName
    firstname
    lastname
    externalId
  }
}
    `;
export const DeleteOrganizationVatRateFragmentDoc = gql`
    fragment DeleteOrganizationVatRate on Tax {
  id
  name
  appliedToOrganization
}
    `;
export const EditOrganizationDefaultCurrencyForDialogFragmentDoc = gql`
    fragment EditOrganizationDefaultCurrencyForDialog on CurrentOrganization {
  id
  defaultCurrency
}
    `;
export const EditCustomerFinalizeZeroAmountInvoiceForDialogFragmentDoc = gql`
    fragment EditCustomerFinalizeZeroAmountInvoiceForDialog on Customer {
  id
  externalId
  name
  finalizeZeroAmountInvoice
}
    `;
export const EditOrganizationFinalizeZeroAmountInvoiceForDialogFragmentDoc = gql`
    fragment EditOrganizationFinalizeZeroAmountInvoiceForDialog on CurrentOrganization {
  id
  finalizeZeroAmountInvoice
}
    `;
export const EditCustomerNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditCustomerNetPaymentTermForDialog on Customer {
  id
  externalId
  name
  netPaymentTerm
}
    `;
export const EditOrganizationNetPaymentTermForDialogFragmentDoc = gql`
    fragment EditOrganizationNetPaymentTermForDialog on CurrentOrganization {
  id
  netPaymentTerm
}
    `;
export const EditOrganizationInformationsDialogFragmentDoc = gql`
    fragment EditOrganizationInformationsDialog on CurrentOrganization {
  id
  logoUrl
  name
  legalName
  legalNumber
  taxIdentificationNumber
  email
  addressLine1
  addressLine2
  zipcode
  city
  state
  country
}
    `;
export const EditOrganizationInvoiceNumberingDialogFragmentDoc = gql`
    fragment EditOrganizationInvoiceNumberingDialog on CurrentOrganization {
  id
  documentNumbering
  documentNumberPrefix
}
    `;
export const EditOrganizationInvoiceTemplateDialogFragmentDoc = gql`
    fragment EditOrganizationInvoiceTemplateDialog on CurrentOrganization {
  billingConfiguration {
    id
    invoiceFooter
  }
}
    `;
export const DeleteOktaIntegrationDialogFragmentDoc = gql`
    fragment DeleteOktaIntegrationDialog on OktaIntegration {
  id
  name
}
    `;
export const AddOktaIntegrationDialogFragmentDoc = gql`
    fragment AddOktaIntegrationDialog on OktaIntegration {
  id
  domain
  clientId
  clientSecret
  organizationName
  ...DeleteOktaIntegrationDialog
}
    ${DeleteOktaIntegrationDialogFragmentDoc}`;
export const OrganizationInfoForPreviewDunningCampaignFragmentDoc = gql`
    fragment OrganizationInfoForPreviewDunningCampaign on CurrentOrganization {
  name
  email
}
    `;
export const AddAdyenProviderDialogFragmentDoc = gql`
    fragment AddAdyenProviderDialog on AdyenProvider {
  id
  name
  code
  apiKey
  hmacKey
  livePrefix
  merchantAccount
}
    `;
export const AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment AdyenForCreateAndEditSuccessRedirectUrl on AdyenProvider {
  id
  successRedirectUrl
}
    `;
export const GocardlessForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment gocardlessForCreateAndEditSuccessRedirectUrl on GocardlessProvider {
  id
  successRedirectUrl
}
    `;
export const StripeForCreateAndEditSuccessRedirectUrlFragmentDoc = gql`
    fragment StripeForCreateAndEditSuccessRedirectUrl on StripeProvider {
  id
  successRedirectUrl
}
    `;
export const AddGocardlessProviderDialogFragmentDoc = gql`
    fragment AddGocardlessProviderDialog on GocardlessProvider {
  id
  name
  code
}
    `;
export const AddStripeProviderDialogFragmentDoc = gql`
    fragment AddStripeProviderDialog on StripeProvider {
  id
  name
  code
  secretKey
}
    `;
export const AnrokIntegrationItemsListAddonsFragmentDoc = gql`
    fragment AnrokIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AnrokIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment AnrokIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const AnrokIntegrationItemsListDefaultFragmentDoc = gql`
    fragment AnrokIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
}
    `;
export const AnrokIntegrationMapItemDialogFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialog on IntegrationItem {
  id
  externalId
  externalName
  externalAccountCode
  itemType
}
    `;
export const AnrokIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AnrokIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment AnrokIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const AnrokIntegrationSettingsFragmentDoc = gql`
    fragment AnrokIntegrationSettings on AnrokIntegration {
  id
  name
  code
  apiKey
  hasMappingsConfigured
  failedInvoicesCount
}
    `;
export const DeleteAdyenIntegrationDialogFragmentDoc = gql`
    fragment DeleteAdyenIntegrationDialog on AdyenProvider {
  id
  name
}
    `;
export const DeleteGocardlessIntegrationDialogFragmentDoc = gql`
    fragment DeleteGocardlessIntegrationDialog on GocardlessProvider {
  id
  name
}
    `;
export const DeleteStripeIntegrationDialogFragmentDoc = gql`
    fragment DeleteStripeIntegrationDialog on StripeProvider {
  id
  name
}
    `;
export const NetsuiteIntegrationItemsListAddonsFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const NetsuiteIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const NetsuiteIntegrationItemsListDefaultFragmentDoc = gql`
    fragment NetsuiteIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
  taxCode
  taxNexus
  taxType
}
    `;
export const NetsuiteIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment NetsuiteIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const NetsuiteIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment NetsuiteIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const NetsuiteIntegrationSettingsFragmentDoc = gql`
    fragment NetsuiteIntegrationSettings on NetsuiteIntegration {
  id
  accountId
  clientId
  clientSecret
  code
  hasMappingsConfigured
  name
  scriptEndpointUrl
  syncCreditNotes
  syncInvoices
  syncPayments
  syncSalesOrders
}
    `;
export const XeroIntegrationItemsListAddonsFragmentDoc = gql`
    fragment XeroIntegrationItemsListAddons on AddOn {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const XeroIntegrationItemsListBillableMetricsFragmentDoc = gql`
    fragment XeroIntegrationItemsListBillableMetrics on BillableMetric {
  id
  name
  code
  integrationMappings(integrationId: $integrationId) {
    id
    externalId
    externalAccountCode
    externalName
    mappableType
  }
}
    `;
export const XeroIntegrationItemsListDefaultFragmentDoc = gql`
    fragment XeroIntegrationItemsListDefault on CollectionMapping {
  id
  mappingType
  externalId
  externalAccountCode
  externalName
}
    `;
export const XeroIntegrationMapItemDialogFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialog on IntegrationItem {
  id
  externalId
  externalName
  externalAccountCode
  itemType
}
    `;
export const XeroIntegrationMapItemDialogCollectionMappingItemFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialogCollectionMappingItem on CollectionMapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const XeroIntegrationMapItemDialogCollectionItemFragmentDoc = gql`
    fragment XeroIntegrationMapItemDialogCollectionItem on Mapping {
  id
  externalId
  externalName
  externalAccountCode
}
    `;
export const XeroIntegrationSettingsFragmentDoc = gql`
    fragment XeroIntegrationSettings on XeroIntegration {
  id
  code
  connectionId
  hasMappingsConfigured
  name
  syncCreditNotes
  syncInvoices
  syncPayments
}
    `;
export const InviteForRolePickerFieldFragmentDoc = gql`
    fragment InviteForRolePickerField on Invite {
  id
  role
}
    `;
export const SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc = gql`
    fragment SubscriptionCurrentUsageTableComponentCustomerUsage on CustomerUsage {
  amountCents
  currency
  fromDatetime
  toDatetime
  chargesUsage {
    id
    units
    amountCents
    charge {
      id
      invoiceDisplayName
    }
    billableMetric {
      id
      code
      name
    }
    filters {
      id
    }
    groupedUsage {
      amountCents
      groupedBy
      eventsCount
      units
      filters {
        id
      }
    }
  }
}
    `;
export const SubscriptionForSubscriptionInformationsFragmentDoc = gql`
    fragment SubscriptionForSubscriptionInformations on Subscription {
  id
  externalId
  status
  subscriptionAt
  endingAt
  nextPendingStartDate
  nextPlan {
    id
    name
  }
  customer {
    id
    name
    displayName
  }
  plan {
    id
    name
    parent {
      id
      name
    }
  }
}
    `;
export const SubscriptionUsageLifetimeGraphForLifetimeGraphFragmentDoc = gql`
    fragment SubscriptionUsageLifetimeGraphForLifetimeGraph on Subscription {
  id
  lifetimeUsage {
    lastThresholdAmountCents
    nextThresholdAmountCents
    totalUsageAmountCents
    totalUsageFromDatetime
    totalUsageToDatetime
  }
  customer {
    id
    currency
    applicableTimezone
  }
  plan {
    id
  }
}
    `;
export const WalletForTopupFragmentDoc = gql`
    fragment WalletForTopup on Wallet {
  id
  currency
  rateAmount
  invoiceRequiresSuccessfulPayment
}
    `;
export const WalletForUpdateFragmentDoc = gql`
    fragment WalletForUpdate on Wallet {
  id
  expirationAt
  name
  rateAmount
  invoiceRequiresSuccessfulPayment
  recurringTransactionRules {
    lagoId
    method
    trigger
    interval
    targetOngoingBalance
    paidCredits
    grantedCredits
    thresholdCredits
    startedAt
    invoiceRequiresSuccessfulPayment
  }
}
    `;
export const WalletInfosForTransactionsFragmentDoc = gql`
    fragment WalletInfosForTransactions on Wallet {
  id
  currency
  status
  ongoingUsageBalanceCents
  creditsOngoingUsageBalance
}
    `;
export const WalletAccordionFragmentDoc = gql`
    fragment WalletAccordion on Wallet {
  id
  balanceCents
  consumedAmountCents
  consumedCredits
  createdAt
  creditsBalance
  currency
  expirationAt
  lastBalanceSyncAt
  lastConsumedCreditAt
  name
  rateAmount
  status
  terminatedAt
  ongoingBalanceCents
  creditsOngoingBalance
  ...WalletInfosForTransactions
}
    ${WalletInfosForTransactionsFragmentDoc}`;
export const CustomerWalletFragmentDoc = gql`
    fragment CustomerWallet on Wallet {
  ...WalletForTopup
  ...WalletForUpdate
  ...WalletAccordion
  ...WalletInfosForTransactions
}
    ${WalletForTopupFragmentDoc}
${WalletForUpdateFragmentDoc}
${WalletAccordionFragmentDoc}
${WalletInfosForTransactionsFragmentDoc}`;
export const WalletForVoidTransactionFragmentDoc = gql`
    fragment WalletForVoidTransaction on Wallet {
  id
  currency
  rateAmount
  creditsBalance
}
    `;
export const WalletTransactionForTransactionListItemFragmentDoc = gql`
    fragment WalletTransactionForTransactionListItem on WalletTransaction {
  id
  status
  transactionStatus
  transactionType
  amount
  creditAmount
  settledAt
  createdAt
  wallet {
    id
    currency
  }
}
    `;
export const CurrentUserFragmentDoc = gql`
    fragment CurrentUser on User {
  id
  organizations {
    id
    name
    timezone
  }
}
    `;
export const InvoiceFeeFragmentDoc = gql`
    fragment InvoiceFee on Fee {
  id
  amountCurrency
  feeType
  invoiceName
  invoiceDisplayName
  groupedBy
  succeededAt
  appliedTaxes {
    id
    taxName
    taxRate
  }
  creditableAmountCents
  trueUpFee {
    id
  }
  charge {
    id
    billableMetric {
      id
      name
    }
  }
  chargeFilter {
    id
    invoiceDisplayName
    values
  }
}
    `;
export const InvoiceForCreditNoteFormCalculationFragmentDoc = gql`
    fragment InvoiceForCreditNoteFormCalculation on Invoice {
  id
  couponsAmountCents
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  feesAmountCents
  currency
  versionNumber
  paymentDisputeLostAt
  fees {
    id
    appliedTaxes {
      id
      taxName
      taxRate
    }
  }
}
    `;
export const CreateCreditNoteInvoiceFragmentDoc = gql`
    fragment CreateCreditNoteInvoice on Invoice {
  id
  currency
  number
  paymentStatus
  creditableAmountCents
  refundableAmountCents
  subTotalIncludingTaxesAmountCents
  availableToCreditAmountCents
  paymentDisputeLostAt
  invoiceType
  ...InvoiceForCreditNoteFormCalculation
}
    ${InvoiceForCreditNoteFormCalculationFragmentDoc}`;
export const InvoiceCreateCreditNoteFragmentDoc = gql`
    fragment InvoiceCreateCreditNote on Invoice {
  id
  refundableAmountCents
  creditableAmountCents
  invoiceType
  fees {
    id
    amountCurrency
    itemCode
    itemName
    invoiceName
    invoiceDisplayName
    creditableAmountCents
    succeededAt
    appliedTaxes {
      id
      taxName
      taxRate
    }
    trueUpFee {
      id
    }
  }
  invoiceSubscriptions {
    subscription {
      id
      name
      plan {
        id
        name
        invoiceDisplayName
      }
    }
    fees {
      ...InvoiceFee
    }
  }
  ...CreateCreditNoteInvoice
}
    ${InvoiceFeeFragmentDoc}
${CreateCreditNoteInvoiceFragmentDoc}`;
export const TaxOnAddOnEditCreateFragmentDoc = gql`
    fragment TaxOnAddOnEditCreate on Tax {
  id
  name
  code
  rate
}
    `;
export const EditAddOnFragmentDoc = gql`
    fragment EditAddOn on AddOn {
  id
  name
  code
  description
  amountCents
  amountCurrency
  taxes {
    id
    ...TaxOnAddOnEditCreate
  }
}
    ${TaxOnAddOnEditCreateFragmentDoc}`;
export const PlansForCouponsFragmentDoc = gql`
    fragment PlansForCoupons on Plan {
  id
  name
  code
}
    `;
export const BillableMetricsForCouponsFragmentDoc = gql`
    fragment BillableMetricsForCoupons on BillableMetric {
  id
  name
  code
}
    `;
export const EditCouponFragmentDoc = gql`
    fragment EditCoupon on Coupon {
  id
  amountCents
  amountCurrency
  appliedCouponsCount
  code
  couponType
  description
  expiration
  expirationAt
  frequency
  frequencyDuration
  limitedBillableMetrics
  limitedPlans
  name
  percentageRate
  reusable
  plans {
    ...PlansForCoupons
  }
  billableMetrics {
    ...BillableMetricsForCoupons
  }
}
    ${PlansForCouponsFragmentDoc}
${BillableMetricsForCouponsFragmentDoc}`;
export const TaxFormFragmentDoc = gql`
    fragment TaxForm on Tax {
  id
  code
  description
  name
  rate
  customersCount
}
    `;
export const TaxFormQueryShapeFragmentDoc = gql`
    fragment TaxFormQueryShape on Tax {
  ...TaxForm
  autoGenerated
}
    ${TaxFormFragmentDoc}`;
export const MembershipPermissionsFragmentDoc = gql`
    fragment MembershipPermissions on Membership {
  id
  permissions {
    addonsCreate
    addonsDelete
    addonsUpdate
    addonsView
    analyticsView
    analyticsOverdueBalancesView
    billableMetricsCreate
    billableMetricsDelete
    billableMetricsUpdate
    billableMetricsView
    couponsAttach
    couponsCreate
    couponsDelete
    couponsDetach
    couponsUpdate
    couponsView
    creditNotesCreate
    creditNotesView
    creditNotesVoid
    customerSettingsUpdateGracePeriod
    customerSettingsUpdateLang
    customerSettingsUpdatePaymentTerms
    customerSettingsUpdateTaxRates
    customerSettingsView
    customersCreate
    customersDelete
    customersUpdate
    customersView
    developersKeysManage
    developersManage
    draftInvoicesUpdate
    dunningCampaignsCreate
    dunningCampaignsUpdate
    dunningCampaignsView
    invoicesCreate
    invoicesSend
    invoicesUpdate
    invoicesView
    invoicesVoid
    organizationEmailsUpdate
    organizationEmailsView
    organizationIntegrationsCreate
    organizationIntegrationsDelete
    organizationIntegrationsUpdate
    organizationIntegrationsView
    organizationInvoicesUpdate
    organizationInvoicesView
    organizationMembersCreate
    organizationMembersDelete
    organizationMembersUpdate
    organizationMembersView
    organizationTaxesUpdate
    organizationTaxesView
    organizationUpdate
    organizationView
    plansCreate
    plansDelete
    plansUpdate
    plansView
    subscriptionsCreate
    subscriptionsUpdate
    subscriptionsView
    walletsCreate
    walletsTerminate
    walletsTopUp
    walletsUpdate
  }
}
    `;
export const CurrentUserInfosFragmentDoc = gql`
    fragment CurrentUserInfos on User {
  id
  email
  premium
  memberships {
    id
    ...MembershipPermissions
    organization {
      id
      name
      logoUrl
    }
  }
}
    ${MembershipPermissionsFragmentDoc}`;
export const OrganizationForDatePickerFragmentDoc = gql`
    fragment OrganizationForDatePicker on CurrentOrganization {
  id
  timezone
}
    `;
export const MainOrganizationInfosFragmentDoc = gql`
    fragment MainOrganizationInfos on CurrentOrganization {
  id
  name
  logoUrl
  timezone
  defaultCurrency
  premiumIntegrations
  ...OrganizationForDatePicker
}
    ${OrganizationForDatePickerFragmentDoc}`;
export const CustomerMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment CustomerMetadatasForInvoiceOverview on Customer {
  id
  metadata {
    id
    displayInInvoice
    key
    value
  }
}
    `;
export const InvoiceDetailsForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceDetailsForInvoiceOverview on Invoice {
  id
  invoiceType
  status
  issuingDate
  externalIntegrationId
  taxProviderVoidable
  integrationCrmSyncable
  externalCrmIntegrationId
  customer {
    id
    applicableTimezone
    anrokCustomer {
      id
      externalAccountId
    }
    netsuiteCustomer {
      externalCustomerId
    }
    xeroCustomer {
      externalCustomerId
    }
    hubspotCustomer {
      externalCustomerId
    }
  }
}
    `;
export const InvoiceForCreditNotesTableFragmentDoc = gql`
    fragment InvoiceForCreditNotesTable on Invoice {
  id
  customer {
    id
  }
  creditNotes {
    id
    couponsAdjustmentAmountCents
    number
    subTotalExcludingTaxesAmountCents
    currency
    totalAmountCents
    appliedTaxes {
      id
      amountCents
      baseAmountCents
      taxRate
      taxName
    }
    items {
      amountCents
      amountCurrency
      fee {
        id
        amountCents
        eventsCount
        units
        feeType
        groupedBy
        itemName
        invoiceName
        appliedTaxes {
          id
          taxRate
        }
        trueUpParentFee {
          id
        }
        charge {
          id
          billableMetric {
            id
            name
            aggregationType
          }
        }
        subscription {
          id
          name
          plan {
            id
            name
            invoiceDisplayName
          }
        }
        chargeFilter {
          invoiceDisplayName
          values
        }
      }
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduated on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedRanges {
      flatUnitAmount
      fromValue
      perUnitAmount
      perUnitTotalAmount
      toValue
      totalWithFlatAmount
      units
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineGraduatedPercentage on Fee {
  id
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    graduatedPercentageRanges {
      flatUnitAmount
      fromValue
      perUnitTotalAmount
      rate
      toValue
      totalWithFlatAmount
      units
    }
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLineVolume on Fee {
  id
  units
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    flatUnitAmount
    perUnitAmount
    perUnitTotalAmount
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePackage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    paidUnits
    perPackageSize
    perPackageUnitAmount
  }
}
    `;
export const FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLinePercentage on Fee {
  id
  units
  amountCents
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    fixedFeeTotalAmount
    fixedFeeUnitAmount
    freeEvents
    freeUnits
    minMaxAdjustmentTotalAmount
    paidEvents
    paidUnits
    perUnitTotalAmount
    rate
    units
  }
}
    `;
export const FeeForEditfeeDrawerFragmentDoc = gql`
    fragment FeeForEditfeeDrawer on Fee {
  id
  currency
}
    `;
export const FeeForDeleteAdjustmentFeeDialogFragmentDoc = gql`
    fragment FeeForDeleteAdjustmentFeeDialog on Fee {
  id
}
    `;
export const FeeForInvoiceDetailsTableBodyLineFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTableBodyLine on Fee {
  id
  units
  preciseUnitAmount
  amountCents
  eventsCount
  adjustedFee
  adjustedFeeType
  succeededAt
  charge {
    id
    chargeModel
    minAmountCents
    payInAdvance
    prorated
    billableMetric {
      id
      recurring
    }
  }
  appliedTaxes {
    id
    taxRate
  }
  amountDetails {
    freeUnits
    fixedFeeUnitAmount
    flatUnitAmount
    graduatedRanges {
      toValue
    }
    graduatedPercentageRanges {
      toValue
    }
  }
  ...FeeForInvoiceDetailsTableBodyLineGraduated
  ...FeeForInvoiceDetailsTableBodyLineGraduatedPercentage
  ...FeeForInvoiceDetailsTableBodyLineVolume
  ...FeeForInvoiceDetailsTableBodyLinePackage
  ...FeeForInvoiceDetailsTableBodyLinePercentage
  ...FeeForEditfeeDrawer
  ...FeeForDeleteAdjustmentFeeDialog
}
    ${FeeForInvoiceDetailsTableBodyLineGraduatedFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineGraduatedPercentageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLineVolumeFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePackageFragmentDoc}
${FeeForInvoiceDetailsTableBodyLinePercentageFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}`;
export const FeeForInvoiceFeeArrearsDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeArrearsDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceFeeAdvanceDetailsTable on Fee {
  id
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForDeleteAdjustmentFeeDialog
  ...FeeForEditfeeDrawer
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForDeleteAdjustmentFeeDialogFragmentDoc}
${FeeForEditfeeDrawerFragmentDoc}`;
export const FeeForInvoiceDetailsTableFragmentDoc = gql`
    fragment FeeForInvoiceDetailsTable on Fee {
  id
  amountCents
  description
  feeType
  invoiceDisplayName
  invoiceName
  itemName
  units
  preciseUnitAmount
  appliedTaxes {
    id
    taxRate
  }
  trueUpFee {
    id
  }
  trueUpParentFee {
    id
  }
  charge {
    id
    payInAdvance
    invoiceDisplayName
    billableMetric {
      id
      name
      aggregationType
    }
  }
  chargeFilter {
    invoiceDisplayName
    values
  }
  ...FeeForInvoiceDetailsTableBodyLine
  ...FeeForInvoiceFeeArrearsDetailsTable
  ...FeeForInvoiceFeeAdvanceDetailsTable
}
    ${FeeForInvoiceDetailsTableBodyLineFragmentDoc}
${FeeForInvoiceFeeArrearsDetailsTableFragmentDoc}
${FeeForInvoiceFeeAdvanceDetailsTableFragmentDoc}`;
export const InvoiceSubscriptionFormatingFragmentDoc = gql`
    fragment InvoiceSubscriptionFormating on InvoiceSubscription {
  fromDatetime
  toDatetime
  chargesFromDatetime
  chargesToDatetime
  inAdvanceChargesFromDatetime
  inAdvanceChargesToDatetime
  fees {
    id
    amountCents
    invoiceName
    invoiceDisplayName
    units
    groupedBy
    charge {
      id
      payInAdvance
      minAmountCents
      billableMetric {
        id
        name
      }
    }
    chargeFilter {
      invoiceDisplayName
      values
    }
    subscription {
      id
      plan {
        id
        interval
      }
    }
  }
  subscription {
    id
    name
    plan {
      id
      name
      invoiceDisplayName
    }
  }
  invoice {
    id
    status
  }
}
    `;
export const InvoiceForDetailsTableFooterFragmentDoc = gql`
    fragment InvoiceForDetailsTableFooter on Invoice {
  couponsAmountCents
  creditNotesAmountCents
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  currency
  invoiceType
  status
  prepaidCreditAmountCents
  progressiveBillingCreditAmountCents
  versionNumber
  appliedTaxes {
    id
    amountCents
    feesAmountCents
    taxableAmountCents
    taxRate
    taxName
    enumedTaxCode
  }
}
    `;
export const InvoiceForDetailsTableFragmentDoc = gql`
    fragment InvoiceForDetailsTable on Invoice {
  invoiceType
  subTotalExcludingTaxesAmountCents
  subTotalIncludingTaxesAmountCents
  totalAmountCents
  currency
  issuingDate
  versionNumber
  errorDetails {
    errorCode
    errorDetails
  }
  fees {
    id
    ...FeeForInvoiceDetailsTable
  }
  customer {
    id
    currency
    applicableTimezone
  }
  invoiceSubscriptions {
    fromDatetime
    toDatetime
    chargesFromDatetime
    chargesToDatetime
    inAdvanceChargesFromDatetime
    inAdvanceChargesToDatetime
    subscription {
      id
      name
      plan {
        id
        name
        interval
        amountCents
        amountCurrency
        invoiceDisplayName
      }
    }
    fees {
      id
      subscription {
        id
        name
        plan {
          id
          name
          invoiceDisplayName
        }
      }
      ...FeeForInvoiceDetailsTable
    }
    ...InvoiceSubscriptionFormating
  }
  ...InvoiceForDetailsTableFooter
}
    ${FeeForInvoiceDetailsTableFragmentDoc}
${InvoiceSubscriptionFormatingFragmentDoc}
${InvoiceForDetailsTableFooterFragmentDoc}`;
export const InvoiceForInvoiceInfosFragmentDoc = gql`
    fragment InvoiceForInvoiceInfos on Invoice {
  number
  issuingDate
  paymentDueDate
  paymentOverdue
  status
  paymentStatus
  paymentDisputeLostAt
  taxProviderVoidable
  errorDetails {
    errorCode
    errorDetails
  }
  customer {
    id
    name
    displayName
    legalNumber
    legalName
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
    applicableTimezone
    deletedAt
  }
}
    `;
export const InvoiceMetadatasForInvoiceOverviewFragmentDoc = gql`
    fragment InvoiceMetadatasForInvoiceOverview on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const InvoiceMetadatasForMetadataDrawerFragmentDoc = gql`
    fragment InvoiceMetadatasForMetadataDrawer on Invoice {
  id
  metadata {
    id
    key
    value
  }
}
    `;
export const AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc = gql`
    fragment AllInvoiceDetailsForCustomerInvoiceDetails on Invoice {
  id
  invoiceType
  number
  paymentStatus
  status
  totalAmountCents
  currency
  refundableAmountCents
  creditableAmountCents
  voidable
  paymentDisputeLostAt
  integrationSyncable
  externalIntegrationId
  taxProviderVoidable
  integrationCrmSyncable
  associatedActiveWalletPresent
  errorDetails {
    errorCode
    errorDetails
  }
  customer {
    name
    displayName
    ...CustomerMetadatasForInvoiceOverview
    netsuiteCustomer {
      id
      integrationId
      externalCustomerId
    }
    xeroCustomer {
      id
      integrationId
    }
    hubspotCustomer {
      id
      integrationId
    }
  }
  ...InvoiceDetailsForInvoiceOverview
  ...InvoiceForCreditNotesTable
  ...InvoiceForDetailsTable
  ...InvoiceForInvoiceInfos
  ...InvoiceForFinalizeInvoice
  ...InvoiceForUpdateInvoicePaymentStatus
  ...InvoiceMetadatasForInvoiceOverview
  ...InvoiceMetadatasForMetadataDrawer
}
    ${CustomerMetadatasForInvoiceOverviewFragmentDoc}
${InvoiceDetailsForInvoiceOverviewFragmentDoc}
${InvoiceForCreditNotesTableFragmentDoc}
${InvoiceForDetailsTableFragmentDoc}
${InvoiceForInvoiceInfosFragmentDoc}
${InvoiceForFinalizeInvoiceFragmentDoc}
${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}
${InvoiceMetadatasForInvoiceOverviewFragmentDoc}
${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;
export const EditBillableMetricFragmentDoc = gql`
    fragment EditBillableMetric on BillableMetric {
  id
  name
  code
  expression
  description
  aggregationType
  fieldName
  subscriptionsCount
  plansCount
  recurring
  roundingFunction
  roundingPrecision
  filters {
    key
    values
  }
}
    `;
export const TaxInfosForCreateInvoiceFragmentDoc = gql`
    fragment TaxInfosForCreateInvoice on Tax {
  id
  name
  code
  rate
}
    `;
export const TaxForPlanAndChargesInPlanFormFragmentDoc = gql`
    fragment TaxForPlanAndChargesInPlanForm on Tax {
  id
  code
  name
  rate
}
    `;
export const BillableMetricForPlanFragmentDoc = gql`
    fragment BillableMetricForPlan on BillableMetric {
  id
  name
  code
  aggregationType
  recurring
  filters {
    id
    key
    values
  }
}
    `;
export const GraduatedChargeFragmentDoc = gql`
    fragment GraduatedCharge on Properties {
  graduatedRanges {
    flatAmount
    fromValue
    perUnitAmount
    toValue
  }
}
    `;
export const GraduatedPercentageChargeFragmentDoc = gql`
    fragment GraduatedPercentageCharge on Properties {
  graduatedPercentageRanges {
    flatAmount
    fromValue
    rate
    toValue
  }
}
    `;
export const VolumeRangesFragmentDoc = gql`
    fragment VolumeRanges on Properties {
  volumeRanges {
    flatAmount
    fromValue
    perUnitAmount
    toValue
  }
}
    `;
export const PackageChargeFragmentDoc = gql`
    fragment PackageCharge on Properties {
  amount
  packageSize
  freeUnits
}
    `;
export const StandardChargeFragmentDoc = gql`
    fragment StandardCharge on Properties {
  amount
  groupedBy
}
    `;
export const PercentageChargeFragmentDoc = gql`
    fragment PercentageCharge on Properties {
  fixedAmount
  freeUnitsPerEvents
  freeUnitsPerTotalAggregation
  rate
  perTransactionMinAmount
  perTransactionMaxAmount
}
    `;
export const CustomChargeFragmentDoc = gql`
    fragment CustomCharge on Properties {
  customProperties
}
    `;
export const DynamicChargeFragmentDoc = gql`
    fragment DynamicCharge on Properties {
  groupedBy
}
    `;
export const TaxForPlanChargeAccordionFragmentDoc = gql`
    fragment TaxForPlanChargeAccordion on Tax {
  id
  code
  name
  rate
}
    `;
export const ChargeForChargeOptionsAccordionFragmentDoc = gql`
    fragment ChargeForChargeOptionsAccordion on Charge {
  id
  invoiceable
  minAmountCents
  payInAdvance
  regroupPaidFees
}
    `;
export const ChargeAccordionFragmentDoc = gql`
    fragment ChargeAccordion on Charge {
  id
  chargeModel
  invoiceable
  minAmountCents
  payInAdvance
  prorated
  invoiceDisplayName
  regroupPaidFees
  properties {
    ...GraduatedCharge
    ...GraduatedPercentageCharge
    ...VolumeRanges
    ...PackageCharge
    ...StandardCharge
    ...PercentageCharge
    ...CustomCharge
    ...DynamicCharge
  }
  filters {
    invoiceDisplayName
    values
    properties {
      ...GraduatedCharge
      ...GraduatedPercentageCharge
      ...VolumeRanges
      ...PackageCharge
      ...StandardCharge
      ...PercentageCharge
      ...CustomCharge
      ...DynamicCharge
    }
  }
  billableMetric {
    id
    name
    aggregationType
    recurring
    filters {
      key
      values
    }
  }
  taxes {
    ...TaxForPlanChargeAccordion
  }
  ...ChargeForChargeOptionsAccordion
}
    ${GraduatedChargeFragmentDoc}
${GraduatedPercentageChargeFragmentDoc}
${VolumeRangesFragmentDoc}
${PackageChargeFragmentDoc}
${StandardChargeFragmentDoc}
${PercentageChargeFragmentDoc}
${CustomChargeFragmentDoc}
${DynamicChargeFragmentDoc}
${TaxForPlanChargeAccordionFragmentDoc}
${ChargeForChargeOptionsAccordionFragmentDoc}`;
export const PlanForChargeAccordionFragmentDoc = gql`
    fragment PlanForChargeAccordion on Plan {
  billChargesMonthly
}
    `;
export const TaxForPlanSettingsSectionFragmentDoc = gql`
    fragment TaxForPlanSettingsSection on Tax {
  id
  code
  name
  rate
}
    `;
export const PlanForSettingsSectionFragmentDoc = gql`
    fragment PlanForSettingsSection on Plan {
  id
  amountCurrency
  code
  description
  interval
  name
  taxes {
    ...TaxForPlanSettingsSection
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;
export const PlanForFixedFeeSectionFragmentDoc = gql`
    fragment PlanForFixedFeeSection on Plan {
  id
  amountCents
  payInAdvance
  trialPeriod
  invoiceDisplayName
}
    `;
export const EditPlanFragmentDoc = gql`
    fragment EditPlan on Plan {
  id
  name
  code
  description
  interval
  payInAdvance
  invoiceDisplayName
  amountCents
  amountCurrency
  trialPeriod
  subscriptionsCount
  billChargesMonthly
  minimumCommitment {
    amountCents
    commitmentType
    invoiceDisplayName
    taxes {
      id
      ...TaxForPlanAndChargesInPlanForm
    }
  }
  taxes {
    ...TaxForPlanAndChargesInPlanForm
  }
  charges {
    id
    minAmountCents
    payInAdvance
    taxes {
      ...TaxForPlanAndChargesInPlanForm
    }
    billableMetric {
      id
      code
      ...BillableMetricForPlan
    }
    ...ChargeAccordion
    chargeModel
  }
  usageThresholds {
    id
    amountCents
    recurring
    thresholdDisplayName
  }
  ...PlanForChargeAccordion
  ...PlanForSettingsSection
  ...PlanForFixedFeeSection
}
    ${TaxForPlanAndChargesInPlanFormFragmentDoc}
${BillableMetricForPlanFragmentDoc}
${ChargeAccordionFragmentDoc}
${PlanForChargeAccordionFragmentDoc}
${PlanForSettingsSectionFragmentDoc}
${PlanForFixedFeeSectionFragmentDoc}`;
export const AddSubscriptionPlanFragmentDoc = gql`
    fragment AddSubscriptionPlan on Plan {
  id
  name
  code
  interval
}
    `;
export const CustomerMainInfosFragmentDoc = gql`
    fragment CustomerMainInfos on Customer {
  id
  customerType
  name
  firstname
  lastname
  externalId
  externalSalesforceId
  legalName
  legalNumber
  taxIdentificationNumber
  phone
  email
  currency
  addressLine1
  addressLine2
  state
  country
  city
  url
  zipcode
  shippingAddress {
    addressLine1
    addressLine2
    city
    country
    state
    zipcode
  }
  paymentProvider
  timezone
  anrokCustomer {
    id
    integrationId
    externalCustomerId
  }
  netsuiteCustomer {
    id
    integrationId
    externalCustomerId
  }
  paymentProviderCode
  providerCustomer {
    id
    providerCustomerId
    providerPaymentMethods
  }
  xeroCustomer {
    id
    integrationId
    externalCustomerId
  }
  hubspotCustomer {
    id
    integrationId
    externalCustomerId
    targetedObject
  }
  metadata {
    id
    key
    value
  }
}
    `;
export const CustomerDetailsFragmentDoc = gql`
    fragment CustomerDetails on Customer {
  id
  customerType
  name
  displayName
  firstname
  lastname
  externalId
  hasActiveWallet
  currency
  hasCreditNotes
  creditNotesCreditsAvailableCount
  creditNotesBalanceAmountCents
  applicableTimezone
  hasOverdueInvoices
  ...AddCustomerDrawer
  ...CustomerMainInfos
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerMainInfosFragmentDoc}`;
export const CustomerForRequestOverduePaymentFormFragmentDoc = gql`
    fragment CustomerForRequestOverduePaymentForm on Customer {
  email
}
    `;
export const InvoicesForRequestOverduePaymentFormFragmentDoc = gql`
    fragment InvoicesForRequestOverduePaymentForm on Invoice {
  id
  number
  totalAmountCents
  currency
  issuingDate
}
    `;
export const LastPaymentRequestFragmentDoc = gql`
    fragment LastPaymentRequest on PaymentRequest {
  createdAt
}
    `;
export const NetsuiteIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment NetsuiteIntegrationInfosForInvoiceOverview on NetsuiteIntegration {
  id
  accountId
  name
}
    `;
export const HubspotIntegrationInfosForInvoiceOverviewFragmentDoc = gql`
    fragment HubspotIntegrationInfosForInvoiceOverview on HubspotIntegration {
  id
  portalId
  invoicesObjectTypeId
}
    `;
export const EventItemFragmentDoc = gql`
    fragment EventItem on Event {
  id
  code
  receivedAt
  matchBillableMetric
  matchCustomField
}
    `;
export const DebuggerEventDetailsFragmentDoc = gql`
    fragment DebuggerEventDetails on Event {
  id
  code
  transactionId
  timestamp
  receivedAt
  payload
  billableMetricName
  matchBillableMetric
  matchCustomField
  apiClient
  ipAddress
  externalSubscriptionId
  customerTimezone
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on Event {
  id
  code
  transactionId
  timestamp
  receivedAt
  payload
  billableMetricName
  matchBillableMetric
  matchCustomField
  apiClient
  ipAddress
  externalSubscriptionId
  customerTimezone
  ...EventItem
  ...DebuggerEventDetails
}
    ${EventItemFragmentDoc}
${DebuggerEventDetailsFragmentDoc}`;
export const WebhookLogItemFragmentDoc = gql`
    fragment WebhookLogItem on Webhook {
  id
  status
  updatedAt
  webhookType
}
    `;
export const WebhookLogDetailsFragmentDoc = gql`
    fragment WebhookLogDetails on Webhook {
  id
  webhookType
  status
  payload
  response
  httpStatus
  endpoint
  retries
  updatedAt
}
    `;
export const WebhookLogFragmentDoc = gql`
    fragment WebhookLog on Webhook {
  id
  createdAt
  endpoint
  ...WebhookLogItem
  ...WebhookLogDetails
}
    ${WebhookLogItemFragmentDoc}
${WebhookLogDetailsFragmentDoc}`;
export const AdyenIntegrationDetailsFragmentDoc = gql`
    fragment AdyenIntegrationDetails on AdyenProvider {
  id
  apiKey
  code
  hmacKey
  livePrefix
  merchantAccount
  successRedirectUrl
  name
}
    `;
export const AdyenIntegrationsFragmentDoc = gql`
    fragment AdyenIntegrations on AdyenProvider {
  id
  name
  code
}
    `;
export const DeleteAnrokIntegrationDialogFragmentDoc = gql`
    fragment DeleteAnrokIntegrationDialog on AnrokIntegration {
  id
  name
}
    `;
export const AddAnrokIntegrationDialogFragmentDoc = gql`
    fragment AddAnrokIntegrationDialog on AnrokIntegration {
  id
  name
  code
  apiKey
}
    `;
export const AnrokIntegrationItemsFragmentDoc = gql`
    fragment AnrokIntegrationItems on AnrokIntegration {
  id
}
    `;
export const AnrokIntegrationDetailsFragmentDoc = gql`
    fragment AnrokIntegrationDetails on AnrokIntegration {
  id
  name
  ...DeleteAnrokIntegrationDialog
  ...AddAnrokIntegrationDialog
  ...AnrokIntegrationItems
}
    ${DeleteAnrokIntegrationDialogFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationItemsFragmentDoc}`;
export const AnrokIntegrationsFragmentDoc = gql`
    fragment AnrokIntegrations on AnrokIntegration {
  id
  name
  code
  ...AddAnrokIntegrationDialog
}
    ${AddAnrokIntegrationDialogFragmentDoc}`;
export const OktaIntegrationDetailsFragmentDoc = gql`
    fragment OktaIntegrationDetails on OktaIntegration {
  id
  clientId
  clientSecret
  code
  organizationName
  domain
  name
}
    `;
export const DunningCampaignItemFragmentDoc = gql`
    fragment DunningCampaignItem on DunningCampaign {
  id
  name
  code
  appliedToOrganization
}
    `;
export const GocardlessIntegrationDetailsFragmentDoc = gql`
    fragment GocardlessIntegrationDetails on GocardlessProvider {
  id
  code
  name
  successRedirectUrl
  webhookSecret
}
    `;
export const GocardlessIntegrationOauthCallbackFragmentDoc = gql`
    fragment GocardlessIntegrationOauthCallback on GocardlessProvider {
  id
  name
  code
}
    `;
export const GocardlessIntegrationsFragmentDoc = gql`
    fragment GocardlessIntegrations on GocardlessProvider {
  id
  name
  code
}
    `;
export const DeleteHubspotIntegrationDialogFragmentDoc = gql`
    fragment DeleteHubspotIntegrationDialog on HubspotIntegration {
  id
  name
}
    `;
export const HubspotForCreateDialogFragmentDoc = gql`
    fragment HubspotForCreateDialog on HubspotIntegration {
  id
  name
  code
  defaultTargetedObject
  syncInvoices
  syncSubscriptions
  ...DeleteHubspotIntegrationDialog
}
    ${DeleteHubspotIntegrationDialogFragmentDoc}`;
export const HubspotIntegrationDetailsFragmentDoc = gql`
    fragment HubspotIntegrationDetails on HubspotIntegration {
  id
  name
  code
  defaultTargetedObject
  syncInvoices
  syncSubscriptions
  ...HubspotForCreateDialog
  ...DeleteHubspotIntegrationDialog
}
    ${HubspotForCreateDialogFragmentDoc}
${DeleteHubspotIntegrationDialogFragmentDoc}`;
export const HubspotIntegrationsFragmentDoc = gql`
    fragment HubspotIntegrations on HubspotIntegration {
  id
  name
  code
  ...HubspotForCreateDialog
}
    ${HubspotForCreateDialogFragmentDoc}`;
export const InviteForEditRoleForDialogFragmentDoc = gql`
    fragment InviteForEditRoleForDialog on Invite {
  id
  role
  email
}
    `;
export const InviteItemForMembersSettingsFragmentDoc = gql`
    fragment InviteItemForMembersSettings on Invite {
  id
  email
  token
  role
  organization {
    id
    name
  }
  ...InviteForEditRoleForDialog
}
    ${InviteForEditRoleForDialogFragmentDoc}`;
export const MemberForEditRoleForDialogFragmentDoc = gql`
    fragment MemberForEditRoleForDialog on Membership {
  id
  role
  user {
    id
    email
  }
  ...MembershipPermissions
}
    ${MembershipPermissionsFragmentDoc}`;
export const MembershipItemForMembershipSettingsFragmentDoc = gql`
    fragment MembershipItemForMembershipSettings on Membership {
  id
  role
  user {
    id
    email
  }
  organization {
    id
    name
  }
  ...MemberForEditRoleForDialog
}
    ${MemberForEditRoleForDialogFragmentDoc}`;
export const DeleteNetsuiteIntegrationDialogFragmentDoc = gql`
    fragment DeleteNetsuiteIntegrationDialog on NetsuiteIntegration {
  id
  name
}
    `;
export const NetsuiteForCreateDialogDialogFragmentDoc = gql`
    fragment NetsuiteForCreateDialogDialog on NetsuiteIntegration {
  id
  accountId
  clientId
  clientSecret
  code
  name
  scriptEndpointUrl
  syncCreditNotes
  syncInvoices
  syncPayments
  syncSalesOrders
  tokenId
  tokenSecret
}
    `;
export const NetsuiteIntegrationItemsFragmentDoc = gql`
    fragment NetsuiteIntegrationItems on NetsuiteIntegration {
  id
}
    `;
export const NetsuiteIntegrationDetailsFragmentDoc = gql`
    fragment NetsuiteIntegrationDetails on NetsuiteIntegration {
  id
  name
  ...DeleteNetsuiteIntegrationDialog
  ...NetsuiteForCreateDialogDialog
  ...NetsuiteIntegrationItems
}
    ${DeleteNetsuiteIntegrationDialogFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}
${NetsuiteIntegrationItemsFragmentDoc}`;
export const NetsuiteIntegrationsFragmentDoc = gql`
    fragment NetsuiteIntegrations on NetsuiteIntegration {
  id
  name
  code
  ...NetsuiteForCreateDialogDialog
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export const OrganizationInformationsFragmentDoc = gql`
    fragment OrganizationInformations on CurrentOrganization {
  id
  logoUrl
  name
  legalName
  legalNumber
  taxIdentificationNumber
  email
  addressLine1
  addressLine2
  zipcode
  city
  state
  country
  timezone
}
    `;
export const StripeIntegrationDetailsFragmentDoc = gql`
    fragment StripeIntegrationDetails on StripeProvider {
  id
  code
  name
  secretKey
  successRedirectUrl
}
    `;
export const StripeIntegrationsFragmentDoc = gql`
    fragment StripeIntegrations on StripeProvider {
  id
  name
  code
}
    `;
export const DeleteTaxFragmentDoc = gql`
    fragment DeleteTax on Tax {
  id
  name
  customersCount
}
    `;
export const TaxItemForTaxSettingsFragmentDoc = gql`
    fragment TaxItemForTaxSettings on Tax {
  id
  code
  name
  rate
  autoGenerated
  ...DeleteTax
}
    ${DeleteTaxFragmentDoc}`;
export const DeleteXeroIntegrationDialogFragmentDoc = gql`
    fragment DeleteXeroIntegrationDialog on XeroIntegration {
  id
  name
}
    `;
export const XeroForCreateDialogDialogFragmentDoc = gql`
    fragment XeroForCreateDialogDialog on XeroIntegration {
  id
  code
  connectionId
  hasMappingsConfigured
  name
  syncCreditNotes
  syncInvoices
  syncPayments
}
    `;
export const XeroIntegrationItemsFragmentDoc = gql`
    fragment XeroIntegrationItems on XeroIntegration {
  id
}
    `;
export const XeroIntegrationDetailsFragmentDoc = gql`
    fragment XeroIntegrationDetails on XeroIntegration {
  id
  name
  ...DeleteXeroIntegrationDialog
  ...XeroForCreateDialogDialog
  ...XeroIntegrationItems
}
    ${DeleteXeroIntegrationDialogFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}
${XeroIntegrationItemsFragmentDoc}`;
export const XeroIntegrationsFragmentDoc = gql`
    fragment XeroIntegrations on XeroIntegration {
  id
  name
  code
  ...XeroForCreateDialogDialog
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export const UserIdentifierDocument = gql`
    query UserIdentifier {
  me: currentUser {
    id
    email
    ...CurrentUserInfos
  }
  organization {
    ...MainOrganizationInfos
  }
}
    ${CurrentUserInfosFragmentDoc}
${MainOrganizationInfosFragmentDoc}`;

/**
 * __useUserIdentifierQuery__
 *
 * To run a query within a React component, call `useUserIdentifierQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserIdentifierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserIdentifierQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserIdentifierQuery(baseOptions?: Apollo.QueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
      }
export function useUserIdentifierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export function useUserIdentifierSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UserIdentifierQuery, UserIdentifierQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserIdentifierQuery, UserIdentifierQueryVariables>(UserIdentifierDocument, options);
        }
export type UserIdentifierQueryHookResult = ReturnType<typeof useUserIdentifierQuery>;
export type UserIdentifierLazyQueryHookResult = ReturnType<typeof useUserIdentifierLazyQuery>;
export type UserIdentifierSuspenseQueryHookResult = ReturnType<typeof useUserIdentifierSuspenseQuery>;
export type UserIdentifierQueryResult = Apollo.QueryResult<UserIdentifierQuery, UserIdentifierQueryVariables>;
export const DeleteAddOnDocument = gql`
    mutation deleteAddOn($input: DestroyAddOnInput!) {
  destroyAddOn(input: $input) {
    id
  }
}
    `;
export type DeleteAddOnMutationFn = Apollo.MutationFunction<DeleteAddOnMutation, DeleteAddOnMutationVariables>;

/**
 * __useDeleteAddOnMutation__
 *
 * To run a mutation, you first call `useDeleteAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAddOnMutation, { data, loading, error }] = useDeleteAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAddOnMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAddOnMutation, DeleteAddOnMutationVariables>(DeleteAddOnDocument, options);
      }
export type DeleteAddOnMutationHookResult = ReturnType<typeof useDeleteAddOnMutation>;
export type DeleteAddOnMutationResult = Apollo.MutationResult<DeleteAddOnMutation>;
export type DeleteAddOnMutationOptions = Apollo.BaseMutationOptions<DeleteAddOnMutation, DeleteAddOnMutationVariables>;
export const GetGoogleAuthUrlDocument = gql`
    query getGoogleAuthUrl {
  googleAuthUrl {
    url
  }
}
    `;

/**
 * __useGetGoogleAuthUrlQuery__
 *
 * To run a query within a React component, call `useGetGoogleAuthUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGoogleAuthUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGoogleAuthUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetGoogleAuthUrlQuery(baseOptions?: Apollo.QueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
      }
export function useGetGoogleAuthUrlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export function useGetGoogleAuthUrlSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>(GetGoogleAuthUrlDocument, options);
        }
export type GetGoogleAuthUrlQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlQuery>;
export type GetGoogleAuthUrlLazyQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlLazyQuery>;
export type GetGoogleAuthUrlSuspenseQueryHookResult = ReturnType<typeof useGetGoogleAuthUrlSuspenseQuery>;
export type GetGoogleAuthUrlQueryResult = Apollo.QueryResult<GetGoogleAuthUrlQuery, GetGoogleAuthUrlQueryVariables>;
export const GetBillableMetricToDeleteDocument = gql`
    query getBillableMetricToDelete($id: ID!) {
  billableMetric(id: $id) {
    ...DeleteBillableMetricDialog
  }
}
    ${DeleteBillableMetricDialogFragmentDoc}`;

/**
 * __useGetBillableMetricToDeleteQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricToDeleteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricToDeleteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricToDeleteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBillableMetricToDeleteQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables> & ({ variables: GetBillableMetricToDeleteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
      }
export function useGetBillableMetricToDeleteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
        }
export function useGetBillableMetricToDeleteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>(GetBillableMetricToDeleteDocument, options);
        }
export type GetBillableMetricToDeleteQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteQuery>;
export type GetBillableMetricToDeleteLazyQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteLazyQuery>;
export type GetBillableMetricToDeleteSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricToDeleteSuspenseQuery>;
export type GetBillableMetricToDeleteQueryResult = Apollo.QueryResult<GetBillableMetricToDeleteQuery, GetBillableMetricToDeleteQueryVariables>;
export const DeleteBillableMetricDocument = gql`
    mutation deleteBillableMetric($input: DestroyBillableMetricInput!) {
  destroyBillableMetric(input: $input) {
    id
  }
}
    `;
export type DeleteBillableMetricMutationFn = Apollo.MutationFunction<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;

/**
 * __useDeleteBillableMetricMutation__
 *
 * To run a mutation, you first call `useDeleteBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBillableMetricMutation, { data, loading, error }] = useDeleteBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>(DeleteBillableMetricDocument, options);
      }
export type DeleteBillableMetricMutationHookResult = ReturnType<typeof useDeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationResult = Apollo.MutationResult<DeleteBillableMetricMutation>;
export type DeleteBillableMetricMutationOptions = Apollo.BaseMutationOptions<DeleteBillableMetricMutation, DeleteBillableMetricMutationVariables>;
export const GetBillableMetricsForCouponsDocument = gql`
    query getBillableMetricsForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...BillableMetricsForCoupons
    }
  }
}
    ${BillableMetricsForCouponsFragmentDoc}`;

/**
 * __useGetBillableMetricsForCouponsQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetBillableMetricsForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
      }
export function useGetBillableMetricsForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export function useGetBillableMetricsForCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>(GetBillableMetricsForCouponsDocument, options);
        }
export type GetBillableMetricsForCouponsQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsQuery>;
export type GetBillableMetricsForCouponsLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsLazyQuery>;
export type GetBillableMetricsForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForCouponsSuspenseQuery>;
export type GetBillableMetricsForCouponsQueryResult = Apollo.QueryResult<GetBillableMetricsForCouponsQuery, GetBillableMetricsForCouponsQueryVariables>;
export const GetPlansForCouponsDocument = gql`
    query getPlansForCoupons($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...PlansForCoupons
    }
  }
}
    ${PlansForCouponsFragmentDoc}`;

/**
 * __useGetPlansForCouponsQuery__
 *
 * To run a query within a React component, call `useGetPlansForCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansForCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansForCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansForCouponsQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
      }
export function useGetPlansForCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export function useGetPlansForCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>(GetPlansForCouponsDocument, options);
        }
export type GetPlansForCouponsQueryHookResult = ReturnType<typeof useGetPlansForCouponsQuery>;
export type GetPlansForCouponsLazyQueryHookResult = ReturnType<typeof useGetPlansForCouponsLazyQuery>;
export type GetPlansForCouponsSuspenseQueryHookResult = ReturnType<typeof useGetPlansForCouponsSuspenseQuery>;
export type GetPlansForCouponsQueryResult = Apollo.QueryResult<GetPlansForCouponsQuery, GetPlansForCouponsQueryVariables>;
export const DeleteCouponDocument = gql`
    mutation deleteCoupon($input: DestroyCouponInput!) {
  destroyCoupon(input: $input) {
    id
  }
}
    `;
export type DeleteCouponMutationFn = Apollo.MutationFunction<DeleteCouponMutation, DeleteCouponMutationVariables>;

/**
 * __useDeleteCouponMutation__
 *
 * To run a mutation, you first call `useDeleteCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCouponMutation, { data, loading, error }] = useDeleteCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCouponMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCouponMutation, DeleteCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCouponMutation, DeleteCouponMutationVariables>(DeleteCouponDocument, options);
      }
export type DeleteCouponMutationHookResult = ReturnType<typeof useDeleteCouponMutation>;
export type DeleteCouponMutationResult = Apollo.MutationResult<DeleteCouponMutation>;
export type DeleteCouponMutationOptions = Apollo.BaseMutationOptions<DeleteCouponMutation, DeleteCouponMutationVariables>;
export const TerminateCouponDocument = gql`
    mutation terminateCoupon($input: TerminateCouponInput!) {
  terminateCoupon(input: $input) {
    id
  }
}
    `;
export type TerminateCouponMutationFn = Apollo.MutationFunction<TerminateCouponMutation, TerminateCouponMutationVariables>;

/**
 * __useTerminateCouponMutation__
 *
 * To run a mutation, you first call `useTerminateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCouponMutation, { data, loading, error }] = useTerminateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCouponMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCouponMutation, TerminateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCouponMutation, TerminateCouponMutationVariables>(TerminateCouponDocument, options);
      }
export type TerminateCouponMutationHookResult = ReturnType<typeof useTerminateCouponMutation>;
export type TerminateCouponMutationResult = Apollo.MutationResult<TerminateCouponMutation>;
export type TerminateCouponMutationOptions = Apollo.BaseMutationOptions<TerminateCouponMutation, TerminateCouponMutationVariables>;
export const CreditNoteEstimateDocument = gql`
    query creditNoteEstimate($invoiceId: ID!, $items: [CreditNoteItemInput!]!) {
  creditNoteEstimate(invoiceId: $invoiceId, items: $items) {
    appliedTaxes {
      taxCode
      taxName
      taxRate
      amountCents
    }
    couponsAdjustmentAmountCents
    currency
    items {
      amountCents
      fee {
        id
      }
    }
    maxCreditableAmountCents
    maxRefundableAmountCents
    subTotalExcludingTaxesAmountCents
    taxesAmountCents
    taxesRate
  }
}
    `;

/**
 * __useCreditNoteEstimateQuery__
 *
 * To run a query within a React component, call `useCreditNoteEstimateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreditNoteEstimateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreditNoteEstimateQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      items: // value for 'items'
 *   },
 * });
 */
export function useCreditNoteEstimateQuery(baseOptions: Apollo.QueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables> & ({ variables: CreditNoteEstimateQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
      }
export function useCreditNoteEstimateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export function useCreditNoteEstimateSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>(CreditNoteEstimateDocument, options);
        }
export type CreditNoteEstimateQueryHookResult = ReturnType<typeof useCreditNoteEstimateQuery>;
export type CreditNoteEstimateLazyQueryHookResult = ReturnType<typeof useCreditNoteEstimateLazyQuery>;
export type CreditNoteEstimateSuspenseQueryHookResult = ReturnType<typeof useCreditNoteEstimateSuspenseQuery>;
export type CreditNoteEstimateQueryResult = Apollo.QueryResult<CreditNoteEstimateQuery, CreditNoteEstimateQueryVariables>;
export const DownloadCreditNoteDocument = gql`
    mutation downloadCreditNote($input: DownloadCreditNoteInput!) {
  downloadCreditNote(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCreditNoteMutationFn = Apollo.MutationFunction<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;

/**
 * __useDownloadCreditNoteMutation__
 *
 * To run a mutation, you first call `useDownloadCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCreditNoteMutation, { data, loading, error }] = useDownloadCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>(DownloadCreditNoteDocument, options);
      }
export type DownloadCreditNoteMutationHookResult = ReturnType<typeof useDownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationResult = Apollo.MutationResult<DownloadCreditNoteMutation>;
export type DownloadCreditNoteMutationOptions = Apollo.BaseMutationOptions<DownloadCreditNoteMutation, DownloadCreditNoteMutationVariables>;
export const GetPortalCustomerInfosDocument = gql`
    query getPortalCustomerInfos {
  customerPortalUser {
    id
    customerType
    name
    firstname
    lastname
    legalName
    legalNumber
    taxIdentificationNumber
    email
    addressLine1
    addressLine2
    state
    country
    city
    zipcode
    shippingAddress {
      addressLine1
      addressLine2
      city
      country
      state
      zipcode
    }
  }
}
    `;

/**
 * __useGetPortalCustomerInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalCustomerInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalCustomerInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalCustomerInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalCustomerInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
      }
export function useGetPortalCustomerInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export function useGetPortalCustomerInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>(GetPortalCustomerInfosDocument, options);
        }
export type GetPortalCustomerInfosQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosQuery>;
export type GetPortalCustomerInfosLazyQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosLazyQuery>;
export type GetPortalCustomerInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalCustomerInfosSuspenseQuery>;
export type GetPortalCustomerInfosQueryResult = Apollo.QueryResult<GetPortalCustomerInfosQuery, GetPortalCustomerInfosQueryVariables>;
export const CustomerPortalInvoicesDocument = gql`
    query customerPortalInvoices($limit: Int, $page: Int, $searchTerm: String, $status: [InvoiceStatusTypeEnum!]) {
  customerPortalInvoices(
    limit: $limit
    page: $page
    searchTerm: $searchTerm
    status: $status
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...PortalInvoiceListItem
    }
  }
}
    ${PortalInvoiceListItemFragmentDoc}`;

/**
 * __useCustomerPortalInvoicesQuery__
 *
 * To run a query within a React component, call `useCustomerPortalInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerPortalInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerPortalInvoicesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useCustomerPortalInvoicesQuery(baseOptions?: Apollo.QueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
      }
export function useCustomerPortalInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export function useCustomerPortalInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>(CustomerPortalInvoicesDocument, options);
        }
export type CustomerPortalInvoicesQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesQuery>;
export type CustomerPortalInvoicesLazyQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesLazyQuery>;
export type CustomerPortalInvoicesSuspenseQueryHookResult = ReturnType<typeof useCustomerPortalInvoicesSuspenseQuery>;
export type CustomerPortalInvoicesQueryResult = Apollo.QueryResult<CustomerPortalInvoicesQuery, CustomerPortalInvoicesQueryVariables>;
export const DownloadCustomerPortalInvoiceDocument = gql`
    mutation downloadCustomerPortalInvoice($input: DownloadCustomerPortalInvoiceInput!) {
  downloadCustomerPortalInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadCustomerPortalInvoiceMutationFn = Apollo.MutationFunction<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;

/**
 * __useDownloadCustomerPortalInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadCustomerPortalInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadCustomerPortalInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadCustomerPortalInvoiceMutation, { data, loading, error }] = useDownloadCustomerPortalInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadCustomerPortalInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>(DownloadCustomerPortalInvoiceDocument, options);
      }
export type DownloadCustomerPortalInvoiceMutationHookResult = ReturnType<typeof useDownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationResult = Apollo.MutationResult<DownloadCustomerPortalInvoiceMutation>;
export type DownloadCustomerPortalInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadCustomerPortalInvoiceMutation, DownloadCustomerPortalInvoiceMutationVariables>;
export const GetCustomerPortalInvoicesCollectionDocument = gql`
    query getCustomerPortalInvoicesCollection($expireCache: Boolean) {
  customerPortalInvoiceCollections(expireCache: $expireCache) {
    collection {
      amountCents
      invoicesCount
      currency
    }
  }
}
    `;

/**
 * __useGetCustomerPortalInvoicesCollectionQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalInvoicesCollectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalInvoicesCollectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalInvoicesCollectionQuery({
 *   variables: {
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerPortalInvoicesCollectionQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
      }
export function useGetCustomerPortalInvoicesCollectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
        }
export function useGetCustomerPortalInvoicesCollectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>(GetCustomerPortalInvoicesCollectionDocument, options);
        }
export type GetCustomerPortalInvoicesCollectionQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionQuery>;
export type GetCustomerPortalInvoicesCollectionLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionLazyQuery>;
export type GetCustomerPortalInvoicesCollectionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalInvoicesCollectionSuspenseQuery>;
export type GetCustomerPortalInvoicesCollectionQueryResult = Apollo.QueryResult<GetCustomerPortalInvoicesCollectionQuery, GetCustomerPortalInvoicesCollectionQueryVariables>;
export const GetCustomerPortalOverdueBalancesDocument = gql`
    query getCustomerPortalOverdueBalances($expireCache: Boolean) {
  customerPortalOverdueBalances(expireCache: $expireCache) {
    collection {
      amountCents
      currency
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetCustomerPortalOverdueBalancesQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalOverdueBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalOverdueBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalOverdueBalancesQuery({
 *   variables: {
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerPortalOverdueBalancesQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
      }
export function useGetCustomerPortalOverdueBalancesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
        }
export function useGetCustomerPortalOverdueBalancesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>(GetCustomerPortalOverdueBalancesDocument, options);
        }
export type GetCustomerPortalOverdueBalancesQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesQuery>;
export type GetCustomerPortalOverdueBalancesLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesLazyQuery>;
export type GetCustomerPortalOverdueBalancesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalOverdueBalancesSuspenseQuery>;
export type GetCustomerPortalOverdueBalancesQueryResult = Apollo.QueryResult<GetCustomerPortalOverdueBalancesQuery, GetCustomerPortalOverdueBalancesQueryVariables>;
export const GetCustomerPortalUserCurrencyDocument = gql`
    query getCustomerPortalUserCurrency {
  customerPortalUser {
    currency
  }
}
    `;

/**
 * __useGetCustomerPortalUserCurrencyQuery__
 *
 * To run a query within a React component, call `useGetCustomerPortalUserCurrencyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerPortalUserCurrencyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerPortalUserCurrencyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCustomerPortalUserCurrencyQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
      }
export function useGetCustomerPortalUserCurrencyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
        }
export function useGetCustomerPortalUserCurrencySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>(GetCustomerPortalUserCurrencyDocument, options);
        }
export type GetCustomerPortalUserCurrencyQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencyQuery>;
export type GetCustomerPortalUserCurrencyLazyQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencyLazyQuery>;
export type GetCustomerPortalUserCurrencySuspenseQueryHookResult = ReturnType<typeof useGetCustomerPortalUserCurrencySuspenseQuery>;
export type GetCustomerPortalUserCurrencyQueryResult = Apollo.QueryResult<GetCustomerPortalUserCurrencyQuery, GetCustomerPortalUserCurrencyQueryVariables>;
export const GetPortalLocaleDocument = gql`
    query getPortalLocale {
  customerPortalOrganization {
    id
    premiumIntegrations
    billingConfiguration {
      id
      documentLocale
    }
  }
  customerPortalUser {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;

/**
 * __useGetPortalLocaleQuery__
 *
 * To run a query within a React component, call `useGetPortalLocaleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalLocaleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalLocaleQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalLocaleQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
      }
export function useGetPortalLocaleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export function useGetPortalLocaleSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>(GetPortalLocaleDocument, options);
        }
export type GetPortalLocaleQueryHookResult = ReturnType<typeof useGetPortalLocaleQuery>;
export type GetPortalLocaleLazyQueryHookResult = ReturnType<typeof useGetPortalLocaleLazyQuery>;
export type GetPortalLocaleSuspenseQueryHookResult = ReturnType<typeof useGetPortalLocaleSuspenseQuery>;
export type GetPortalLocaleQueryResult = Apollo.QueryResult<GetPortalLocaleQuery, GetPortalLocaleQueryVariables>;
export const UpdatePortalCustomerDocument = gql`
    mutation updatePortalCustomer($input: UpdateCustomerPortalCustomerInput!) {
  updateCustomerPortalCustomer(input: $input) {
    id
  }
}
    `;
export type UpdatePortalCustomerMutationFn = Apollo.MutationFunction<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>;

/**
 * __useUpdatePortalCustomerMutation__
 *
 * To run a mutation, you first call `useUpdatePortalCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePortalCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePortalCustomerMutation, { data, loading, error }] = useUpdatePortalCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePortalCustomerMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>(UpdatePortalCustomerDocument, options);
      }
export type UpdatePortalCustomerMutationHookResult = ReturnType<typeof useUpdatePortalCustomerMutation>;
export type UpdatePortalCustomerMutationResult = Apollo.MutationResult<UpdatePortalCustomerMutation>;
export type UpdatePortalCustomerMutationOptions = Apollo.BaseMutationOptions<UpdatePortalCustomerMutation, UpdatePortalCustomerMutationVariables>;
export const GetSubscriptionForPortalDocument = gql`
    query getSubscriptionForPortal($subscriptionId: ID!) {
  customerPortalSubscription(id: $subscriptionId) {
    id
    ...SubscriptionForPortalUsage
  }
}
    ${SubscriptionForPortalUsageFragmentDoc}`;

/**
 * __useGetSubscriptionForPortalQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForPortalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForPortalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForPortalQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForPortalQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables> & ({ variables: GetSubscriptionForPortalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
      }
export function useGetSubscriptionForPortalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
        }
export function useGetSubscriptionForPortalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>(GetSubscriptionForPortalDocument, options);
        }
export type GetSubscriptionForPortalQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalQuery>;
export type GetSubscriptionForPortalLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalLazyQuery>;
export type GetSubscriptionForPortalSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForPortalSuspenseQuery>;
export type GetSubscriptionForPortalQueryResult = Apollo.QueryResult<GetSubscriptionForPortalQuery, GetSubscriptionForPortalQueryVariables>;
export const GetCustomerUsageForPortalDocument = gql`
    query getCustomerUsageForPortal($subscriptionId: ID!) {
  customerPortalCustomerUsage(subscriptionId: $subscriptionId) {
    amountCents
    ...SubscriptionCurrentUsageTableComponentCustomerUsage
    ...CustomerUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc}
${CustomerUsageForUsageDetailsFragmentDoc}`;

/**
 * __useGetCustomerUsageForPortalQuery__
 *
 * To run a query within a React component, call `useGetCustomerUsageForPortalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerUsageForPortalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerUsageForPortalQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetCustomerUsageForPortalQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables> & ({ variables: GetCustomerUsageForPortalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
      }
export function useGetCustomerUsageForPortalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
        }
export function useGetCustomerUsageForPortalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>(GetCustomerUsageForPortalDocument, options);
        }
export type GetCustomerUsageForPortalQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalQuery>;
export type GetCustomerUsageForPortalLazyQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalLazyQuery>;
export type GetCustomerUsageForPortalSuspenseQueryHookResult = ReturnType<typeof useGetCustomerUsageForPortalSuspenseQuery>;
export type GetCustomerUsageForPortalQueryResult = Apollo.QueryResult<GetCustomerUsageForPortalQuery, GetCustomerUsageForPortalQueryVariables>;
export const GetPortalUsageDocument = gql`
    query getPortalUsage {
  customerPortalSubscriptions {
    collection {
      id
      ...SubscriptionForPortalUsage
    }
  }
}
    ${SubscriptionForPortalUsageFragmentDoc}`;

/**
 * __useGetPortalUsageQuery__
 *
 * To run a query within a React component, call `useGetPortalUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalUsageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalUsageQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
      }
export function useGetPortalUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
        }
export function useGetPortalUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalUsageQuery, GetPortalUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalUsageQuery, GetPortalUsageQueryVariables>(GetPortalUsageDocument, options);
        }
export type GetPortalUsageQueryHookResult = ReturnType<typeof useGetPortalUsageQuery>;
export type GetPortalUsageLazyQueryHookResult = ReturnType<typeof useGetPortalUsageLazyQuery>;
export type GetPortalUsageSuspenseQueryHookResult = ReturnType<typeof useGetPortalUsageSuspenseQuery>;
export type GetPortalUsageQueryResult = Apollo.QueryResult<GetPortalUsageQuery, GetPortalUsageQueryVariables>;
export const TopUpPortalWalletDocument = gql`
    mutation TopUpPortalWallet($input: CreateCustomerPortalWalletTransactionInput!) {
  createCustomerPortalWalletTransaction(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type TopUpPortalWalletMutationFn = Apollo.MutationFunction<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>;

/**
 * __useTopUpPortalWalletMutation__
 *
 * To run a mutation, you first call `useTopUpPortalWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTopUpPortalWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [topUpPortalWalletMutation, { data, loading, error }] = useTopUpPortalWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTopUpPortalWalletMutation(baseOptions?: Apollo.MutationHookOptions<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>(TopUpPortalWalletDocument, options);
      }
export type TopUpPortalWalletMutationHookResult = ReturnType<typeof useTopUpPortalWalletMutation>;
export type TopUpPortalWalletMutationResult = Apollo.MutationResult<TopUpPortalWalletMutation>;
export type TopUpPortalWalletMutationOptions = Apollo.BaseMutationOptions<TopUpPortalWalletMutation, TopUpPortalWalletMutationVariables>;
export const GetPortalCustomerDataDocument = gql`
    query getPortalCustomerData {
  customerPortalUser {
    applicableTimezone
    premium
  }
}
    `;

/**
 * __useGetPortalCustomerDataQuery__
 *
 * To run a query within a React component, call `useGetPortalCustomerDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalCustomerDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalCustomerDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalCustomerDataQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
      }
export function useGetPortalCustomerDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
        }
export function useGetPortalCustomerDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>(GetPortalCustomerDataDocument, options);
        }
export type GetPortalCustomerDataQueryHookResult = ReturnType<typeof useGetPortalCustomerDataQuery>;
export type GetPortalCustomerDataLazyQueryHookResult = ReturnType<typeof useGetPortalCustomerDataLazyQuery>;
export type GetPortalCustomerDataSuspenseQueryHookResult = ReturnType<typeof useGetPortalCustomerDataSuspenseQuery>;
export type GetPortalCustomerDataQueryResult = Apollo.QueryResult<GetPortalCustomerDataQuery, GetPortalCustomerDataQueryVariables>;
export const GetPortalWalletsDocument = gql`
    query getPortalWallets {
  customerPortalWallets {
    collection {
      ...CustomerPortalWalletInfo
    }
  }
}
    ${CustomerPortalWalletInfoFragmentDoc}`;

/**
 * __useGetPortalWalletsQuery__
 *
 * To run a query within a React component, call `useGetPortalWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalWalletsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalWalletsQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
      }
export function useGetPortalWalletsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
        }
export function useGetPortalWalletsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>(GetPortalWalletsDocument, options);
        }
export type GetPortalWalletsQueryHookResult = ReturnType<typeof useGetPortalWalletsQuery>;
export type GetPortalWalletsLazyQueryHookResult = ReturnType<typeof useGetPortalWalletsLazyQuery>;
export type GetPortalWalletsSuspenseQueryHookResult = ReturnType<typeof useGetPortalWalletsSuspenseQuery>;
export type GetPortalWalletsQueryResult = Apollo.QueryResult<GetPortalWalletsQuery, GetPortalWalletsQueryVariables>;
export const GetCouponForCustomerDocument = gql`
    query getCouponForCustomer($page: Int, $limit: Int, $status: CouponStatusEnum, $searchTerm: String) {
  coupons(page: $page, limit: $limit, status: $status, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      amountCurrency
      amountCents
      couponType
      percentageRate
      frequency
      frequencyDuration
      plans {
        ...CouponPlansForCustomer
      }
      billableMetrics {
        ...CouponBillableMetricsForCustomer
      }
      ...CouponCaption
    }
  }
}
    ${CouponPlansForCustomerFragmentDoc}
${CouponBillableMetricsForCustomerFragmentDoc}
${CouponCaptionFragmentDoc}`;

/**
 * __useGetCouponForCustomerQuery__
 *
 * To run a query within a React component, call `useGetCouponForCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForCustomerQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCouponForCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
      }
export function useGetCouponForCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export function useGetCouponForCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>(GetCouponForCustomerDocument, options);
        }
export type GetCouponForCustomerQueryHookResult = ReturnType<typeof useGetCouponForCustomerQuery>;
export type GetCouponForCustomerLazyQueryHookResult = ReturnType<typeof useGetCouponForCustomerLazyQuery>;
export type GetCouponForCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCouponForCustomerSuspenseQuery>;
export type GetCouponForCustomerQueryResult = Apollo.QueryResult<GetCouponForCustomerQuery, GetCouponForCustomerQueryVariables>;
export const AddCouponDocument = gql`
    mutation addCoupon($input: CreateAppliedCouponInput!) {
  createAppliedCoupon(input: $input) {
    id
    ...CustomerCoupon
  }
}
    ${CustomerCouponFragmentDoc}`;
export type AddCouponMutationFn = Apollo.MutationFunction<AddCouponMutation, AddCouponMutationVariables>;

/**
 * __useAddCouponMutation__
 *
 * To run a mutation, you first call `useAddCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCouponMutation, { data, loading, error }] = useAddCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddCouponMutation(baseOptions?: Apollo.MutationHookOptions<AddCouponMutation, AddCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCouponMutation, AddCouponMutationVariables>(AddCouponDocument, options);
      }
export type AddCouponMutationHookResult = ReturnType<typeof useAddCouponMutation>;
export type AddCouponMutationResult = Apollo.MutationResult<AddCouponMutation>;
export type AddCouponMutationOptions = Apollo.BaseMutationOptions<AddCouponMutation, AddCouponMutationVariables>;
export const GetCustomerCreditNotesDocument = gql`
    query getCustomerCreditNotes($customerId: ID!, $page: Int, $limit: Int, $searchTerm: String) {
  creditNotes(
    customerId: $customerId
    page: $page
    limit: $limit
    searchTerm: $searchTerm
  ) {
    ...CreditNotesForTable
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetCustomerCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetCustomerCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCreditNotesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables> & ({ variables: GetCustomerCreditNotesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
      }
export function useGetCustomerCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export function useGetCustomerCreditNotesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>(GetCustomerCreditNotesDocument, options);
        }
export type GetCustomerCreditNotesQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesQuery>;
export type GetCustomerCreditNotesLazyQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesLazyQuery>;
export type GetCustomerCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCreditNotesSuspenseQuery>;
export type GetCustomerCreditNotesQueryResult = Apollo.QueryResult<GetCustomerCreditNotesQuery, GetCustomerCreditNotesQueryVariables>;
export const DownloadInvoiceItemDocument = gql`
    mutation downloadInvoiceItem($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceItemMutationFn = Apollo.MutationFunction<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;

/**
 * __useDownloadInvoiceItemMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceItemMutation, { data, loading, error }] = useDownloadInvoiceItemMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceItemMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>(DownloadInvoiceItemDocument, options);
      }
export type DownloadInvoiceItemMutationHookResult = ReturnType<typeof useDownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationResult = Apollo.MutationResult<DownloadInvoiceItemMutation>;
export type DownloadInvoiceItemMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceItemMutation, DownloadInvoiceItemMutationVariables>;
export const RetryInvoicePaymentDocument = gql`
    mutation retryInvoicePayment($input: RetryInvoicePaymentInput!) {
  retryInvoicePayment(input: $input) {
    id
    ...InvoiceListItem
  }
}
    ${InvoiceListItemFragmentDoc}`;
export type RetryInvoicePaymentMutationFn = Apollo.MutationFunction<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;

/**
 * __useRetryInvoicePaymentMutation__
 *
 * To run a mutation, you first call `useRetryInvoicePaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryInvoicePaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryInvoicePaymentMutation, { data, loading, error }] = useRetryInvoicePaymentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryInvoicePaymentMutation(baseOptions?: Apollo.MutationHookOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>(RetryInvoicePaymentDocument, options);
      }
export type RetryInvoicePaymentMutationHookResult = ReturnType<typeof useRetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationResult = Apollo.MutationResult<RetryInvoicePaymentMutation>;
export type RetryInvoicePaymentMutationOptions = Apollo.BaseMutationOptions<RetryInvoicePaymentMutation, RetryInvoicePaymentMutationVariables>;
export const GetCustomerInvoicesDocument = gql`
    query getCustomerInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables> & ({ variables: GetCustomerInvoicesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
      }
export function useGetCustomerInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export function useGetCustomerInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>(GetCustomerInvoicesDocument, options);
        }
export type GetCustomerInvoicesQueryHookResult = ReturnType<typeof useGetCustomerInvoicesQuery>;
export type GetCustomerInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerInvoicesLazyQuery>;
export type GetCustomerInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInvoicesSuspenseQuery>;
export type GetCustomerInvoicesQueryResult = Apollo.QueryResult<GetCustomerInvoicesQuery, GetCustomerInvoicesQueryVariables>;
export const PaymentProvidersListForCustomerMainInfosDocument = gql`
    query paymentProvidersListForCustomerMainInfos($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        id
        name
        code
      }
      ... on GocardlessProvider {
        id
        name
        code
      }
      ... on AdyenProvider {
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __usePaymentProvidersListForCustomerMainInfosQuery__
 *
 * To run a query within a React component, call `usePaymentProvidersListForCustomerMainInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentProvidersListForCustomerMainInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentProvidersListForCustomerMainInfosQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function usePaymentProvidersListForCustomerMainInfosQuery(baseOptions?: Apollo.QueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
      }
export function usePaymentProvidersListForCustomerMainInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
        }
export function usePaymentProvidersListForCustomerMainInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>(PaymentProvidersListForCustomerMainInfosDocument, options);
        }
export type PaymentProvidersListForCustomerMainInfosQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosQuery>;
export type PaymentProvidersListForCustomerMainInfosLazyQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosLazyQuery>;
export type PaymentProvidersListForCustomerMainInfosSuspenseQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerMainInfosSuspenseQuery>;
export type PaymentProvidersListForCustomerMainInfosQueryResult = Apollo.QueryResult<PaymentProvidersListForCustomerMainInfosQuery, PaymentProvidersListForCustomerMainInfosQueryVariables>;
export const IntegrationsListForCustomerMainInfosDocument = gql`
    query integrationsListForCustomerMainInfos($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        name
        accountId
      }
      ... on AnrokIntegration {
        __typename
        id
        name
        apiKey
        externalAccountId
      }
      ... on XeroIntegration {
        __typename
        id
        name
      }
      ... on HubspotIntegration {
        __typename
        id
        name
        portalId
      }
    }
  }
}
    `;

/**
 * __useIntegrationsListForCustomerMainInfosQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerMainInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerMainInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerMainInfosQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerMainInfosQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
      }
export function useIntegrationsListForCustomerMainInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export function useIntegrationsListForCustomerMainInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>(IntegrationsListForCustomerMainInfosDocument, options);
        }
export type IntegrationsListForCustomerMainInfosQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosQuery>;
export type IntegrationsListForCustomerMainInfosLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosLazyQuery>;
export type IntegrationsListForCustomerMainInfosSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerMainInfosSuspenseQuery>;
export type IntegrationsListForCustomerMainInfosQueryResult = Apollo.QueryResult<IntegrationsListForCustomerMainInfosQuery, IntegrationsListForCustomerMainInfosQueryVariables>;
export const GetCustomerSettingsDocument = gql`
    query getCustomerSettings($id: ID!) {
  customer(id: $id) {
    id
    invoiceGracePeriod
    netPaymentTerm
    finalizeZeroAmountInvoice
    billingConfiguration {
      id
      documentLocale
    }
    ...CustomerAppliedTaxRatesForSettings
    ...EditCustomerVatRate
    ...EditCustomerDocumentLocale
    ...EditCustomerInvoiceGracePeriod
    ...DeleteCustomerGracePeriod
    ...DeleteCustomerDocumentLocale
    ...CustomerForDeleteVatRateDialog
    ...DeleteCustomerNetPaymentTerm
  }
  organization {
    id
    netPaymentTerm
    finalizeZeroAmountInvoice
    billingConfiguration {
      id
      invoiceGracePeriod
      documentLocale
    }
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}
${EditCustomerVatRateFragmentDoc}
${EditCustomerDocumentLocaleFragmentDoc}
${EditCustomerInvoiceGracePeriodFragmentDoc}
${DeleteCustomerGracePeriodFragmentDoc}
${DeleteCustomerDocumentLocaleFragmentDoc}
${CustomerForDeleteVatRateDialogFragmentDoc}
${DeleteCustomerNetPaymentTermFragmentDoc}`;

/**
 * __useGetCustomerSettingsQuery__
 *
 * To run a query within a React component, call `useGetCustomerSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables> & ({ variables: GetCustomerSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
      }
export function useGetCustomerSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export function useGetCustomerSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>(GetCustomerSettingsDocument, options);
        }
export type GetCustomerSettingsQueryHookResult = ReturnType<typeof useGetCustomerSettingsQuery>;
export type GetCustomerSettingsLazyQueryHookResult = ReturnType<typeof useGetCustomerSettingsLazyQuery>;
export type GetCustomerSettingsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSettingsSuspenseQuery>;
export type GetCustomerSettingsQueryResult = Apollo.QueryResult<GetCustomerSettingsQuery, GetCustomerSettingsQueryVariables>;
export const DeleteCustomerDocument = gql`
    mutation deleteCustomer($input: DestroyCustomerInput!) {
  destroyCustomer(input: $input) {
    id
  }
}
    `;
export type DeleteCustomerMutationFn = Apollo.MutationFunction<DeleteCustomerMutation, DeleteCustomerMutationVariables>;

/**
 * __useDeleteCustomerMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerMutation, { data, loading, error }] = useDeleteCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerMutation, DeleteCustomerMutationVariables>(DeleteCustomerDocument, options);
      }
export type DeleteCustomerMutationHookResult = ReturnType<typeof useDeleteCustomerMutation>;
export type DeleteCustomerMutationResult = Apollo.MutationResult<DeleteCustomerMutation>;
export type DeleteCustomerMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerMutation, DeleteCustomerMutationVariables>;
export const DeleteCustomerDocumentLocaleDocument = gql`
    mutation deleteCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type DeleteCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;

/**
 * __useDeleteCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerDocumentLocaleMutation, { data, loading, error }] = useDeleteCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>(DeleteCustomerDocumentLocaleDocument, options);
      }
export type DeleteCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useDeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationResult = Apollo.MutationResult<DeleteCustomerDocumentLocaleMutation>;
export type DeleteCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerDocumentLocaleMutation, DeleteCustomerDocumentLocaleMutationVariables>;
export const DeleteCustomerFinalizeZeroAmountInvoiceDocument = gql`
    mutation deleteCustomerFinalizeZeroAmountInvoice($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...DeleteCustomerFinalizeZeroAmountInvoice
  }
}
    ${DeleteCustomerFinalizeZeroAmountInvoiceFragmentDoc}`;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useDeleteCustomerFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useDeleteCustomerFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>(DeleteCustomerFinalizeZeroAmountInvoiceDocument, options);
      }
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useDeleteCustomerFinalizeZeroAmountInvoiceMutation>;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<DeleteCustomerFinalizeZeroAmountInvoiceMutation>;
export type DeleteCustomerFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerFinalizeZeroAmountInvoiceMutation, DeleteCustomerFinalizeZeroAmountInvoiceMutationVariables>;
export const DeleteCustomerGracePeriodDocument = gql`
    mutation deleteCustomerGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    invoiceGracePeriod
  }
}
    `;
export type DeleteCustomerGracePeriodMutationFn = Apollo.MutationFunction<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;

/**
 * __useDeleteCustomerGracePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerGracePeriodMutation, { data, loading, error }] = useDeleteCustomerGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>(DeleteCustomerGracePeriodDocument, options);
      }
export type DeleteCustomerGracePeriodMutationHookResult = ReturnType<typeof useDeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationResult = Apollo.MutationResult<DeleteCustomerGracePeriodMutation>;
export type DeleteCustomerGracePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerGracePeriodMutation, DeleteCustomerGracePeriodMutationVariables>;
export const DeleteCustomerNetPaymentTermDocument = gql`
    mutation deleteCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...DeleteCustomerNetPaymentTerm
  }
}
    ${DeleteCustomerNetPaymentTermFragmentDoc}`;
export type DeleteCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;

/**
 * __useDeleteCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useDeleteCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCustomerNetPaymentTermMutation, { data, loading, error }] = useDeleteCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>(DeleteCustomerNetPaymentTermDocument, options);
      }
export type DeleteCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useDeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationResult = Apollo.MutationResult<DeleteCustomerNetPaymentTermMutation>;
export type DeleteCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerNetPaymentTermMutation, DeleteCustomerNetPaymentTermMutationVariables>;
export const RemoveAppliedTaxRateOnCustomerDocument = gql`
    mutation removeAppliedTaxRateOnCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
  }
}
    `;
export type RemoveAppliedTaxRateOnCustomerMutationFn = Apollo.MutationFunction<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;

/**
 * __useRemoveAppliedTaxRateOnCustomerMutation__
 *
 * To run a mutation, you first call `useRemoveAppliedTaxRateOnCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveAppliedTaxRateOnCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeAppliedTaxRateOnCustomerMutation, { data, loading, error }] = useRemoveAppliedTaxRateOnCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveAppliedTaxRateOnCustomerMutation(baseOptions?: Apollo.MutationHookOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>(RemoveAppliedTaxRateOnCustomerDocument, options);
      }
export type RemoveAppliedTaxRateOnCustomerMutationHookResult = ReturnType<typeof useRemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationResult = Apollo.MutationResult<RemoveAppliedTaxRateOnCustomerMutation>;
export type RemoveAppliedTaxRateOnCustomerMutationOptions = Apollo.BaseMutationOptions<RemoveAppliedTaxRateOnCustomerMutation, RemoveAppliedTaxRateOnCustomerMutationVariables>;
export const UpdateCustomerDocumentLocaleDocument = gql`
    mutation updateCustomerDocumentLocale($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateCustomerDocumentLocaleMutationFn = Apollo.MutationFunction<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;

/**
 * __useUpdateCustomerDocumentLocaleMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerDocumentLocaleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerDocumentLocaleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerDocumentLocaleMutation, { data, loading, error }] = useUpdateCustomerDocumentLocaleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerDocumentLocaleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>(UpdateCustomerDocumentLocaleDocument, options);
      }
export type UpdateCustomerDocumentLocaleMutationHookResult = ReturnType<typeof useUpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationResult = Apollo.MutationResult<UpdateCustomerDocumentLocaleMutation>;
export type UpdateCustomerDocumentLocaleMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerDocumentLocaleMutation, UpdateCustomerDocumentLocaleMutationVariables>;
export const UpdateCustomerInvoiceGracePeriodDocument = gql`
    mutation updateCustomerInvoiceGracePeriod($input: UpdateCustomerInvoiceGracePeriodInput!) {
  updateCustomerInvoiceGracePeriod(input: $input) {
    id
    ...EditCustomerInvoiceGracePeriod
  }
}
    ${EditCustomerInvoiceGracePeriodFragmentDoc}`;
export type UpdateCustomerInvoiceGracePeriodMutationFn = Apollo.MutationFunction<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;

/**
 * __useUpdateCustomerInvoiceGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerInvoiceGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerInvoiceGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerInvoiceGracePeriodMutation, { data, loading, error }] = useUpdateCustomerInvoiceGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerInvoiceGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>(UpdateCustomerInvoiceGracePeriodDocument, options);
      }
export type UpdateCustomerInvoiceGracePeriodMutationHookResult = ReturnType<typeof useUpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationResult = Apollo.MutationResult<UpdateCustomerInvoiceGracePeriodMutation>;
export type UpdateCustomerInvoiceGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerInvoiceGracePeriodMutation, UpdateCustomerInvoiceGracePeriodMutationVariables>;
export const GetTaxRatesForEditCustomerDocument = gql`
    query getTaxRatesForEditCustomer($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
      code
    }
  }
}
    `;

/**
 * __useGetTaxRatesForEditCustomerQuery__
 *
 * To run a query within a React component, call `useGetTaxRatesForEditCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxRatesForEditCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxRatesForEditCustomerQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxRatesForEditCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
      }
export function useGetTaxRatesForEditCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export function useGetTaxRatesForEditCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>(GetTaxRatesForEditCustomerDocument, options);
        }
export type GetTaxRatesForEditCustomerQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerQuery>;
export type GetTaxRatesForEditCustomerLazyQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerLazyQuery>;
export type GetTaxRatesForEditCustomerSuspenseQueryHookResult = ReturnType<typeof useGetTaxRatesForEditCustomerSuspenseQuery>;
export type GetTaxRatesForEditCustomerQueryResult = Apollo.QueryResult<GetTaxRatesForEditCustomerQuery, GetTaxRatesForEditCustomerQueryVariables>;
export const CreateCustomerAppliedTaxDocument = gql`
    mutation createCustomerAppliedTax($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...CustomerAppliedTaxRatesForSettings
  }
}
    ${CustomerAppliedTaxRatesForSettingsFragmentDoc}`;
export type CreateCustomerAppliedTaxMutationFn = Apollo.MutationFunction<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;

/**
 * __useCreateCustomerAppliedTaxMutation__
 *
 * To run a mutation, you first call `useCreateCustomerAppliedTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerAppliedTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerAppliedTaxMutation, { data, loading, error }] = useCreateCustomerAppliedTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerAppliedTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>(CreateCustomerAppliedTaxDocument, options);
      }
export type CreateCustomerAppliedTaxMutationHookResult = ReturnType<typeof useCreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationResult = Apollo.MutationResult<CreateCustomerAppliedTaxMutation>;
export type CreateCustomerAppliedTaxMutationOptions = Apollo.BaseMutationOptions<CreateCustomerAppliedTaxMutation, CreateCustomerAppliedTaxMutationVariables>;
export const PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument = gql`
    query paymentProvidersListForCustomerCreateEditExternalAppsAccordion($limit: Int) {
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        __typename
        id
        name
        code
      }
      ... on GocardlessProvider {
        __typename
        id
        name
        code
      }
      ... on AdyenProvider {
        __typename
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
      }
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export function usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>(PaymentProvidersListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionLazyQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof usePaymentProvidersListForCustomerCreateEditExternalAppsAccordionSuspenseQuery>;
export type PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryResult = Apollo.QueryResult<PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQuery, PaymentProvidersListForCustomerCreateEditExternalAppsAccordionQueryVariables>;
export const AccountingIntegrationsListForCustomerEditExternalAppsAccordionDocument = gql`
    query accountingIntegrationsListForCustomerEditExternalAppsAccordion($limit: Int, $page: Int) {
  integrations(limit: $limit, page: $page) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        code
        name
      }
      ... on AnrokIntegration {
        __typename
        id
        code
        name
      }
      ... on XeroIntegration {
        __typename
        id
        code
        name
      }
      ... on HubspotIntegration {
        __typename
        id
        code
        name
        defaultTargetedObject
      }
    }
  }
}
    `;

/**
 * __useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>(AccountingIntegrationsListForCustomerEditExternalAppsAccordionDocument, options);
      }
export function useAccountingIntegrationsListForCustomerEditExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>(AccountingIntegrationsListForCustomerEditExternalAppsAccordionDocument, options);
        }
export function useAccountingIntegrationsListForCustomerEditExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>(AccountingIntegrationsListForCustomerEditExternalAppsAccordionDocument, options);
        }
export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryHookResult = ReturnType<typeof useAccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery>;
export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useAccountingIntegrationsListForCustomerEditExternalAppsAccordionLazyQuery>;
export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useAccountingIntegrationsListForCustomerEditExternalAppsAccordionSuspenseQuery>;
export type AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryResult = Apollo.QueryResult<AccountingIntegrationsListForCustomerEditExternalAppsAccordionQuery, AccountingIntegrationsListForCustomerEditExternalAppsAccordionQueryVariables>;
export const SubsidiariesListForCustomerCreateEditExternalAppsAccordionDocument = gql`
    query subsidiariesListForCustomerCreateEditExternalAppsAccordion($integrationId: ID) {
  integrationSubsidiaries(integrationId: $integrationId) {
    collection {
      externalId
      externalName
    }
  }
}
    `;

/**
 * __useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery__
 *
 * To run a query within a React component, call `useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery(baseOptions?: Apollo.QueryHookOptions<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>(SubsidiariesListForCustomerCreateEditExternalAppsAccordionDocument, options);
      }
export function useSubsidiariesListForCustomerCreateEditExternalAppsAccordionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>(SubsidiariesListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export function useSubsidiariesListForCustomerCreateEditExternalAppsAccordionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>(SubsidiariesListForCustomerCreateEditExternalAppsAccordionDocument, options);
        }
export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryHookResult = ReturnType<typeof useSubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery>;
export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionLazyQueryHookResult = ReturnType<typeof useSubsidiariesListForCustomerCreateEditExternalAppsAccordionLazyQuery>;
export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionSuspenseQueryHookResult = ReturnType<typeof useSubsidiariesListForCustomerCreateEditExternalAppsAccordionSuspenseQuery>;
export type SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryResult = Apollo.QueryResult<SubsidiariesListForCustomerCreateEditExternalAppsAccordionQuery, SubsidiariesListForCustomerCreateEditExternalAppsAccordionQueryVariables>;
export const VoidCreditNoteDocument = gql`
    mutation voidCreditNote($input: VoidCreditNoteInput!) {
  voidCreditNote(input: $input) {
    id
  }
}
    `;
export type VoidCreditNoteMutationFn = Apollo.MutationFunction<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;

/**
 * __useVoidCreditNoteMutation__
 *
 * To run a mutation, you first call `useVoidCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidCreditNoteMutation, { data, loading, error }] = useVoidCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>(VoidCreditNoteDocument, options);
      }
export type VoidCreditNoteMutationHookResult = ReturnType<typeof useVoidCreditNoteMutation>;
export type VoidCreditNoteMutationResult = Apollo.MutationResult<VoidCreditNoteMutation>;
export type VoidCreditNoteMutationOptions = Apollo.BaseMutationOptions<VoidCreditNoteMutation, VoidCreditNoteMutationVariables>;
export const GetCustomerCouponsDocument = gql`
    query getCustomerCoupons($id: ID!) {
  customer(id: $id) {
    id
    name
    displayName
    ...CustomerAppliedCoupons
  }
}
    ${CustomerAppliedCouponsFragmentDoc}`;

/**
 * __useGetCustomerCouponsQuery__
 *
 * To run a query within a React component, call `useGetCustomerCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerCouponsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerCouponsQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables> & ({ variables: GetCustomerCouponsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
      }
export function useGetCustomerCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export function useGetCustomerCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>(GetCustomerCouponsDocument, options);
        }
export type GetCustomerCouponsQueryHookResult = ReturnType<typeof useGetCustomerCouponsQuery>;
export type GetCustomerCouponsLazyQueryHookResult = ReturnType<typeof useGetCustomerCouponsLazyQuery>;
export type GetCustomerCouponsSuspenseQueryHookResult = ReturnType<typeof useGetCustomerCouponsSuspenseQuery>;
export type GetCustomerCouponsQueryResult = Apollo.QueryResult<GetCustomerCouponsQuery, GetCustomerCouponsQueryVariables>;
export const RemoveCouponDocument = gql`
    mutation removeCoupon($input: TerminateAppliedCouponInput!) {
  terminateAppliedCoupon(input: $input) {
    id
  }
}
    `;
export type RemoveCouponMutationFn = Apollo.MutationFunction<RemoveCouponMutation, RemoveCouponMutationVariables>;

/**
 * __useRemoveCouponMutation__
 *
 * To run a mutation, you first call `useRemoveCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCouponMutation, { data, loading, error }] = useRemoveCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveCouponMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCouponMutation, RemoveCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCouponMutation, RemoveCouponMutationVariables>(RemoveCouponDocument, options);
      }
export type RemoveCouponMutationHookResult = ReturnType<typeof useRemoveCouponMutation>;
export type RemoveCouponMutationResult = Apollo.MutationResult<RemoveCouponMutation>;
export type RemoveCouponMutationOptions = Apollo.BaseMutationOptions<RemoveCouponMutation, RemoveCouponMutationVariables>;
export const GetCustomerOverdueBalancesDocument = gql`
    query getCustomerOverdueBalances($externalCustomerId: String!, $currency: CurrencyEnum, $expireCache: Boolean) {
  paymentRequests(externalCustomerId: $externalCustomerId) {
    collection {
      createdAt
    }
  }
  overdueBalances(
    externalCustomerId: $externalCustomerId
    currency: $currency
    expireCache: $expireCache
  ) {
    collection {
      amountCents
      currency
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetCustomerOverdueBalancesQuery__
 *
 * To run a query within a React component, call `useGetCustomerOverdueBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerOverdueBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerOverdueBalancesQuery({
 *   variables: {
 *      externalCustomerId: // value for 'externalCustomerId'
 *      currency: // value for 'currency'
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerOverdueBalancesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables> & ({ variables: GetCustomerOverdueBalancesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
      }
export function useGetCustomerOverdueBalancesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
        }
export function useGetCustomerOverdueBalancesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>(GetCustomerOverdueBalancesDocument, options);
        }
export type GetCustomerOverdueBalancesQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesQuery>;
export type GetCustomerOverdueBalancesLazyQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesLazyQuery>;
export type GetCustomerOverdueBalancesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerOverdueBalancesSuspenseQuery>;
export type GetCustomerOverdueBalancesQueryResult = Apollo.QueryResult<GetCustomerOverdueBalancesQuery, GetCustomerOverdueBalancesQueryVariables>;
export const GetCustomerGrossRevenuesDocument = gql`
    query getCustomerGrossRevenues($externalCustomerId: String!, $currency: CurrencyEnum, $expireCache: Boolean) {
  grossRevenues(
    externalCustomerId: $externalCustomerId
    currency: $currency
    expireCache: $expireCache
  ) {
    collection {
      amountCents
      currency
      invoicesCount
      month
    }
  }
}
    `;

/**
 * __useGetCustomerGrossRevenuesQuery__
 *
 * To run a query within a React component, call `useGetCustomerGrossRevenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerGrossRevenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerGrossRevenuesQuery({
 *   variables: {
 *      externalCustomerId: // value for 'externalCustomerId'
 *      currency: // value for 'currency'
 *      expireCache: // value for 'expireCache'
 *   },
 * });
 */
export function useGetCustomerGrossRevenuesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables> & ({ variables: GetCustomerGrossRevenuesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
      }
export function useGetCustomerGrossRevenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
        }
export function useGetCustomerGrossRevenuesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>(GetCustomerGrossRevenuesDocument, options);
        }
export type GetCustomerGrossRevenuesQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesQuery>;
export type GetCustomerGrossRevenuesLazyQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesLazyQuery>;
export type GetCustomerGrossRevenuesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerGrossRevenuesSuspenseQuery>;
export type GetCustomerGrossRevenuesQueryResult = Apollo.QueryResult<GetCustomerGrossRevenuesQuery, GetCustomerGrossRevenuesQueryVariables>;
export const GetCustomerSubscriptionForListDocument = gql`
    query getCustomerSubscriptionForList($id: ID!) {
  customer(id: $id) {
    id
    subscriptions(status: [active, pending]) {
      id
      plan {
        id
        amountCurrency
      }
      ...SubscriptionItem
    }
  }
}
    ${SubscriptionItemFragmentDoc}`;

/**
 * __useGetCustomerSubscriptionForListQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForListQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables> & ({ variables: GetCustomerSubscriptionForListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
      }
export function useGetCustomerSubscriptionForListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export function useGetCustomerSubscriptionForListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>(GetCustomerSubscriptionForListDocument, options);
        }
export type GetCustomerSubscriptionForListQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListQuery>;
export type GetCustomerSubscriptionForListLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListLazyQuery>;
export type GetCustomerSubscriptionForListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForListSuspenseQuery>;
export type GetCustomerSubscriptionForListQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForListQuery, GetCustomerSubscriptionForListQueryVariables>;
export const TerminateCustomerSubscriptionDocument = gql`
    mutation terminateCustomerSubscription($input: TerminateSubscriptionInput!) {
  terminateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
    }
  }
}
    `;
export type TerminateCustomerSubscriptionMutationFn = Apollo.MutationFunction<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;

/**
 * __useTerminateCustomerSubscriptionMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerSubscriptionMutation, { data, loading, error }] = useTerminateCustomerSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>(TerminateCustomerSubscriptionDocument, options);
      }
export type TerminateCustomerSubscriptionMutationHookResult = ReturnType<typeof useTerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationResult = Apollo.MutationResult<TerminateCustomerSubscriptionMutation>;
export type TerminateCustomerSubscriptionMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerSubscriptionMutation, TerminateCustomerSubscriptionMutationVariables>;
export const GetCustomerSubscriptionForUsageDocument = gql`
    query getCustomerSubscriptionForUsage($id: ID!) {
  customer(id: $id) {
    id
    externalId
    currency
  }
}
    `;

/**
 * __useGetCustomerSubscriptionForUsageQuery__
 *
 * To run a query within a React component, call `useGetCustomerSubscriptionForUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerSubscriptionForUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerSubscriptionForUsageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerSubscriptionForUsageQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables> & ({ variables: GetCustomerSubscriptionForUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
      }
export function useGetCustomerSubscriptionForUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export function useGetCustomerSubscriptionForUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>(GetCustomerSubscriptionForUsageDocument, options);
        }
export type GetCustomerSubscriptionForUsageQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageQuery>;
export type GetCustomerSubscriptionForUsageLazyQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageLazyQuery>;
export type GetCustomerSubscriptionForUsageSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSubscriptionForUsageSuspenseQuery>;
export type GetCustomerSubscriptionForUsageQueryResult = Apollo.QueryResult<GetCustomerSubscriptionForUsageQuery, GetCustomerSubscriptionForUsageQueryVariables>;
export const GetCustomersForFilterItemCustomerDocument = gql`
    query getCustomersForFilterItemCustomer($page: Int, $limit: Int, $searchTerm: String) {
  customers(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      displayName
      externalId
    }
  }
}
    `;

/**
 * __useGetCustomersForFilterItemCustomerQuery__
 *
 * To run a query within a React component, call `useGetCustomersForFilterItemCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomersForFilterItemCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomersForFilterItemCustomerQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomersForFilterItemCustomerQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
      }
export function useGetCustomersForFilterItemCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
        }
export function useGetCustomersForFilterItemCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>(GetCustomersForFilterItemCustomerDocument, options);
        }
export type GetCustomersForFilterItemCustomerQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerQuery>;
export type GetCustomersForFilterItemCustomerLazyQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerLazyQuery>;
export type GetCustomersForFilterItemCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCustomersForFilterItemCustomerSuspenseQuery>;
export type GetCustomersForFilterItemCustomerQueryResult = Apollo.QueryResult<GetCustomersForFilterItemCustomerQuery, GetCustomersForFilterItemCustomerQueryVariables>;
export const CreateWebhookEndpointDocument = gql`
    mutation createWebhookEndpoint($input: WebhookEndpointCreateInput!) {
  createWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type CreateWebhookEndpointMutationFn = Apollo.MutationFunction<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;

/**
 * __useCreateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useCreateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createWebhookEndpointMutation, { data, loading, error }] = useCreateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>(CreateWebhookEndpointDocument, options);
      }
export type CreateWebhookEndpointMutationHookResult = ReturnType<typeof useCreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationResult = Apollo.MutationResult<CreateWebhookEndpointMutation>;
export type CreateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<CreateWebhookEndpointMutation, CreateWebhookEndpointMutationVariables>;
export const UpdateWebhookEndpointDocument = gql`
    mutation updateWebhookEndpoint($input: WebhookEndpointUpdateInput!) {
  updateWebhookEndpoint(input: $input) {
    id
    ...WebhookForCreateAndEdit
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;
export type UpdateWebhookEndpointMutationFn = Apollo.MutationFunction<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;

/**
 * __useUpdateWebhookEndpointMutation__
 *
 * To run a mutation, you first call `useUpdateWebhookEndpointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWebhookEndpointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWebhookEndpointMutation, { data, loading, error }] = useUpdateWebhookEndpointMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateWebhookEndpointMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>(UpdateWebhookEndpointDocument, options);
      }
export type UpdateWebhookEndpointMutationHookResult = ReturnType<typeof useUpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationResult = Apollo.MutationResult<UpdateWebhookEndpointMutation>;
export type UpdateWebhookEndpointMutationOptions = Apollo.BaseMutationOptions<UpdateWebhookEndpointMutation, UpdateWebhookEndpointMutationVariables>;
export const DeleteWebhookDocument = gql`
    mutation deleteWebhook($input: DestroyWebhookEndpointInput!) {
  destroyWebhookEndpoint(input: $input) {
    id
  }
}
    `;
export type DeleteWebhookMutationFn = Apollo.MutationFunction<DeleteWebhookMutation, DeleteWebhookMutationVariables>;

/**
 * __useDeleteWebhookMutation__
 *
 * To run a mutation, you first call `useDeleteWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWebhookMutation, { data, loading, error }] = useDeleteWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteWebhookMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWebhookMutation, DeleteWebhookMutationVariables>(DeleteWebhookDocument, options);
      }
export type DeleteWebhookMutationHookResult = ReturnType<typeof useDeleteWebhookMutation>;
export type DeleteWebhookMutationResult = Apollo.MutationResult<DeleteWebhookMutation>;
export type DeleteWebhookMutationOptions = Apollo.BaseMutationOptions<DeleteWebhookMutation, DeleteWebhookMutationVariables>;
export const RetryWebhookDocument = gql`
    mutation retryWebhook($input: RetryWebhookInput!) {
  retryWebhook(input: $input) {
    id
  }
}
    `;
export type RetryWebhookMutationFn = Apollo.MutationFunction<RetryWebhookMutation, RetryWebhookMutationVariables>;

/**
 * __useRetryWebhookMutation__
 *
 * To run a mutation, you first call `useRetryWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryWebhookMutation, { data, loading, error }] = useRetryWebhookMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryWebhookMutation(baseOptions?: Apollo.MutationHookOptions<RetryWebhookMutation, RetryWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryWebhookMutation, RetryWebhookMutationVariables>(RetryWebhookDocument, options);
      }
export type RetryWebhookMutationHookResult = ReturnType<typeof useRetryWebhookMutation>;
export type RetryWebhookMutationResult = Apollo.MutationResult<RetryWebhookMutation>;
export type RetryWebhookMutationOptions = Apollo.BaseMutationOptions<RetryWebhookMutation, RetryWebhookMutationVariables>;
export const GetGrossRevenuesDocument = gql`
    query getGrossRevenues($currency: CurrencyEnum!, $externalCustomerId: String, $months: Int) {
  grossRevenues(
    currency: $currency
    externalCustomerId: $externalCustomerId
    months: $months
  ) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetGrossRevenuesQuery__
 *
 * To run a query within a React component, call `useGetGrossRevenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGrossRevenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGrossRevenuesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      months: // value for 'months'
 *   },
 * });
 */
export function useGetGrossRevenuesQuery(baseOptions: Apollo.QueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables> & ({ variables: GetGrossRevenuesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
      }
export function useGetGrossRevenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export function useGetGrossRevenuesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>(GetGrossRevenuesDocument, options);
        }
export type GetGrossRevenuesQueryHookResult = ReturnType<typeof useGetGrossRevenuesQuery>;
export type GetGrossRevenuesLazyQueryHookResult = ReturnType<typeof useGetGrossRevenuesLazyQuery>;
export type GetGrossRevenuesSuspenseQueryHookResult = ReturnType<typeof useGetGrossRevenuesSuspenseQuery>;
export type GetGrossRevenuesQueryResult = Apollo.QueryResult<GetGrossRevenuesQuery, GetGrossRevenuesQueryVariables>;
export const GetInvoiceCollectionsDocument = gql`
    query getInvoiceCollections($currency: CurrencyEnum!) {
  invoiceCollections(currency: $currency) {
    collection {
      paymentStatus
      invoicesCount
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetInvoiceCollectionsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCollectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCollectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCollectionsQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoiceCollectionsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables> & ({ variables: GetInvoiceCollectionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
      }
export function useGetInvoiceCollectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export function useGetInvoiceCollectionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>(GetInvoiceCollectionsDocument, options);
        }
export type GetInvoiceCollectionsQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsQuery>;
export type GetInvoiceCollectionsLazyQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsLazyQuery>;
export type GetInvoiceCollectionsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCollectionsSuspenseQuery>;
export type GetInvoiceCollectionsQueryResult = Apollo.QueryResult<GetInvoiceCollectionsQuery, GetInvoiceCollectionsQueryVariables>;
export const GetMrrDocument = gql`
    query getMrr($currency: CurrencyEnum!) {
  mrrs(currency: $currency) {
    collection {
      amountCents
      currency
      month
    }
  }
}
    `;

/**
 * __useGetMrrQuery__
 *
 * To run a query within a React component, call `useGetMrrQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMrrQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMrrQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetMrrQuery(baseOptions: Apollo.QueryHookOptions<GetMrrQuery, GetMrrQueryVariables> & ({ variables: GetMrrQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
      }
export function useGetMrrLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export function useGetMrrSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMrrQuery, GetMrrQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMrrQuery, GetMrrQueryVariables>(GetMrrDocument, options);
        }
export type GetMrrQueryHookResult = ReturnType<typeof useGetMrrQuery>;
export type GetMrrLazyQueryHookResult = ReturnType<typeof useGetMrrLazyQuery>;
export type GetMrrSuspenseQueryHookResult = ReturnType<typeof useGetMrrSuspenseQuery>;
export type GetMrrQueryResult = Apollo.QueryResult<GetMrrQuery, GetMrrQueryVariables>;
export const GetOverdueDocument = gql`
    query getOverdue($currency: CurrencyEnum!, $externalCustomerId: String, $months: Int!) {
  overdueBalances(
    currency: $currency
    externalCustomerId: $externalCustomerId
    months: $months
  ) {
    collection {
      amountCents
      currency
      month
      lagoInvoiceIds
    }
  }
}
    `;

/**
 * __useGetOverdueQuery__
 *
 * To run a query within a React component, call `useGetOverdueQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOverdueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOverdueQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      externalCustomerId: // value for 'externalCustomerId'
 *      months: // value for 'months'
 *   },
 * });
 */
export function useGetOverdueQuery(baseOptions: Apollo.QueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables> & ({ variables: GetOverdueQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
      }
export function useGetOverdueLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
        }
export function useGetOverdueSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOverdueQuery, GetOverdueQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOverdueQuery, GetOverdueQueryVariables>(GetOverdueDocument, options);
        }
export type GetOverdueQueryHookResult = ReturnType<typeof useGetOverdueQuery>;
export type GetOverdueLazyQueryHookResult = ReturnType<typeof useGetOverdueLazyQuery>;
export type GetOverdueSuspenseQueryHookResult = ReturnType<typeof useGetOverdueSuspenseQuery>;
export type GetOverdueQueryResult = Apollo.QueryResult<GetOverdueQuery, GetOverdueQueryVariables>;
export const GetInvoicedUsagesDocument = gql`
    query getInvoicedUsages($currency: CurrencyEnum!) {
  invoicedUsages(currency: $currency) {
    collection {
      amountCents
      month
      currency
      code
    }
  }
}
    `;

/**
 * __useGetInvoicedUsagesQuery__
 *
 * To run a query within a React component, call `useGetInvoicedUsagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicedUsagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicedUsagesQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *   },
 * });
 */
export function useGetInvoicedUsagesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables> & ({ variables: GetInvoicedUsagesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
      }
export function useGetInvoicedUsagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export function useGetInvoicedUsagesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>(GetInvoicedUsagesDocument, options);
        }
export type GetInvoicedUsagesQueryHookResult = ReturnType<typeof useGetInvoicedUsagesQuery>;
export type GetInvoicedUsagesLazyQueryHookResult = ReturnType<typeof useGetInvoicedUsagesLazyQuery>;
export type GetInvoicedUsagesSuspenseQueryHookResult = ReturnType<typeof useGetInvoicedUsagesSuspenseQuery>;
export type GetInvoicedUsagesQueryResult = Apollo.QueryResult<GetInvoicedUsagesQuery, GetInvoicedUsagesQueryVariables>;
export const UpdateInvoiceMetadataDocument = gql`
    mutation updateInvoiceMetadata($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceMetadatasForMetadataDrawer
  }
}
    ${InvoiceMetadatasForMetadataDrawerFragmentDoc}`;
export type UpdateInvoiceMetadataMutationFn = Apollo.MutationFunction<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;

/**
 * __useUpdateInvoiceMetadataMutation__
 *
 * To run a mutation, you first call `useUpdateInvoiceMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoiceMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoiceMetadataMutation, { data, loading, error }] = useUpdateInvoiceMetadataMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoiceMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>(UpdateInvoiceMetadataDocument, options);
      }
export type UpdateInvoiceMetadataMutationHookResult = ReturnType<typeof useUpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationResult = Apollo.MutationResult<UpdateInvoiceMetadataMutation>;
export type UpdateInvoiceMetadataMutationOptions = Apollo.BaseMutationOptions<UpdateInvoiceMetadataMutation, UpdateInvoiceMetadataMutationVariables>;
export const DisputeInvoiceDocument = gql`
    mutation disputeInvoice($input: LoseInvoiceDisputeInput!) {
  loseInvoiceDispute(input: $input) {
    id
    status
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type DisputeInvoiceMutationFn = Apollo.MutationFunction<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;

/**
 * __useDisputeInvoiceMutation__
 *
 * To run a mutation, you first call `useDisputeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDisputeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [disputeInvoiceMutation, { data, loading, error }] = useDisputeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDisputeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>(DisputeInvoiceDocument, options);
      }
export type DisputeInvoiceMutationHookResult = ReturnType<typeof useDisputeInvoiceMutation>;
export type DisputeInvoiceMutationResult = Apollo.MutationResult<DisputeInvoiceMutation>;
export type DisputeInvoiceMutationOptions = Apollo.BaseMutationOptions<DisputeInvoiceMutation, DisputeInvoiceMutationVariables>;
export const GetTaxesForInvoiceEditTaxDialogDocument = gql`
    query getTaxesForInvoiceEditTaxDialog($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForInvoiceEditTaxDialog
    }
  }
}
    ${TaxForInvoiceEditTaxDialogFragmentDoc}`;

/**
 * __useGetTaxesForInvoiceEditTaxDialogQuery__
 *
 * To run a query within a React component, call `useGetTaxesForInvoiceEditTaxDialogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForInvoiceEditTaxDialogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForInvoiceEditTaxDialogQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForInvoiceEditTaxDialogQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
      }
export function useGetTaxesForInvoiceEditTaxDialogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export function useGetTaxesForInvoiceEditTaxDialogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>(GetTaxesForInvoiceEditTaxDialogDocument, options);
        }
export type GetTaxesForInvoiceEditTaxDialogQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogQuery>;
export type GetTaxesForInvoiceEditTaxDialogLazyQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogLazyQuery>;
export type GetTaxesForInvoiceEditTaxDialogSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForInvoiceEditTaxDialogSuspenseQuery>;
export type GetTaxesForInvoiceEditTaxDialogQueryResult = Apollo.QueryResult<GetTaxesForInvoiceEditTaxDialogQuery, GetTaxesForInvoiceEditTaxDialogQueryVariables>;
export const UpdateInvoicePaymentStatusDocument = gql`
    mutation updateInvoicePaymentStatus($input: UpdateInvoiceInput!) {
  updateInvoice(input: $input) {
    id
    ...InvoiceForUpdateInvoicePaymentStatus
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceForUpdateInvoicePaymentStatusFragmentDoc}
${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type UpdateInvoicePaymentStatusMutationFn = Apollo.MutationFunction<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;

/**
 * __useUpdateInvoicePaymentStatusMutation__
 *
 * To run a mutation, you first call `useUpdateInvoicePaymentStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoicePaymentStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoicePaymentStatusMutation, { data, loading, error }] = useUpdateInvoicePaymentStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoicePaymentStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>(UpdateInvoicePaymentStatusDocument, options);
      }
export type UpdateInvoicePaymentStatusMutationHookResult = ReturnType<typeof useUpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationResult = Apollo.MutationResult<UpdateInvoicePaymentStatusMutation>;
export type UpdateInvoicePaymentStatusMutationOptions = Apollo.BaseMutationOptions<UpdateInvoicePaymentStatusMutation, UpdateInvoicePaymentStatusMutationVariables>;
export const CreateInvoicesDataExportDocument = gql`
    mutation createInvoicesDataExport($input: CreateDataExportsInvoicesInput!) {
  createInvoicesDataExport(input: $input) {
    id
  }
}
    `;
export type CreateInvoicesDataExportMutationFn = Apollo.MutationFunction<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>;

/**
 * __useCreateInvoicesDataExportMutation__
 *
 * To run a mutation, you first call `useCreateInvoicesDataExportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoicesDataExportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoicesDataExportMutation, { data, loading, error }] = useCreateInvoicesDataExportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoicesDataExportMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>(CreateInvoicesDataExportDocument, options);
      }
export type CreateInvoicesDataExportMutationHookResult = ReturnType<typeof useCreateInvoicesDataExportMutation>;
export type CreateInvoicesDataExportMutationResult = Apollo.MutationResult<CreateInvoicesDataExportMutation>;
export type CreateInvoicesDataExportMutationOptions = Apollo.BaseMutationOptions<CreateInvoicesDataExportMutation, CreateInvoicesDataExportMutationVariables>;
export const FinalizeInvoiceDocument = gql`
    mutation finalizeInvoice($input: FinalizeInvoiceInput!) {
  finalizeInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type FinalizeInvoiceMutationFn = Apollo.MutationFunction<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;

/**
 * __useFinalizeInvoiceMutation__
 *
 * To run a mutation, you first call `useFinalizeInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinalizeInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finalizeInvoiceMutation, { data, loading, error }] = useFinalizeInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFinalizeInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>(FinalizeInvoiceDocument, options);
      }
export type FinalizeInvoiceMutationHookResult = ReturnType<typeof useFinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationResult = Apollo.MutationResult<FinalizeInvoiceMutation>;
export type FinalizeInvoiceMutationOptions = Apollo.BaseMutationOptions<FinalizeInvoiceMutation, FinalizeInvoiceMutationVariables>;
export const VoidInvoiceDocument = gql`
    mutation voidInvoice($input: VoidInvoiceInput!) {
  voidInvoice(input: $input) {
    id
    status
    ...InvoiceListItem
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${InvoiceListItemFragmentDoc}
${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type VoidInvoiceMutationFn = Apollo.MutationFunction<VoidInvoiceMutation, VoidInvoiceMutationVariables>;

/**
 * __useVoidInvoiceMutation__
 *
 * To run a mutation, you first call `useVoidInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoidInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voidInvoiceMutation, { data, loading, error }] = useVoidInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoidInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VoidInvoiceMutation, VoidInvoiceMutationVariables>(VoidInvoiceDocument, options);
      }
export type VoidInvoiceMutationHookResult = ReturnType<typeof useVoidInvoiceMutation>;
export type VoidInvoiceMutationResult = Apollo.MutationResult<VoidInvoiceMutation>;
export type VoidInvoiceMutationOptions = Apollo.BaseMutationOptions<VoidInvoiceMutation, VoidInvoiceMutationVariables>;
export const DestroyAdjustedFeeDocument = gql`
    mutation destroyAdjustedFee($input: DestroyAdjustedFeeInput!) {
  destroyAdjustedFee(input: $input) {
    id
  }
}
    `;
export type DestroyAdjustedFeeMutationFn = Apollo.MutationFunction<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;

/**
 * __useDestroyAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useDestroyAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyAdjustedFeeMutation, { data, loading, error }] = useDestroyAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>(DestroyAdjustedFeeDocument, options);
      }
export type DestroyAdjustedFeeMutationHookResult = ReturnType<typeof useDestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationResult = Apollo.MutationResult<DestroyAdjustedFeeMutation>;
export type DestroyAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<DestroyAdjustedFeeMutation, DestroyAdjustedFeeMutationVariables>;
export const CreateAdjustedFeeDocument = gql`
    mutation createAdjustedFee($input: CreateAdjustedFeeInput!) {
  createAdjustedFee(input: $input) {
    id
  }
}
    `;
export type CreateAdjustedFeeMutationFn = Apollo.MutationFunction<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;

/**
 * __useCreateAdjustedFeeMutation__
 *
 * To run a mutation, you first call `useCreateAdjustedFeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAdjustedFeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAdjustedFeeMutation, { data, loading, error }] = useCreateAdjustedFeeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAdjustedFeeMutation(baseOptions?: Apollo.MutationHookOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>(CreateAdjustedFeeDocument, options);
      }
export type CreateAdjustedFeeMutationHookResult = ReturnType<typeof useCreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationResult = Apollo.MutationResult<CreateAdjustedFeeMutation>;
export type CreateAdjustedFeeMutationOptions = Apollo.BaseMutationOptions<CreateAdjustedFeeMutation, CreateAdjustedFeeMutationVariables>;
export const GetTaxesForChargesDocument = gql`
    query getTaxesForCharges($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanChargeAccordion
    }
  }
}
    ${TaxForPlanChargeAccordionFragmentDoc}`;

/**
 * __useGetTaxesForChargesQuery__
 *
 * To run a query within a React component, call `useGetTaxesForChargesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForChargesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForChargesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForChargesQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
      }
export function useGetTaxesForChargesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
        }
export function useGetTaxesForChargesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>(GetTaxesForChargesDocument, options);
        }
export type GetTaxesForChargesQueryHookResult = ReturnType<typeof useGetTaxesForChargesQuery>;
export type GetTaxesForChargesLazyQueryHookResult = ReturnType<typeof useGetTaxesForChargesLazyQuery>;
export type GetTaxesForChargesSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForChargesSuspenseQuery>;
export type GetTaxesForChargesQueryResult = Apollo.QueryResult<GetTaxesForChargesQuery, GetTaxesForChargesQueryVariables>;
export const GetMeteredBillableMetricsDocument = gql`
    query getMeteredBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: false
  ) {
    collection {
      id
      ...BillableMetricForChargeSection
    }
  }
}
    ${BillableMetricForChargeSectionFragmentDoc}`;

/**
 * __useGetMeteredBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetMeteredBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMeteredBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMeteredBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetMeteredBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
      }
export function useGetMeteredBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export function useGetMeteredBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>(GetMeteredBillableMetricsDocument, options);
        }
export type GetMeteredBillableMetricsQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsQuery>;
export type GetMeteredBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsLazyQuery>;
export type GetMeteredBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetMeteredBillableMetricsSuspenseQuery>;
export type GetMeteredBillableMetricsQueryResult = Apollo.QueryResult<GetMeteredBillableMetricsQuery, GetMeteredBillableMetricsQueryVariables>;
export const GetRecurringBillableMetricsDocument = gql`
    query getRecurringBillableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(
    page: $page
    limit: $limit
    searchTerm: $searchTerm
    recurring: true
  ) {
    collection {
      id
      ...BillableMetricForChargeSection
    }
  }
}
    ${BillableMetricForChargeSectionFragmentDoc}`;

/**
 * __useGetRecurringBillableMetricsQuery__
 *
 * To run a query within a React component, call `useGetRecurringBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRecurringBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRecurringBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetRecurringBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
      }
export function useGetRecurringBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export function useGetRecurringBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>(GetRecurringBillableMetricsDocument, options);
        }
export type GetRecurringBillableMetricsQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsQuery>;
export type GetRecurringBillableMetricsLazyQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsLazyQuery>;
export type GetRecurringBillableMetricsSuspenseQueryHookResult = ReturnType<typeof useGetRecurringBillableMetricsSuspenseQuery>;
export type GetRecurringBillableMetricsQueryResult = Apollo.QueryResult<GetRecurringBillableMetricsQuery, GetRecurringBillableMetricsQueryVariables>;
export const GetTaxesForCommitmentsDocument = gql`
    query getTaxesForCommitments($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanChargeAccordion
    }
  }
}
    ${TaxForPlanChargeAccordionFragmentDoc}`;

/**
 * __useGetTaxesForCommitmentsQuery__
 *
 * To run a query within a React component, call `useGetTaxesForCommitmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForCommitmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForCommitmentsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForCommitmentsQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
      }
export function useGetTaxesForCommitmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export function useGetTaxesForCommitmentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>(GetTaxesForCommitmentsDocument, options);
        }
export type GetTaxesForCommitmentsQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsQuery>;
export type GetTaxesForCommitmentsLazyQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsLazyQuery>;
export type GetTaxesForCommitmentsSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForCommitmentsSuspenseQuery>;
export type GetTaxesForCommitmentsQueryResult = Apollo.QueryResult<GetTaxesForCommitmentsQuery, GetTaxesForCommitmentsQueryVariables>;
export const DeletePlanDocument = gql`
    mutation deletePlan($input: DestroyPlanInput!) {
  destroyPlan(input: $input) {
    id
  }
}
    `;
export type DeletePlanMutationFn = Apollo.MutationFunction<DeletePlanMutation, DeletePlanMutationVariables>;

/**
 * __useDeletePlanMutation__
 *
 * To run a mutation, you first call `useDeletePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePlanMutation, { data, loading, error }] = useDeletePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeletePlanMutation(baseOptions?: Apollo.MutationHookOptions<DeletePlanMutation, DeletePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePlanMutation, DeletePlanMutationVariables>(DeletePlanDocument, options);
      }
export type DeletePlanMutationHookResult = ReturnType<typeof useDeletePlanMutation>;
export type DeletePlanMutationResult = Apollo.MutationResult<DeletePlanMutation>;
export type DeletePlanMutationOptions = Apollo.BaseMutationOptions<DeletePlanMutation, DeletePlanMutationVariables>;
export const GetTaxesForPlanDocument = gql`
    query getTaxesForPlan($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxForPlanSettingsSection
    }
  }
}
    ${TaxForPlanSettingsSectionFragmentDoc}`;

/**
 * __useGetTaxesForPlanQuery__
 *
 * To run a query within a React component, call `useGetTaxesForPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForPlanQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesForPlanQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
      }
export function useGetTaxesForPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export function useGetTaxesForPlanSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>(GetTaxesForPlanDocument, options);
        }
export type GetTaxesForPlanQueryHookResult = ReturnType<typeof useGetTaxesForPlanQuery>;
export type GetTaxesForPlanLazyQueryHookResult = ReturnType<typeof useGetTaxesForPlanLazyQuery>;
export type GetTaxesForPlanSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForPlanSuspenseQuery>;
export type GetTaxesForPlanQueryResult = Apollo.QueryResult<GetTaxesForPlanQuery, GetTaxesForPlanQueryVariables>;
export const GetPlanForDetailsOverviewSectionDocument = gql`
    query getPlanForDetailsOverviewSection($plan: ID!) {
  plan(id: $plan) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetPlanForDetailsOverviewSectionQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsOverviewSectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsOverviewSectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsOverviewSectionQuery({
 *   variables: {
 *      plan: // value for 'plan'
 *   },
 * });
 */
export function useGetPlanForDetailsOverviewSectionQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables> & ({ variables: GetPlanForDetailsOverviewSectionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
      }
export function useGetPlanForDetailsOverviewSectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export function useGetPlanForDetailsOverviewSectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>(GetPlanForDetailsOverviewSectionDocument, options);
        }
export type GetPlanForDetailsOverviewSectionQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionQuery>;
export type GetPlanForDetailsOverviewSectionLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionLazyQuery>;
export type GetPlanForDetailsOverviewSectionSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsOverviewSectionSuspenseQuery>;
export type GetPlanForDetailsOverviewSectionQueryResult = Apollo.QueryResult<GetPlanForDetailsOverviewSectionQuery, GetPlanForDetailsOverviewSectionQueryVariables>;
export const GetSubscribtionsForPlanDetailsDocument = gql`
    query getSubscribtionsForPlanDetails($page: Int, $limit: Int, $planCode: String, $status: [StatusTypeEnum!]) {
  subscriptions(page: $page, limit: $limit, planCode: $planCode, status: $status) {
    collection {
      id
      ...PlanSubscriptionListItemForSubscriptionList
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${PlanSubscriptionListItemForSubscriptionListFragmentDoc}`;

/**
 * __useGetSubscribtionsForPlanDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscribtionsForPlanDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscribtionsForPlanDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscribtionsForPlanDetailsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      planCode: // value for 'planCode'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetSubscribtionsForPlanDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
      }
export function useGetSubscribtionsForPlanDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export function useGetSubscribtionsForPlanDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>(GetSubscribtionsForPlanDetailsDocument, options);
        }
export type GetSubscribtionsForPlanDetailsQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsQuery>;
export type GetSubscribtionsForPlanDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsLazyQuery>;
export type GetSubscribtionsForPlanDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscribtionsForPlanDetailsSuspenseQuery>;
export type GetSubscribtionsForPlanDetailsQueryResult = Apollo.QueryResult<GetSubscribtionsForPlanDetailsQuery, GetSubscribtionsForPlanDetailsQueryVariables>;
export const GetTaxRatesForEditOrgaDocument = gql`
    query getTaxRatesForEditOrga($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
    }
  }
}
    `;

/**
 * __useGetTaxRatesForEditOrgaQuery__
 *
 * To run a query within a React component, call `useGetTaxRatesForEditOrgaQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxRatesForEditOrgaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxRatesForEditOrgaQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxRatesForEditOrgaQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
      }
export function useGetTaxRatesForEditOrgaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
        }
export function useGetTaxRatesForEditOrgaSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>(GetTaxRatesForEditOrgaDocument, options);
        }
export type GetTaxRatesForEditOrgaQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaQuery>;
export type GetTaxRatesForEditOrgaLazyQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaLazyQuery>;
export type GetTaxRatesForEditOrgaSuspenseQueryHookResult = ReturnType<typeof useGetTaxRatesForEditOrgaSuspenseQuery>;
export type GetTaxRatesForEditOrgaQueryResult = Apollo.QueryResult<GetTaxRatesForEditOrgaQuery, GetTaxRatesForEditOrgaQueryVariables>;
export const AssignTaxRateToOrganizationDocument = gql`
    mutation assignTaxRateToOrganization($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    id
  }
}
    `;
export type AssignTaxRateToOrganizationMutationFn = Apollo.MutationFunction<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>;

/**
 * __useAssignTaxRateToOrganizationMutation__
 *
 * To run a mutation, you first call `useAssignTaxRateToOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignTaxRateToOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignTaxRateToOrganizationMutation, { data, loading, error }] = useAssignTaxRateToOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAssignTaxRateToOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>(AssignTaxRateToOrganizationDocument, options);
      }
export type AssignTaxRateToOrganizationMutationHookResult = ReturnType<typeof useAssignTaxRateToOrganizationMutation>;
export type AssignTaxRateToOrganizationMutationResult = Apollo.MutationResult<AssignTaxRateToOrganizationMutation>;
export type AssignTaxRateToOrganizationMutationOptions = Apollo.BaseMutationOptions<AssignTaxRateToOrganizationMutation, AssignTaxRateToOrganizationMutationVariables>;
export const UnassignTaxRateToOrganizationDocument = gql`
    mutation unassignTaxRateToOrganization($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    id
    ...DeleteOrganizationVatRate
  }
}
    ${DeleteOrganizationVatRateFragmentDoc}`;
export type UnassignTaxRateToOrganizationMutationFn = Apollo.MutationFunction<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>;

/**
 * __useUnassignTaxRateToOrganizationMutation__
 *
 * To run a mutation, you first call `useUnassignTaxRateToOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnassignTaxRateToOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unassignTaxRateToOrganizationMutation, { data, loading, error }] = useUnassignTaxRateToOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUnassignTaxRateToOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>(UnassignTaxRateToOrganizationDocument, options);
      }
export type UnassignTaxRateToOrganizationMutationHookResult = ReturnType<typeof useUnassignTaxRateToOrganizationMutation>;
export type UnassignTaxRateToOrganizationMutationResult = Apollo.MutationResult<UnassignTaxRateToOrganizationMutation>;
export type UnassignTaxRateToOrganizationMutationOptions = Apollo.BaseMutationOptions<UnassignTaxRateToOrganizationMutation, UnassignTaxRateToOrganizationMutationVariables>;
export const UpdateOrganizationDefaultCurrencyDocument = gql`
    mutation updateOrganizationDefaultCurrency($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationDefaultCurrencyForDialog
  }
}
    ${EditOrganizationDefaultCurrencyForDialogFragmentDoc}`;
export type UpdateOrganizationDefaultCurrencyMutationFn = Apollo.MutationFunction<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>;

/**
 * __useUpdateOrganizationDefaultCurrencyMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationDefaultCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationDefaultCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationDefaultCurrencyMutation, { data, loading, error }] = useUpdateOrganizationDefaultCurrencyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationDefaultCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>(UpdateOrganizationDefaultCurrencyDocument, options);
      }
export type UpdateOrganizationDefaultCurrencyMutationHookResult = ReturnType<typeof useUpdateOrganizationDefaultCurrencyMutation>;
export type UpdateOrganizationDefaultCurrencyMutationResult = Apollo.MutationResult<UpdateOrganizationDefaultCurrencyMutation>;
export type UpdateOrganizationDefaultCurrencyMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationDefaultCurrencyMutation, UpdateOrganizationDefaultCurrencyMutationVariables>;
export const UpdateCustomerFinalizeZeroAmountInvoiceDocument = gql`
    mutation updateCustomerFinalizeZeroAmountInvoice($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...EditCustomerFinalizeZeroAmountInvoiceForDialog
  }
}
    ${EditCustomerFinalizeZeroAmountInvoiceForDialogFragmentDoc}`;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useUpdateCustomerFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useUpdateCustomerFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>(UpdateCustomerFinalizeZeroAmountInvoiceDocument, options);
      }
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useUpdateCustomerFinalizeZeroAmountInvoiceMutation>;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<UpdateCustomerFinalizeZeroAmountInvoiceMutation>;
export type UpdateCustomerFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerFinalizeZeroAmountInvoiceMutation, UpdateCustomerFinalizeZeroAmountInvoiceMutationVariables>;
export const UpdateOrganizationFinalizeZeroAmountInvoiceDocument = gql`
    mutation updateOrganizationFinalizeZeroAmountInvoice($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationFinalizeZeroAmountInvoiceForDialog
  }
}
    ${EditOrganizationFinalizeZeroAmountInvoiceForDialogFragmentDoc}`;
export type UpdateOrganizationFinalizeZeroAmountInvoiceMutationFn = Apollo.MutationFunction<UpdateOrganizationFinalizeZeroAmountInvoiceMutation, UpdateOrganizationFinalizeZeroAmountInvoiceMutationVariables>;

/**
 * __useUpdateOrganizationFinalizeZeroAmountInvoiceMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationFinalizeZeroAmountInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationFinalizeZeroAmountInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationFinalizeZeroAmountInvoiceMutation, { data, loading, error }] = useUpdateOrganizationFinalizeZeroAmountInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationFinalizeZeroAmountInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationFinalizeZeroAmountInvoiceMutation, UpdateOrganizationFinalizeZeroAmountInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationFinalizeZeroAmountInvoiceMutation, UpdateOrganizationFinalizeZeroAmountInvoiceMutationVariables>(UpdateOrganizationFinalizeZeroAmountInvoiceDocument, options);
      }
export type UpdateOrganizationFinalizeZeroAmountInvoiceMutationHookResult = ReturnType<typeof useUpdateOrganizationFinalizeZeroAmountInvoiceMutation>;
export type UpdateOrganizationFinalizeZeroAmountInvoiceMutationResult = Apollo.MutationResult<UpdateOrganizationFinalizeZeroAmountInvoiceMutation>;
export type UpdateOrganizationFinalizeZeroAmountInvoiceMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationFinalizeZeroAmountInvoiceMutation, UpdateOrganizationFinalizeZeroAmountInvoiceMutationVariables>;
export const UpdateCustomerNetPaymentTermDocument = gql`
    mutation updateCustomerNetPaymentTerm($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    id
    ...EditCustomerNetPaymentTermForDialog
  }
}
    ${EditCustomerNetPaymentTermForDialogFragmentDoc}`;
export type UpdateCustomerNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;

/**
 * __useUpdateCustomerNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerNetPaymentTermMutation, { data, loading, error }] = useUpdateCustomerNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>(UpdateCustomerNetPaymentTermDocument, options);
      }
export type UpdateCustomerNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationResult = Apollo.MutationResult<UpdateCustomerNetPaymentTermMutation>;
export type UpdateCustomerNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerNetPaymentTermMutation, UpdateCustomerNetPaymentTermMutationVariables>;
export const UpdateOrganizationNetPaymentTermDocument = gql`
    mutation updateOrganizationNetPaymentTerm($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationNetPaymentTermForDialog
  }
}
    ${EditOrganizationNetPaymentTermForDialogFragmentDoc}`;
export type UpdateOrganizationNetPaymentTermMutationFn = Apollo.MutationFunction<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>;

/**
 * __useUpdateOrganizationNetPaymentTermMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationNetPaymentTermMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationNetPaymentTermMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationNetPaymentTermMutation, { data, loading, error }] = useUpdateOrganizationNetPaymentTermMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationNetPaymentTermMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>(UpdateOrganizationNetPaymentTermDocument, options);
      }
export type UpdateOrganizationNetPaymentTermMutationHookResult = ReturnType<typeof useUpdateOrganizationNetPaymentTermMutation>;
export type UpdateOrganizationNetPaymentTermMutationResult = Apollo.MutationResult<UpdateOrganizationNetPaymentTermMutation>;
export type UpdateOrganizationNetPaymentTermMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationNetPaymentTermMutation, UpdateOrganizationNetPaymentTermMutationVariables>;
export const UpdateDocumentLocaleOrganizationDocument = gql`
    mutation updateDocumentLocaleOrganization($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    billingConfiguration {
      id
      documentLocale
    }
  }
}
    `;
export type UpdateDocumentLocaleOrganizationMutationFn = Apollo.MutationFunction<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>;

/**
 * __useUpdateDocumentLocaleOrganizationMutation__
 *
 * To run a mutation, you first call `useUpdateDocumentLocaleOrganizationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDocumentLocaleOrganizationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDocumentLocaleOrganizationMutation, { data, loading, error }] = useUpdateDocumentLocaleOrganizationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDocumentLocaleOrganizationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>(UpdateDocumentLocaleOrganizationDocument, options);
      }
export type UpdateDocumentLocaleOrganizationMutationHookResult = ReturnType<typeof useUpdateDocumentLocaleOrganizationMutation>;
export type UpdateDocumentLocaleOrganizationMutationResult = Apollo.MutationResult<UpdateDocumentLocaleOrganizationMutation>;
export type UpdateDocumentLocaleOrganizationMutationOptions = Apollo.BaseMutationOptions<UpdateDocumentLocaleOrganizationMutation, UpdateDocumentLocaleOrganizationMutationVariables>;
export const UpdateOrganizationGracePeriodDocument = gql`
    mutation updateOrganizationGracePeriod($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    billingConfiguration {
      id
      invoiceGracePeriod
    }
  }
}
    `;
export type UpdateOrganizationGracePeriodMutationFn = Apollo.MutationFunction<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>;

/**
 * __useUpdateOrganizationGracePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationGracePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationGracePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationGracePeriodMutation, { data, loading, error }] = useUpdateOrganizationGracePeriodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationGracePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>(UpdateOrganizationGracePeriodDocument, options);
      }
export type UpdateOrganizationGracePeriodMutationHookResult = ReturnType<typeof useUpdateOrganizationGracePeriodMutation>;
export type UpdateOrganizationGracePeriodMutationResult = Apollo.MutationResult<UpdateOrganizationGracePeriodMutation>;
export type UpdateOrganizationGracePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationGracePeriodMutation, UpdateOrganizationGracePeriodMutationVariables>;
export const UpdateOrganizationInformationsDocument = gql`
    mutation updateOrganizationInformations($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    ...OrganizationInformations
    ...EditOrganizationInformationsDialog
  }
}
    ${OrganizationInformationsFragmentDoc}
${EditOrganizationInformationsDialogFragmentDoc}`;
export type UpdateOrganizationInformationsMutationFn = Apollo.MutationFunction<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>;

/**
 * __useUpdateOrganizationInformationsMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInformationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInformationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInformationsMutation, { data, loading, error }] = useUpdateOrganizationInformationsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInformationsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>(UpdateOrganizationInformationsDocument, options);
      }
export type UpdateOrganizationInformationsMutationHookResult = ReturnType<typeof useUpdateOrganizationInformationsMutation>;
export type UpdateOrganizationInformationsMutationResult = Apollo.MutationResult<UpdateOrganizationInformationsMutation>;
export type UpdateOrganizationInformationsMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInformationsMutation, UpdateOrganizationInformationsMutationVariables>;
export const UpdateOrganizationInvoiceNumberingDocument = gql`
    mutation updateOrganizationInvoiceNumbering($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationInvoiceNumberingDialog
  }
}
    ${EditOrganizationInvoiceNumberingDialogFragmentDoc}`;
export type UpdateOrganizationInvoiceNumberingMutationFn = Apollo.MutationFunction<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>;

/**
 * __useUpdateOrganizationInvoiceNumberingMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInvoiceNumberingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInvoiceNumberingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInvoiceNumberingMutation, { data, loading, error }] = useUpdateOrganizationInvoiceNumberingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInvoiceNumberingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>(UpdateOrganizationInvoiceNumberingDocument, options);
      }
export type UpdateOrganizationInvoiceNumberingMutationHookResult = ReturnType<typeof useUpdateOrganizationInvoiceNumberingMutation>;
export type UpdateOrganizationInvoiceNumberingMutationResult = Apollo.MutationResult<UpdateOrganizationInvoiceNumberingMutation>;
export type UpdateOrganizationInvoiceNumberingMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInvoiceNumberingMutation, UpdateOrganizationInvoiceNumberingMutationVariables>;
export const UpdateOrganizationInvoiceTemplateDocument = gql`
    mutation updateOrganizationInvoiceTemplate($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    ...EditOrganizationInvoiceTemplateDialog
  }
}
    ${EditOrganizationInvoiceTemplateDialogFragmentDoc}`;
export type UpdateOrganizationInvoiceTemplateMutationFn = Apollo.MutationFunction<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>;

/**
 * __useUpdateOrganizationInvoiceTemplateMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationInvoiceTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationInvoiceTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationInvoiceTemplateMutation, { data, loading, error }] = useUpdateOrganizationInvoiceTemplateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationInvoiceTemplateMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>(UpdateOrganizationInvoiceTemplateDocument, options);
      }
export type UpdateOrganizationInvoiceTemplateMutationHookResult = ReturnType<typeof useUpdateOrganizationInvoiceTemplateMutation>;
export type UpdateOrganizationInvoiceTemplateMutationResult = Apollo.MutationResult<UpdateOrganizationInvoiceTemplateMutation>;
export type UpdateOrganizationInvoiceTemplateMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationInvoiceTemplateMutation, UpdateOrganizationInvoiceTemplateMutationVariables>;
export const UpdateOrganizationTimezoneDocument = gql`
    mutation updateOrganizationTimezone($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    timezone
  }
}
    `;
export type UpdateOrganizationTimezoneMutationFn = Apollo.MutationFunction<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>;

/**
 * __useUpdateOrganizationTimezoneMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationTimezoneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationTimezoneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationTimezoneMutation, { data, loading, error }] = useUpdateOrganizationTimezoneMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationTimezoneMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>(UpdateOrganizationTimezoneDocument, options);
      }
export type UpdateOrganizationTimezoneMutationHookResult = ReturnType<typeof useUpdateOrganizationTimezoneMutation>;
export type UpdateOrganizationTimezoneMutationResult = Apollo.MutationResult<UpdateOrganizationTimezoneMutation>;
export type UpdateOrganizationTimezoneMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationTimezoneMutation, UpdateOrganizationTimezoneMutationVariables>;
export const DestroyIntegrationDocument = gql`
    mutation DestroyIntegration($input: DestroyIntegrationInput!) {
  destroyIntegration(input: $input) {
    id
  }
}
    `;
export type DestroyIntegrationMutationFn = Apollo.MutationFunction<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>;

/**
 * __useDestroyIntegrationMutation__
 *
 * To run a mutation, you first call `useDestroyIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyIntegrationMutation, { data, loading, error }] = useDestroyIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>(DestroyIntegrationDocument, options);
      }
export type DestroyIntegrationMutationHookResult = ReturnType<typeof useDestroyIntegrationMutation>;
export type DestroyIntegrationMutationResult = Apollo.MutationResult<DestroyIntegrationMutation>;
export type DestroyIntegrationMutationOptions = Apollo.BaseMutationOptions<DestroyIntegrationMutation, DestroyIntegrationMutationVariables>;
export const CreateOktaIntegrationDocument = gql`
    mutation createOktaIntegration($input: CreateOktaIntegrationInput!) {
  createOktaIntegration(input: $input) {
    id
  }
}
    `;
export type CreateOktaIntegrationMutationFn = Apollo.MutationFunction<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>;

/**
 * __useCreateOktaIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateOktaIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOktaIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOktaIntegrationMutation, { data, loading, error }] = useCreateOktaIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOktaIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>(CreateOktaIntegrationDocument, options);
      }
export type CreateOktaIntegrationMutationHookResult = ReturnType<typeof useCreateOktaIntegrationMutation>;
export type CreateOktaIntegrationMutationResult = Apollo.MutationResult<CreateOktaIntegrationMutation>;
export type CreateOktaIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateOktaIntegrationMutation, CreateOktaIntegrationMutationVariables>;
export const UpdateOktaIntegrationDocument = gql`
    mutation updateOktaIntegration($input: UpdateOktaIntegrationInput!) {
  updateOktaIntegration(input: $input) {
    id
  }
}
    `;
export type UpdateOktaIntegrationMutationFn = Apollo.MutationFunction<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>;

/**
 * __useUpdateOktaIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateOktaIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOktaIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOktaIntegrationMutation, { data, loading, error }] = useUpdateOktaIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOktaIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>(UpdateOktaIntegrationDocument, options);
      }
export type UpdateOktaIntegrationMutationHookResult = ReturnType<typeof useUpdateOktaIntegrationMutation>;
export type UpdateOktaIntegrationMutationResult = Apollo.MutationResult<UpdateOktaIntegrationMutation>;
export type UpdateOktaIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateOktaIntegrationMutation, UpdateOktaIntegrationMutationVariables>;
export const GetOrganizationInfoForPreviewDunningCampaignDocument = gql`
    query getOrganizationInfoForPreviewDunningCampaign {
  organization {
    ...OrganizationInfoForPreviewDunningCampaign
  }
}
    ${OrganizationInfoForPreviewDunningCampaignFragmentDoc}`;

/**
 * __useGetOrganizationInfoForPreviewDunningCampaignQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfoForPreviewDunningCampaignQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfoForPreviewDunningCampaignQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfoForPreviewDunningCampaignQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfoForPreviewDunningCampaignQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
      }
export function useGetOrganizationInfoForPreviewDunningCampaignLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
        }
export function useGetOrganizationInfoForPreviewDunningCampaignSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>(GetOrganizationInfoForPreviewDunningCampaignDocument, options);
        }
export type GetOrganizationInfoForPreviewDunningCampaignQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignLazyQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfoForPreviewDunningCampaignSuspenseQuery>;
export type GetOrganizationInfoForPreviewDunningCampaignQueryResult = Apollo.QueryResult<GetOrganizationInfoForPreviewDunningCampaignQuery, GetOrganizationInfoForPreviewDunningCampaignQueryVariables>;
export const UpdateOrganizationLogoDocument = gql`
    mutation updateOrganizationLogo($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    logoUrl
  }
}
    `;
export type UpdateOrganizationLogoMutationFn = Apollo.MutationFunction<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>;

/**
 * __useUpdateOrganizationLogoMutation__
 *
 * To run a mutation, you first call `useUpdateOrganizationLogoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrganizationLogoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrganizationLogoMutation, { data, loading, error }] = useUpdateOrganizationLogoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrganizationLogoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>(UpdateOrganizationLogoDocument, options);
      }
export type UpdateOrganizationLogoMutationHookResult = ReturnType<typeof useUpdateOrganizationLogoMutation>;
export type UpdateOrganizationLogoMutationResult = Apollo.MutationResult<UpdateOrganizationLogoMutation>;
export type UpdateOrganizationLogoMutationOptions = Apollo.BaseMutationOptions<UpdateOrganizationLogoMutation, UpdateOrganizationLogoMutationVariables>;
export const GetProviderByCodeForAdyenDocument = gql`
    query getProviderByCodeForAdyen($code: String) {
  paymentProvider(code: $code) {
    ... on AdyenProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on StripeProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForAdyenQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForAdyenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForAdyenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForAdyenQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForAdyenQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
      }
export function useGetProviderByCodeForAdyenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export function useGetProviderByCodeForAdyenSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>(GetProviderByCodeForAdyenDocument, options);
        }
export type GetProviderByCodeForAdyenQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenQuery>;
export type GetProviderByCodeForAdyenLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenLazyQuery>;
export type GetProviderByCodeForAdyenSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForAdyenSuspenseQuery>;
export type GetProviderByCodeForAdyenQueryResult = Apollo.QueryResult<GetProviderByCodeForAdyenQuery, GetProviderByCodeForAdyenQueryVariables>;
export const AddAdyenApiKeyDocument = gql`
    mutation addAdyenApiKey($input: AddAdyenPaymentProviderInput!) {
  addAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type AddAdyenApiKeyMutationFn = Apollo.MutationFunction<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;

/**
 * __useAddAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useAddAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAdyenApiKeyMutation, { data, loading, error }] = useAddAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>(AddAdyenApiKeyDocument, options);
      }
export type AddAdyenApiKeyMutationHookResult = ReturnType<typeof useAddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationResult = Apollo.MutationResult<AddAdyenApiKeyMutation>;
export type AddAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<AddAdyenApiKeyMutation, AddAdyenApiKeyMutationVariables>;
export const UpdateAdyenApiKeyDocument = gql`
    mutation updateAdyenApiKey($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    ...AddAdyenProviderDialog
    ...AdyenIntegrationDetails
  }
}
    ${AddAdyenProviderDialogFragmentDoc}
${AdyenIntegrationDetailsFragmentDoc}`;
export type UpdateAdyenApiKeyMutationFn = Apollo.MutationFunction<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;

/**
 * __useUpdateAdyenApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenApiKeyMutation, { data, loading, error }] = useUpdateAdyenApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>(UpdateAdyenApiKeyDocument, options);
      }
export type UpdateAdyenApiKeyMutationHookResult = ReturnType<typeof useUpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationResult = Apollo.MutationResult<UpdateAdyenApiKeyMutation>;
export type UpdateAdyenApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenApiKeyMutation, UpdateAdyenApiKeyMutationVariables>;
export const CreateAnrokIntegrationDocument = gql`
    mutation createAnrokIntegration($input: CreateAnrokIntegrationInput!) {
  createAnrokIntegration(input: $input) {
    id
    ...AddAnrokIntegrationDialog
    ...AnrokIntegrationDetails
  }
}
    ${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationDetailsFragmentDoc}`;
export type CreateAnrokIntegrationMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>;

/**
 * __useCreateAnrokIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationMutation, { data, loading, error }] = useCreateAnrokIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>(CreateAnrokIntegrationDocument, options);
      }
export type CreateAnrokIntegrationMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationMutation>;
export type CreateAnrokIntegrationMutationResult = Apollo.MutationResult<CreateAnrokIntegrationMutation>;
export type CreateAnrokIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationMutation, CreateAnrokIntegrationMutationVariables>;
export const UpdateAnrokIntegrationDocument = gql`
    mutation updateAnrokIntegration($input: UpdateAnrokIntegrationInput!) {
  updateAnrokIntegration(input: $input) {
    id
    ...AddAnrokIntegrationDialog
    ...AnrokIntegrationDetails
  }
}
    ${AddAnrokIntegrationDialogFragmentDoc}
${AnrokIntegrationDetailsFragmentDoc}`;
export type UpdateAnrokIntegrationMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>;

/**
 * __useUpdateAnrokIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationMutation, { data, loading, error }] = useUpdateAnrokIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>(UpdateAnrokIntegrationDocument, options);
      }
export type UpdateAnrokIntegrationMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationMutation>;
export type UpdateAnrokIntegrationMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationMutation>;
export type UpdateAnrokIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationMutation, UpdateAnrokIntegrationMutationVariables>;
export const UpdateAdyenPaymentProviderDocument = gql`
    mutation updateAdyenPaymentProvider($input: UpdateAdyenPaymentProviderInput!) {
  updateAdyenPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateAdyenPaymentProviderMutationFn = Apollo.MutationFunction<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;

/**
 * __useUpdateAdyenPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateAdyenPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAdyenPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAdyenPaymentProviderMutation, { data, loading, error }] = useUpdateAdyenPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAdyenPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>(UpdateAdyenPaymentProviderDocument, options);
      }
export type UpdateAdyenPaymentProviderMutationHookResult = ReturnType<typeof useUpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationResult = Apollo.MutationResult<UpdateAdyenPaymentProviderMutation>;
export type UpdateAdyenPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateAdyenPaymentProviderMutation, UpdateAdyenPaymentProviderMutationVariables>;
export const UpdateGocardlessPaymentProviderDocument = gql`
    mutation updateGocardlessPaymentProvider($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateGocardlessPaymentProviderMutationFn = Apollo.MutationFunction<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;

/**
 * __useUpdateGocardlessPaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessPaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessPaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessPaymentProviderMutation, { data, loading, error }] = useUpdateGocardlessPaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessPaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>(UpdateGocardlessPaymentProviderDocument, options);
      }
export type UpdateGocardlessPaymentProviderMutationHookResult = ReturnType<typeof useUpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationResult = Apollo.MutationResult<UpdateGocardlessPaymentProviderMutation>;
export type UpdateGocardlessPaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessPaymentProviderMutation, UpdateGocardlessPaymentProviderMutationVariables>;
export const UpdateStripePaymentProviderDocument = gql`
    mutation updateStripePaymentProvider($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    successRedirectUrl
  }
}
    `;
export type UpdateStripePaymentProviderMutationFn = Apollo.MutationFunction<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;

/**
 * __useUpdateStripePaymentProviderMutation__
 *
 * To run a mutation, you first call `useUpdateStripePaymentProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripePaymentProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripePaymentProviderMutation, { data, loading, error }] = useUpdateStripePaymentProviderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripePaymentProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>(UpdateStripePaymentProviderDocument, options);
      }
export type UpdateStripePaymentProviderMutationHookResult = ReturnType<typeof useUpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationResult = Apollo.MutationResult<UpdateStripePaymentProviderMutation>;
export type UpdateStripePaymentProviderMutationOptions = Apollo.BaseMutationOptions<UpdateStripePaymentProviderMutation, UpdateStripePaymentProviderMutationVariables>;
export const GetProviderByCodeForGocardlessDocument = gql`
    query getProviderByCodeForGocardless($code: String) {
  paymentProvider(code: $code) {
    ... on GocardlessProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
    ... on StripeProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForGocardlessQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForGocardlessQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForGocardlessQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForGocardlessQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForGocardlessQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
      }
export function useGetProviderByCodeForGocardlessLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export function useGetProviderByCodeForGocardlessSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>(GetProviderByCodeForGocardlessDocument, options);
        }
export type GetProviderByCodeForGocardlessQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessQuery>;
export type GetProviderByCodeForGocardlessLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessLazyQuery>;
export type GetProviderByCodeForGocardlessSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForGocardlessSuspenseQuery>;
export type GetProviderByCodeForGocardlessQueryResult = Apollo.QueryResult<GetProviderByCodeForGocardlessQuery, GetProviderByCodeForGocardlessQueryVariables>;
export const UpdateGocardlessApiKeyDocument = gql`
    mutation updateGocardlessApiKey($input: UpdateGocardlessPaymentProviderInput!) {
  updateGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationDetails
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationDetailsFragmentDoc}`;
export type UpdateGocardlessApiKeyMutationFn = Apollo.MutationFunction<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;

/**
 * __useUpdateGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGocardlessApiKeyMutation, { data, loading, error }] = useUpdateGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>(UpdateGocardlessApiKeyDocument, options);
      }
export type UpdateGocardlessApiKeyMutationHookResult = ReturnType<typeof useUpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationResult = Apollo.MutationResult<UpdateGocardlessApiKeyMutation>;
export type UpdateGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateGocardlessApiKeyMutation, UpdateGocardlessApiKeyMutationVariables>;
export const CreateHubspotIntegrationDocument = gql`
    mutation createHubspotIntegration($input: CreateHubspotIntegrationInput!) {
  createHubspotIntegration(input: $input) {
    ...HubspotForCreateDialog
  }
}
    ${HubspotForCreateDialogFragmentDoc}`;
export type CreateHubspotIntegrationMutationFn = Apollo.MutationFunction<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>;

/**
 * __useCreateHubspotIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateHubspotIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateHubspotIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createHubspotIntegrationMutation, { data, loading, error }] = useCreateHubspotIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateHubspotIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>(CreateHubspotIntegrationDocument, options);
      }
export type CreateHubspotIntegrationMutationHookResult = ReturnType<typeof useCreateHubspotIntegrationMutation>;
export type CreateHubspotIntegrationMutationResult = Apollo.MutationResult<CreateHubspotIntegrationMutation>;
export type CreateHubspotIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateHubspotIntegrationMutation, CreateHubspotIntegrationMutationVariables>;
export const UpdateHubspotIntegrationDocument = gql`
    mutation updateHubspotIntegration($input: UpdateHubspotIntegrationInput!) {
  updateHubspotIntegration(input: $input) {
    ...HubspotForCreateDialog
  }
}
    ${HubspotForCreateDialogFragmentDoc}`;
export type UpdateHubspotIntegrationMutationFn = Apollo.MutationFunction<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>;

/**
 * __useUpdateHubspotIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateHubspotIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHubspotIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHubspotIntegrationMutation, { data, loading, error }] = useUpdateHubspotIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateHubspotIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>(UpdateHubspotIntegrationDocument, options);
      }
export type UpdateHubspotIntegrationMutationHookResult = ReturnType<typeof useUpdateHubspotIntegrationMutation>;
export type UpdateHubspotIntegrationMutationResult = Apollo.MutationResult<UpdateHubspotIntegrationMutation>;
export type UpdateHubspotIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateHubspotIntegrationMutation, UpdateHubspotIntegrationMutationVariables>;
export const UpdateOrgaForLagoTaxManagementDocument = gql`
    mutation updateOrgaForLagoTaxManagement($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
  }
}
    `;
export type UpdateOrgaForLagoTaxManagementMutationFn = Apollo.MutationFunction<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>;

/**
 * __useUpdateOrgaForLagoTaxManagementMutation__
 *
 * To run a mutation, you first call `useUpdateOrgaForLagoTaxManagementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOrgaForLagoTaxManagementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOrgaForLagoTaxManagementMutation, { data, loading, error }] = useUpdateOrgaForLagoTaxManagementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateOrgaForLagoTaxManagementMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>(UpdateOrgaForLagoTaxManagementDocument, options);
      }
export type UpdateOrgaForLagoTaxManagementMutationHookResult = ReturnType<typeof useUpdateOrgaForLagoTaxManagementMutation>;
export type UpdateOrgaForLagoTaxManagementMutationResult = Apollo.MutationResult<UpdateOrgaForLagoTaxManagementMutation>;
export type UpdateOrgaForLagoTaxManagementMutationOptions = Apollo.BaseMutationOptions<UpdateOrgaForLagoTaxManagementMutation, UpdateOrgaForLagoTaxManagementMutationVariables>;
export const CreateNetsuiteIntegrationDocument = gql`
    mutation createNetsuiteIntegration($input: CreateNetsuiteIntegrationInput!) {
  createNetsuiteIntegration(input: $input) {
    ...NetsuiteForCreateDialogDialog
  }
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export type CreateNetsuiteIntegrationMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationMutation, { data, loading, error }] = useCreateNetsuiteIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>(CreateNetsuiteIntegrationDocument, options);
      }
export type CreateNetsuiteIntegrationMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationMutation>;
export type CreateNetsuiteIntegrationMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationMutation>;
export type CreateNetsuiteIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationMutation, CreateNetsuiteIntegrationMutationVariables>;
export const UpdateNetsuiteIntegrationDocument = gql`
    mutation updateNetsuiteIntegration($input: UpdateNetsuiteIntegrationInput!) {
  updateNetsuiteIntegration(input: $input) {
    ...NetsuiteForCreateDialogDialog
  }
}
    ${NetsuiteForCreateDialogDialogFragmentDoc}`;
export type UpdateNetsuiteIntegrationMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>(UpdateNetsuiteIntegrationDocument, options);
      }
export type UpdateNetsuiteIntegrationMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationMutation>;
export type UpdateNetsuiteIntegrationMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationMutation>;
export type UpdateNetsuiteIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationMutation, UpdateNetsuiteIntegrationMutationVariables>;
export const GetProviderByCodeForStripeDocument = gql`
    query getProviderByCodeForStripe($code: String) {
  paymentProvider(code: $code) {
    ... on StripeProvider {
      id
    }
    ... on GocardlessProvider {
      id
    }
    ... on AdyenProvider {
      id
    }
  }
}
    `;

/**
 * __useGetProviderByCodeForStripeQuery__
 *
 * To run a query within a React component, call `useGetProviderByCodeForStripeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProviderByCodeForStripeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProviderByCodeForStripeQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetProviderByCodeForStripeQuery(baseOptions?: Apollo.QueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
      }
export function useGetProviderByCodeForStripeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export function useGetProviderByCodeForStripeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>(GetProviderByCodeForStripeDocument, options);
        }
export type GetProviderByCodeForStripeQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeQuery>;
export type GetProviderByCodeForStripeLazyQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeLazyQuery>;
export type GetProviderByCodeForStripeSuspenseQueryHookResult = ReturnType<typeof useGetProviderByCodeForStripeSuspenseQuery>;
export type GetProviderByCodeForStripeQueryResult = Apollo.QueryResult<GetProviderByCodeForStripeQuery, GetProviderByCodeForStripeQueryVariables>;
export const AddStripeApiKeyDocument = gql`
    mutation addStripeApiKey($input: AddStripePaymentProviderInput!) {
  addStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type AddStripeApiKeyMutationFn = Apollo.MutationFunction<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;

/**
 * __useAddStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useAddStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addStripeApiKeyMutation, { data, loading, error }] = useAddStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>(AddStripeApiKeyDocument, options);
      }
export type AddStripeApiKeyMutationHookResult = ReturnType<typeof useAddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationResult = Apollo.MutationResult<AddStripeApiKeyMutation>;
export type AddStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<AddStripeApiKeyMutation, AddStripeApiKeyMutationVariables>;
export const UpdateStripeApiKeyDocument = gql`
    mutation updateStripeApiKey($input: UpdateStripePaymentProviderInput!) {
  updateStripePaymentProvider(input: $input) {
    id
    ...AddStripeProviderDialog
    ...StripeIntegrationDetails
  }
}
    ${AddStripeProviderDialogFragmentDoc}
${StripeIntegrationDetailsFragmentDoc}`;
export type UpdateStripeApiKeyMutationFn = Apollo.MutationFunction<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;

/**
 * __useUpdateStripeApiKeyMutation__
 *
 * To run a mutation, you first call `useUpdateStripeApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStripeApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStripeApiKeyMutation, { data, loading, error }] = useUpdateStripeApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStripeApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>(UpdateStripeApiKeyDocument, options);
      }
export type UpdateStripeApiKeyMutationHookResult = ReturnType<typeof useUpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationResult = Apollo.MutationResult<UpdateStripeApiKeyMutation>;
export type UpdateStripeApiKeyMutationOptions = Apollo.BaseMutationOptions<UpdateStripeApiKeyMutation, UpdateStripeApiKeyMutationVariables>;
export const CreateXeroIntegrationDocument = gql`
    mutation createXeroIntegration($input: CreateXeroIntegrationInput!) {
  createXeroIntegration(input: $input) {
    ...XeroForCreateDialogDialog
  }
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export type CreateXeroIntegrationMutationFn = Apollo.MutationFunction<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>;

/**
 * __useCreateXeroIntegrationMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationMutation, { data, loading, error }] = useCreateXeroIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>(CreateXeroIntegrationDocument, options);
      }
export type CreateXeroIntegrationMutationHookResult = ReturnType<typeof useCreateXeroIntegrationMutation>;
export type CreateXeroIntegrationMutationResult = Apollo.MutationResult<CreateXeroIntegrationMutation>;
export type CreateXeroIntegrationMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationMutation, CreateXeroIntegrationMutationVariables>;
export const UpdateXeroIntegrationDocument = gql`
    mutation updateXeroIntegration($input: UpdateXeroIntegrationInput!) {
  updateXeroIntegration(input: $input) {
    ...XeroForCreateDialogDialog
  }
}
    ${XeroForCreateDialogDialogFragmentDoc}`;
export type UpdateXeroIntegrationMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>;

/**
 * __useUpdateXeroIntegrationMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationMutation, { data, loading, error }] = useUpdateXeroIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>(UpdateXeroIntegrationDocument, options);
      }
export type UpdateXeroIntegrationMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationMutation>;
export type UpdateXeroIntegrationMutationResult = Apollo.MutationResult<UpdateXeroIntegrationMutation>;
export type UpdateXeroIntegrationMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationMutation, UpdateXeroIntegrationMutationVariables>;
export const GetAnrokIntegrationCollectionMappingsDocument = gql`
    query getAnrokIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...AnrokIntegrationItemsListDefault
    }
  }
}
    ${AnrokIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetAnrokIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAnrokIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables> & ({ variables: GetAnrokIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
      }
export function useGetAnrokIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
        }
export function useGetAnrokIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>(GetAnrokIntegrationCollectionMappingsDocument, options);
        }
export type GetAnrokIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsQuery>;
export type GetAnrokIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsLazyQuery>;
export type GetAnrokIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationCollectionMappingsSuspenseQuery>;
export type GetAnrokIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetAnrokIntegrationCollectionMappingsQuery, GetAnrokIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForAnrokItemsListDocument = gql`
    query getAddOnsForAnrokItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AnrokIntegrationItemsListAddons
    }
  }
}
    ${AnrokIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForAnrokItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForAnrokItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForAnrokItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForAnrokItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForAnrokItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables> & ({ variables: GetAddOnsForAnrokItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
      }
export function useGetAddOnsForAnrokItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
        }
export function useGetAddOnsForAnrokItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>(GetAddOnsForAnrokItemsListDocument, options);
        }
export type GetAddOnsForAnrokItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListQuery>;
export type GetAddOnsForAnrokItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListLazyQuery>;
export type GetAddOnsForAnrokItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForAnrokItemsListSuspenseQuery>;
export type GetAddOnsForAnrokItemsListQueryResult = Apollo.QueryResult<GetAddOnsForAnrokItemsListQuery, GetAddOnsForAnrokItemsListQueryVariables>;
export const GetBillableMetricsForAnrokItemsListDocument = gql`
    query getBillableMetricsForAnrokItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AnrokIntegrationItemsListBillableMetrics
    }
  }
}
    ${AnrokIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForAnrokItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForAnrokItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForAnrokItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForAnrokItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForAnrokItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables> & ({ variables: GetBillableMetricsForAnrokItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
      }
export function useGetBillableMetricsForAnrokItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
        }
export function useGetBillableMetricsForAnrokItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>(GetBillableMetricsForAnrokItemsListDocument, options);
        }
export type GetBillableMetricsForAnrokItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListQuery>;
export type GetBillableMetricsForAnrokItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListLazyQuery>;
export type GetBillableMetricsForAnrokItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForAnrokItemsListSuspenseQuery>;
export type GetBillableMetricsForAnrokItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForAnrokItemsListQuery, GetBillableMetricsForAnrokItemsListQueryVariables>;
export const CreateAnrokIntegrationCollectionMappingDocument = gql`
    mutation createAnrokIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...AnrokIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${AnrokIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>(CreateAnrokIntegrationCollectionMappingDocument, options);
      }
export type CreateAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationCollectionMappingMutation>;
export type CreateAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateAnrokIntegrationCollectionMappingMutation>;
export type CreateAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationCollectionMappingMutation, CreateAnrokIntegrationCollectionMappingMutationVariables>;
export const CreateAnrokIntegrationMappingDocument = gql`
    mutation createAnrokIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...AnrokIntegrationMapItemDialogCollectionItem
  }
}
    ${AnrokIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>;

/**
 * __useCreateAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnrokIntegrationMappingMutation, { data, loading, error }] = useCreateAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>(CreateAnrokIntegrationMappingDocument, options);
      }
export type CreateAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useCreateAnrokIntegrationMappingMutation>;
export type CreateAnrokIntegrationMappingMutationResult = Apollo.MutationResult<CreateAnrokIntegrationMappingMutation>;
export type CreateAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateAnrokIntegrationMappingMutation, CreateAnrokIntegrationMappingMutationVariables>;
export const UpdateAnrokIntegrationCollectionMappingDocument = gql`
    mutation updateAnrokIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>(UpdateAnrokIntegrationCollectionMappingDocument, options);
      }
export type UpdateAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationCollectionMappingMutation>;
export type UpdateAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationCollectionMappingMutation>;
export type UpdateAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationCollectionMappingMutation, UpdateAnrokIntegrationCollectionMappingMutationVariables>;
export const UpdateAnrokIntegrationMappingDocument = gql`
    mutation updateAnrokIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>;

/**
 * __useUpdateAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnrokIntegrationMappingMutation, { data, loading, error }] = useUpdateAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>(UpdateAnrokIntegrationMappingDocument, options);
      }
export type UpdateAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateAnrokIntegrationMappingMutation>;
export type UpdateAnrokIntegrationMappingMutationResult = Apollo.MutationResult<UpdateAnrokIntegrationMappingMutation>;
export type UpdateAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateAnrokIntegrationMappingMutation, UpdateAnrokIntegrationMappingMutationVariables>;
export const DeleteAnrokIntegrationCollectionMappingDocument = gql`
    mutation deleteAnrokIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAnrokIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteAnrokIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAnrokIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnrokIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnrokIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteAnrokIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAnrokIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>(DeleteAnrokIntegrationCollectionMappingDocument, options);
      }
export type DeleteAnrokIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteAnrokIntegrationCollectionMappingMutation>;
export type DeleteAnrokIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteAnrokIntegrationCollectionMappingMutation>;
export type DeleteAnrokIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAnrokIntegrationCollectionMappingMutation, DeleteAnrokIntegrationCollectionMappingMutationVariables>;
export const DeleteAnrokIntegrationMappingDocument = gql`
    mutation deleteAnrokIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteAnrokIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>;

/**
 * __useDeleteAnrokIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteAnrokIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnrokIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnrokIntegrationMappingMutation, { data, loading, error }] = useDeleteAnrokIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAnrokIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>(DeleteAnrokIntegrationMappingDocument, options);
      }
export type DeleteAnrokIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteAnrokIntegrationMappingMutation>;
export type DeleteAnrokIntegrationMappingMutationResult = Apollo.MutationResult<DeleteAnrokIntegrationMappingMutation>;
export type DeleteAnrokIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteAnrokIntegrationMappingMutation, DeleteAnrokIntegrationMappingMutationVariables>;
export const GetAnrokIntegrationsSettingsDocument = gql`
    query getAnrokIntegrationsSettings($id: ID!, $limit: Int) {
  integration(id: $id) {
    ... on AnrokIntegration {
      id
      ...AnrokIntegrationSettings
      ...DeleteAnrokIntegrationDialog
      ...AddAnrokIntegrationDialog
    }
  }
  integrations(limit: $limit) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    ${AnrokIntegrationSettingsFragmentDoc}
${DeleteAnrokIntegrationDialogFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAnrokIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables> & ({ variables: GetAnrokIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
      }
export function useGetAnrokIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
        }
export function useGetAnrokIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>(GetAnrokIntegrationsSettingsDocument, options);
        }
export type GetAnrokIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsQuery>;
export type GetAnrokIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsLazyQuery>;
export type GetAnrokIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsSettingsSuspenseQuery>;
export type GetAnrokIntegrationsSettingsQueryResult = Apollo.QueryResult<GetAnrokIntegrationsSettingsQuery, GetAnrokIntegrationsSettingsQueryVariables>;
export const RetryAllInvoicesDocument = gql`
    mutation retryAllInvoices($input: RetryAllInvoicesInput!) {
  retryAllInvoices(input: $input) {
    metadata {
      totalCount
    }
  }
}
    `;
export type RetryAllInvoicesMutationFn = Apollo.MutationFunction<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>;

/**
 * __useRetryAllInvoicesMutation__
 *
 * To run a mutation, you first call `useRetryAllInvoicesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllInvoicesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllInvoicesMutation, { data, loading, error }] = useRetryAllInvoicesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllInvoicesMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>(RetryAllInvoicesDocument, options);
      }
export type RetryAllInvoicesMutationHookResult = ReturnType<typeof useRetryAllInvoicesMutation>;
export type RetryAllInvoicesMutationResult = Apollo.MutationResult<RetryAllInvoicesMutation>;
export type RetryAllInvoicesMutationOptions = Apollo.BaseMutationOptions<RetryAllInvoicesMutation, RetryAllInvoicesMutationVariables>;
export const DeleteAdyenIntegrationDocument = gql`
    mutation deleteAdyenIntegration($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteAdyenIntegrationMutationFn = Apollo.MutationFunction<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;

/**
 * __useDeleteAdyenIntegrationMutation__
 *
 * To run a mutation, you first call `useDeleteAdyenIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAdyenIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAdyenIntegrationMutation, { data, loading, error }] = useDeleteAdyenIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAdyenIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>(DeleteAdyenIntegrationDocument, options);
      }
export type DeleteAdyenIntegrationMutationHookResult = ReturnType<typeof useDeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationResult = Apollo.MutationResult<DeleteAdyenIntegrationMutation>;
export type DeleteAdyenIntegrationMutationOptions = Apollo.BaseMutationOptions<DeleteAdyenIntegrationMutation, DeleteAdyenIntegrationMutationVariables>;
export const DestroyNangoIntegrationDocument = gql`
    mutation destroyNangoIntegration($input: DestroyIntegrationInput!) {
  destroyIntegration(input: $input) {
    id
  }
}
    `;
export type DestroyNangoIntegrationMutationFn = Apollo.MutationFunction<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>;

/**
 * __useDestroyNangoIntegrationMutation__
 *
 * To run a mutation, you first call `useDestroyNangoIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDestroyNangoIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [destroyNangoIntegrationMutation, { data, loading, error }] = useDestroyNangoIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDestroyNangoIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>(DestroyNangoIntegrationDocument, options);
      }
export type DestroyNangoIntegrationMutationHookResult = ReturnType<typeof useDestroyNangoIntegrationMutation>;
export type DestroyNangoIntegrationMutationResult = Apollo.MutationResult<DestroyNangoIntegrationMutation>;
export type DestroyNangoIntegrationMutationOptions = Apollo.BaseMutationOptions<DestroyNangoIntegrationMutation, DestroyNangoIntegrationMutationVariables>;
export const DeleteGocardlessDocument = gql`
    mutation deleteGocardless($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteGocardlessMutationFn = Apollo.MutationFunction<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;

/**
 * __useDeleteGocardlessMutation__
 *
 * To run a mutation, you first call `useDeleteGocardlessMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGocardlessMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGocardlessMutation, { data, loading, error }] = useDeleteGocardlessMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteGocardlessMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>(DeleteGocardlessDocument, options);
      }
export type DeleteGocardlessMutationHookResult = ReturnType<typeof useDeleteGocardlessMutation>;
export type DeleteGocardlessMutationResult = Apollo.MutationResult<DeleteGocardlessMutation>;
export type DeleteGocardlessMutationOptions = Apollo.BaseMutationOptions<DeleteGocardlessMutation, DeleteGocardlessMutationVariables>;
export const DeleteStripeDocument = gql`
    mutation deleteStripe($input: DestroyPaymentProviderInput!) {
  destroyPaymentProvider(input: $input) {
    id
  }
}
    `;
export type DeleteStripeMutationFn = Apollo.MutationFunction<DeleteStripeMutation, DeleteStripeMutationVariables>;

/**
 * __useDeleteStripeMutation__
 *
 * To run a mutation, you first call `useDeleteStripeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStripeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStripeMutation, { data, loading, error }] = useDeleteStripeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteStripeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStripeMutation, DeleteStripeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStripeMutation, DeleteStripeMutationVariables>(DeleteStripeDocument, options);
      }
export type DeleteStripeMutationHookResult = ReturnType<typeof useDeleteStripeMutation>;
export type DeleteStripeMutationResult = Apollo.MutationResult<DeleteStripeMutation>;
export type DeleteStripeMutationOptions = Apollo.BaseMutationOptions<DeleteStripeMutation, DeleteStripeMutationVariables>;
export const GetNetsuiteIntegrationCollectionMappingsDocument = gql`
    query getNetsuiteIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...NetsuiteIntegrationItemsListDefault
    }
  }
}
    ${NetsuiteIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables> & ({ variables: GetNetsuiteIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
      }
export function useGetNetsuiteIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
        }
export function useGetNetsuiteIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>(GetNetsuiteIntegrationCollectionMappingsDocument, options);
        }
export type GetNetsuiteIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsQuery>;
export type GetNetsuiteIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsLazyQuery>;
export type GetNetsuiteIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationCollectionMappingsSuspenseQuery>;
export type GetNetsuiteIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationCollectionMappingsQuery, GetNetsuiteIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForNetsuiteItemsListDocument = gql`
    query getAddOnsForNetsuiteItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...NetsuiteIntegrationItemsListAddons
    }
  }
}
    ${NetsuiteIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForNetsuiteItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForNetsuiteItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForNetsuiteItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForNetsuiteItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForNetsuiteItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables> & ({ variables: GetAddOnsForNetsuiteItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
      }
export function useGetAddOnsForNetsuiteItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
        }
export function useGetAddOnsForNetsuiteItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>(GetAddOnsForNetsuiteItemsListDocument, options);
        }
export type GetAddOnsForNetsuiteItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListQuery>;
export type GetAddOnsForNetsuiteItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListLazyQuery>;
export type GetAddOnsForNetsuiteItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForNetsuiteItemsListSuspenseQuery>;
export type GetAddOnsForNetsuiteItemsListQueryResult = Apollo.QueryResult<GetAddOnsForNetsuiteItemsListQuery, GetAddOnsForNetsuiteItemsListQueryVariables>;
export const GetBillableMetricsForNetsuiteItemsListDocument = gql`
    query getBillableMetricsForNetsuiteItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...NetsuiteIntegrationItemsListBillableMetrics
    }
  }
}
    ${NetsuiteIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForNetsuiteItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForNetsuiteItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForNetsuiteItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForNetsuiteItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForNetsuiteItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables> & ({ variables: GetBillableMetricsForNetsuiteItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
      }
export function useGetBillableMetricsForNetsuiteItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
        }
export function useGetBillableMetricsForNetsuiteItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>(GetBillableMetricsForNetsuiteItemsListDocument, options);
        }
export type GetBillableMetricsForNetsuiteItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListQuery>;
export type GetBillableMetricsForNetsuiteItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListLazyQuery>;
export type GetBillableMetricsForNetsuiteItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForNetsuiteItemsListSuspenseQuery>;
export type GetBillableMetricsForNetsuiteItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForNetsuiteItemsListQuery, GetBillableMetricsForNetsuiteItemsListQueryVariables>;
export const CreateNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation createNetsuiteIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...NetsuiteIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${NetsuiteIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>(CreateNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type CreateNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationCollectionMappingMutation>;
export type CreateNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationCollectionMappingMutation>;
export type CreateNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationCollectionMappingMutation, CreateNetsuiteIntegrationCollectionMappingMutationVariables>;
export const CreateNetsuiteIntegrationMappingDocument = gql`
    mutation createNetsuiteIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...NetsuiteIntegrationMapItemDialogCollectionItem
  }
}
    ${NetsuiteIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useCreateNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNetsuiteIntegrationMappingMutation, { data, loading, error }] = useCreateNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>(CreateNetsuiteIntegrationMappingDocument, options);
      }
export type CreateNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useCreateNetsuiteIntegrationMappingMutation>;
export type CreateNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<CreateNetsuiteIntegrationMappingMutation>;
export type CreateNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateNetsuiteIntegrationMappingMutation, CreateNetsuiteIntegrationMappingMutationVariables>;
export const UpdateNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation updateNetsuiteIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>(UpdateNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type UpdateNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationCollectionMappingMutation>;
export type UpdateNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationCollectionMappingMutation>;
export type UpdateNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationCollectionMappingMutation, UpdateNetsuiteIntegrationCollectionMappingMutationVariables>;
export const UpdateNetsuiteIntegrationMappingDocument = gql`
    mutation updateNetsuiteIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useUpdateNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNetsuiteIntegrationMappingMutation, { data, loading, error }] = useUpdateNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>(UpdateNetsuiteIntegrationMappingDocument, options);
      }
export type UpdateNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateNetsuiteIntegrationMappingMutation>;
export type UpdateNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<UpdateNetsuiteIntegrationMappingMutation>;
export type UpdateNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateNetsuiteIntegrationMappingMutation, UpdateNetsuiteIntegrationMappingMutationVariables>;
export const DeleteNetsuiteIntegrationCollectionMappingDocument = gql`
    mutation deleteNetsuiteIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteNetsuiteIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteNetsuiteIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteNetsuiteIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNetsuiteIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNetsuiteIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteNetsuiteIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteNetsuiteIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>(DeleteNetsuiteIntegrationCollectionMappingDocument, options);
      }
export type DeleteNetsuiteIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteNetsuiteIntegrationCollectionMappingMutation>;
export type DeleteNetsuiteIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteNetsuiteIntegrationCollectionMappingMutation>;
export type DeleteNetsuiteIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteNetsuiteIntegrationCollectionMappingMutation, DeleteNetsuiteIntegrationCollectionMappingMutationVariables>;
export const DeleteNetsuiteIntegrationMappingDocument = gql`
    mutation deleteNetsuiteIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteNetsuiteIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>;

/**
 * __useDeleteNetsuiteIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteNetsuiteIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNetsuiteIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNetsuiteIntegrationMappingMutation, { data, loading, error }] = useDeleteNetsuiteIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteNetsuiteIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>(DeleteNetsuiteIntegrationMappingDocument, options);
      }
export type DeleteNetsuiteIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteNetsuiteIntegrationMappingMutation>;
export type DeleteNetsuiteIntegrationMappingMutationResult = Apollo.MutationResult<DeleteNetsuiteIntegrationMappingMutation>;
export type DeleteNetsuiteIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteNetsuiteIntegrationMappingMutation, DeleteNetsuiteIntegrationMappingMutationVariables>;
export const GetNetsuiteIntegrationsSettingsDocument = gql`
    query getNetsuiteIntegrationsSettings($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on NetsuiteIntegration {
      id
      ...NetsuiteIntegrationSettings
      ...DeleteNetsuiteIntegrationDialog
      ...NetsuiteForCreateDialogDialog
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on NetsuiteIntegration {
        id
      }
    }
  }
}
    ${NetsuiteIntegrationSettingsFragmentDoc}
${DeleteNetsuiteIntegrationDialogFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables> & ({ variables: GetNetsuiteIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
      }
export function useGetNetsuiteIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
        }
export function useGetNetsuiteIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>(GetNetsuiteIntegrationsSettingsDocument, options);
        }
export type GetNetsuiteIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsQuery>;
export type GetNetsuiteIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsLazyQuery>;
export type GetNetsuiteIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsSettingsSuspenseQuery>;
export type GetNetsuiteIntegrationsSettingsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsSettingsQuery, GetNetsuiteIntegrationsSettingsQueryVariables>;
export const GetXeroIntegrationCollectionMappingsDocument = gql`
    query getXeroIntegrationCollectionMappings($integrationId: ID!) {
  integrationCollectionMappings(integrationId: $integrationId) {
    collection {
      id
      ...XeroIntegrationItemsListDefault
    }
  }
}
    ${XeroIntegrationItemsListDefaultFragmentDoc}`;

/**
 * __useGetXeroIntegrationCollectionMappingsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationCollectionMappingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationCollectionMappingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationCollectionMappingsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetXeroIntegrationCollectionMappingsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables> & ({ variables: GetXeroIntegrationCollectionMappingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
      }
export function useGetXeroIntegrationCollectionMappingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
        }
export function useGetXeroIntegrationCollectionMappingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>(GetXeroIntegrationCollectionMappingsDocument, options);
        }
export type GetXeroIntegrationCollectionMappingsQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsQuery>;
export type GetXeroIntegrationCollectionMappingsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsLazyQuery>;
export type GetXeroIntegrationCollectionMappingsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationCollectionMappingsSuspenseQuery>;
export type GetXeroIntegrationCollectionMappingsQueryResult = Apollo.QueryResult<GetXeroIntegrationCollectionMappingsQuery, GetXeroIntegrationCollectionMappingsQueryVariables>;
export const GetAddOnsForXeroItemsListDocument = gql`
    query getAddOnsForXeroItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...XeroIntegrationItemsListAddons
    }
  }
}
    ${XeroIntegrationItemsListAddonsFragmentDoc}`;

/**
 * __useGetAddOnsForXeroItemsListQuery__
 *
 * To run a query within a React component, call `useGetAddOnsForXeroItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnsForXeroItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnsForXeroItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetAddOnsForXeroItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables> & ({ variables: GetAddOnsForXeroItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
      }
export function useGetAddOnsForXeroItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
        }
export function useGetAddOnsForXeroItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>(GetAddOnsForXeroItemsListDocument, options);
        }
export type GetAddOnsForXeroItemsListQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListQuery>;
export type GetAddOnsForXeroItemsListLazyQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListLazyQuery>;
export type GetAddOnsForXeroItemsListSuspenseQueryHookResult = ReturnType<typeof useGetAddOnsForXeroItemsListSuspenseQuery>;
export type GetAddOnsForXeroItemsListQueryResult = Apollo.QueryResult<GetAddOnsForXeroItemsListQuery, GetAddOnsForXeroItemsListQueryVariables>;
export const GetBillableMetricsForXeroItemsListDocument = gql`
    query getBillableMetricsForXeroItemsList($page: Int, $limit: Int, $searchTerm: String, $integrationId: ID!) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...XeroIntegrationItemsListBillableMetrics
    }
  }
}
    ${XeroIntegrationItemsListBillableMetricsFragmentDoc}`;

/**
 * __useGetBillableMetricsForXeroItemsListQuery__
 *
 * To run a query within a React component, call `useGetBillableMetricsForXeroItemsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBillableMetricsForXeroItemsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBillableMetricsForXeroItemsListQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *      integrationId: // value for 'integrationId'
 *   },
 * });
 */
export function useGetBillableMetricsForXeroItemsListQuery(baseOptions: Apollo.QueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables> & ({ variables: GetBillableMetricsForXeroItemsListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
      }
export function useGetBillableMetricsForXeroItemsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
        }
export function useGetBillableMetricsForXeroItemsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>(GetBillableMetricsForXeroItemsListDocument, options);
        }
export type GetBillableMetricsForXeroItemsListQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListQuery>;
export type GetBillableMetricsForXeroItemsListLazyQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListLazyQuery>;
export type GetBillableMetricsForXeroItemsListSuspenseQueryHookResult = ReturnType<typeof useGetBillableMetricsForXeroItemsListSuspenseQuery>;
export type GetBillableMetricsForXeroItemsListQueryResult = Apollo.QueryResult<GetBillableMetricsForXeroItemsListQuery, GetBillableMetricsForXeroItemsListQueryVariables>;
export const GetXeroIntegrationItemsDocument = gql`
    query getXeroIntegrationItems($integrationId: ID!, $itemType: IntegrationItemTypeEnum, $page: Int, $limit: Int, $searchTerm: String) {
  integrationItems(
    integrationId: $integrationId
    itemType: $itemType
    page: $page
    limit: $limit
    searchTerm: $searchTerm
  ) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
    metadata {
      currentPage
      totalPages
      totalCount
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationItemsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationItemsQuery({
 *   variables: {
 *      integrationId: // value for 'integrationId'
 *      itemType: // value for 'itemType'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetXeroIntegrationItemsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables> & ({ variables: GetXeroIntegrationItemsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
      }
export function useGetXeroIntegrationItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
        }
export function useGetXeroIntegrationItemsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>(GetXeroIntegrationItemsDocument, options);
        }
export type GetXeroIntegrationItemsQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsQuery>;
export type GetXeroIntegrationItemsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsLazyQuery>;
export type GetXeroIntegrationItemsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationItemsSuspenseQuery>;
export type GetXeroIntegrationItemsQueryResult = Apollo.QueryResult<GetXeroIntegrationItemsQuery, GetXeroIntegrationItemsQueryVariables>;
export const TriggerXeroIntegrationAccountsRefetchDocument = gql`
    mutation triggerXeroIntegrationAccountsRefetch($input: FetchIntegrationAccountsInput!) {
  fetchIntegrationAccounts(input: $input) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;
export type TriggerXeroIntegrationAccountsRefetchMutationFn = Apollo.MutationFunction<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>;

/**
 * __useTriggerXeroIntegrationAccountsRefetchMutation__
 *
 * To run a mutation, you first call `useTriggerXeroIntegrationAccountsRefetchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerXeroIntegrationAccountsRefetchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerXeroIntegrationAccountsRefetchMutation, { data, loading, error }] = useTriggerXeroIntegrationAccountsRefetchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTriggerXeroIntegrationAccountsRefetchMutation(baseOptions?: Apollo.MutationHookOptions<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>(TriggerXeroIntegrationAccountsRefetchDocument, options);
      }
export type TriggerXeroIntegrationAccountsRefetchMutationHookResult = ReturnType<typeof useTriggerXeroIntegrationAccountsRefetchMutation>;
export type TriggerXeroIntegrationAccountsRefetchMutationResult = Apollo.MutationResult<TriggerXeroIntegrationAccountsRefetchMutation>;
export type TriggerXeroIntegrationAccountsRefetchMutationOptions = Apollo.BaseMutationOptions<TriggerXeroIntegrationAccountsRefetchMutation, TriggerXeroIntegrationAccountsRefetchMutationVariables>;
export const TriggerXeroIntegrationItemsRefetchDocument = gql`
    mutation triggerXeroIntegrationItemsRefetch($input: FetchIntegrationItemsInput!) {
  fetchIntegrationItems(input: $input) {
    collection {
      ...XeroIntegrationMapItemDialog
    }
  }
}
    ${XeroIntegrationMapItemDialogFragmentDoc}`;
export type TriggerXeroIntegrationItemsRefetchMutationFn = Apollo.MutationFunction<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>;

/**
 * __useTriggerXeroIntegrationItemsRefetchMutation__
 *
 * To run a mutation, you first call `useTriggerXeroIntegrationItemsRefetchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerXeroIntegrationItemsRefetchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerXeroIntegrationItemsRefetchMutation, { data, loading, error }] = useTriggerXeroIntegrationItemsRefetchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTriggerXeroIntegrationItemsRefetchMutation(baseOptions?: Apollo.MutationHookOptions<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>(TriggerXeroIntegrationItemsRefetchDocument, options);
      }
export type TriggerXeroIntegrationItemsRefetchMutationHookResult = ReturnType<typeof useTriggerXeroIntegrationItemsRefetchMutation>;
export type TriggerXeroIntegrationItemsRefetchMutationResult = Apollo.MutationResult<TriggerXeroIntegrationItemsRefetchMutation>;
export type TriggerXeroIntegrationItemsRefetchMutationOptions = Apollo.BaseMutationOptions<TriggerXeroIntegrationItemsRefetchMutation, TriggerXeroIntegrationItemsRefetchMutationVariables>;
export const CreateXeroIntegrationCollectionMappingDocument = gql`
    mutation createXeroIntegrationCollectionMapping($input: CreateIntegrationCollectionMappingInput!) {
  createIntegrationCollectionMapping(input: $input) {
    id
    ...XeroIntegrationMapItemDialogCollectionMappingItem
  }
}
    ${XeroIntegrationMapItemDialogCollectionMappingItemFragmentDoc}`;
export type CreateXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useCreateXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useCreateXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>(CreateXeroIntegrationCollectionMappingDocument, options);
      }
export type CreateXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useCreateXeroIntegrationCollectionMappingMutation>;
export type CreateXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<CreateXeroIntegrationCollectionMappingMutation>;
export type CreateXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationCollectionMappingMutation, CreateXeroIntegrationCollectionMappingMutationVariables>;
export const CreateXeroIntegrationMappingDocument = gql`
    mutation createXeroIntegrationMapping($input: CreateIntegrationMappingInput!) {
  createIntegrationMapping(input: $input) {
    id
    ...XeroIntegrationMapItemDialogCollectionItem
  }
}
    ${XeroIntegrationMapItemDialogCollectionItemFragmentDoc}`;
export type CreateXeroIntegrationMappingMutationFn = Apollo.MutationFunction<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>;

/**
 * __useCreateXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useCreateXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createXeroIntegrationMappingMutation, { data, loading, error }] = useCreateXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>(CreateXeroIntegrationMappingDocument, options);
      }
export type CreateXeroIntegrationMappingMutationHookResult = ReturnType<typeof useCreateXeroIntegrationMappingMutation>;
export type CreateXeroIntegrationMappingMutationResult = Apollo.MutationResult<CreateXeroIntegrationMappingMutation>;
export type CreateXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<CreateXeroIntegrationMappingMutation, CreateXeroIntegrationMappingMutationVariables>;
export const UpdateXeroIntegrationCollectionMappingDocument = gql`
    mutation updateXeroIntegrationCollectionMapping($input: UpdateIntegrationCollectionMappingInput!) {
  updateIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type UpdateXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useUpdateXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useUpdateXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>(UpdateXeroIntegrationCollectionMappingDocument, options);
      }
export type UpdateXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationCollectionMappingMutation>;
export type UpdateXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<UpdateXeroIntegrationCollectionMappingMutation>;
export type UpdateXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationCollectionMappingMutation, UpdateXeroIntegrationCollectionMappingMutationVariables>;
export const UpdateXeroIntegrationMappingDocument = gql`
    mutation updateXeroIntegrationMapping($input: UpdateIntegrationMappingInput!) {
  updateIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type UpdateXeroIntegrationMappingMutationFn = Apollo.MutationFunction<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>;

/**
 * __useUpdateXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useUpdateXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateXeroIntegrationMappingMutation, { data, loading, error }] = useUpdateXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>(UpdateXeroIntegrationMappingDocument, options);
      }
export type UpdateXeroIntegrationMappingMutationHookResult = ReturnType<typeof useUpdateXeroIntegrationMappingMutation>;
export type UpdateXeroIntegrationMappingMutationResult = Apollo.MutationResult<UpdateXeroIntegrationMappingMutation>;
export type UpdateXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<UpdateXeroIntegrationMappingMutation, UpdateXeroIntegrationMappingMutationVariables>;
export const DeleteXeroIntegrationCollectionMappingDocument = gql`
    mutation deleteXeroIntegrationCollectionMapping($input: DestroyIntegrationCollectionMappingInput!) {
  destroyIntegrationCollectionMapping(input: $input) {
    id
  }
}
    `;
export type DeleteXeroIntegrationCollectionMappingMutationFn = Apollo.MutationFunction<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>;

/**
 * __useDeleteXeroIntegrationCollectionMappingMutation__
 *
 * To run a mutation, you first call `useDeleteXeroIntegrationCollectionMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteXeroIntegrationCollectionMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteXeroIntegrationCollectionMappingMutation, { data, loading, error }] = useDeleteXeroIntegrationCollectionMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteXeroIntegrationCollectionMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>(DeleteXeroIntegrationCollectionMappingDocument, options);
      }
export type DeleteXeroIntegrationCollectionMappingMutationHookResult = ReturnType<typeof useDeleteXeroIntegrationCollectionMappingMutation>;
export type DeleteXeroIntegrationCollectionMappingMutationResult = Apollo.MutationResult<DeleteXeroIntegrationCollectionMappingMutation>;
export type DeleteXeroIntegrationCollectionMappingMutationOptions = Apollo.BaseMutationOptions<DeleteXeroIntegrationCollectionMappingMutation, DeleteXeroIntegrationCollectionMappingMutationVariables>;
export const DeleteXeroIntegrationMappingDocument = gql`
    mutation deleteXeroIntegrationMapping($input: DestroyIntegrationMappingInput!) {
  destroyIntegrationMapping(input: $input) {
    id
  }
}
    `;
export type DeleteXeroIntegrationMappingMutationFn = Apollo.MutationFunction<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>;

/**
 * __useDeleteXeroIntegrationMappingMutation__
 *
 * To run a mutation, you first call `useDeleteXeroIntegrationMappingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteXeroIntegrationMappingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteXeroIntegrationMappingMutation, { data, loading, error }] = useDeleteXeroIntegrationMappingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteXeroIntegrationMappingMutation(baseOptions?: Apollo.MutationHookOptions<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>(DeleteXeroIntegrationMappingDocument, options);
      }
export type DeleteXeroIntegrationMappingMutationHookResult = ReturnType<typeof useDeleteXeroIntegrationMappingMutation>;
export type DeleteXeroIntegrationMappingMutationResult = Apollo.MutationResult<DeleteXeroIntegrationMappingMutation>;
export type DeleteXeroIntegrationMappingMutationOptions = Apollo.BaseMutationOptions<DeleteXeroIntegrationMappingMutation, DeleteXeroIntegrationMappingMutationVariables>;
export const GetXeroIntegrationsSettingsDocument = gql`
    query getXeroIntegrationsSettings($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on XeroIntegration {
      id
      ...XeroIntegrationSettings
      ...DeleteXeroIntegrationDialog
      ...XeroForCreateDialogDialog
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on XeroIntegration {
        id
      }
    }
  }
}
    ${XeroIntegrationSettingsFragmentDoc}
${DeleteXeroIntegrationDialogFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationsSettingsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetXeroIntegrationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables> & ({ variables: GetXeroIntegrationsSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
      }
export function useGetXeroIntegrationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
        }
export function useGetXeroIntegrationsSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>(GetXeroIntegrationsSettingsDocument, options);
        }
export type GetXeroIntegrationsSettingsQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsQuery>;
export type GetXeroIntegrationsSettingsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsLazyQuery>;
export type GetXeroIntegrationsSettingsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsSettingsSuspenseQuery>;
export type GetXeroIntegrationsSettingsQueryResult = Apollo.QueryResult<GetXeroIntegrationsSettingsQuery, GetXeroIntegrationsSettingsQueryVariables>;
export const CreateInviteDocument = gql`
    mutation createInvite($input: CreateInviteInput!) {
  createInvite(input: $input) {
    id
    token
    ...InviteItemForMembersSettings
  }
}
    ${InviteItemForMembersSettingsFragmentDoc}`;
export type CreateInviteMutationFn = Apollo.MutationFunction<CreateInviteMutation, CreateInviteMutationVariables>;

/**
 * __useCreateInviteMutation__
 *
 * To run a mutation, you first call `useCreateInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInviteMutation, { data, loading, error }] = useCreateInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInviteMutation(baseOptions?: Apollo.MutationHookOptions<CreateInviteMutation, CreateInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInviteMutation, CreateInviteMutationVariables>(CreateInviteDocument, options);
      }
export type CreateInviteMutationHookResult = ReturnType<typeof useCreateInviteMutation>;
export type CreateInviteMutationResult = Apollo.MutationResult<CreateInviteMutation>;
export type CreateInviteMutationOptions = Apollo.BaseMutationOptions<CreateInviteMutation, CreateInviteMutationVariables>;
export const UpdateInviteRoleDocument = gql`
    mutation updateInviteRole($input: UpdateInviteInput!) {
  updateInvite(input: $input) {
    id
    ...InviteForEditRoleForDialog
  }
}
    ${InviteForEditRoleForDialogFragmentDoc}`;
export type UpdateInviteRoleMutationFn = Apollo.MutationFunction<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>;

/**
 * __useUpdateInviteRoleMutation__
 *
 * To run a mutation, you first call `useUpdateInviteRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInviteRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInviteRoleMutation, { data, loading, error }] = useUpdateInviteRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInviteRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>(UpdateInviteRoleDocument, options);
      }
export type UpdateInviteRoleMutationHookResult = ReturnType<typeof useUpdateInviteRoleMutation>;
export type UpdateInviteRoleMutationResult = Apollo.MutationResult<UpdateInviteRoleMutation>;
export type UpdateInviteRoleMutationOptions = Apollo.BaseMutationOptions<UpdateInviteRoleMutation, UpdateInviteRoleMutationVariables>;
export const UpdateMembershipRoleDocument = gql`
    mutation updateMembershipRole($input: UpdateMembershipInput!) {
  updateMembership(input: $input) {
    id
    ...MemberForEditRoleForDialog
  }
}
    ${MemberForEditRoleForDialogFragmentDoc}`;
export type UpdateMembershipRoleMutationFn = Apollo.MutationFunction<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>;

/**
 * __useUpdateMembershipRoleMutation__
 *
 * To run a mutation, you first call `useUpdateMembershipRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMembershipRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMembershipRoleMutation, { data, loading, error }] = useUpdateMembershipRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMembershipRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>(UpdateMembershipRoleDocument, options);
      }
export type UpdateMembershipRoleMutationHookResult = ReturnType<typeof useUpdateMembershipRoleMutation>;
export type UpdateMembershipRoleMutationResult = Apollo.MutationResult<UpdateMembershipRoleMutation>;
export type UpdateMembershipRoleMutationOptions = Apollo.BaseMutationOptions<UpdateMembershipRoleMutation, UpdateMembershipRoleMutationVariables>;
export const RevokeInviteDocument = gql`
    mutation revokeInvite($input: RevokeInviteInput!) {
  revokeInvite(input: $input) {
    id
  }
}
    `;
export type RevokeInviteMutationFn = Apollo.MutationFunction<RevokeInviteMutation, RevokeInviteMutationVariables>;

/**
 * __useRevokeInviteMutation__
 *
 * To run a mutation, you first call `useRevokeInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeInviteMutation, { data, loading, error }] = useRevokeInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeInviteMutation(baseOptions?: Apollo.MutationHookOptions<RevokeInviteMutation, RevokeInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeInviteMutation, RevokeInviteMutationVariables>(RevokeInviteDocument, options);
      }
export type RevokeInviteMutationHookResult = ReturnType<typeof useRevokeInviteMutation>;
export type RevokeInviteMutationResult = Apollo.MutationResult<RevokeInviteMutation>;
export type RevokeInviteMutationOptions = Apollo.BaseMutationOptions<RevokeInviteMutation, RevokeInviteMutationVariables>;
export const RevokeMembershipDocument = gql`
    mutation revokeMembership($input: RevokeMembershipInput!) {
  revokeMembership(input: $input) {
    id
  }
}
    `;
export type RevokeMembershipMutationFn = Apollo.MutationFunction<RevokeMembershipMutation, RevokeMembershipMutationVariables>;

/**
 * __useRevokeMembershipMutation__
 *
 * To run a mutation, you first call `useRevokeMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevokeMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revokeMembershipMutation, { data, loading, error }] = useRevokeMembershipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRevokeMembershipMutation(baseOptions?: Apollo.MutationHookOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevokeMembershipMutation, RevokeMembershipMutationVariables>(RevokeMembershipDocument, options);
      }
export type RevokeMembershipMutationHookResult = ReturnType<typeof useRevokeMembershipMutation>;
export type RevokeMembershipMutationResult = Apollo.MutationResult<RevokeMembershipMutation>;
export type RevokeMembershipMutationOptions = Apollo.BaseMutationOptions<RevokeMembershipMutation, RevokeMembershipMutationVariables>;
export const CustomerForSubscriptionUsageDocument = gql`
    query customerForSubscriptionUsage($customerId: ID!) {
  customer(id: $customerId) {
    id
    applicableTimezone
  }
}
    `;

/**
 * __useCustomerForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useCustomerForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerForSubscriptionUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *   },
 * });
 */
export function useCustomerForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables> & ({ variables: CustomerForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
      }
export function useCustomerForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
        }
export function useCustomerForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>(CustomerForSubscriptionUsageDocument, options);
        }
export type CustomerForSubscriptionUsageQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageQuery>;
export type CustomerForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageLazyQuery>;
export type CustomerForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useCustomerForSubscriptionUsageSuspenseQuery>;
export type CustomerForSubscriptionUsageQueryResult = Apollo.QueryResult<CustomerForSubscriptionUsageQuery, CustomerForSubscriptionUsageQueryVariables>;
export const SubscrptionForSubscriptionUsageDocument = gql`
    query subscrptionForSubscriptionUsage($subscription: ID!) {
  subscription(id: $subscription) {
    id
    name
    plan {
      id
      name
      code
    }
    customer {
      id
      applicableTimezone
    }
  }
}
    `;

/**
 * __useSubscrptionForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useSubscrptionForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscrptionForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscrptionForSubscriptionUsageQuery({
 *   variables: {
 *      subscription: // value for 'subscription'
 *   },
 * });
 */
export function useSubscrptionForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables> & ({ variables: SubscrptionForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
      }
export function useSubscrptionForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
        }
export function useSubscrptionForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>(SubscrptionForSubscriptionUsageDocument, options);
        }
export type SubscrptionForSubscriptionUsageQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageQuery>;
export type SubscrptionForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageLazyQuery>;
export type SubscrptionForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useSubscrptionForSubscriptionUsageSuspenseQuery>;
export type SubscrptionForSubscriptionUsageQueryResult = Apollo.QueryResult<SubscrptionForSubscriptionUsageQuery, SubscrptionForSubscriptionUsageQueryVariables>;
export const UsageForSubscriptionUsageDocument = gql`
    query usageForSubscriptionUsage($customerId: ID!, $subscriptionId: ID!) {
  customerUsage(customerId: $customerId, subscriptionId: $subscriptionId) {
    amountCents
    ...SubscriptionCurrentUsageTableComponentCustomerUsage
    ...CustomerUsageForUsageDetails
  }
}
    ${SubscriptionCurrentUsageTableComponentCustomerUsageFragmentDoc}
${CustomerUsageForUsageDetailsFragmentDoc}`;

/**
 * __useUsageForSubscriptionUsageQuery__
 *
 * To run a query within a React component, call `useUsageForSubscriptionUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsageForSubscriptionUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsageForSubscriptionUsageQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useUsageForSubscriptionUsageQuery(baseOptions: Apollo.QueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables> & ({ variables: UsageForSubscriptionUsageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
      }
export function useUsageForSubscriptionUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
        }
export function useUsageForSubscriptionUsageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>(UsageForSubscriptionUsageDocument, options);
        }
export type UsageForSubscriptionUsageQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageQuery>;
export type UsageForSubscriptionUsageLazyQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageLazyQuery>;
export type UsageForSubscriptionUsageSuspenseQueryHookResult = ReturnType<typeof useUsageForSubscriptionUsageSuspenseQuery>;
export type UsageForSubscriptionUsageQueryResult = Apollo.QueryResult<UsageForSubscriptionUsageQuery, UsageForSubscriptionUsageQueryVariables>;
export const GetSubscriptionForDetailsOverviewDocument = gql`
    query getSubscriptionForDetailsOverview($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    plan {
      id
    }
    ...SubscriptionForSubscriptionInformations
  }
}
    ${SubscriptionForSubscriptionInformationsFragmentDoc}`;

/**
 * __useGetSubscriptionForDetailsOverviewQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsOverviewQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsOverviewQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables> & ({ variables: GetSubscriptionForDetailsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
      }
export function useGetSubscriptionForDetailsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export function useGetSubscriptionForDetailsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>(GetSubscriptionForDetailsOverviewDocument, options);
        }
export type GetSubscriptionForDetailsOverviewQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewQuery>;
export type GetSubscriptionForDetailsOverviewLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewLazyQuery>;
export type GetSubscriptionForDetailsOverviewSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsOverviewSuspenseQuery>;
export type GetSubscriptionForDetailsOverviewQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsOverviewQuery, GetSubscriptionForDetailsOverviewQueryVariables>;
export const GetSubscriptionForSubscriptionUsageLifetimeGraphDocument = gql`
    query getSubscriptionForSubscriptionUsageLifetimeGraph($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    ...SubscriptionUsageLifetimeGraphForLifetimeGraph
  }
}
    ${SubscriptionUsageLifetimeGraphForLifetimeGraphFragmentDoc}`;

/**
 * __useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables> & ({ variables: GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
      }
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
        }
export function useGetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>(GetSubscriptionForSubscriptionUsageLifetimeGraphDocument, options);
        }
export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphLazyQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForSubscriptionUsageLifetimeGraphSuspenseQuery>;
export type GetSubscriptionForSubscriptionUsageLifetimeGraphQueryResult = Apollo.QueryResult<GetSubscriptionForSubscriptionUsageLifetimeGraphQuery, GetSubscriptionForSubscriptionUsageLifetimeGraphQueryVariables>;
export const DeleteTaxDocument = gql`
    mutation deleteTax($input: DestroyTaxInput!) {
  destroyTax(input: $input) {
    id
  }
}
    `;
export type DeleteTaxMutationFn = Apollo.MutationFunction<DeleteTaxMutation, DeleteTaxMutationVariables>;

/**
 * __useDeleteTaxMutation__
 *
 * To run a mutation, you first call `useDeleteTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTaxMutation, { data, loading, error }] = useDeleteTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTaxMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTaxMutation, DeleteTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTaxMutation, DeleteTaxMutationVariables>(DeleteTaxDocument, options);
      }
export type DeleteTaxMutationHookResult = ReturnType<typeof useDeleteTaxMutation>;
export type DeleteTaxMutationResult = Apollo.MutationResult<DeleteTaxMutation>;
export type DeleteTaxMutationOptions = Apollo.BaseMutationOptions<DeleteTaxMutation, DeleteTaxMutationVariables>;
export const GetCustomerWalletListDocument = gql`
    query getCustomerWalletList($customerId: ID!, $page: Int, $limit: Int) {
  wallets(customerId: $customerId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CustomerWallet
    }
  }
}
    ${CustomerWalletFragmentDoc}`;

/**
 * __useGetCustomerWalletListQuery__
 *
 * To run a query within a React component, call `useGetCustomerWalletListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerWalletListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerWalletListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetCustomerWalletListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables> & ({ variables: GetCustomerWalletListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
      }
export function useGetCustomerWalletListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export function useGetCustomerWalletListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>(GetCustomerWalletListDocument, options);
        }
export type GetCustomerWalletListQueryHookResult = ReturnType<typeof useGetCustomerWalletListQuery>;
export type GetCustomerWalletListLazyQueryHookResult = ReturnType<typeof useGetCustomerWalletListLazyQuery>;
export type GetCustomerWalletListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerWalletListSuspenseQuery>;
export type GetCustomerWalletListQueryResult = Apollo.QueryResult<GetCustomerWalletListQuery, GetCustomerWalletListQueryVariables>;
export const TerminateCustomerWalletDocument = gql`
    mutation terminateCustomerWallet($input: TerminateCustomerWalletInput!) {
  terminateCustomerWallet(input: $input) {
    id
    status
    ...WalletAccordion
    customer {
      id
      hasActiveWallet
    }
  }
}
    ${WalletAccordionFragmentDoc}`;
export type TerminateCustomerWalletMutationFn = Apollo.MutationFunction<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;

/**
 * __useTerminateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useTerminateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTerminateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [terminateCustomerWalletMutation, { data, loading, error }] = useTerminateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useTerminateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>(TerminateCustomerWalletDocument, options);
      }
export type TerminateCustomerWalletMutationHookResult = ReturnType<typeof useTerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationResult = Apollo.MutationResult<TerminateCustomerWalletMutation>;
export type TerminateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<TerminateCustomerWalletMutation, TerminateCustomerWalletMutationVariables>;
export const CreateCustomerWalletTransactionDocument = gql`
    mutation createCustomerWalletTransaction($input: CreateCustomerWalletTransactionInput!) {
  createCustomerWalletTransaction(input: $input) {
    collection {
      id
    }
  }
}
    `;
export type CreateCustomerWalletTransactionMutationFn = Apollo.MutationFunction<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;

/**
 * __useCreateCustomerWalletTransactionMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletTransactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletTransactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletTransactionMutation, { data, loading, error }] = useCreateCustomerWalletTransactionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletTransactionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>(CreateCustomerWalletTransactionDocument, options);
      }
export type CreateCustomerWalletTransactionMutationHookResult = ReturnType<typeof useCreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationResult = Apollo.MutationResult<CreateCustomerWalletTransactionMutation>;
export type CreateCustomerWalletTransactionMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletTransactionMutation, CreateCustomerWalletTransactionMutationVariables>;
export const GetWalletTransactionsDocument = gql`
    query getWalletTransactions($walletId: ID!, $page: Int, $limit: Int) {
  walletTransactions(walletId: $walletId, page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...WalletTransactionForTransactionListItem
    }
  }
}
    ${WalletTransactionForTransactionListItemFragmentDoc}`;

/**
 * __useGetWalletTransactionsQuery__
 *
 * To run a query within a React component, call `useGetWalletTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletTransactionsQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWalletTransactionsQuery(baseOptions: Apollo.QueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables> & ({ variables: GetWalletTransactionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
      }
export function useGetWalletTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export function useGetWalletTransactionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>(GetWalletTransactionsDocument, options);
        }
export type GetWalletTransactionsQueryHookResult = ReturnType<typeof useGetWalletTransactionsQuery>;
export type GetWalletTransactionsLazyQueryHookResult = ReturnType<typeof useGetWalletTransactionsLazyQuery>;
export type GetWalletTransactionsSuspenseQueryHookResult = ReturnType<typeof useGetWalletTransactionsSuspenseQuery>;
export type GetWalletTransactionsQueryResult = Apollo.QueryResult<GetWalletTransactionsQuery, GetWalletTransactionsQueryVariables>;
export const CreateSubscriptionDocument = gql`
    mutation createSubscription($input: CreateSubscriptionInput!) {
  createSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type CreateSubscriptionMutationFn = Apollo.MutationFunction<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;

/**
 * __useCreateSubscriptionMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionMutation, { data, loading, error }] = useCreateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>(CreateSubscriptionDocument, options);
      }
export type CreateSubscriptionMutationHookResult = ReturnType<typeof useCreateSubscriptionMutation>;
export type CreateSubscriptionMutationResult = Apollo.MutationResult<CreateSubscriptionMutation>;
export type CreateSubscriptionMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionMutation, CreateSubscriptionMutationVariables>;
export const UpdateSubscriptionDocument = gql`
    mutation updateSubscription($input: UpdateSubscriptionInput!) {
  updateSubscription(input: $input) {
    id
    customer {
      id
      activeSubscriptionsCount
      ...CustomerDetails
    }
    plan {
      id
    }
  }
}
    ${CustomerDetailsFragmentDoc}`;
export type UpdateSubscriptionMutationFn = Apollo.MutationFunction<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;

/**
 * __useUpdateSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionMutation, { data, loading, error }] = useUpdateSubscriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>(UpdateSubscriptionDocument, options);
      }
export type UpdateSubscriptionMutationHookResult = ReturnType<typeof useUpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationResult = Apollo.MutationResult<UpdateSubscriptionMutation>;
export type UpdateSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionMutation, UpdateSubscriptionMutationVariables>;
export const GetSinglePlanDocument = gql`
    query getSinglePlan($id: ID!) {
  plan(id: $id) {
    ...EditPlan
  }
}
    ${EditPlanFragmentDoc}`;

/**
 * __useGetSinglePlanQuery__
 *
 * To run a query within a React component, call `useGetSinglePlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSinglePlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSinglePlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSinglePlanQuery(baseOptions: Apollo.QueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables> & ({ variables: GetSinglePlanQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
      }
export function useGetSinglePlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export function useGetSinglePlanSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSinglePlanQuery, GetSinglePlanQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSinglePlanQuery, GetSinglePlanQueryVariables>(GetSinglePlanDocument, options);
        }
export type GetSinglePlanQueryHookResult = ReturnType<typeof useGetSinglePlanQuery>;
export type GetSinglePlanLazyQueryHookResult = ReturnType<typeof useGetSinglePlanLazyQuery>;
export type GetSinglePlanSuspenseQueryHookResult = ReturnType<typeof useGetSinglePlanSuspenseQuery>;
export type GetSinglePlanQueryResult = Apollo.QueryResult<GetSinglePlanQuery, GetSinglePlanQueryVariables>;
export const CreatePlanDocument = gql`
    mutation createPlan($input: CreatePlanInput!) {
  createPlan(input: $input) {
    id
  }
}
    `;
export type CreatePlanMutationFn = Apollo.MutationFunction<CreatePlanMutation, CreatePlanMutationVariables>;

/**
 * __useCreatePlanMutation__
 *
 * To run a mutation, you first call `useCreatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlanMutation, { data, loading, error }] = useCreatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlanMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlanMutation, CreatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlanMutation, CreatePlanMutationVariables>(CreatePlanDocument, options);
      }
export type CreatePlanMutationHookResult = ReturnType<typeof useCreatePlanMutation>;
export type CreatePlanMutationResult = Apollo.MutationResult<CreatePlanMutation>;
export type CreatePlanMutationOptions = Apollo.BaseMutationOptions<CreatePlanMutation, CreatePlanMutationVariables>;
export const UpdatePlanDocument = gql`
    mutation updatePlan($input: UpdatePlanInput!) {
  updatePlan(input: $input) {
    ...PlanItem
    ...DeletePlanDialog
    ...EditPlan
  }
}
    ${PlanItemFragmentDoc}
${DeletePlanDialogFragmentDoc}
${EditPlanFragmentDoc}`;
export type UpdatePlanMutationFn = Apollo.MutationFunction<UpdatePlanMutation, UpdatePlanMutationVariables>;

/**
 * __useUpdatePlanMutation__
 *
 * To run a mutation, you first call `useUpdatePlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePlanMutation, { data, loading, error }] = useUpdatePlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePlanMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePlanMutation, UpdatePlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePlanMutation, UpdatePlanMutationVariables>(UpdatePlanDocument, options);
      }
export type UpdatePlanMutationHookResult = ReturnType<typeof useUpdatePlanMutation>;
export type UpdatePlanMutationResult = Apollo.MutationResult<UpdatePlanMutation>;
export type UpdatePlanMutationOptions = Apollo.BaseMutationOptions<UpdatePlanMutation, UpdatePlanMutationVariables>;
export const GetInvoiceCreateCreditNoteDocument = gql`
    query getInvoiceCreateCreditNote($id: ID!) {
  invoice(id: $id) {
    ...InvoiceCreateCreditNote
  }
}
    ${InvoiceCreateCreditNoteFragmentDoc}`;

/**
 * __useGetInvoiceCreateCreditNoteQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreateCreditNoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreateCreditNoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreateCreditNoteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceCreateCreditNoteQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables> & ({ variables: GetInvoiceCreateCreditNoteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
      }
export function useGetInvoiceCreateCreditNoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export function useGetInvoiceCreateCreditNoteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>(GetInvoiceCreateCreditNoteDocument, options);
        }
export type GetInvoiceCreateCreditNoteQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteQuery>;
export type GetInvoiceCreateCreditNoteLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteLazyQuery>;
export type GetInvoiceCreateCreditNoteSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreateCreditNoteSuspenseQuery>;
export type GetInvoiceCreateCreditNoteQueryResult = Apollo.QueryResult<GetInvoiceCreateCreditNoteQuery, GetInvoiceCreateCreditNoteQueryVariables>;
export const CreateCreditNoteDocument = gql`
    mutation createCreditNote($input: CreateCreditNoteInput!) {
  createCreditNote(input: $input) {
    id
  }
}
    `;
export type CreateCreditNoteMutationFn = Apollo.MutationFunction<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;

/**
 * __useCreateCreditNoteMutation__
 *
 * To run a mutation, you first call `useCreateCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreditNoteMutation, { data, loading, error }] = useCreateCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>(CreateCreditNoteDocument, options);
      }
export type CreateCreditNoteMutationHookResult = ReturnType<typeof useCreateCreditNoteMutation>;
export type CreateCreditNoteMutationResult = Apollo.MutationResult<CreateCreditNoteMutation>;
export type CreateCreditNoteMutationOptions = Apollo.BaseMutationOptions<CreateCreditNoteMutation, CreateCreditNoteMutationVariables>;
export const GetSingleAddOnDocument = gql`
    query getSingleAddOn($id: ID!) {
  addOn(id: $id) {
    ...EditAddOn
  }
}
    ${EditAddOnFragmentDoc}`;

/**
 * __useGetSingleAddOnQuery__
 *
 * To run a query within a React component, call `useGetSingleAddOnQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleAddOnQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleAddOnQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleAddOnQuery(baseOptions: Apollo.QueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables> & ({ variables: GetSingleAddOnQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
      }
export function useGetSingleAddOnLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export function useGetSingleAddOnSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>(GetSingleAddOnDocument, options);
        }
export type GetSingleAddOnQueryHookResult = ReturnType<typeof useGetSingleAddOnQuery>;
export type GetSingleAddOnLazyQueryHookResult = ReturnType<typeof useGetSingleAddOnLazyQuery>;
export type GetSingleAddOnSuspenseQueryHookResult = ReturnType<typeof useGetSingleAddOnSuspenseQuery>;
export type GetSingleAddOnQueryResult = Apollo.QueryResult<GetSingleAddOnQuery, GetSingleAddOnQueryVariables>;
export const CreateAddOnDocument = gql`
    mutation createAddOn($input: CreateAddOnInput!) {
  createAddOn(input: $input) {
    id
  }
}
    `;
export type CreateAddOnMutationFn = Apollo.MutationFunction<CreateAddOnMutation, CreateAddOnMutationVariables>;

/**
 * __useCreateAddOnMutation__
 *
 * To run a mutation, you first call `useCreateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAddOnMutation, { data, loading, error }] = useCreateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<CreateAddOnMutation, CreateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAddOnMutation, CreateAddOnMutationVariables>(CreateAddOnDocument, options);
      }
export type CreateAddOnMutationHookResult = ReturnType<typeof useCreateAddOnMutation>;
export type CreateAddOnMutationResult = Apollo.MutationResult<CreateAddOnMutation>;
export type CreateAddOnMutationOptions = Apollo.BaseMutationOptions<CreateAddOnMutation, CreateAddOnMutationVariables>;
export const UpdateAddOnDocument = gql`
    mutation updateAddOn($input: UpdateAddOnInput!) {
  updateAddOn(input: $input) {
    ...AddOnItem
  }
}
    ${AddOnItemFragmentDoc}`;
export type UpdateAddOnMutationFn = Apollo.MutationFunction<UpdateAddOnMutation, UpdateAddOnMutationVariables>;

/**
 * __useUpdateAddOnMutation__
 *
 * To run a mutation, you first call `useUpdateAddOnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAddOnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAddOnMutation, { data, loading, error }] = useUpdateAddOnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAddOnMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAddOnMutation, UpdateAddOnMutationVariables>(UpdateAddOnDocument, options);
      }
export type UpdateAddOnMutationHookResult = ReturnType<typeof useUpdateAddOnMutation>;
export type UpdateAddOnMutationResult = Apollo.MutationResult<UpdateAddOnMutation>;
export type UpdateAddOnMutationOptions = Apollo.BaseMutationOptions<UpdateAddOnMutation, UpdateAddOnMutationVariables>;
export const GetSingleBillableMetricDocument = gql`
    query getSingleBillableMetric($id: ID!) {
  billableMetric(id: $id) {
    ...EditBillableMetric
  }
}
    ${EditBillableMetricFragmentDoc}`;

/**
 * __useGetSingleBillableMetricQuery__
 *
 * To run a query within a React component, call `useGetSingleBillableMetricQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleBillableMetricQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleBillableMetricQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleBillableMetricQuery(baseOptions: Apollo.QueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables> & ({ variables: GetSingleBillableMetricQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
      }
export function useGetSingleBillableMetricLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export function useGetSingleBillableMetricSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>(GetSingleBillableMetricDocument, options);
        }
export type GetSingleBillableMetricQueryHookResult = ReturnType<typeof useGetSingleBillableMetricQuery>;
export type GetSingleBillableMetricLazyQueryHookResult = ReturnType<typeof useGetSingleBillableMetricLazyQuery>;
export type GetSingleBillableMetricSuspenseQueryHookResult = ReturnType<typeof useGetSingleBillableMetricSuspenseQuery>;
export type GetSingleBillableMetricQueryResult = Apollo.QueryResult<GetSingleBillableMetricQuery, GetSingleBillableMetricQueryVariables>;
export const CreateBillableMetricDocument = gql`
    mutation createBillableMetric($input: CreateBillableMetricInput!) {
  createBillableMetric(input: $input) {
    id
  }
}
    `;
export type CreateBillableMetricMutationFn = Apollo.MutationFunction<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;

/**
 * __useCreateBillableMetricMutation__
 *
 * To run a mutation, you first call `useCreateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillableMetricMutation, { data, loading, error }] = useCreateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>(CreateBillableMetricDocument, options);
      }
export type CreateBillableMetricMutationHookResult = ReturnType<typeof useCreateBillableMetricMutation>;
export type CreateBillableMetricMutationResult = Apollo.MutationResult<CreateBillableMetricMutation>;
export type CreateBillableMetricMutationOptions = Apollo.BaseMutationOptions<CreateBillableMetricMutation, CreateBillableMetricMutationVariables>;
export const UpdateBillableMetricDocument = gql`
    mutation updateBillableMetric($input: UpdateBillableMetricInput!) {
  updateBillableMetric(input: $input) {
    ...BillableMetricItem
  }
}
    ${BillableMetricItemFragmentDoc}`;
export type UpdateBillableMetricMutationFn = Apollo.MutationFunction<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;

/**
 * __useUpdateBillableMetricMutation__
 *
 * To run a mutation, you first call `useUpdateBillableMetricMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillableMetricMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillableMetricMutation, { data, loading, error }] = useUpdateBillableMetricMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillableMetricMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>(UpdateBillableMetricDocument, options);
      }
export type UpdateBillableMetricMutationHookResult = ReturnType<typeof useUpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationResult = Apollo.MutationResult<UpdateBillableMetricMutation>;
export type UpdateBillableMetricMutationOptions = Apollo.BaseMutationOptions<UpdateBillableMetricMutation, UpdateBillableMetricMutationVariables>;
export const GetSingleCouponDocument = gql`
    query getSingleCoupon($id: ID!) {
  coupon(id: $id) {
    ...EditCoupon
  }
}
    ${EditCouponFragmentDoc}`;

/**
 * __useGetSingleCouponQuery__
 *
 * To run a query within a React component, call `useGetSingleCouponQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleCouponQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleCouponQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleCouponQuery(baseOptions: Apollo.QueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables> & ({ variables: GetSingleCouponQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
      }
export function useGetSingleCouponLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export function useGetSingleCouponSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleCouponQuery, GetSingleCouponQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleCouponQuery, GetSingleCouponQueryVariables>(GetSingleCouponDocument, options);
        }
export type GetSingleCouponQueryHookResult = ReturnType<typeof useGetSingleCouponQuery>;
export type GetSingleCouponLazyQueryHookResult = ReturnType<typeof useGetSingleCouponLazyQuery>;
export type GetSingleCouponSuspenseQueryHookResult = ReturnType<typeof useGetSingleCouponSuspenseQuery>;
export type GetSingleCouponQueryResult = Apollo.QueryResult<GetSingleCouponQuery, GetSingleCouponQueryVariables>;
export const CreateCouponDocument = gql`
    mutation createCoupon($input: CreateCouponInput!) {
  createCoupon(input: $input) {
    id
  }
}
    `;
export type CreateCouponMutationFn = Apollo.MutationFunction<CreateCouponMutation, CreateCouponMutationVariables>;

/**
 * __useCreateCouponMutation__
 *
 * To run a mutation, you first call `useCreateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCouponMutation, { data, loading, error }] = useCreateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCouponMutation(baseOptions?: Apollo.MutationHookOptions<CreateCouponMutation, CreateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCouponMutation, CreateCouponMutationVariables>(CreateCouponDocument, options);
      }
export type CreateCouponMutationHookResult = ReturnType<typeof useCreateCouponMutation>;
export type CreateCouponMutationResult = Apollo.MutationResult<CreateCouponMutation>;
export type CreateCouponMutationOptions = Apollo.BaseMutationOptions<CreateCouponMutation, CreateCouponMutationVariables>;
export const UpdateCouponDocument = gql`
    mutation updateCoupon($input: UpdateCouponInput!) {
  updateCoupon(input: $input) {
    ...CouponItem
  }
}
    ${CouponItemFragmentDoc}`;
export type UpdateCouponMutationFn = Apollo.MutationFunction<UpdateCouponMutation, UpdateCouponMutationVariables>;

/**
 * __useUpdateCouponMutation__
 *
 * To run a mutation, you first call `useUpdateCouponMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCouponMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCouponMutation, { data, loading, error }] = useUpdateCouponMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCouponMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCouponMutation, UpdateCouponMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCouponMutation, UpdateCouponMutationVariables>(UpdateCouponDocument, options);
      }
export type UpdateCouponMutationHookResult = ReturnType<typeof useUpdateCouponMutation>;
export type UpdateCouponMutationResult = Apollo.MutationResult<UpdateCouponMutation>;
export type UpdateCouponMutationOptions = Apollo.BaseMutationOptions<UpdateCouponMutation, UpdateCouponMutationVariables>;
export const CreateCustomerDocument = gql`
    mutation createCustomer($input: CreateCustomerInput!) {
  createCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type CreateCustomerMutationFn = Apollo.MutationFunction<CreateCustomerMutation, CreateCustomerMutationVariables>;

/**
 * __useCreateCustomerMutation__
 *
 * To run a mutation, you first call `useCreateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerMutation, { data, loading, error }] = useCreateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerMutation, CreateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerMutation, CreateCustomerMutationVariables>(CreateCustomerDocument, options);
      }
export type CreateCustomerMutationHookResult = ReturnType<typeof useCreateCustomerMutation>;
export type CreateCustomerMutationResult = Apollo.MutationResult<CreateCustomerMutation>;
export type CreateCustomerMutationOptions = Apollo.BaseMutationOptions<CreateCustomerMutation, CreateCustomerMutationVariables>;
export const UpdateCustomerDocument = gql`
    mutation updateCustomer($input: UpdateCustomerInput!) {
  updateCustomer(input: $input) {
    ...AddCustomerDrawer
    ...CustomerItem
  }
}
    ${AddCustomerDrawerFragmentDoc}
${CustomerItemFragmentDoc}`;
export type UpdateCustomerMutationFn = Apollo.MutationFunction<UpdateCustomerMutation, UpdateCustomerMutationVariables>;

/**
 * __useUpdateCustomerMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerMutation, { data, loading, error }] = useUpdateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerMutation, UpdateCustomerMutationVariables>(UpdateCustomerDocument, options);
      }
export type UpdateCustomerMutationHookResult = ReturnType<typeof useUpdateCustomerMutation>;
export type UpdateCustomerMutationResult = Apollo.MutationResult<UpdateCustomerMutation>;
export type UpdateCustomerMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerMutation, UpdateCustomerMutationVariables>;
export const GetSingleTaxDocument = gql`
    query getSingleTax($id: ID!) {
  tax(id: $id) {
    id
    autoGenerated
    ...TaxFormQueryShape
  }
}
    ${TaxFormQueryShapeFragmentDoc}`;

/**
 * __useGetSingleTaxQuery__
 *
 * To run a query within a React component, call `useGetSingleTaxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleTaxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleTaxQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSingleTaxQuery(baseOptions: Apollo.QueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables> & ({ variables: GetSingleTaxQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
      }
export function useGetSingleTaxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export function useGetSingleTaxSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSingleTaxQuery, GetSingleTaxQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSingleTaxQuery, GetSingleTaxQueryVariables>(GetSingleTaxDocument, options);
        }
export type GetSingleTaxQueryHookResult = ReturnType<typeof useGetSingleTaxQuery>;
export type GetSingleTaxLazyQueryHookResult = ReturnType<typeof useGetSingleTaxLazyQuery>;
export type GetSingleTaxSuspenseQueryHookResult = ReturnType<typeof useGetSingleTaxSuspenseQuery>;
export type GetSingleTaxQueryResult = Apollo.QueryResult<GetSingleTaxQuery, GetSingleTaxQueryVariables>;
export const CreateTaxDocument = gql`
    mutation createTax($input: TaxCreateInput!) {
  createTax(input: $input) {
    id
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type CreateTaxMutationFn = Apollo.MutationFunction<CreateTaxMutation, CreateTaxMutationVariables>;

/**
 * __useCreateTaxMutation__
 *
 * To run a mutation, you first call `useCreateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTaxMutation, { data, loading, error }] = useCreateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTaxMutation(baseOptions?: Apollo.MutationHookOptions<CreateTaxMutation, CreateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTaxMutation, CreateTaxMutationVariables>(CreateTaxDocument, options);
      }
export type CreateTaxMutationHookResult = ReturnType<typeof useCreateTaxMutation>;
export type CreateTaxMutationResult = Apollo.MutationResult<CreateTaxMutation>;
export type CreateTaxMutationOptions = Apollo.BaseMutationOptions<CreateTaxMutation, CreateTaxMutationVariables>;
export const UpdateTaxDocument = gql`
    mutation updateTax($input: TaxUpdateInput!) {
  updateTax(input: $input) {
    ...TaxForm
  }
}
    ${TaxFormFragmentDoc}`;
export type UpdateTaxMutationFn = Apollo.MutationFunction<UpdateTaxMutation, UpdateTaxMutationVariables>;

/**
 * __useUpdateTaxMutation__
 *
 * To run a mutation, you first call `useUpdateTaxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTaxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTaxMutation, { data, loading, error }] = useUpdateTaxMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTaxMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTaxMutation, UpdateTaxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTaxMutation, UpdateTaxMutationVariables>(UpdateTaxDocument, options);
      }
export type UpdateTaxMutationHookResult = ReturnType<typeof useUpdateTaxMutation>;
export type UpdateTaxMutationResult = Apollo.MutationResult<UpdateTaxMutation>;
export type UpdateTaxMutationOptions = Apollo.BaseMutationOptions<UpdateTaxMutation, UpdateTaxMutationVariables>;
export const GetCurrentUserInfosDocument = gql`
    query getCurrentUserInfos {
  currentUser {
    ...CurrentUserInfos
  }
}
    ${CurrentUserInfosFragmentDoc}`;

/**
 * __useGetCurrentUserInfosQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
      }
export function useGetCurrentUserInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export function useGetCurrentUserInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>(GetCurrentUserInfosDocument, options);
        }
export type GetCurrentUserInfosQueryHookResult = ReturnType<typeof useGetCurrentUserInfosQuery>;
export type GetCurrentUserInfosLazyQueryHookResult = ReturnType<typeof useGetCurrentUserInfosLazyQuery>;
export type GetCurrentUserInfosSuspenseQueryHookResult = ReturnType<typeof useGetCurrentUserInfosSuspenseQuery>;
export type GetCurrentUserInfosQueryResult = Apollo.QueryResult<GetCurrentUserInfosQuery, GetCurrentUserInfosQueryVariables>;
export const GetEmailSettingsDocument = gql`
    query getEmailSettings {
  organization {
    id
    emailSettings
    logoUrl
    name
  }
}
    `;

/**
 * __useGetEmailSettingsQuery__
 *
 * To run a query within a React component, call `useGetEmailSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEmailSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEmailSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetEmailSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
      }
export function useGetEmailSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
        }
export function useGetEmailSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>(GetEmailSettingsDocument, options);
        }
export type GetEmailSettingsQueryHookResult = ReturnType<typeof useGetEmailSettingsQuery>;
export type GetEmailSettingsLazyQueryHookResult = ReturnType<typeof useGetEmailSettingsLazyQuery>;
export type GetEmailSettingsSuspenseQueryHookResult = ReturnType<typeof useGetEmailSettingsSuspenseQuery>;
export type GetEmailSettingsQueryResult = Apollo.QueryResult<GetEmailSettingsQuery, GetEmailSettingsQueryVariables>;
export const UpdateEmailSettingDocument = gql`
    mutation updateEmailSetting($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    emailSettings
  }
}
    `;
export type UpdateEmailSettingMutationFn = Apollo.MutationFunction<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>;

/**
 * __useUpdateEmailSettingMutation__
 *
 * To run a mutation, you first call `useUpdateEmailSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEmailSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEmailSettingMutation, { data, loading, error }] = useUpdateEmailSettingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateEmailSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>(UpdateEmailSettingDocument, options);
      }
export type UpdateEmailSettingMutationHookResult = ReturnType<typeof useUpdateEmailSettingMutation>;
export type UpdateEmailSettingMutationResult = Apollo.MutationResult<UpdateEmailSettingMutation>;
export type UpdateEmailSettingMutationOptions = Apollo.BaseMutationOptions<UpdateEmailSettingMutation, UpdateEmailSettingMutationVariables>;
export const GetTaxProviderPresenceDocument = gql`
    query getTaxProviderPresence($limit: Int, $integrationsType: IntegrationTypeEnum) {
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    `;

/**
 * __useGetTaxProviderPresenceQuery__
 *
 * To run a query within a React component, call `useGetTaxProviderPresenceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxProviderPresenceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxProviderPresenceQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetTaxProviderPresenceQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
      }
export function useGetTaxProviderPresenceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
        }
export function useGetTaxProviderPresenceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>(GetTaxProviderPresenceDocument, options);
        }
export type GetTaxProviderPresenceQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceQuery>;
export type GetTaxProviderPresenceLazyQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceLazyQuery>;
export type GetTaxProviderPresenceSuspenseQueryHookResult = ReturnType<typeof useGetTaxProviderPresenceSuspenseQuery>;
export type GetTaxProviderPresenceQueryResult = Apollo.QueryResult<GetTaxProviderPresenceQuery, GetTaxProviderPresenceQueryVariables>;
export const GetOrganizationInfosDocument = gql`
    query getOrganizationInfos {
  organization {
    ...MainOrganizationInfos
  }
}
    ${MainOrganizationInfosFragmentDoc}`;

/**
 * __useGetOrganizationInfosQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
      }
export function useGetOrganizationInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export function useGetOrganizationInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>(GetOrganizationInfosDocument, options);
        }
export type GetOrganizationInfosQueryHookResult = ReturnType<typeof useGetOrganizationInfosQuery>;
export type GetOrganizationInfosLazyQueryHookResult = ReturnType<typeof useGetOrganizationInfosLazyQuery>;
export type GetOrganizationInfosSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInfosSuspenseQuery>;
export type GetOrganizationInfosQueryResult = Apollo.QueryResult<GetOrganizationInfosQuery, GetOrganizationInfosQueryVariables>;
export const GetInvoiceDetailsDocument = gql`
    query getInvoiceDetails($id: ID!) {
  invoice(id: $id) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;

/**
 * __useGetInvoiceDetailsQuery__
 *
 * To run a query within a React component, call `useGetInvoiceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables> & ({ variables: GetInvoiceDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
      }
export function useGetInvoiceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export function useGetInvoiceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>(GetInvoiceDetailsDocument, options);
        }
export type GetInvoiceDetailsQueryHookResult = ReturnType<typeof useGetInvoiceDetailsQuery>;
export type GetInvoiceDetailsLazyQueryHookResult = ReturnType<typeof useGetInvoiceDetailsLazyQuery>;
export type GetInvoiceDetailsSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceDetailsSuspenseQuery>;
export type GetInvoiceDetailsQueryResult = Apollo.QueryResult<GetInvoiceDetailsQuery, GetInvoiceDetailsQueryVariables>;
export const IntegrationsListForCustomerInvoiceDetailsDocument = gql`
    query integrationsListForCustomerInvoiceDetails($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        ...NetsuiteIntegrationInfosForInvoiceOverview
      }
      ... on HubspotIntegration {
        __typename
        id
        ...HubspotIntegrationInfosForInvoiceOverview
      }
    }
  }
}
    ${NetsuiteIntegrationInfosForInvoiceOverviewFragmentDoc}
${HubspotIntegrationInfosForInvoiceOverviewFragmentDoc}`;

/**
 * __useIntegrationsListForCustomerInvoiceDetailsQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCustomerInvoiceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCustomerInvoiceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCustomerInvoiceDetailsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCustomerInvoiceDetailsQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
      }
export function useIntegrationsListForCustomerInvoiceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
        }
export function useIntegrationsListForCustomerInvoiceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>(IntegrationsListForCustomerInvoiceDetailsDocument, options);
        }
export type IntegrationsListForCustomerInvoiceDetailsQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsQuery>;
export type IntegrationsListForCustomerInvoiceDetailsLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsLazyQuery>;
export type IntegrationsListForCustomerInvoiceDetailsSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCustomerInvoiceDetailsSuspenseQuery>;
export type IntegrationsListForCustomerInvoiceDetailsQueryResult = Apollo.QueryResult<IntegrationsListForCustomerInvoiceDetailsQuery, IntegrationsListForCustomerInvoiceDetailsQueryVariables>;
export const DownloadInvoiceDocument = gql`
    mutation downloadInvoice($input: DownloadInvoiceInput!) {
  downloadInvoice(input: $input) {
    id
    fileUrl
  }
}
    `;
export type DownloadInvoiceMutationFn = Apollo.MutationFunction<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;

/**
 * __useDownloadInvoiceMutation__
 *
 * To run a mutation, you first call `useDownloadInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadInvoiceMutation, { data, loading, error }] = useDownloadInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDownloadInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>(DownloadInvoiceDocument, options);
      }
export type DownloadInvoiceMutationHookResult = ReturnType<typeof useDownloadInvoiceMutation>;
export type DownloadInvoiceMutationResult = Apollo.MutationResult<DownloadInvoiceMutation>;
export type DownloadInvoiceMutationOptions = Apollo.BaseMutationOptions<DownloadInvoiceMutation, DownloadInvoiceMutationVariables>;
export const RefreshInvoiceDocument = gql`
    mutation refreshInvoice($input: RefreshInvoiceInput!) {
  refreshInvoice(input: $input) {
    id
    ...AllInvoiceDetailsForCustomerInvoiceDetails
  }
}
    ${AllInvoiceDetailsForCustomerInvoiceDetailsFragmentDoc}`;
export type RefreshInvoiceMutationFn = Apollo.MutationFunction<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;

/**
 * __useRefreshInvoiceMutation__
 *
 * To run a mutation, you first call `useRefreshInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshInvoiceMutation, { data, loading, error }] = useRefreshInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRefreshInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>(RefreshInvoiceDocument, options);
      }
export type RefreshInvoiceMutationHookResult = ReturnType<typeof useRefreshInvoiceMutation>;
export type RefreshInvoiceMutationResult = Apollo.MutationResult<RefreshInvoiceMutation>;
export type RefreshInvoiceMutationOptions = Apollo.BaseMutationOptions<RefreshInvoiceMutation, RefreshInvoiceMutationVariables>;
export const SyncIntegrationInvoiceDocument = gql`
    mutation syncIntegrationInvoice($input: SyncIntegrationInvoiceInput!) {
  syncIntegrationInvoice(input: $input) {
    invoiceId
  }
}
    `;
export type SyncIntegrationInvoiceMutationFn = Apollo.MutationFunction<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>;

/**
 * __useSyncIntegrationInvoiceMutation__
 *
 * To run a mutation, you first call `useSyncIntegrationInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncIntegrationInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncIntegrationInvoiceMutation, { data, loading, error }] = useSyncIntegrationInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncIntegrationInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>(SyncIntegrationInvoiceDocument, options);
      }
export type SyncIntegrationInvoiceMutationHookResult = ReturnType<typeof useSyncIntegrationInvoiceMutation>;
export type SyncIntegrationInvoiceMutationResult = Apollo.MutationResult<SyncIntegrationInvoiceMutation>;
export type SyncIntegrationInvoiceMutationOptions = Apollo.BaseMutationOptions<SyncIntegrationInvoiceMutation, SyncIntegrationInvoiceMutationVariables>;
export const SyncCrmIntegrationInvoiceDocument = gql`
    mutation syncCrmIntegrationInvoice($input: SyncCrmIntegrationInvoiceInput!) {
  syncCrmIntegrationInvoice(input: $input) {
    invoiceId
  }
}
    `;
export type SyncCrmIntegrationInvoiceMutationFn = Apollo.MutationFunction<SyncCrmIntegrationInvoiceMutation, SyncCrmIntegrationInvoiceMutationVariables>;

/**
 * __useSyncCrmIntegrationInvoiceMutation__
 *
 * To run a mutation, you first call `useSyncCrmIntegrationInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncCrmIntegrationInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncCrmIntegrationInvoiceMutation, { data, loading, error }] = useSyncCrmIntegrationInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncCrmIntegrationInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncCrmIntegrationInvoiceMutation, SyncCrmIntegrationInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncCrmIntegrationInvoiceMutation, SyncCrmIntegrationInvoiceMutationVariables>(SyncCrmIntegrationInvoiceDocument, options);
      }
export type SyncCrmIntegrationInvoiceMutationHookResult = ReturnType<typeof useSyncCrmIntegrationInvoiceMutation>;
export type SyncCrmIntegrationInvoiceMutationResult = Apollo.MutationResult<SyncCrmIntegrationInvoiceMutation>;
export type SyncCrmIntegrationInvoiceMutationOptions = Apollo.BaseMutationOptions<SyncCrmIntegrationInvoiceMutation, SyncCrmIntegrationInvoiceMutationVariables>;
export const RetryInvoiceDocument = gql`
    mutation retryInvoice($input: RetryInvoiceInput!) {
  retryInvoice(input: $input) {
    id
  }
}
    `;
export type RetryInvoiceMutationFn = Apollo.MutationFunction<RetryInvoiceMutation, RetryInvoiceMutationVariables>;

/**
 * __useRetryInvoiceMutation__
 *
 * To run a mutation, you first call `useRetryInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryInvoiceMutation, { data, loading, error }] = useRetryInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<RetryInvoiceMutation, RetryInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryInvoiceMutation, RetryInvoiceMutationVariables>(RetryInvoiceDocument, options);
      }
export type RetryInvoiceMutationHookResult = ReturnType<typeof useRetryInvoiceMutation>;
export type RetryInvoiceMutationResult = Apollo.MutationResult<RetryInvoiceMutation>;
export type RetryInvoiceMutationOptions = Apollo.BaseMutationOptions<RetryInvoiceMutation, RetryInvoiceMutationVariables>;
export const RetryTaxProviderVoidingDocument = gql`
    mutation retryTaxProviderVoiding($input: RetryTaxProviderVoidingInput!) {
  retryTaxProviderVoiding(input: $input) {
    id
  }
}
    `;
export type RetryTaxProviderVoidingMutationFn = Apollo.MutationFunction<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>;

/**
 * __useRetryTaxProviderVoidingMutation__
 *
 * To run a mutation, you first call `useRetryTaxProviderVoidingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryTaxProviderVoidingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryTaxProviderVoidingMutation, { data, loading, error }] = useRetryTaxProviderVoidingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryTaxProviderVoidingMutation(baseOptions?: Apollo.MutationHookOptions<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>(RetryTaxProviderVoidingDocument, options);
      }
export type RetryTaxProviderVoidingMutationHookResult = ReturnType<typeof useRetryTaxProviderVoidingMutation>;
export type RetryTaxProviderVoidingMutationResult = Apollo.MutationResult<RetryTaxProviderVoidingMutation>;
export type RetryTaxProviderVoidingMutationOptions = Apollo.BaseMutationOptions<RetryTaxProviderVoidingMutation, RetryTaxProviderVoidingMutationVariables>;
export const SideNavInfosDocument = gql`
    query SideNavInfos {
  currentVersion {
    githubUrl
    number
  }
}
    `;

/**
 * __useSideNavInfosQuery__
 *
 * To run a query within a React component, call `useSideNavInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useSideNavInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSideNavInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useSideNavInfosQuery(baseOptions?: Apollo.QueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
      }
export function useSideNavInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export function useSideNavInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SideNavInfosQuery, SideNavInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SideNavInfosQuery, SideNavInfosQueryVariables>(SideNavInfosDocument, options);
        }
export type SideNavInfosQueryHookResult = ReturnType<typeof useSideNavInfosQuery>;
export type SideNavInfosLazyQueryHookResult = ReturnType<typeof useSideNavInfosLazyQuery>;
export type SideNavInfosSuspenseQueryHookResult = ReturnType<typeof useSideNavInfosSuspenseQuery>;
export type SideNavInfosQueryResult = Apollo.QueryResult<SideNavInfosQuery, SideNavInfosQueryVariables>;
export const GetAddOnForDetailsDocument = gql`
    query getAddOnForDetails($addOn: ID!) {
  addOn(id: $addOn) {
    id
    name
    amountCents
    amountCurrency
    code
    taxes {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetAddOnForDetailsQuery__
 *
 * To run a query within a React component, call `useGetAddOnForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddOnForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddOnForDetailsQuery({
 *   variables: {
 *      addOn: // value for 'addOn'
 *   },
 * });
 */
export function useGetAddOnForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables> & ({ variables: GetAddOnForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
      }
export function useGetAddOnForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export function useGetAddOnForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>(GetAddOnForDetailsDocument, options);
        }
export type GetAddOnForDetailsQueryHookResult = ReturnType<typeof useGetAddOnForDetailsQuery>;
export type GetAddOnForDetailsLazyQueryHookResult = ReturnType<typeof useGetAddOnForDetailsLazyQuery>;
export type GetAddOnForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAddOnForDetailsSuspenseQuery>;
export type GetAddOnForDetailsQueryResult = Apollo.QueryResult<GetAddOnForDetailsQuery, GetAddOnForDetailsQueryVariables>;
export const AddOnsDocument = gql`
    query addOns($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...AddOnItem
    }
  }
}
    ${AddOnItemFragmentDoc}`;

/**
 * __useAddOnsQuery__
 *
 * To run a query within a React component, call `useAddOnsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddOnsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddOnsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useAddOnsQuery(baseOptions?: Apollo.QueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
      }
export function useAddOnsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export function useAddOnsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AddOnsQuery, AddOnsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AddOnsQuery, AddOnsQueryVariables>(AddOnsDocument, options);
        }
export type AddOnsQueryHookResult = ReturnType<typeof useAddOnsQuery>;
export type AddOnsLazyQueryHookResult = ReturnType<typeof useAddOnsLazyQuery>;
export type AddOnsSuspenseQueryHookResult = ReturnType<typeof useAddOnsSuspenseQuery>;
export type AddOnsQueryResult = Apollo.QueryResult<AddOnsQuery, AddOnsQueryVariables>;
export const BillableMetricsDocument = gql`
    query billableMetrics($page: Int, $limit: Int, $searchTerm: String) {
  billableMetrics(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...BillableMetricItem
    }
  }
}
    ${BillableMetricItemFragmentDoc}`;

/**
 * __useBillableMetricsQuery__
 *
 * To run a query within a React component, call `useBillableMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillableMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillableMetricsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useBillableMetricsQuery(baseOptions?: Apollo.QueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
      }
export function useBillableMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export function useBillableMetricsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<BillableMetricsQuery, BillableMetricsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BillableMetricsQuery, BillableMetricsQueryVariables>(BillableMetricsDocument, options);
        }
export type BillableMetricsQueryHookResult = ReturnType<typeof useBillableMetricsQuery>;
export type BillableMetricsLazyQueryHookResult = ReturnType<typeof useBillableMetricsLazyQuery>;
export type BillableMetricsSuspenseQueryHookResult = ReturnType<typeof useBillableMetricsSuspenseQuery>;
export type BillableMetricsQueryResult = Apollo.QueryResult<BillableMetricsQuery, BillableMetricsQueryVariables>;
export const GetCouponForDetailsDocument = gql`
    query getCouponForDetails($id: ID!) {
  coupon(id: $id) {
    id
    amountCents
    amountCurrency
    percentageRate
    code
    expirationAt
    name
    frequency
    reusable
    couponType
    billableMetrics {
      id
      name
    }
    plans {
      id
      name
    }
  }
}
    `;

/**
 * __useGetCouponForDetailsQuery__
 *
 * To run a query within a React component, call `useGetCouponForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCouponForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCouponForDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCouponForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables> & ({ variables: GetCouponForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
      }
export function useGetCouponForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
        }
export function useGetCouponForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>(GetCouponForDetailsDocument, options);
        }
export type GetCouponForDetailsQueryHookResult = ReturnType<typeof useGetCouponForDetailsQuery>;
export type GetCouponForDetailsLazyQueryHookResult = ReturnType<typeof useGetCouponForDetailsLazyQuery>;
export type GetCouponForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetCouponForDetailsSuspenseQuery>;
export type GetCouponForDetailsQueryResult = Apollo.QueryResult<GetCouponForDetailsQuery, GetCouponForDetailsQueryVariables>;
export const CouponsDocument = gql`
    query coupons($page: Int, $limit: Int, $searchTerm: String) {
  coupons(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CouponItem
      ...CouponCaption
    }
  }
}
    ${CouponItemFragmentDoc}
${CouponCaptionFragmentDoc}`;

/**
 * __useCouponsQuery__
 *
 * To run a query within a React component, call `useCouponsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCouponsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCouponsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCouponsQuery(baseOptions?: Apollo.QueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
      }
export function useCouponsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export function useCouponsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CouponsQuery, CouponsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CouponsQuery, CouponsQueryVariables>(CouponsDocument, options);
        }
export type CouponsQueryHookResult = ReturnType<typeof useCouponsQuery>;
export type CouponsLazyQueryHookResult = ReturnType<typeof useCouponsLazyQuery>;
export type CouponsSuspenseQueryHookResult = ReturnType<typeof useCouponsSuspenseQuery>;
export type CouponsQueryResult = Apollo.QueryResult<CouponsQuery, CouponsQueryVariables>;
export const GetTaxesForAddOnFormDocument = gql`
    query getTaxesForAddOnForm($limit: Int, $page: Int, $searchTerm: String) {
  taxes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      rate
      ...TaxOnAddOnEditCreate
    }
  }
}
    ${TaxOnAddOnEditCreateFragmentDoc}`;

/**
 * __useGetTaxesForAddOnFormQuery__
 *
 * To run a query within a React component, call `useGetTaxesForAddOnFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForAddOnFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForAddOnFormQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetTaxesForAddOnFormQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
      }
export function useGetTaxesForAddOnFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
        }
export function useGetTaxesForAddOnFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>(GetTaxesForAddOnFormDocument, options);
        }
export type GetTaxesForAddOnFormQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormQuery>;
export type GetTaxesForAddOnFormLazyQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormLazyQuery>;
export type GetTaxesForAddOnFormSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForAddOnFormSuspenseQuery>;
export type GetTaxesForAddOnFormQueryResult = Apollo.QueryResult<GetTaxesForAddOnFormQuery, GetTaxesForAddOnFormQueryVariables>;
export const CreateInvoiceDocument = gql`
    mutation createInvoice($input: CreateInvoiceInput!) {
  createInvoice(input: $input) {
    id
  }
}
    `;
export type CreateInvoiceMutationFn = Apollo.MutationFunction<CreateInvoiceMutation, CreateInvoiceMutationVariables>;

/**
 * __useCreateInvoiceMutation__
 *
 * To run a mutation, you first call `useCreateInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoiceMutation, { data, loading, error }] = useCreateInvoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoiceMutation, CreateInvoiceMutationVariables>(CreateInvoiceDocument, options);
      }
export type CreateInvoiceMutationHookResult = ReturnType<typeof useCreateInvoiceMutation>;
export type CreateInvoiceMutationResult = Apollo.MutationResult<CreateInvoiceMutation>;
export type CreateInvoiceMutationOptions = Apollo.BaseMutationOptions<CreateInvoiceMutation, CreateInvoiceMutationVariables>;
export const GetInfosForCreateInvoiceDocument = gql`
    query getInfosForCreateInvoice($id: ID!) {
  customer(id: $id) {
    id
    addressLine1
    addressLine2
    city
    country
    currency
    email
    name
    displayName
    legalName
    legalNumber
    taxIdentificationNumber
    state
    zipcode
    taxes {
      id
      ...TaxInfosForCreateInvoice
    }
    anrokCustomer {
      id
    }
  }
  organization {
    id
    addressLine1
    addressLine2
    city
    country
    email
    name
    legalName
    legalNumber
    taxIdentificationNumber
    logoUrl
    state
    zipcode
    defaultCurrency
  }
  taxes(page: 1, limit: 1000, appliedToOrganization: true) {
    collection {
      id
      ...TaxInfosForCreateInvoice
    }
  }
}
    ${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetInfosForCreateInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInfosForCreateInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInfosForCreateInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInfosForCreateInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInfosForCreateInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables> & ({ variables: GetInfosForCreateInvoiceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
      }
export function useGetInfosForCreateInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export function useGetInfosForCreateInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>(GetInfosForCreateInvoiceDocument, options);
        }
export type GetInfosForCreateInvoiceQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceQuery>;
export type GetInfosForCreateInvoiceLazyQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceLazyQuery>;
export type GetInfosForCreateInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetInfosForCreateInvoiceSuspenseQuery>;
export type GetInfosForCreateInvoiceQueryResult = Apollo.QueryResult<GetInfosForCreateInvoiceQuery, GetInfosForCreateInvoiceQueryVariables>;
export const GetAddonListForInfoiceDocument = gql`
    query getAddonListForInfoice($page: Int, $limit: Int, $searchTerm: String) {
  addOns(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      name
      description
      amountCents
      amountCurrency
      invoiceDisplayName
      ...AddOnForInvoiceEditTaxDialog
      taxes {
        id
        ...TaxInfosForCreateInvoice
      }
    }
  }
}
    ${AddOnForInvoiceEditTaxDialogFragmentDoc}
${TaxInfosForCreateInvoiceFragmentDoc}`;

/**
 * __useGetAddonListForInfoiceQuery__
 *
 * To run a query within a React component, call `useGetAddonListForInfoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddonListForInfoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddonListForInfoiceQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetAddonListForInfoiceQuery(baseOptions?: Apollo.QueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
      }
export function useGetAddonListForInfoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export function useGetAddonListForInfoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>(GetAddonListForInfoiceDocument, options);
        }
export type GetAddonListForInfoiceQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceQuery>;
export type GetAddonListForInfoiceLazyQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceLazyQuery>;
export type GetAddonListForInfoiceSuspenseQueryHookResult = ReturnType<typeof useGetAddonListForInfoiceSuspenseQuery>;
export type GetAddonListForInfoiceQueryResult = Apollo.QueryResult<GetAddonListForInfoiceQuery, GetAddonListForInfoiceQueryVariables>;
export const FetchDraftInvoiceTaxesDocument = gql`
    mutation fetchDraftInvoiceTaxes($input: FetchDraftInvoiceTaxesInput!) {
  fetchDraftInvoiceTaxes(input: $input) {
    collection {
      amountCents
      itemId
      taxAmountCents
      taxBreakdown {
        name
        rate
        taxAmount
        enumedTaxCode
      }
    }
  }
}
    `;
export type FetchDraftInvoiceTaxesMutationFn = Apollo.MutationFunction<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>;

/**
 * __useFetchDraftInvoiceTaxesMutation__
 *
 * To run a mutation, you first call `useFetchDraftInvoiceTaxesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFetchDraftInvoiceTaxesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fetchDraftInvoiceTaxesMutation, { data, loading, error }] = useFetchDraftInvoiceTaxesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFetchDraftInvoiceTaxesMutation(baseOptions?: Apollo.MutationHookOptions<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>(FetchDraftInvoiceTaxesDocument, options);
      }
export type FetchDraftInvoiceTaxesMutationHookResult = ReturnType<typeof useFetchDraftInvoiceTaxesMutation>;
export type FetchDraftInvoiceTaxesMutationResult = Apollo.MutationResult<FetchDraftInvoiceTaxesMutation>;
export type FetchDraftInvoiceTaxesMutationOptions = Apollo.BaseMutationOptions<FetchDraftInvoiceTaxesMutation, FetchDraftInvoiceTaxesMutationVariables>;
export const GetPlansDocument = gql`
    query getPlans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    collection {
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetPlansQuery__
 *
 * To run a query within a React component, call `useGetPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetPlansQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
      }
export function useGetPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export function useGetPlansSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export type GetPlansQueryHookResult = ReturnType<typeof useGetPlansQuery>;
export type GetPlansLazyQueryHookResult = ReturnType<typeof useGetPlansLazyQuery>;
export type GetPlansSuspenseQueryHookResult = ReturnType<typeof useGetPlansSuspenseQuery>;
export type GetPlansQueryResult = Apollo.QueryResult<GetPlansQuery, GetPlansQueryVariables>;
export const GetCustomerForCreateSubscriptionDocument = gql`
    query getCustomerForCreateSubscription($id: ID!) {
  customer(id: $id) {
    id
    applicableTimezone
    name
    displayName
    externalId
  }
}
    `;

/**
 * __useGetCustomerForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetCustomerForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables> & ({ variables: GetCustomerForCreateSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
      }
export function useGetCustomerForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export function useGetCustomerForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>(GetCustomerForCreateSubscriptionDocument, options);
        }
export type GetCustomerForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionQuery>;
export type GetCustomerForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionLazyQuery>;
export type GetCustomerForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetCustomerForCreateSubscriptionSuspenseQuery>;
export type GetCustomerForCreateSubscriptionQueryResult = Apollo.QueryResult<GetCustomerForCreateSubscriptionQuery, GetCustomerForCreateSubscriptionQueryVariables>;
export const GetSubscriptionForCreateSubscriptionDocument = gql`
    query getSubscriptionForCreateSubscription($id: ID!) {
  subscription(id: $id) {
    id
    name
    externalId
    subscriptionAt
    endingAt
    billingTime
    periodEndDate
    status
    startedAt
    plan {
      id
      parent {
        id
      }
      ...AddSubscriptionPlan
    }
  }
}
    ${AddSubscriptionPlanFragmentDoc}`;

/**
 * __useGetSubscriptionForCreateSubscriptionQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForCreateSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForCreateSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForCreateSubscriptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetSubscriptionForCreateSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables> & ({ variables: GetSubscriptionForCreateSubscriptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
      }
export function useGetSubscriptionForCreateSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export function useGetSubscriptionForCreateSubscriptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>(GetSubscriptionForCreateSubscriptionDocument, options);
        }
export type GetSubscriptionForCreateSubscriptionQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionQuery>;
export type GetSubscriptionForCreateSubscriptionLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionLazyQuery>;
export type GetSubscriptionForCreateSubscriptionSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForCreateSubscriptionSuspenseQuery>;
export type GetSubscriptionForCreateSubscriptionQueryResult = Apollo.QueryResult<GetSubscriptionForCreateSubscriptionQuery, GetSubscriptionForCreateSubscriptionQueryVariables>;
export const GetCreditNoteDocument = gql`
    query getCreditNote($id: ID!) {
  creditNote(id: $id) {
    id
    balanceAmountCents
    canBeVoided
    couponsAdjustmentAmountCents
    createdAt
    creditAmountCents
    creditStatus
    currency
    number
    refundAmountCents
    refundedAt
    refundStatus
    subTotalExcludingTaxesAmountCents
    totalAmountCents
    integrationSyncable
    taxProviderSyncable
    taxProviderId
    externalIntegrationId
    customer {
      id
      name
      displayName
      deletedAt
      applicableTimezone
      netsuiteCustomer {
        id
        integrationId
      }
      xeroCustomer {
        id
        integrationId
      }
      anrokCustomer {
        id
        integrationId
        externalAccountId
      }
    }
    invoice {
      id
      invoiceType
      number
    }
    appliedTaxes {
      id
      amountCents
      baseAmountCents
      taxRate
      taxName
    }
    items {
      amountCents
      amountCurrency
      fee {
        id
        amountCents
        eventsCount
        units
        feeType
        itemName
        groupedBy
        invoiceName
        appliedTaxes {
          id
          taxRate
        }
        trueUpParentFee {
          id
        }
        charge {
          id
          billableMetric {
            id
            name
            aggregationType
          }
        }
        subscription {
          id
          name
          plan {
            id
            name
            invoiceDisplayName
          }
        }
        chargeFilter {
          invoiceDisplayName
          values
        }
      }
    }
  }
}
    `;

/**
 * __useGetCreditNoteQuery__
 *
 * To run a query within a React component, call `useGetCreditNoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNoteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCreditNoteQuery(baseOptions: Apollo.QueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables> & ({ variables: GetCreditNoteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
      }
export function useGetCreditNoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
        }
export function useGetCreditNoteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNoteQuery, GetCreditNoteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNoteQuery, GetCreditNoteQueryVariables>(GetCreditNoteDocument, options);
        }
export type GetCreditNoteQueryHookResult = ReturnType<typeof useGetCreditNoteQuery>;
export type GetCreditNoteLazyQueryHookResult = ReturnType<typeof useGetCreditNoteLazyQuery>;
export type GetCreditNoteSuspenseQueryHookResult = ReturnType<typeof useGetCreditNoteSuspenseQuery>;
export type GetCreditNoteQueryResult = Apollo.QueryResult<GetCreditNoteQuery, GetCreditNoteQueryVariables>;
export const IntegrationsListForCreditNoteDetailsDocument = gql`
    query integrationsListForCreditNoteDetails($limit: Int) {
  integrations(limit: $limit) {
    collection {
      ... on NetsuiteIntegration {
        __typename
        id
        accountId
        name
      }
    }
  }
}
    `;

/**
 * __useIntegrationsListForCreditNoteDetailsQuery__
 *
 * To run a query within a React component, call `useIntegrationsListForCreditNoteDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsListForCreditNoteDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsListForCreditNoteDetailsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsListForCreditNoteDetailsQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>(IntegrationsListForCreditNoteDetailsDocument, options);
      }
export function useIntegrationsListForCreditNoteDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>(IntegrationsListForCreditNoteDetailsDocument, options);
        }
export function useIntegrationsListForCreditNoteDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>(IntegrationsListForCreditNoteDetailsDocument, options);
        }
export type IntegrationsListForCreditNoteDetailsQueryHookResult = ReturnType<typeof useIntegrationsListForCreditNoteDetailsQuery>;
export type IntegrationsListForCreditNoteDetailsLazyQueryHookResult = ReturnType<typeof useIntegrationsListForCreditNoteDetailsLazyQuery>;
export type IntegrationsListForCreditNoteDetailsSuspenseQueryHookResult = ReturnType<typeof useIntegrationsListForCreditNoteDetailsSuspenseQuery>;
export type IntegrationsListForCreditNoteDetailsQueryResult = Apollo.QueryResult<IntegrationsListForCreditNoteDetailsQuery, IntegrationsListForCreditNoteDetailsQueryVariables>;
export const SyncIntegrationCreditNoteDocument = gql`
    mutation syncIntegrationCreditNote($input: SyncIntegrationCreditNoteInput!) {
  syncIntegrationCreditNote(input: $input) {
    creditNoteId
  }
}
    `;
export type SyncIntegrationCreditNoteMutationFn = Apollo.MutationFunction<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>;

/**
 * __useSyncIntegrationCreditNoteMutation__
 *
 * To run a mutation, you first call `useSyncIntegrationCreditNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncIntegrationCreditNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncIntegrationCreditNoteMutation, { data, loading, error }] = useSyncIntegrationCreditNoteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSyncIntegrationCreditNoteMutation(baseOptions?: Apollo.MutationHookOptions<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>(SyncIntegrationCreditNoteDocument, options);
      }
export type SyncIntegrationCreditNoteMutationHookResult = ReturnType<typeof useSyncIntegrationCreditNoteMutation>;
export type SyncIntegrationCreditNoteMutationResult = Apollo.MutationResult<SyncIntegrationCreditNoteMutation>;
export type SyncIntegrationCreditNoteMutationOptions = Apollo.BaseMutationOptions<SyncIntegrationCreditNoteMutation, SyncIntegrationCreditNoteMutationVariables>;
export const RetryTaxReportingDocument = gql`
    mutation retryTaxReporting($input: RetryTaxReportingInput!) {
  retryTaxReporting(input: $input) {
    id
  }
}
    `;
export type RetryTaxReportingMutationFn = Apollo.MutationFunction<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>;

/**
 * __useRetryTaxReportingMutation__
 *
 * To run a mutation, you first call `useRetryTaxReportingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryTaxReportingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryTaxReportingMutation, { data, loading, error }] = useRetryTaxReportingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryTaxReportingMutation(baseOptions?: Apollo.MutationHookOptions<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>(RetryTaxReportingDocument, options);
      }
export type RetryTaxReportingMutationHookResult = ReturnType<typeof useRetryTaxReportingMutation>;
export type RetryTaxReportingMutationResult = Apollo.MutationResult<RetryTaxReportingMutation>;
export type RetryTaxReportingMutationOptions = Apollo.BaseMutationOptions<RetryTaxReportingMutation, RetryTaxReportingMutationVariables>;
export const GetCustomerDocument = gql`
    query getCustomer($id: ID!) {
  customer(id: $id) {
    ...CustomerDetails
  }
}
    ${CustomerDetailsFragmentDoc}`;

/**
 * __useGetCustomerQuery__
 *
 * To run a query within a React component, call `useGetCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables> & ({ variables: GetCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
      }
export function useGetCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export function useGetCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerQuery, GetCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerQuery, GetCustomerQueryVariables>(GetCustomerDocument, options);
        }
export type GetCustomerQueryHookResult = ReturnType<typeof useGetCustomerQuery>;
export type GetCustomerLazyQueryHookResult = ReturnType<typeof useGetCustomerLazyQuery>;
export type GetCustomerSuspenseQueryHookResult = ReturnType<typeof useGetCustomerSuspenseQuery>;
export type GetCustomerQueryResult = Apollo.QueryResult<GetCustomerQuery, GetCustomerQueryVariables>;
export const GenerateCustomerPortalUrlDocument = gql`
    mutation generateCustomerPortalUrl($input: GenerateCustomerPortalUrlInput!) {
  generateCustomerPortalUrl(input: $input) {
    url
  }
}
    `;
export type GenerateCustomerPortalUrlMutationFn = Apollo.MutationFunction<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;

/**
 * __useGenerateCustomerPortalUrlMutation__
 *
 * To run a mutation, you first call `useGenerateCustomerPortalUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateCustomerPortalUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateCustomerPortalUrlMutation, { data, loading, error }] = useGenerateCustomerPortalUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGenerateCustomerPortalUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>(GenerateCustomerPortalUrlDocument, options);
      }
export type GenerateCustomerPortalUrlMutationHookResult = ReturnType<typeof useGenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationResult = Apollo.MutationResult<GenerateCustomerPortalUrlMutation>;
export type GenerateCustomerPortalUrlMutationOptions = Apollo.BaseMutationOptions<GenerateCustomerPortalUrlMutation, GenerateCustomerPortalUrlMutationVariables>;
export const GetCustomerDraftInvoicesDocument = gql`
    query getCustomerDraftInvoices($customerId: ID!, $limit: Int, $page: Int, $status: [InvoiceStatusTypeEnum!], $searchTerm: String) {
  customerInvoices(
    customerId: $customerId
    limit: $limit
    page: $page
    status: $status
    searchTerm: $searchTerm
  ) {
    ...InvoiceForInvoiceList
  }
}
    ${InvoiceForInvoiceListFragmentDoc}`;

/**
 * __useGetCustomerDraftInvoicesQuery__
 *
 * To run a query within a React component, call `useGetCustomerDraftInvoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerDraftInvoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerDraftInvoicesQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCustomerDraftInvoicesQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables> & ({ variables: GetCustomerDraftInvoicesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
      }
export function useGetCustomerDraftInvoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export function useGetCustomerDraftInvoicesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>(GetCustomerDraftInvoicesDocument, options);
        }
export type GetCustomerDraftInvoicesQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesQuery>;
export type GetCustomerDraftInvoicesLazyQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesLazyQuery>;
export type GetCustomerDraftInvoicesSuspenseQueryHookResult = ReturnType<typeof useGetCustomerDraftInvoicesSuspenseQuery>;
export type GetCustomerDraftInvoicesQueryResult = Apollo.QueryResult<GetCustomerDraftInvoicesQuery, GetCustomerDraftInvoicesQueryVariables>;
export const GetCustomerInfosForDraftInvoicesListDocument = gql`
    query getCustomerInfosForDraftInvoicesList($customerId: ID!, $status: [InvoiceStatusTypeEnum!]) {
  customer(id: $customerId) {
    id
    name
    displayName
    applicableTimezone
  }
  customerInvoices(customerId: $customerId, status: $status) {
    metadata {
      totalCount
    }
  }
}
    `;

/**
 * __useGetCustomerInfosForDraftInvoicesListQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForDraftInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForDraftInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForDraftInvoicesListQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetCustomerInfosForDraftInvoicesListQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables> & ({ variables: GetCustomerInfosForDraftInvoicesListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
      }
export function useGetCustomerInfosForDraftInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export function useGetCustomerInfosForDraftInvoicesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>(GetCustomerInfosForDraftInvoicesListDocument, options);
        }
export type GetCustomerInfosForDraftInvoicesListQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListQuery>;
export type GetCustomerInfosForDraftInvoicesListLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListLazyQuery>;
export type GetCustomerInfosForDraftInvoicesListSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForDraftInvoicesListSuspenseQuery>;
export type GetCustomerInfosForDraftInvoicesListQueryResult = Apollo.QueryResult<GetCustomerInfosForDraftInvoicesListQuery, GetCustomerInfosForDraftInvoicesListQueryVariables>;
export const GetRequestOverduePaymentInfosDocument = gql`
    query getRequestOverduePaymentInfos($id: ID!) {
  organization {
    defaultCurrency
    ...OrganizationForDunningEmail
  }
  customer(id: $id) {
    externalId
    currency
    ...CustomerForRequestOverduePaymentForm
    ...CustomerForDunningEmail
  }
  paymentRequests {
    collection {
      ...LastPaymentRequest
    }
  }
  invoices(paymentOverdue: true, customerId: $id) {
    collection {
      ...InvoicesForDunningEmail
      ...InvoicesForRequestOverduePaymentForm
    }
  }
}
    ${OrganizationForDunningEmailFragmentDoc}
${CustomerForRequestOverduePaymentFormFragmentDoc}
${CustomerForDunningEmailFragmentDoc}
${LastPaymentRequestFragmentDoc}
${InvoicesForDunningEmailFragmentDoc}
${InvoicesForRequestOverduePaymentFormFragmentDoc}`;

/**
 * __useGetRequestOverduePaymentInfosQuery__
 *
 * To run a query within a React component, call `useGetRequestOverduePaymentInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRequestOverduePaymentInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRequestOverduePaymentInfosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetRequestOverduePaymentInfosQuery(baseOptions: Apollo.QueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables> & ({ variables: GetRequestOverduePaymentInfosQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
      }
export function useGetRequestOverduePaymentInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
        }
export function useGetRequestOverduePaymentInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>(GetRequestOverduePaymentInfosDocument, options);
        }
export type GetRequestOverduePaymentInfosQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosQuery>;
export type GetRequestOverduePaymentInfosLazyQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosLazyQuery>;
export type GetRequestOverduePaymentInfosSuspenseQueryHookResult = ReturnType<typeof useGetRequestOverduePaymentInfosSuspenseQuery>;
export type GetRequestOverduePaymentInfosQueryResult = Apollo.QueryResult<GetRequestOverduePaymentInfosQuery, GetRequestOverduePaymentInfosQueryVariables>;
export const CreatePaymentRequestDocument = gql`
    mutation createPaymentRequest($input: PaymentRequestCreateInput!) {
  createPaymentRequest(input: $input) {
    id
  }
}
    `;
export type CreatePaymentRequestMutationFn = Apollo.MutationFunction<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>;

/**
 * __useCreatePaymentRequestMutation__
 *
 * To run a mutation, you first call `useCreatePaymentRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePaymentRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPaymentRequestMutation, { data, loading, error }] = useCreatePaymentRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePaymentRequestMutation(baseOptions?: Apollo.MutationHookOptions<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>(CreatePaymentRequestDocument, options);
      }
export type CreatePaymentRequestMutationHookResult = ReturnType<typeof useCreatePaymentRequestMutation>;
export type CreatePaymentRequestMutationResult = Apollo.MutationResult<CreatePaymentRequestMutation>;
export type CreatePaymentRequestMutationOptions = Apollo.BaseMutationOptions<CreatePaymentRequestMutation, CreatePaymentRequestMutationVariables>;
export const CustomersDocument = gql`
    query customers($page: Int, $limit: Int, $searchTerm: String) {
  customers(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...CustomerItem
    }
  }
}
    ${CustomerItemFragmentDoc}`;

/**
 * __useCustomersQuery__
 *
 * To run a query within a React component, call `useCustomersQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCustomersQuery(baseOptions?: Apollo.QueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
      }
export function useCustomersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export function useCustomersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export type CustomersQueryHookResult = ReturnType<typeof useCustomersQuery>;
export type CustomersLazyQueryHookResult = ReturnType<typeof useCustomersLazyQuery>;
export type CustomersSuspenseQueryHookResult = ReturnType<typeof useCustomersSuspenseQuery>;
export type CustomersQueryResult = Apollo.QueryResult<CustomersQuery, CustomersQueryVariables>;
export const GetinviteDocument = gql`
    query getinvite($token: String!) {
  invite(token: $token) {
    id
    email
    organization {
      id
      name
    }
  }
}
    `;

/**
 * __useGetinviteQuery__
 *
 * To run a query within a React component, call `useGetinviteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetinviteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetinviteQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetinviteQuery(baseOptions: Apollo.QueryHookOptions<GetinviteQuery, GetinviteQueryVariables> & ({ variables: GetinviteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
      }
export function useGetinviteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export function useGetinviteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetinviteQuery, GetinviteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetinviteQuery, GetinviteQueryVariables>(GetinviteDocument, options);
        }
export type GetinviteQueryHookResult = ReturnType<typeof useGetinviteQuery>;
export type GetinviteLazyQueryHookResult = ReturnType<typeof useGetinviteLazyQuery>;
export type GetinviteSuspenseQueryHookResult = ReturnType<typeof useGetinviteSuspenseQuery>;
export type GetinviteQueryResult = Apollo.QueryResult<GetinviteQuery, GetinviteQueryVariables>;
export const AcceptInviteDocument = gql`
    mutation acceptInvite($input: AcceptInviteInput!) {
  acceptInvite(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type AcceptInviteMutationFn = Apollo.MutationFunction<AcceptInviteMutation, AcceptInviteMutationVariables>;

/**
 * __useAcceptInviteMutation__
 *
 * To run a mutation, you first call `useAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptInviteMutation, { data, loading, error }] = useAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<AcceptInviteMutation, AcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AcceptInviteMutation, AcceptInviteMutationVariables>(AcceptInviteDocument, options);
      }
export type AcceptInviteMutationHookResult = ReturnType<typeof useAcceptInviteMutation>;
export type AcceptInviteMutationResult = Apollo.MutationResult<AcceptInviteMutation>;
export type AcceptInviteMutationOptions = Apollo.BaseMutationOptions<AcceptInviteMutation, AcceptInviteMutationVariables>;
export const GoogleAcceptInviteDocument = gql`
    mutation googleAcceptInvite($input: GoogleAcceptInviteInput!) {
  googleAcceptInvite(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleAcceptInviteMutationFn = Apollo.MutationFunction<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;

/**
 * __useGoogleAcceptInviteMutation__
 *
 * To run a mutation, you first call `useGoogleAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleAcceptInviteMutation, { data, loading, error }] = useGoogleAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>(GoogleAcceptInviteDocument, options);
      }
export type GoogleAcceptInviteMutationHookResult = ReturnType<typeof useGoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationResult = Apollo.MutationResult<GoogleAcceptInviteMutation>;
export type GoogleAcceptInviteMutationOptions = Apollo.BaseMutationOptions<GoogleAcceptInviteMutation, GoogleAcceptInviteMutationVariables>;
export const FetchOktaAuthorizeUrlDocument = gql`
    mutation fetchOktaAuthorizeUrl($input: OktaAuthorizeInput!) {
  oktaAuthorize(input: $input) {
    url
  }
}
    `;
export type FetchOktaAuthorizeUrlMutationFn = Apollo.MutationFunction<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>;

/**
 * __useFetchOktaAuthorizeUrlMutation__
 *
 * To run a mutation, you first call `useFetchOktaAuthorizeUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFetchOktaAuthorizeUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fetchOktaAuthorizeUrlMutation, { data, loading, error }] = useFetchOktaAuthorizeUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFetchOktaAuthorizeUrlMutation(baseOptions?: Apollo.MutationHookOptions<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>(FetchOktaAuthorizeUrlDocument, options);
      }
export type FetchOktaAuthorizeUrlMutationHookResult = ReturnType<typeof useFetchOktaAuthorizeUrlMutation>;
export type FetchOktaAuthorizeUrlMutationResult = Apollo.MutationResult<FetchOktaAuthorizeUrlMutation>;
export type FetchOktaAuthorizeUrlMutationOptions = Apollo.BaseMutationOptions<FetchOktaAuthorizeUrlMutation, FetchOktaAuthorizeUrlMutationVariables>;
export const OktaAcceptInviteDocument = gql`
    mutation oktaAcceptInvite($input: OktaAcceptInviteInput!) {
  oktaAcceptInvite(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type OktaAcceptInviteMutationFn = Apollo.MutationFunction<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>;

/**
 * __useOktaAcceptInviteMutation__
 *
 * To run a mutation, you first call `useOktaAcceptInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOktaAcceptInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [oktaAcceptInviteMutation, { data, loading, error }] = useOktaAcceptInviteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOktaAcceptInviteMutation(baseOptions?: Apollo.MutationHookOptions<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>(OktaAcceptInviteDocument, options);
      }
export type OktaAcceptInviteMutationHookResult = ReturnType<typeof useOktaAcceptInviteMutation>;
export type OktaAcceptInviteMutationResult = Apollo.MutationResult<OktaAcceptInviteMutation>;
export type OktaAcceptInviteMutationOptions = Apollo.BaseMutationOptions<OktaAcceptInviteMutation, OktaAcceptInviteMutationVariables>;
export const GetInvoiceCreditNotesDocument = gql`
    query getInvoiceCreditNotes($invoiceId: ID!, $page: Int, $limit: Int) {
  invoiceCreditNotes(invoiceId: $invoiceId, page: $page, limit: $limit) {
    ...CreditNotesForTable
  }
  invoice(id: $invoiceId) {
    id
    invoiceType
    associatedActiveWalletPresent
    paymentStatus
    refundableAmountCents
    creditableAmountCents
    status
    customer {
      id
      applicableTimezone
      displayName
    }
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetInvoiceCreditNotesQuery__
 *
 * To run a query within a React component, call `useGetInvoiceCreditNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceCreditNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceCreditNotesQuery({
 *   variables: {
 *      invoiceId: // value for 'invoiceId'
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvoiceCreditNotesQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables> & ({ variables: GetInvoiceCreditNotesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
      }
export function useGetInvoiceCreditNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export function useGetInvoiceCreditNotesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>(GetInvoiceCreditNotesDocument, options);
        }
export type GetInvoiceCreditNotesQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesQuery>;
export type GetInvoiceCreditNotesLazyQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesLazyQuery>;
export type GetInvoiceCreditNotesSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceCreditNotesSuspenseQuery>;
export type GetInvoiceCreditNotesQueryResult = Apollo.QueryResult<GetInvoiceCreditNotesQuery, GetInvoiceCreditNotesQueryVariables>;
export const GetInvoicesListDocument = gql`
    query getInvoicesList($currency: CurrencyEnum, $customerExternalId: String, $invoiceType: [InvoiceTypeEnum!], $issuingDateFrom: ISO8601Date, $issuingDateTo: ISO8601Date, $limit: Int, $page: Int, $paymentDisputeLost: Boolean, $paymentOverdue: Boolean, $paymentStatus: [InvoicePaymentStatusTypeEnum!], $searchTerm: String, $status: [InvoiceStatusTypeEnum!]) {
  invoices(
    currency: $currency
    customerExternalId: $customerExternalId
    invoiceType: $invoiceType
    issuingDateFrom: $issuingDateFrom
    issuingDateTo: $issuingDateTo
    limit: $limit
    page: $page
    paymentDisputeLost: $paymentDisputeLost
    paymentOverdue: $paymentOverdue
    paymentStatus: $paymentStatus
    searchTerm: $searchTerm
    status: $status
  ) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      id
      ...InvoiceListItem
    }
  }
}
    ${InvoiceListItemFragmentDoc}`;

/**
 * __useGetInvoicesListQuery__
 *
 * To run a query within a React component, call `useGetInvoicesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoicesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoicesListQuery({
 *   variables: {
 *      currency: // value for 'currency'
 *      customerExternalId: // value for 'customerExternalId'
 *      invoiceType: // value for 'invoiceType'
 *      issuingDateFrom: // value for 'issuingDateFrom'
 *      issuingDateTo: // value for 'issuingDateTo'
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      paymentDisputeLost: // value for 'paymentDisputeLost'
 *      paymentOverdue: // value for 'paymentOverdue'
 *      paymentStatus: // value for 'paymentStatus'
 *      searchTerm: // value for 'searchTerm'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetInvoicesListQuery(baseOptions?: Apollo.QueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
      }
export function useGetInvoicesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
        }
export function useGetInvoicesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoicesListQuery, GetInvoicesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoicesListQuery, GetInvoicesListQueryVariables>(GetInvoicesListDocument, options);
        }
export type GetInvoicesListQueryHookResult = ReturnType<typeof useGetInvoicesListQuery>;
export type GetInvoicesListLazyQueryHookResult = ReturnType<typeof useGetInvoicesListLazyQuery>;
export type GetInvoicesListSuspenseQueryHookResult = ReturnType<typeof useGetInvoicesListSuspenseQuery>;
export type GetInvoicesListQueryResult = Apollo.QueryResult<GetInvoicesListQuery, GetInvoicesListQueryVariables>;
export const GetCreditNotesListDocument = gql`
    query getCreditNotesList($limit: Int, $page: Int, $searchTerm: String) {
  creditNotes(limit: $limit, page: $page, searchTerm: $searchTerm) {
    ...CreditNotesForTable
  }
}
    ${CreditNotesForTableFragmentDoc}`;

/**
 * __useGetCreditNotesListQuery__
 *
 * To run a query within a React component, call `useGetCreditNotesListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCreditNotesListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCreditNotesListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetCreditNotesListQuery(baseOptions?: Apollo.QueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
      }
export function useGetCreditNotesListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
        }
export function useGetCreditNotesListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>(GetCreditNotesListDocument, options);
        }
export type GetCreditNotesListQueryHookResult = ReturnType<typeof useGetCreditNotesListQuery>;
export type GetCreditNotesListLazyQueryHookResult = ReturnType<typeof useGetCreditNotesListLazyQuery>;
export type GetCreditNotesListSuspenseQueryHookResult = ReturnType<typeof useGetCreditNotesListSuspenseQuery>;
export type GetCreditNotesListQueryResult = Apollo.QueryResult<GetCreditNotesListQuery, GetCreditNotesListQueryVariables>;
export const RetryAllInvoicePaymentsDocument = gql`
    mutation retryAllInvoicePayments($input: RetryAllInvoicePaymentsInput!) {
  retryAllInvoicePayments(input: $input) {
    metadata {
      totalCount
    }
  }
}
    `;
export type RetryAllInvoicePaymentsMutationFn = Apollo.MutationFunction<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;

/**
 * __useRetryAllInvoicePaymentsMutation__
 *
 * To run a mutation, you first call `useRetryAllInvoicePaymentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryAllInvoicePaymentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryAllInvoicePaymentsMutation, { data, loading, error }] = useRetryAllInvoicePaymentsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRetryAllInvoicePaymentsMutation(baseOptions?: Apollo.MutationHookOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>(RetryAllInvoicePaymentsDocument, options);
      }
export type RetryAllInvoicePaymentsMutationHookResult = ReturnType<typeof useRetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationResult = Apollo.MutationResult<RetryAllInvoicePaymentsMutation>;
export type RetryAllInvoicePaymentsMutationOptions = Apollo.BaseMutationOptions<RetryAllInvoicePaymentsMutation, RetryAllInvoicePaymentsMutationVariables>;
export const GetPlanForDetailsDocument = gql`
    query getPlanForDetails($planId: ID!) {
  plan(id: $planId) {
    id
    name
    code
    parent {
      id
    }
    ...DeletePlanDialog
  }
}
    ${DeletePlanDialogFragmentDoc}`;

/**
 * __useGetPlanForDetailsQuery__
 *
 * To run a query within a React component, call `useGetPlanForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlanForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlanForDetailsQuery({
 *   variables: {
 *      planId: // value for 'planId'
 *   },
 * });
 */
export function useGetPlanForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables> & ({ variables: GetPlanForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
      }
export function useGetPlanForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export function useGetPlanForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>(GetPlanForDetailsDocument, options);
        }
export type GetPlanForDetailsQueryHookResult = ReturnType<typeof useGetPlanForDetailsQuery>;
export type GetPlanForDetailsLazyQueryHookResult = ReturnType<typeof useGetPlanForDetailsLazyQuery>;
export type GetPlanForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetPlanForDetailsSuspenseQuery>;
export type GetPlanForDetailsQueryResult = Apollo.QueryResult<GetPlanForDetailsQuery, GetPlanForDetailsQueryVariables>;
export const PlansDocument = gql`
    query plans($page: Int, $limit: Int, $searchTerm: String) {
  plans(page: $page, limit: $limit, searchTerm: $searchTerm) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...PlanItem
    }
  }
}
    ${PlanItemFragmentDoc}`;

/**
 * __usePlansQuery__
 *
 * To run a query within a React component, call `usePlansQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlansQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function usePlansQuery(baseOptions?: Apollo.QueryHookOptions<PlansQuery, PlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
      }
export function usePlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export function usePlansSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PlansQuery, PlansQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlansQuery, PlansQueryVariables>(PlansDocument, options);
        }
export type PlansQueryHookResult = ReturnType<typeof usePlansQuery>;
export type PlansLazyQueryHookResult = ReturnType<typeof usePlansLazyQuery>;
export type PlansSuspenseQueryHookResult = ReturnType<typeof usePlansSuspenseQuery>;
export type PlansQueryResult = Apollo.QueryResult<PlansQuery, PlansQueryVariables>;
export const GetSubscriptionForDetailsDocument = gql`
    query getSubscriptionForDetails($subscriptionId: ID!) {
  subscription(id: $subscriptionId) {
    id
    name
    status
    externalId
    plan {
      id
      name
      code
      parent {
        id
        name
        code
      }
    }
    customer {
      id
    }
  }
}
    `;

/**
 * __useGetSubscriptionForDetailsQuery__
 *
 * To run a query within a React component, call `useGetSubscriptionForDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubscriptionForDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubscriptionForDetailsQuery({
 *   variables: {
 *      subscriptionId: // value for 'subscriptionId'
 *   },
 * });
 */
export function useGetSubscriptionForDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables> & ({ variables: GetSubscriptionForDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
      }
export function useGetSubscriptionForDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export function useGetSubscriptionForDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>(GetSubscriptionForDetailsDocument, options);
        }
export type GetSubscriptionForDetailsQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsQuery>;
export type GetSubscriptionForDetailsLazyQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsLazyQuery>;
export type GetSubscriptionForDetailsSuspenseQueryHookResult = ReturnType<typeof useGetSubscriptionForDetailsSuspenseQuery>;
export type GetSubscriptionForDetailsQueryResult = Apollo.QueryResult<GetSubscriptionForDetailsQuery, GetSubscriptionForDetailsQueryVariables>;
export const GetCustomerInfosForWalletFormDocument = gql`
    query getCustomerInfosForWalletForm($id: ID!) {
  customer(id: $id) {
    id
    currency
    timezone
  }
}
    `;

/**
 * __useGetCustomerInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetCustomerInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCustomerInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCustomerInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCustomerInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables> & ({ variables: GetCustomerInfosForWalletFormQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
      }
export function useGetCustomerInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export function useGetCustomerInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>(GetCustomerInfosForWalletFormDocument, options);
        }
export type GetCustomerInfosForWalletFormQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormQuery>;
export type GetCustomerInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormLazyQuery>;
export type GetCustomerInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetCustomerInfosForWalletFormSuspenseQuery>;
export type GetCustomerInfosForWalletFormQueryResult = Apollo.QueryResult<GetCustomerInfosForWalletFormQuery, GetCustomerInfosForWalletFormQueryVariables>;
export const GetWalletInfosForWalletFormDocument = gql`
    query getWalletInfosForWalletForm($id: ID!) {
  wallet(id: $id) {
    id
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;

/**
 * __useGetWalletInfosForWalletFormQuery__
 *
 * To run a query within a React component, call `useGetWalletInfosForWalletFormQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWalletInfosForWalletFormQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWalletInfosForWalletFormQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWalletInfosForWalletFormQuery(baseOptions: Apollo.QueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables> & ({ variables: GetWalletInfosForWalletFormQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
      }
export function useGetWalletInfosForWalletFormLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export function useGetWalletInfosForWalletFormSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>(GetWalletInfosForWalletFormDocument, options);
        }
export type GetWalletInfosForWalletFormQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormQuery>;
export type GetWalletInfosForWalletFormLazyQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormLazyQuery>;
export type GetWalletInfosForWalletFormSuspenseQueryHookResult = ReturnType<typeof useGetWalletInfosForWalletFormSuspenseQuery>;
export type GetWalletInfosForWalletFormQueryResult = Apollo.QueryResult<GetWalletInfosForWalletFormQuery, GetWalletInfosForWalletFormQueryVariables>;
export const CreateCustomerWalletDocument = gql`
    mutation createCustomerWallet($input: CreateCustomerWalletInput!) {
  createCustomerWallet(input: $input) {
    id
    customer {
      id
      hasActiveWallet
    }
  }
}
    `;
export type CreateCustomerWalletMutationFn = Apollo.MutationFunction<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;

/**
 * __useCreateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useCreateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCustomerWalletMutation, { data, loading, error }] = useCreateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>(CreateCustomerWalletDocument, options);
      }
export type CreateCustomerWalletMutationHookResult = ReturnType<typeof useCreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationResult = Apollo.MutationResult<CreateCustomerWalletMutation>;
export type CreateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<CreateCustomerWalletMutation, CreateCustomerWalletMutationVariables>;
export const UpdateCustomerWalletDocument = gql`
    mutation updateCustomerWallet($input: UpdateCustomerWalletInput!) {
  updateCustomerWallet(input: $input) {
    ...WalletForUpdate
  }
}
    ${WalletForUpdateFragmentDoc}`;
export type UpdateCustomerWalletMutationFn = Apollo.MutationFunction<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;

/**
 * __useUpdateCustomerWalletMutation__
 *
 * To run a mutation, you first call `useUpdateCustomerWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCustomerWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCustomerWalletMutation, { data, loading, error }] = useUpdateCustomerWalletMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCustomerWalletMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>(UpdateCustomerWalletDocument, options);
      }
export type UpdateCustomerWalletMutationHookResult = ReturnType<typeof useUpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationResult = Apollo.MutationResult<UpdateCustomerWalletMutation>;
export type UpdateCustomerWalletMutationOptions = Apollo.BaseMutationOptions<UpdateCustomerWalletMutation, UpdateCustomerWalletMutationVariables>;
export const CreatePasswordResetDocument = gql`
    mutation createPasswordReset($input: CreatePasswordResetInput!) {
  createPasswordReset(input: $input) {
    id
  }
}
    `;
export type CreatePasswordResetMutationFn = Apollo.MutationFunction<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;

/**
 * __useCreatePasswordResetMutation__
 *
 * To run a mutation, you first call `useCreatePasswordResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePasswordResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPasswordResetMutation, { data, loading, error }] = useCreatePasswordResetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePasswordResetMutation(baseOptions?: Apollo.MutationHookOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>(CreatePasswordResetDocument, options);
      }
export type CreatePasswordResetMutationHookResult = ReturnType<typeof useCreatePasswordResetMutation>;
export type CreatePasswordResetMutationResult = Apollo.MutationResult<CreatePasswordResetMutation>;
export type CreatePasswordResetMutationOptions = Apollo.BaseMutationOptions<CreatePasswordResetMutation, CreatePasswordResetMutationVariables>;
export const GoogleLoginUserDocument = gql`
    mutation googleLoginUser($input: GoogleLoginUserInput!) {
  googleLoginUser(input: $input) {
    user {
      id
      ...CurrentUser
    }
    token
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleLoginUserMutationFn = Apollo.MutationFunction<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;

/**
 * __useGoogleLoginUserMutation__
 *
 * To run a mutation, you first call `useGoogleLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleLoginUserMutation, { data, loading, error }] = useGoogleLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>(GoogleLoginUserDocument, options);
      }
export type GoogleLoginUserMutationHookResult = ReturnType<typeof useGoogleLoginUserMutation>;
export type GoogleLoginUserMutationResult = Apollo.MutationResult<GoogleLoginUserMutation>;
export type GoogleLoginUserMutationOptions = Apollo.BaseMutationOptions<GoogleLoginUserMutation, GoogleLoginUserMutationVariables>;
export const LoginUserDocument = gql`
    mutation loginUser($input: LoginUserInput!) {
  loginUser(input: $input) {
    user {
      id
      ...CurrentUser
    }
    token
  }
}
    ${CurrentUserFragmentDoc}`;
export type LoginUserMutationFn = Apollo.MutationFunction<LoginUserMutation, LoginUserMutationVariables>;

/**
 * __useLoginUserMutation__
 *
 * To run a mutation, you first call `useLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginUserMutation, { data, loading, error }] = useLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<LoginUserMutation, LoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginUserMutation, LoginUserMutationVariables>(LoginUserDocument, options);
      }
export type LoginUserMutationHookResult = ReturnType<typeof useLoginUserMutation>;
export type LoginUserMutationResult = Apollo.MutationResult<LoginUserMutation>;
export type LoginUserMutationOptions = Apollo.BaseMutationOptions<LoginUserMutation, LoginUserMutationVariables>;
export const OktaLoginUserDocument = gql`
    mutation oktaLoginUser($input: OktaLoginInput!) {
  oktaLogin(input: $input) {
    user {
      id
      ...CurrentUser
    }
    token
  }
}
    ${CurrentUserFragmentDoc}`;
export type OktaLoginUserMutationFn = Apollo.MutationFunction<OktaLoginUserMutation, OktaLoginUserMutationVariables>;

/**
 * __useOktaLoginUserMutation__
 *
 * To run a mutation, you first call `useOktaLoginUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOktaLoginUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [oktaLoginUserMutation, { data, loading, error }] = useOktaLoginUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOktaLoginUserMutation(baseOptions?: Apollo.MutationHookOptions<OktaLoginUserMutation, OktaLoginUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OktaLoginUserMutation, OktaLoginUserMutationVariables>(OktaLoginUserDocument, options);
      }
export type OktaLoginUserMutationHookResult = ReturnType<typeof useOktaLoginUserMutation>;
export type OktaLoginUserMutationResult = Apollo.MutationResult<OktaLoginUserMutation>;
export type OktaLoginUserMutationOptions = Apollo.BaseMutationOptions<OktaLoginUserMutation, OktaLoginUserMutationVariables>;
export const GetPasswordResetDocument = gql`
    query getPasswordReset($token: String!) {
  passwordReset(token: $token) {
    id
    user {
      id
      email
    }
  }
}
    `;

/**
 * __useGetPasswordResetQuery__
 *
 * To run a query within a React component, call `useGetPasswordResetQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPasswordResetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPasswordResetQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetPasswordResetQuery(baseOptions: Apollo.QueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables> & ({ variables: GetPasswordResetQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
      }
export function useGetPasswordResetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export function useGetPasswordResetSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPasswordResetQuery, GetPasswordResetQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPasswordResetQuery, GetPasswordResetQueryVariables>(GetPasswordResetDocument, options);
        }
export type GetPasswordResetQueryHookResult = ReturnType<typeof useGetPasswordResetQuery>;
export type GetPasswordResetLazyQueryHookResult = ReturnType<typeof useGetPasswordResetLazyQuery>;
export type GetPasswordResetSuspenseQueryHookResult = ReturnType<typeof useGetPasswordResetSuspenseQuery>;
export type GetPasswordResetQueryResult = Apollo.QueryResult<GetPasswordResetQuery, GetPasswordResetQueryVariables>;
export const ResetPasswordDocument = gql`
    mutation resetPassword($input: ResetPasswordInput!) {
  resetPassword(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, options);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const SignupDocument = gql`
    mutation signup($input: RegisterUserInput!) {
  registerUser(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type SignupMutationFn = Apollo.MutationFunction<SignupMutation, SignupMutationVariables>;

/**
 * __useSignupMutation__
 *
 * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupMutation, { data, loading, error }] = useSignupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignupMutation(baseOptions?: Apollo.MutationHookOptions<SignupMutation, SignupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, options);
      }
export type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;
export type SignupMutationResult = Apollo.MutationResult<SignupMutation>;
export type SignupMutationOptions = Apollo.BaseMutationOptions<SignupMutation, SignupMutationVariables>;
export const GoogleRegisterDocument = gql`
    mutation googleRegister($input: GoogleRegisterUserInput!) {
  googleRegisterUser(input: $input) {
    token
    user {
      id
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export type GoogleRegisterMutationFn = Apollo.MutationFunction<GoogleRegisterMutation, GoogleRegisterMutationVariables>;

/**
 * __useGoogleRegisterMutation__
 *
 * To run a mutation, you first call `useGoogleRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleRegisterMutation, { data, loading, error }] = useGoogleRegisterMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGoogleRegisterMutation(baseOptions?: Apollo.MutationHookOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleRegisterMutation, GoogleRegisterMutationVariables>(GoogleRegisterDocument, options);
      }
export type GoogleRegisterMutationHookResult = ReturnType<typeof useGoogleRegisterMutation>;
export type GoogleRegisterMutationResult = Apollo.MutationResult<GoogleRegisterMutation>;
export type GoogleRegisterMutationOptions = Apollo.BaseMutationOptions<GoogleRegisterMutation, GoogleRegisterMutationVariables>;
export const GetPortalOrgaInfosDocument = gql`
    query getPortalOrgaInfos {
  customerPortalOrganization {
    id
    name
    logoUrl
    premiumIntegrations
  }
}
    `;

/**
 * __useGetPortalOrgaInfosQuery__
 *
 * To run a query within a React component, call `useGetPortalOrgaInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPortalOrgaInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPortalOrgaInfosQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPortalOrgaInfosQuery(baseOptions?: Apollo.QueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
      }
export function useGetPortalOrgaInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export function useGetPortalOrgaInfosSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>(GetPortalOrgaInfosDocument, options);
        }
export type GetPortalOrgaInfosQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosQuery>;
export type GetPortalOrgaInfosLazyQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosLazyQuery>;
export type GetPortalOrgaInfosSuspenseQueryHookResult = ReturnType<typeof useGetPortalOrgaInfosSuspenseQuery>;
export type GetPortalOrgaInfosQueryResult = Apollo.QueryResult<GetPortalOrgaInfosQuery, GetPortalOrgaInfosQueryVariables>;
export const GetOrganizationApiKeyDocument = gql`
    query getOrganizationApiKey {
  organization {
    id
    apiKey
  }
}
    `;

/**
 * __useGetOrganizationApiKeyQuery__
 *
 * To run a query within a React component, call `useGetOrganizationApiKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationApiKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationApiKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationApiKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
      }
export function useGetOrganizationApiKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
        }
export function useGetOrganizationApiKeySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>(GetOrganizationApiKeyDocument, options);
        }
export type GetOrganizationApiKeyQueryHookResult = ReturnType<typeof useGetOrganizationApiKeyQuery>;
export type GetOrganizationApiKeyLazyQueryHookResult = ReturnType<typeof useGetOrganizationApiKeyLazyQuery>;
export type GetOrganizationApiKeySuspenseQueryHookResult = ReturnType<typeof useGetOrganizationApiKeySuspenseQuery>;
export type GetOrganizationApiKeyQueryResult = Apollo.QueryResult<GetOrganizationApiKeyQuery, GetOrganizationApiKeyQueryVariables>;
export const EventsDocument = gql`
    query events($page: Int, $limit: Int) {
  events(page: $page, limit: $limit) {
    collection {
      ...EventList
    }
    metadata {
      currentPage
      totalPages
    }
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsQuery__
 *
 * To run a query within a React component, call `useEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useEventsQuery(baseOptions?: Apollo.QueryHookOptions<EventsQuery, EventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
      }
export function useEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export function useEventsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<EventsQuery, EventsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventsQuery, EventsQueryVariables>(EventsDocument, options);
        }
export type EventsQueryHookResult = ReturnType<typeof useEventsQuery>;
export type EventsLazyQueryHookResult = ReturnType<typeof useEventsLazyQuery>;
export type EventsSuspenseQueryHookResult = ReturnType<typeof useEventsSuspenseQuery>;
export type EventsQueryResult = Apollo.QueryResult<EventsQuery, EventsQueryVariables>;
export const GetWebhookInformationsDocument = gql`
    query getWebhookInformations($id: ID!) {
  webhookEndpoint(id: $id) {
    id
    webhookUrl
  }
}
    `;

/**
 * __useGetWebhookInformationsQuery__
 *
 * To run a query within a React component, call `useGetWebhookInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookInformationsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetWebhookInformationsQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables> & ({ variables: GetWebhookInformationsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
      }
export function useGetWebhookInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export function useGetWebhookInformationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>(GetWebhookInformationsDocument, options);
        }
export type GetWebhookInformationsQueryHookResult = ReturnType<typeof useGetWebhookInformationsQuery>;
export type GetWebhookInformationsLazyQueryHookResult = ReturnType<typeof useGetWebhookInformationsLazyQuery>;
export type GetWebhookInformationsSuspenseQueryHookResult = ReturnType<typeof useGetWebhookInformationsSuspenseQuery>;
export type GetWebhookInformationsQueryResult = Apollo.QueryResult<GetWebhookInformationsQuery, GetWebhookInformationsQueryVariables>;
export const GetWebhookLogDocument = gql`
    query getWebhookLog($page: Int, $limit: Int, $webhookEndpointId: String!, $status: WebhookStatusEnum, $searchTerm: String) {
  webhooks(
    page: $page
    limit: $limit
    webhookEndpointId: $webhookEndpointId
    status: $status
    searchTerm: $searchTerm
  ) {
    metadata {
      currentPage
      totalPages
    }
    collection {
      ...WebhookLog
    }
  }
}
    ${WebhookLogFragmentDoc}`;

/**
 * __useGetWebhookLogQuery__
 *
 * To run a query within a React component, call `useGetWebhookLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookLogQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *      webhookEndpointId: // value for 'webhookEndpointId'
 *      status: // value for 'status'
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useGetWebhookLogQuery(baseOptions: Apollo.QueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables> & ({ variables: GetWebhookLogQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
      }
export function useGetWebhookLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export function useGetWebhookLogSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookLogQuery, GetWebhookLogQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookLogQuery, GetWebhookLogQueryVariables>(GetWebhookLogDocument, options);
        }
export type GetWebhookLogQueryHookResult = ReturnType<typeof useGetWebhookLogQuery>;
export type GetWebhookLogLazyQueryHookResult = ReturnType<typeof useGetWebhookLogLazyQuery>;
export type GetWebhookLogSuspenseQueryHookResult = ReturnType<typeof useGetWebhookLogSuspenseQuery>;
export type GetWebhookLogQueryResult = Apollo.QueryResult<GetWebhookLogQuery, GetWebhookLogQueryVariables>;
export const GetWebhookListDocument = gql`
    query getWebhookList($limit: Int) {
  webhookEndpoints(limit: $limit) {
    collection {
      id
      webhookUrl
      signatureAlgo
      ...WebhookForCreateAndEdit
    }
  }
}
    ${WebhookForCreateAndEditFragmentDoc}`;

/**
 * __useGetWebhookListQuery__
 *
 * To run a query within a React component, call `useGetWebhookListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWebhookListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWebhookListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetWebhookListQuery(baseOptions?: Apollo.QueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
      }
export function useGetWebhookListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export function useGetWebhookListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetWebhookListQuery, GetWebhookListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetWebhookListQuery, GetWebhookListQueryVariables>(GetWebhookListDocument, options);
        }
export type GetWebhookListQueryHookResult = ReturnType<typeof useGetWebhookListQuery>;
export type GetWebhookListLazyQueryHookResult = ReturnType<typeof useGetWebhookListLazyQuery>;
export type GetWebhookListSuspenseQueryHookResult = ReturnType<typeof useGetWebhookListSuspenseQuery>;
export type GetWebhookListQueryResult = Apollo.QueryResult<GetWebhookListQuery, GetWebhookListQueryVariables>;
export const GetAdyenIntegrationsDetailsDocument = gql`
    query getAdyenIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on AdyenProvider {
      id
      ...AdyenIntegrationDetails
      ...DeleteAdyenIntegrationDialog
      ...AddAdyenProviderDialog
      ...AdyenForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
      }
    }
  }
}
    ${AdyenIntegrationDetailsFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${AdyenForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables> & ({ variables: GetAdyenIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
      }
export function useGetAdyenIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export function useGetAdyenIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>(GetAdyenIntegrationsDetailsDocument, options);
        }
export type GetAdyenIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsQuery>;
export type GetAdyenIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsLazyQuery>;
export type GetAdyenIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsDetailsSuspenseQuery>;
export type GetAdyenIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAdyenIntegrationsDetailsQuery, GetAdyenIntegrationsDetailsQueryVariables>;
export const GetAdyenIntegrationsListDocument = gql`
    query getAdyenIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on AdyenProvider {
        id
        ...AdyenIntegrations
        ...AddAdyenProviderDialog
        ...DeleteAdyenIntegrationDialog
      }
    }
  }
}
    ${AdyenIntegrationsFragmentDoc}
${AddAdyenProviderDialogFragmentDoc}
${DeleteAdyenIntegrationDialogFragmentDoc}`;

/**
 * __useGetAdyenIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAdyenIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAdyenIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAdyenIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAdyenIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
      }
export function useGetAdyenIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export function useGetAdyenIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>(GetAdyenIntegrationsListDocument, options);
        }
export type GetAdyenIntegrationsListQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListQuery>;
export type GetAdyenIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListLazyQuery>;
export type GetAdyenIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAdyenIntegrationsListSuspenseQuery>;
export type GetAdyenIntegrationsListQueryResult = Apollo.QueryResult<GetAdyenIntegrationsListQuery, GetAdyenIntegrationsListQueryVariables>;
export const GetAnrokIntegrationsDetailsDocument = gql`
    query getAnrokIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on AnrokIntegration {
      id
      ...AnrokIntegrationDetails
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on AnrokIntegration {
        id
      }
    }
  }
}
    ${AnrokIntegrationDetailsFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetAnrokIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables> & ({ variables: GetAnrokIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
      }
export function useGetAnrokIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
        }
export function useGetAnrokIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>(GetAnrokIntegrationsDetailsDocument, options);
        }
export type GetAnrokIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsQuery>;
export type GetAnrokIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsLazyQuery>;
export type GetAnrokIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsDetailsSuspenseQuery>;
export type GetAnrokIntegrationsDetailsQueryResult = Apollo.QueryResult<GetAnrokIntegrationsDetailsQuery, GetAnrokIntegrationsDetailsQueryVariables>;
export const GetAnrokIntegrationsListDocument = gql`
    query getAnrokIntegrationsList($limit: Int, $type: IntegrationTypeEnum) {
  integrations(limit: $limit, type: $type) {
    collection {
      ... on AnrokIntegration {
        id
        ...AnrokIntegrations
        ...AddAnrokIntegrationDialog
        ...DeleteAnrokIntegrationDialog
      }
    }
  }
}
    ${AnrokIntegrationsFragmentDoc}
${AddAnrokIntegrationDialogFragmentDoc}
${DeleteAnrokIntegrationDialogFragmentDoc}`;

/**
 * __useGetAnrokIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetAnrokIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnrokIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnrokIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetAnrokIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
      }
export function useGetAnrokIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
        }
export function useGetAnrokIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>(GetAnrokIntegrationsListDocument, options);
        }
export type GetAnrokIntegrationsListQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListQuery>;
export type GetAnrokIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListLazyQuery>;
export type GetAnrokIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetAnrokIntegrationsListSuspenseQuery>;
export type GetAnrokIntegrationsListQueryResult = Apollo.QueryResult<GetAnrokIntegrationsListQuery, GetAnrokIntegrationsListQueryVariables>;
export const GetAuthIntegrationsDocument = gql`
    query GetAuthIntegrations($limit: Int!) {
  integrations(limit: $limit) {
    collection {
      ... on OktaIntegration {
        id
        ...AddOktaIntegrationDialog
        ...DeleteOktaIntegrationDialog
      }
    }
  }
}
    ${AddOktaIntegrationDialogFragmentDoc}
${DeleteOktaIntegrationDialogFragmentDoc}`;

/**
 * __useGetAuthIntegrationsQuery__
 *
 * To run a query within a React component, call `useGetAuthIntegrationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthIntegrationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthIntegrationsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAuthIntegrationsQuery(baseOptions: Apollo.QueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables> & ({ variables: GetAuthIntegrationsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
      }
export function useGetAuthIntegrationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
        }
export function useGetAuthIntegrationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>(GetAuthIntegrationsDocument, options);
        }
export type GetAuthIntegrationsQueryHookResult = ReturnType<typeof useGetAuthIntegrationsQuery>;
export type GetAuthIntegrationsLazyQueryHookResult = ReturnType<typeof useGetAuthIntegrationsLazyQuery>;
export type GetAuthIntegrationsSuspenseQueryHookResult = ReturnType<typeof useGetAuthIntegrationsSuspenseQuery>;
export type GetAuthIntegrationsQueryResult = Apollo.QueryResult<GetAuthIntegrationsQuery, GetAuthIntegrationsQueryVariables>;
export const GetOktaIntegrationDocument = gql`
    query GetOktaIntegration($id: ID) {
  integration(id: $id) {
    ... on OktaIntegration {
      ...OktaIntegrationDetails
      ...AddOktaIntegrationDialog
      ...DeleteOktaIntegrationDialog
    }
  }
}
    ${OktaIntegrationDetailsFragmentDoc}
${AddOktaIntegrationDialogFragmentDoc}
${DeleteOktaIntegrationDialogFragmentDoc}`;

/**
 * __useGetOktaIntegrationQuery__
 *
 * To run a query within a React component, call `useGetOktaIntegrationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOktaIntegrationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOktaIntegrationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetOktaIntegrationQuery(baseOptions?: Apollo.QueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
      }
export function useGetOktaIntegrationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
        }
export function useGetOktaIntegrationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>(GetOktaIntegrationDocument, options);
        }
export type GetOktaIntegrationQueryHookResult = ReturnType<typeof useGetOktaIntegrationQuery>;
export type GetOktaIntegrationLazyQueryHookResult = ReturnType<typeof useGetOktaIntegrationLazyQuery>;
export type GetOktaIntegrationSuspenseQueryHookResult = ReturnType<typeof useGetOktaIntegrationSuspenseQuery>;
export type GetOktaIntegrationQueryResult = Apollo.QueryResult<GetOktaIntegrationQuery, GetOktaIntegrationQueryVariables>;
export const CreateDunningCampaignDocument = gql`
    mutation CreateDunningCampaign($input: CreateDunningCampaignInput!) {
  createDunningCampaign(input: $input) {
    name
    code
    description
    thresholds {
      amountCents
      currency
    }
    daysBetweenAttempts
    maxAttempts
    appliedToOrganization
  }
}
    `;
export type CreateDunningCampaignMutationFn = Apollo.MutationFunction<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>;

/**
 * __useCreateDunningCampaignMutation__
 *
 * To run a mutation, you first call `useCreateDunningCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDunningCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDunningCampaignMutation, { data, loading, error }] = useCreateDunningCampaignMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateDunningCampaignMutation(baseOptions?: Apollo.MutationHookOptions<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>(CreateDunningCampaignDocument, options);
      }
export type CreateDunningCampaignMutationHookResult = ReturnType<typeof useCreateDunningCampaignMutation>;
export type CreateDunningCampaignMutationResult = Apollo.MutationResult<CreateDunningCampaignMutation>;
export type CreateDunningCampaignMutationOptions = Apollo.BaseMutationOptions<CreateDunningCampaignMutation, CreateDunningCampaignMutationVariables>;
export const CreateDunningCampaignPaymentProviderDocument = gql`
    query CreateDunningCampaignPaymentProvider {
  paymentProviders {
    collection {
      __typename
    }
  }
}
    `;

/**
 * __useCreateDunningCampaignPaymentProviderQuery__
 *
 * To run a query within a React component, call `useCreateDunningCampaignPaymentProviderQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateDunningCampaignPaymentProviderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateDunningCampaignPaymentProviderQuery({
 *   variables: {
 *   },
 * });
 */
export function useCreateDunningCampaignPaymentProviderQuery(baseOptions?: Apollo.QueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
      }
export function useCreateDunningCampaignPaymentProviderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
        }
export function useCreateDunningCampaignPaymentProviderSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>(CreateDunningCampaignPaymentProviderDocument, options);
        }
export type CreateDunningCampaignPaymentProviderQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderQuery>;
export type CreateDunningCampaignPaymentProviderLazyQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderLazyQuery>;
export type CreateDunningCampaignPaymentProviderSuspenseQueryHookResult = ReturnType<typeof useCreateDunningCampaignPaymentProviderSuspenseQuery>;
export type CreateDunningCampaignPaymentProviderQueryResult = Apollo.QueryResult<CreateDunningCampaignPaymentProviderQuery, CreateDunningCampaignPaymentProviderQueryVariables>;
export const GetDunningCampaignsDocument = gql`
    query getDunningCampaigns($limit: Int, $page: Int) {
  dunningCampaigns(limit: $limit, page: $page, order: "name") {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...DunningCampaignItem
    }
  }
}
    ${DunningCampaignItemFragmentDoc}`;

/**
 * __useGetDunningCampaignsQuery__
 *
 * To run a query within a React component, call `useGetDunningCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDunningCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDunningCampaignsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetDunningCampaignsQuery(baseOptions?: Apollo.QueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
      }
export function useGetDunningCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
        }
export function useGetDunningCampaignsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>(GetDunningCampaignsDocument, options);
        }
export type GetDunningCampaignsQueryHookResult = ReturnType<typeof useGetDunningCampaignsQuery>;
export type GetDunningCampaignsLazyQueryHookResult = ReturnType<typeof useGetDunningCampaignsLazyQuery>;
export type GetDunningCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetDunningCampaignsSuspenseQuery>;
export type GetDunningCampaignsQueryResult = Apollo.QueryResult<GetDunningCampaignsQuery, GetDunningCampaignsQueryVariables>;
export const UpdateDunningCampaignStatusDocument = gql`
    mutation updateDunningCampaignStatus($input: UpdateDunningCampaignInput!) {
  updateDunningCampaign(input: $input) {
    id
    appliedToOrganization
  }
}
    `;
export type UpdateDunningCampaignStatusMutationFn = Apollo.MutationFunction<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>;

/**
 * __useUpdateDunningCampaignStatusMutation__
 *
 * To run a mutation, you first call `useUpdateDunningCampaignStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDunningCampaignStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDunningCampaignStatusMutation, { data, loading, error }] = useUpdateDunningCampaignStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateDunningCampaignStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>(UpdateDunningCampaignStatusDocument, options);
      }
export type UpdateDunningCampaignStatusMutationHookResult = ReturnType<typeof useUpdateDunningCampaignStatusMutation>;
export type UpdateDunningCampaignStatusMutationResult = Apollo.MutationResult<UpdateDunningCampaignStatusMutation>;
export type UpdateDunningCampaignStatusMutationOptions = Apollo.BaseMutationOptions<UpdateDunningCampaignStatusMutation, UpdateDunningCampaignStatusMutationVariables>;
export const GetGocardlessIntegrationsDetailsDocument = gql`
    query getGocardlessIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on GocardlessProvider {
      id
      ...GocardlessIntegrationDetails
      ...DeleteGocardlessIntegrationDialog
      ...AddGocardlessProviderDialog
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
      }
    }
  }
}
    ${GocardlessIntegrationDetailsFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables> & ({ variables: GetGocardlessIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
      }
export function useGetGocardlessIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export function useGetGocardlessIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>(GetGocardlessIntegrationsDetailsDocument, options);
        }
export type GetGocardlessIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsQuery>;
export type GetGocardlessIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsLazyQuery>;
export type GetGocardlessIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsDetailsSuspenseQuery>;
export type GetGocardlessIntegrationsDetailsQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsDetailsQuery, GetGocardlessIntegrationsDetailsQueryVariables>;
export const AddGocardlessApiKeyDocument = gql`
    mutation addGocardlessApiKey($input: AddGocardlessPaymentProviderInput!) {
  addGocardlessPaymentProvider(input: $input) {
    id
    ...AddGocardlessProviderDialog
    ...GocardlessIntegrationOauthCallback
  }
}
    ${AddGocardlessProviderDialogFragmentDoc}
${GocardlessIntegrationOauthCallbackFragmentDoc}`;
export type AddGocardlessApiKeyMutationFn = Apollo.MutationFunction<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;

/**
 * __useAddGocardlessApiKeyMutation__
 *
 * To run a mutation, you first call `useAddGocardlessApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddGocardlessApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addGocardlessApiKeyMutation, { data, loading, error }] = useAddGocardlessApiKeyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddGocardlessApiKeyMutation(baseOptions?: Apollo.MutationHookOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>(AddGocardlessApiKeyDocument, options);
      }
export type AddGocardlessApiKeyMutationHookResult = ReturnType<typeof useAddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationResult = Apollo.MutationResult<AddGocardlessApiKeyMutation>;
export type AddGocardlessApiKeyMutationOptions = Apollo.BaseMutationOptions<AddGocardlessApiKeyMutation, AddGocardlessApiKeyMutationVariables>;
export const GetGocardlessIntegrationsListDocument = gql`
    query getGocardlessIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on GocardlessProvider {
        id
        ...GocardlessIntegrations
        ...AddGocardlessProviderDialog
        ...DeleteGocardlessIntegrationDialog
      }
    }
  }
}
    ${GocardlessIntegrationsFragmentDoc}
${AddGocardlessProviderDialogFragmentDoc}
${DeleteGocardlessIntegrationDialogFragmentDoc}`;

/**
 * __useGetGocardlessIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetGocardlessIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGocardlessIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGocardlessIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetGocardlessIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
      }
export function useGetGocardlessIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export function useGetGocardlessIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>(GetGocardlessIntegrationsListDocument, options);
        }
export type GetGocardlessIntegrationsListQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListQuery>;
export type GetGocardlessIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListLazyQuery>;
export type GetGocardlessIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetGocardlessIntegrationsListSuspenseQuery>;
export type GetGocardlessIntegrationsListQueryResult = Apollo.QueryResult<GetGocardlessIntegrationsListQuery, GetGocardlessIntegrationsListQueryVariables>;
export const GetHubspotIntegrationsDetailsDocument = gql`
    query getHubspotIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on HubspotIntegration {
      id
      ...HubspotIntegrationDetails
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on HubspotIntegration {
        id
      }
    }
  }
}
    ${HubspotIntegrationDetailsFragmentDoc}`;

/**
 * __useGetHubspotIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetHubspotIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHubspotIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHubspotIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetHubspotIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables> & ({ variables: GetHubspotIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
      }
export function useGetHubspotIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
        }
export function useGetHubspotIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>(GetHubspotIntegrationsDetailsDocument, options);
        }
export type GetHubspotIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsQuery>;
export type GetHubspotIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsLazyQuery>;
export type GetHubspotIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsDetailsSuspenseQuery>;
export type GetHubspotIntegrationsDetailsQueryResult = Apollo.QueryResult<GetHubspotIntegrationsDetailsQuery, GetHubspotIntegrationsDetailsQueryVariables>;
export const GetHubspotIntegrationsListDocument = gql`
    query getHubspotIntegrationsList($limit: Int, $type: IntegrationTypeEnum) {
  integrations(limit: $limit, type: $type) {
    collection {
      ... on HubspotIntegration {
        id
        ...HubspotIntegrations
        ...HubspotForCreateDialog
      }
    }
  }
}
    ${HubspotIntegrationsFragmentDoc}
${HubspotForCreateDialogFragmentDoc}`;

/**
 * __useGetHubspotIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetHubspotIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHubspotIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHubspotIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetHubspotIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
      }
export function useGetHubspotIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
        }
export function useGetHubspotIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>(GetHubspotIntegrationsListDocument, options);
        }
export type GetHubspotIntegrationsListQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListQuery>;
export type GetHubspotIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListLazyQuery>;
export type GetHubspotIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetHubspotIntegrationsListSuspenseQuery>;
export type GetHubspotIntegrationsListQueryResult = Apollo.QueryResult<GetHubspotIntegrationsListQuery, GetHubspotIntegrationsListQueryVariables>;
export const IntegrationsSettingDocument = gql`
    query integrationsSetting($limit: Int) {
  organization {
    id
    euTaxManagement
    country
  }
  paymentProviders(limit: $limit) {
    collection {
      ... on StripeProvider {
        id
      }
      ... on GocardlessProvider {
        id
      }
      ... on AdyenProvider {
        id
      }
    }
  }
  integrations(limit: $limit) {
    collection {
      ... on AnrokIntegration {
        id
      }
      ... on NetsuiteIntegration {
        id
      }
      ... on XeroIntegration {
        id
      }
      ... on HubspotIntegration {
        id
      }
    }
  }
}
    `;

/**
 * __useIntegrationsSettingQuery__
 *
 * To run a query within a React component, call `useIntegrationsSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntegrationsSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntegrationsSettingQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useIntegrationsSettingQuery(baseOptions?: Apollo.QueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
      }
export function useIntegrationsSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export function useIntegrationsSettingSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>(IntegrationsSettingDocument, options);
        }
export type IntegrationsSettingQueryHookResult = ReturnType<typeof useIntegrationsSettingQuery>;
export type IntegrationsSettingLazyQueryHookResult = ReturnType<typeof useIntegrationsSettingLazyQuery>;
export type IntegrationsSettingSuspenseQueryHookResult = ReturnType<typeof useIntegrationsSettingSuspenseQuery>;
export type IntegrationsSettingQueryResult = Apollo.QueryResult<IntegrationsSettingQuery, IntegrationsSettingQueryVariables>;
export const GetOrganizationSettingsDocument = gql`
    query getOrganizationSettings($appliedToOrganization: Boolean = true) {
  organization {
    id
    netPaymentTerm
    defaultCurrency
    documentNumbering
    documentNumberPrefix
    finalizeZeroAmountInvoice
    billingConfiguration {
      id
      invoiceGracePeriod
      invoiceFooter
      documentLocale
    }
    ...EditOrganizationInvoiceTemplateDialog
    ...EditOrganizationNetPaymentTermForDialog
    ...EditOrganizationDefaultCurrencyForDialog
    ...EditOrganizationInvoiceNumberingDialog
  }
  taxes(appliedToOrganization: $appliedToOrganization) {
    collection {
      id
      name
      code
      rate
      ...DeleteOrganizationVatRate
    }
  }
}
    ${EditOrganizationInvoiceTemplateDialogFragmentDoc}
${EditOrganizationNetPaymentTermForDialogFragmentDoc}
${EditOrganizationDefaultCurrencyForDialogFragmentDoc}
${EditOrganizationInvoiceNumberingDialogFragmentDoc}
${DeleteOrganizationVatRateFragmentDoc}`;

/**
 * __useGetOrganizationSettingsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationSettingsQuery({
 *   variables: {
 *      appliedToOrganization: // value for 'appliedToOrganization'
 *   },
 * });
 */
export function useGetOrganizationSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
      }
export function useGetOrganizationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
        }
export function useGetOrganizationSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>(GetOrganizationSettingsDocument, options);
        }
export type GetOrganizationSettingsQueryHookResult = ReturnType<typeof useGetOrganizationSettingsQuery>;
export type GetOrganizationSettingsLazyQueryHookResult = ReturnType<typeof useGetOrganizationSettingsLazyQuery>;
export type GetOrganizationSettingsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationSettingsSuspenseQuery>;
export type GetOrganizationSettingsQueryResult = Apollo.QueryResult<GetOrganizationSettingsQuery, GetOrganizationSettingsQueryVariables>;
export const LagoTaxManagementIntegrationsSettingDocument = gql`
    query lagoTaxManagementIntegrationsSetting {
  organization {
    id
    country
    euTaxManagement
  }
}
    `;

/**
 * __useLagoTaxManagementIntegrationsSettingQuery__
 *
 * To run a query within a React component, call `useLagoTaxManagementIntegrationsSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useLagoTaxManagementIntegrationsSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLagoTaxManagementIntegrationsSettingQuery({
 *   variables: {
 *   },
 * });
 */
export function useLagoTaxManagementIntegrationsSettingQuery(baseOptions?: Apollo.QueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
      }
export function useLagoTaxManagementIntegrationsSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
        }
export function useLagoTaxManagementIntegrationsSettingSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>(LagoTaxManagementIntegrationsSettingDocument, options);
        }
export type LagoTaxManagementIntegrationsSettingQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingQuery>;
export type LagoTaxManagementIntegrationsSettingLazyQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingLazyQuery>;
export type LagoTaxManagementIntegrationsSettingSuspenseQueryHookResult = ReturnType<typeof useLagoTaxManagementIntegrationsSettingSuspenseQuery>;
export type LagoTaxManagementIntegrationsSettingQueryResult = Apollo.QueryResult<LagoTaxManagementIntegrationsSettingQuery, LagoTaxManagementIntegrationsSettingQueryVariables>;
export const GetTaxesForTaxManagementIntegrationDetailsPageDocument = gql`
    query getTaxesForTaxManagementIntegrationDetailsPage {
  taxes(page: 1, limit: 1000, order: "rate", autoGenerated: true) {
    collection {
      id
      code
      name
      rate
    }
  }
}
    `;

/**
 * __useGetTaxesForTaxManagementIntegrationDetailsPageQuery__
 *
 * To run a query within a React component, call `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesForTaxManagementIntegrationDetailsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesForTaxManagementIntegrationDetailsPageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTaxesForTaxManagementIntegrationDetailsPageQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
      }
export function useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export function useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>(GetTaxesForTaxManagementIntegrationDetailsPageDocument, options);
        }
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageLazyQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageLazyQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageSuspenseQueryHookResult = ReturnType<typeof useGetTaxesForTaxManagementIntegrationDetailsPageSuspenseQuery>;
export type GetTaxesForTaxManagementIntegrationDetailsPageQueryResult = Apollo.QueryResult<GetTaxesForTaxManagementIntegrationDetailsPageQuery, GetTaxesForTaxManagementIntegrationDetailsPageQueryVariables>;
export const RemoveTaxManagementIntegrationDocument = gql`
    mutation removeTaxManagementIntegration($input: UpdateOrganizationInput!) {
  updateOrganization(input: $input) {
    id
    euTaxManagement
  }
}
    `;
export type RemoveTaxManagementIntegrationMutationFn = Apollo.MutationFunction<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>;

/**
 * __useRemoveTaxManagementIntegrationMutation__
 *
 * To run a mutation, you first call `useRemoveTaxManagementIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveTaxManagementIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeTaxManagementIntegrationMutation, { data, loading, error }] = useRemoveTaxManagementIntegrationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveTaxManagementIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>(RemoveTaxManagementIntegrationDocument, options);
      }
export type RemoveTaxManagementIntegrationMutationHookResult = ReturnType<typeof useRemoveTaxManagementIntegrationMutation>;
export type RemoveTaxManagementIntegrationMutationResult = Apollo.MutationResult<RemoveTaxManagementIntegrationMutation>;
export type RemoveTaxManagementIntegrationMutationOptions = Apollo.BaseMutationOptions<RemoveTaxManagementIntegrationMutation, RemoveTaxManagementIntegrationMutationVariables>;
export const GetInvitesDocument = gql`
    query getInvites($page: Int, $limit: Int) {
  invites(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
    }
    collection {
      ...InviteItemForMembersSettings
    }
  }
}
    ${InviteItemForMembersSettingsFragmentDoc}`;

/**
 * __useGetInvitesQuery__
 *
 * To run a query within a React component, call `useGetInvitesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvitesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvitesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetInvitesQuery(baseOptions?: Apollo.QueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
      }
export function useGetInvitesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export function useGetInvitesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvitesQuery, GetInvitesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvitesQuery, GetInvitesQueryVariables>(GetInvitesDocument, options);
        }
export type GetInvitesQueryHookResult = ReturnType<typeof useGetInvitesQuery>;
export type GetInvitesLazyQueryHookResult = ReturnType<typeof useGetInvitesLazyQuery>;
export type GetInvitesSuspenseQueryHookResult = ReturnType<typeof useGetInvitesSuspenseQuery>;
export type GetInvitesQueryResult = Apollo.QueryResult<GetInvitesQuery, GetInvitesQueryVariables>;
export const GetMembersDocument = gql`
    query getMembers($page: Int, $limit: Int) {
  memberships(page: $page, limit: $limit) {
    metadata {
      currentPage
      totalPages
      totalCount
      adminCount
    }
    collection {
      ...MembershipItemForMembershipSettings
    }
  }
}
    ${MembershipItemForMembershipSettingsFragmentDoc}`;

/**
 * __useGetMembersQuery__
 *
 * To run a query within a React component, call `useGetMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembersQuery({
 *   variables: {
 *      page: // value for 'page'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetMembersQuery(baseOptions?: Apollo.QueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
      }
export function useGetMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export function useGetMembersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMembersQuery, GetMembersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMembersQuery, GetMembersQueryVariables>(GetMembersDocument, options);
        }
export type GetMembersQueryHookResult = ReturnType<typeof useGetMembersQuery>;
export type GetMembersLazyQueryHookResult = ReturnType<typeof useGetMembersLazyQuery>;
export type GetMembersSuspenseQueryHookResult = ReturnType<typeof useGetMembersSuspenseQuery>;
export type GetMembersQueryResult = Apollo.QueryResult<GetMembersQuery, GetMembersQueryVariables>;
export const GetNetsuiteIntegrationsDetailsDocument = gql`
    query getNetsuiteIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on NetsuiteIntegration {
      id
      ...NetsuiteIntegrationDetails
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on NetsuiteIntegration {
        id
      }
    }
  }
}
    ${NetsuiteIntegrationDetailsFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables> & ({ variables: GetNetsuiteIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
      }
export function useGetNetsuiteIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
        }
export function useGetNetsuiteIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>(GetNetsuiteIntegrationsDetailsDocument, options);
        }
export type GetNetsuiteIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsQuery>;
export type GetNetsuiteIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsLazyQuery>;
export type GetNetsuiteIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsDetailsSuspenseQuery>;
export type GetNetsuiteIntegrationsDetailsQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsDetailsQuery, GetNetsuiteIntegrationsDetailsQueryVariables>;
export const GetNetsuiteIntegrationsListDocument = gql`
    query getNetsuiteIntegrationsList($limit: Int, $type: IntegrationTypeEnum) {
  integrations(limit: $limit, type: $type) {
    collection {
      ... on NetsuiteIntegration {
        id
        ...NetsuiteIntegrations
        ...NetsuiteForCreateDialogDialog
        ...DeleteNetsuiteIntegrationDialog
      }
    }
  }
}
    ${NetsuiteIntegrationsFragmentDoc}
${NetsuiteForCreateDialogDialogFragmentDoc}
${DeleteNetsuiteIntegrationDialogFragmentDoc}`;

/**
 * __useGetNetsuiteIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetNetsuiteIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNetsuiteIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNetsuiteIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetNetsuiteIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
      }
export function useGetNetsuiteIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
        }
export function useGetNetsuiteIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>(GetNetsuiteIntegrationsListDocument, options);
        }
export type GetNetsuiteIntegrationsListQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListQuery>;
export type GetNetsuiteIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListLazyQuery>;
export type GetNetsuiteIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetNetsuiteIntegrationsListSuspenseQuery>;
export type GetNetsuiteIntegrationsListQueryResult = Apollo.QueryResult<GetNetsuiteIntegrationsListQuery, GetNetsuiteIntegrationsListQueryVariables>;
export const GetOrganizationInformationsDocument = gql`
    query getOrganizationInformations {
  organization {
    id
    ...OrganizationInformations
    ...EditOrganizationInformationsDialog
  }
}
    ${OrganizationInformationsFragmentDoc}
${EditOrganizationInformationsDialogFragmentDoc}`;

/**
 * __useGetOrganizationInformationsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationInformationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationInformationsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
      }
export function useGetOrganizationInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
        }
export function useGetOrganizationInformationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>(GetOrganizationInformationsDocument, options);
        }
export type GetOrganizationInformationsQueryHookResult = ReturnType<typeof useGetOrganizationInformationsQuery>;
export type GetOrganizationInformationsLazyQueryHookResult = ReturnType<typeof useGetOrganizationInformationsLazyQuery>;
export type GetOrganizationInformationsSuspenseQueryHookResult = ReturnType<typeof useGetOrganizationInformationsSuspenseQuery>;
export type GetOrganizationInformationsQueryResult = Apollo.QueryResult<GetOrganizationInformationsQuery, GetOrganizationInformationsQueryVariables>;
export const GetStripeIntegrationsDetailsDocument = gql`
    query getStripeIntegrationsDetails($id: ID!, $limit: Int, $type: ProviderTypeEnum) {
  paymentProvider(id: $id) {
    ... on StripeProvider {
      id
      ...StripeIntegrationDetails
      ...DeleteStripeIntegrationDialog
      ...AddStripeProviderDialog
      ...StripeForCreateAndEditSuccessRedirectUrl
    }
  }
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
      }
    }
  }
}
    ${StripeIntegrationDetailsFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${StripeForCreateAndEditSuccessRedirectUrlFragmentDoc}`;

/**
 * __useGetStripeIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables> & ({ variables: GetStripeIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
      }
export function useGetStripeIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export function useGetStripeIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>(GetStripeIntegrationsDetailsDocument, options);
        }
export type GetStripeIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsQuery>;
export type GetStripeIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsLazyQuery>;
export type GetStripeIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsDetailsSuspenseQuery>;
export type GetStripeIntegrationsDetailsQueryResult = Apollo.QueryResult<GetStripeIntegrationsDetailsQuery, GetStripeIntegrationsDetailsQueryVariables>;
export const GetStripeIntegrationsListDocument = gql`
    query getStripeIntegrationsList($limit: Int, $type: ProviderTypeEnum) {
  paymentProviders(limit: $limit, type: $type) {
    collection {
      ... on StripeProvider {
        id
        ...StripeIntegrations
        ...AddStripeProviderDialog
        ...DeleteStripeIntegrationDialog
      }
    }
  }
}
    ${StripeIntegrationsFragmentDoc}
${AddStripeProviderDialogFragmentDoc}
${DeleteStripeIntegrationDialogFragmentDoc}`;

/**
 * __useGetStripeIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetStripeIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStripeIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStripeIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetStripeIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
      }
export function useGetStripeIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export function useGetStripeIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>(GetStripeIntegrationsListDocument, options);
        }
export type GetStripeIntegrationsListQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListQuery>;
export type GetStripeIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListLazyQuery>;
export type GetStripeIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetStripeIntegrationsListSuspenseQuery>;
export type GetStripeIntegrationsListQueryResult = Apollo.QueryResult<GetStripeIntegrationsListQuery, GetStripeIntegrationsListQueryVariables>;
export const GetTaxesSettingsInformationsDocument = gql`
    query getTaxesSettingsInformations($limit: Int, $page: Int) {
  taxes(limit: $limit, page: $page, order: "name") {
    metadata {
      currentPage
      totalPages
    }
    collection {
      id
      ...TaxItemForTaxSettings
    }
  }
}
    ${TaxItemForTaxSettingsFragmentDoc}`;

/**
 * __useGetTaxesSettingsInformationsQuery__
 *
 * To run a query within a React component, call `useGetTaxesSettingsInformationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTaxesSettingsInformationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTaxesSettingsInformationsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useGetTaxesSettingsInformationsQuery(baseOptions?: Apollo.QueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
      }
export function useGetTaxesSettingsInformationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
        }
export function useGetTaxesSettingsInformationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>(GetTaxesSettingsInformationsDocument, options);
        }
export type GetTaxesSettingsInformationsQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsQuery>;
export type GetTaxesSettingsInformationsLazyQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsLazyQuery>;
export type GetTaxesSettingsInformationsSuspenseQueryHookResult = ReturnType<typeof useGetTaxesSettingsInformationsSuspenseQuery>;
export type GetTaxesSettingsInformationsQueryResult = Apollo.QueryResult<GetTaxesSettingsInformationsQuery, GetTaxesSettingsInformationsQueryVariables>;
export const GetXeroIntegrationsDetailsDocument = gql`
    query getXeroIntegrationsDetails($id: ID!, $limit: Int, $integrationsType: IntegrationTypeEnum!) {
  integration(id: $id) {
    ... on XeroIntegration {
      id
      ...XeroIntegrationDetails
    }
  }
  integrations(limit: $limit, type: $integrationsType) {
    collection {
      ... on XeroIntegration {
        id
      }
    }
  }
}
    ${XeroIntegrationDetailsFragmentDoc}`;

/**
 * __useGetXeroIntegrationsDetailsQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      integrationsType: // value for 'integrationsType'
 *   },
 * });
 */
export function useGetXeroIntegrationsDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables> & ({ variables: GetXeroIntegrationsDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
      }
export function useGetXeroIntegrationsDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
        }
export function useGetXeroIntegrationsDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>(GetXeroIntegrationsDetailsDocument, options);
        }
export type GetXeroIntegrationsDetailsQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsQuery>;
export type GetXeroIntegrationsDetailsLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsLazyQuery>;
export type GetXeroIntegrationsDetailsSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsDetailsSuspenseQuery>;
export type GetXeroIntegrationsDetailsQueryResult = Apollo.QueryResult<GetXeroIntegrationsDetailsQuery, GetXeroIntegrationsDetailsQueryVariables>;
export const GetXeroIntegrationsListDocument = gql`
    query getXeroIntegrationsList($limit: Int, $type: IntegrationTypeEnum) {
  integrations(limit: $limit, type: $type) {
    collection {
      ... on XeroIntegration {
        id
        ...XeroIntegrations
        ...XeroForCreateDialogDialog
        ...DeleteXeroIntegrationDialog
      }
    }
  }
}
    ${XeroIntegrationsFragmentDoc}
${XeroForCreateDialogDialogFragmentDoc}
${DeleteXeroIntegrationDialogFragmentDoc}`;

/**
 * __useGetXeroIntegrationsListQuery__
 *
 * To run a query within a React component, call `useGetXeroIntegrationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetXeroIntegrationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetXeroIntegrationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetXeroIntegrationsListQuery(baseOptions?: Apollo.QueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
      }
export function useGetXeroIntegrationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
        }
export function useGetXeroIntegrationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>(GetXeroIntegrationsListDocument, options);
        }
export type GetXeroIntegrationsListQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListQuery>;
export type GetXeroIntegrationsListLazyQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListLazyQuery>;
export type GetXeroIntegrationsListSuspenseQueryHookResult = ReturnType<typeof useGetXeroIntegrationsListSuspenseQuery>;
export type GetXeroIntegrationsListQueryResult = Apollo.QueryResult<GetXeroIntegrationsListQuery, GetXeroIntegrationsListQueryVariables>;